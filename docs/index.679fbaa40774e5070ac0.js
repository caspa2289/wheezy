"use strict";
(self["webpackChunk_wheezy_demos"] = self["webpackChunk_wheezy_demos"] || []).push([["index"],{

/***/ "./index.ts":
/*!******************!*\
  !*** ./index.ts ***!
  \******************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _wheezy_engine__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @wheezy/engine */ "../engine/index.ts");
/* harmony import */ var _src_Demo0__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./src/Demo0 */ "./src/Demo0.ts");


const canvas = document.getElementById('webgpu-canvas');
const run = async () => {
    const engine = (await _wheezy_engine__WEBPACK_IMPORTED_MODULE_0__.Engine.getOrInit({ canvas }));
    const scene = new _src_Demo0__WEBPACK_IMPORTED_MODULE_1__.Demo0();
    await scene.init();
    engine.scene = scene;
    engine.render();
};
run();


/***/ }),

/***/ "./src/Demo0.ts":
/*!**********************!*\
  !*** ./src/Demo0.ts ***!
  \**********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Demo0: () => (/* binding */ Demo0)
/* harmony export */ });
/* harmony import */ var wgpu_matrix__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! wgpu-matrix */ "../../node_modules/wgpu-matrix/dist/3.x/wgpu-matrix.module.js");
/* harmony import */ var _shaders_testShader_wgsl__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../shaders/testShader.wgsl */ "./shaders/testShader.wgsl");
/* harmony import */ var _wheezy_engine__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @wheezy/engine */ "../engine/index.ts");
/* harmony import */ var _wheezy_engine_src_engine_core_cameras_ArcBallCamera__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @wheezy/engine/src/engine/core/cameras/ArcBallCamera */ "../engine/src/engine/core/cameras/ArcBallCamera/index.ts");




//This is supposed to demonstrate basic workflow
class Demo0 extends _wheezy_engine__WEBPACK_IMPORTED_MODULE_1__.Scene {
    constructor() {
        super();
        this.mercuryHook = this._createTransformObject();
        this.venusHook = this._createTransformObject();
        this.earthHook = this._createTransformObject();
        this.marsHook = this._createTransformObject();
        this.jupiterHook = this._createTransformObject();
        this.saturnHook = this._createTransformObject();
        this.uranusHook = this._createTransformObject();
        this.neptuneHook = this._createTransformObject();
        this.yearsPerMinute = 1;
        this.camera = new _wheezy_engine_src_engine_core_cameras_ArcBallCamera__WEBPACK_IMPORTED_MODULE_2__.ArcBallCamera({
            zFar: 1000,
            zNear: 0.1,
            canvasWidth: this._engine.context.canvas.width,
            canvasHeight: this._engine.context.canvas.height,
            position: wgpu_matrix__WEBPACK_IMPORTED_MODULE_3__.vec3.create(0, 4, 5),
        });
        this._shaderModule = this.engine.device.createShaderModule({
            code: _shaders_testShader_wgsl__WEBPACK_IMPORTED_MODULE_0__,
        });
    }
    _createTransformObject() {
        const gameObject = new _wheezy_engine__WEBPACK_IMPORTED_MODULE_1__.GameObject();
        this.objectManager.addObject(gameObject, this.root);
        new _wheezy_engine__WEBPACK_IMPORTED_MODULE_1__.Transform(gameObject);
        return gameObject;
    }
    async _setupSun() {
        const planetMD = await _wheezy_engine__WEBPACK_IMPORTED_MODULE_1__.WheezyGLBLoader.loadFromUrl('static/models/planets/sun.glb');
        this.sun = await this.uploadModel({
            modelData: planetMD,
            shaderModule: this._shaderModule,
        });
        this.sun.transform.scale(wgpu_matrix__WEBPACK_IMPORTED_MODULE_3__.vec3.create(0.12, 0.12, 0.12));
    }
    async _setupMercury() {
        const planetMD = await _wheezy_engine__WEBPACK_IMPORTED_MODULE_1__.WheezyGLBLoader.loadFromUrl('static/models/planets/mercury.glb');
        this.mercury = await this.uploadModel({
            modelData: planetMD,
            shaderModule: this._shaderModule,
        });
        this.objectManager.reparentObject(this.mercury, this.mercuryHook);
        this.mercuryHook.transform.rotateDegreesEuler({ y: 80 });
        this.mercury.transform.scale(wgpu_matrix__WEBPACK_IMPORTED_MODULE_3__.vec3.create(0.08, 0.08, 0.08));
        this.mercury.transform.translate(wgpu_matrix__WEBPACK_IMPORTED_MODULE_3__.vec3.create(1.4));
    }
    async _setupVenus() {
        const planetMD = await _wheezy_engine__WEBPACK_IMPORTED_MODULE_1__.WheezyGLBLoader.loadFromUrl('static/models/planets/venus.glb');
        this.venus = await this.uploadModel({
            modelData: planetMD,
            shaderModule: this._shaderModule,
        });
        this.objectManager.reparentObject(this.venus, this.venusHook);
        this.venusHook.transform.rotateDegreesEuler({ y: 160 });
        this.venus.transform.scale(wgpu_matrix__WEBPACK_IMPORTED_MODULE_3__.vec3.create(0.12, 0.12, 0.12));
        this.venus.transform.translate(wgpu_matrix__WEBPACK_IMPORTED_MODULE_3__.vec3.create(1.7, 0, 0));
    }
    async _setupEarth() {
        const planetMD = await _wheezy_engine__WEBPACK_IMPORTED_MODULE_1__.WheezyGLBLoader.loadFromUrl('static/models/planets/earth.glb');
        this.earth = await this.uploadModel({
            modelData: planetMD,
            shaderModule: this._shaderModule,
        });
        this.objectManager.reparentObject(this.earth, this.earthHook);
        this.earthHook.transform.rotateDegreesEuler({ y: 10 });
        this.earth.transform.scale(wgpu_matrix__WEBPACK_IMPORTED_MODULE_3__.vec3.create(0.16, 0.16, 0.16));
        this.earth.transform.translate(wgpu_matrix__WEBPACK_IMPORTED_MODULE_3__.vec3.create(2.2, 0, 0));
    }
    async _setupMars() {
        const planetMD = await _wheezy_engine__WEBPACK_IMPORTED_MODULE_1__.WheezyGLBLoader.loadFromUrl('static/models/planets/mars.glb');
        this.mars = await this.uploadModel({
            modelData: planetMD,
            shaderModule: this._shaderModule,
        });
        this.objectManager.reparentObject(this.mars, this.marsHook);
        this.marsHook.transform.rotateDegreesEuler({ y: 50 });
        this.mars.transform.scale(wgpu_matrix__WEBPACK_IMPORTED_MODULE_3__.vec3.create(0.14, 0.14, 0.14));
        this.mars.transform.translate(wgpu_matrix__WEBPACK_IMPORTED_MODULE_3__.vec3.create(2.7, 0, 0));
    }
    async _setupJupiter() {
        const planetMD = await _wheezy_engine__WEBPACK_IMPORTED_MODULE_1__.WheezyGLBLoader.loadFromUrl('static/models/planets/jupiter.glb');
        this.jupiter = await this.uploadModel({
            modelData: planetMD,
            shaderModule: this._shaderModule,
        });
        this.objectManager.reparentObject(this.jupiter, this.jupiterHook);
        this.jupiterHook.transform.rotateDegreesEuler({ y: 150 });
        this.jupiter.transform.scale(wgpu_matrix__WEBPACK_IMPORTED_MODULE_3__.vec3.create(0.15, 0.15, 0.15));
        this.jupiter.transform.rotateDegreesEuler({ x: 90 });
        this.jupiter.transform.translate(wgpu_matrix__WEBPACK_IMPORTED_MODULE_3__.vec3.create(3.4, 0, 0));
    }
    async _setupSaturn() {
        const planetMD = await _wheezy_engine__WEBPACK_IMPORTED_MODULE_1__.WheezyGLBLoader.loadFromUrl('static/models/planets/saturn.glb');
        this.saturn = await this.uploadModel({
            modelData: planetMD,
            shaderModule: this._shaderModule,
        });
        this.objectManager.reparentObject(this.saturn, this.saturnHook);
        this.saturnHook.transform.rotateDegreesEuler({ y: 210 });
        this.saturn.transform.scale(wgpu_matrix__WEBPACK_IMPORTED_MODULE_3__.vec3.create(0.0012, 0.0012, 0.0012));
        this.saturn.transform.rotateDegreesEuler({ x: 76 });
        this.saturn.transform.translate(wgpu_matrix__WEBPACK_IMPORTED_MODULE_3__.vec3.create(4.3, 0, 0));
    }
    async _setupUranus() {
        const planetMD = await _wheezy_engine__WEBPACK_IMPORTED_MODULE_1__.WheezyGLBLoader.loadFromUrl('static/models/planets/uranus.glb');
        this.uranus = await this.uploadModel({
            modelData: planetMD,
            shaderModule: this._shaderModule,
        });
        this.objectManager.reparentObject(this.uranus, this.uranusHook);
        this.uranusHook.transform.rotateDegreesEuler({ y: 270 });
        this.uranus.transform.scale(wgpu_matrix__WEBPACK_IMPORTED_MODULE_3__.vec3.create(0.2, 0.2, 0.2));
        this.uranus.transform.rotateDegreesEuler({ x: 90 });
        this.uranus.transform.translate(wgpu_matrix__WEBPACK_IMPORTED_MODULE_3__.vec3.create(5.2, 0, 0));
    }
    async _setupNeptune() {
        const planetMD = await _wheezy_engine__WEBPACK_IMPORTED_MODULE_1__.WheezyGLBLoader.loadFromUrl('static/models/planets/neptune.glb');
        this.neptune = await this.uploadModel({
            modelData: planetMD,
            shaderModule: this._shaderModule,
        });
        this.objectManager.reparentObject(this.neptune, this.neptuneHook);
        this.neptuneHook.transform.rotateDegreesEuler({ y: 100 });
        this.neptune.transform.scale(wgpu_matrix__WEBPACK_IMPORTED_MODULE_3__.vec3.create(0.2, 0.2, 0.2));
        this.neptune.transform.rotateDegreesEuler({ x: 90 });
        this.neptune.transform.translate(wgpu_matrix__WEBPACK_IMPORTED_MODULE_3__.vec3.create(5.8, 0, 0));
    }
    async init() {
        await this._setupSun();
        await this._setupMercury();
        await this._setupVenus();
        await this._setupEarth();
        await this._setupMars();
        await this._setupJupiter();
        await this._setupSaturn();
        await this._setupUranus();
        await this._setupNeptune();
        const wrapper = document.createElement('div');
        wrapper.style.position = 'absolute';
        wrapper.style.top = '0';
        wrapper.style.zIndex = '10';
        const button0 = document.createElement('button');
        button0.textContent = '1 год в минуту';
        button0.addEventListener('click', () => {
            this.yearsPerMinute = 1;
        });
        const button1 = document.createElement('button');
        button1.textContent = '100 лет в минуту';
        button1.addEventListener('click', () => {
            this.yearsPerMinute = 100;
        });
        wrapper.appendChild(button0);
        wrapper.appendChild(button1);
        document.body.appendChild(wrapper);
    }
    getOrbitRotationPerFrame(name) {
        const commonDivider = 3600 / this.yearsPerMinute;
        switch (name) {
            case 'mercury':
                return (360 * 4.17) / commonDivider;
            case 'venus':
                return (360 * 1.63) / commonDivider;
            case 'earth':
                return (360 * 1) / commonDivider;
            case 'mars':
                return (360 * 0.53) / commonDivider;
            case 'jupiter':
                return (360 * 0.084) / commonDivider;
            case 'saturn':
                return (360 * 0.034) / commonDivider;
            case 'uranus':
                return (360 * 0.012) / commonDivider;
            case 'neptune':
                return (360 * 0.006) / commonDivider;
            default:
                return 0;
        }
    }
    getSelfRotationPerFrame(name) {
        const commonDivider = 3600 / this.yearsPerMinute;
        switch (name) {
            case 'sun':
                return (360 * 0.04 * 365) / commonDivider;
            case 'mercury':
                return (360 * 1.5 * 365) / commonDivider;
            case 'venus':
                return (360 * 1.502 * 365) / commonDivider;
            case 'earth':
                return (360 * 1 * 365) / commonDivider;
            case 'mars':
                return (360 * 1.03 * 365) / commonDivider;
            case 'jupiter':
                return (360 * 0.41 * 365) / commonDivider;
            case 'saturn':
                return (360 * 0.45 * 365) / commonDivider;
            case 'uranus':
                return (360 * 0.666 * 365) / commonDivider;
            case 'neptune':
                return (360 * 0.708 * 365) / commonDivider;
            default:
                return 0;
        }
    }
    onRender(deltaTime) {
        //FYI: Always remember to reset orientation in blender :/
        this.sun.transform.rotateDegreesEuler({
            y: this.getSelfRotationPerFrame('sun'),
        });
        this.mercury.transform.rotateDegreesEuler({
            y: this.getSelfRotationPerFrame('mercury'),
        });
        this.mercuryHook.transform.rotateDegreesEuler({
            y: this.getOrbitRotationPerFrame('mercury'),
        });
        this.venus.transform.rotateDegreesEuler({
            y: this.getSelfRotationPerFrame('venus'),
        });
        this.venusHook.transform.rotateDegreesEuler({
            y: this.getOrbitRotationPerFrame('venus'),
        });
        this.earth.transform.rotateDegreesEuler({
            y: this.getSelfRotationPerFrame('earth'),
        });
        this.earthHook.transform.rotateDegreesEuler({
            y: this.getOrbitRotationPerFrame('earth'),
        });
        this.mars.transform.rotateDegreesEuler({
            y: this.getSelfRotationPerFrame('mars'),
        });
        this.marsHook.transform.rotateDegreesEuler({
            y: this.getOrbitRotationPerFrame('mars'),
        });
        this.jupiter.transform.rotateDegreesEuler({
            z: -this.getSelfRotationPerFrame('jupiter'),
        });
        this.jupiterHook.transform.rotateDegreesEuler({
            y: this.getOrbitRotationPerFrame('jupiter'),
        });
        this.saturn.transform.rotateDegreesEuler({
            z: -this.getSelfRotationPerFrame('saturn'),
        });
        this.saturnHook.transform.rotateDegreesEuler({
            y: this.getOrbitRotationPerFrame('saturn'),
        });
        this.uranus.transform.rotateDegreesEuler({
            z: -this.getSelfRotationPerFrame('uranus'),
        });
        this.uranusHook.transform.rotateDegreesEuler({
            y: this.getOrbitRotationPerFrame('uranus'),
        });
        this.neptune.transform.rotateDegreesEuler({
            z: -this.getSelfRotationPerFrame('neptune'),
        });
        this.neptuneHook.transform.rotateDegreesEuler({
            y: this.getOrbitRotationPerFrame('neptune'),
        });
    }
}


/***/ }),

/***/ "../engine/index.ts":
/*!**************************!*\
  !*** ../engine/index.ts ***!
  \**************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   BufferStorage: () => (/* reexport safe */ _src_engine_core__WEBPACK_IMPORTED_MODULE_0__.BufferStorage),
/* harmony export */   Camera: () => (/* reexport safe */ _src_engine_core__WEBPACK_IMPORTED_MODULE_0__.Camera),
/* harmony export */   Collider: () => (/* reexport safe */ _src_physics__WEBPACK_IMPORTED_MODULE_2__.Collider),
/* harmony export */   Component: () => (/* reexport safe */ _src_engine_core__WEBPACK_IMPORTED_MODULE_0__.Component),
/* harmony export */   DEFAULT_DEPTH_FORMAT: () => (/* reexport safe */ _src_engine_core__WEBPACK_IMPORTED_MODULE_0__.DEFAULT_DEPTH_FORMAT),
/* harmony export */   DEFAULT_SWAP_CHAIN_FORMAT: () => (/* reexport safe */ _src_engine_core__WEBPACK_IMPORTED_MODULE_0__.DEFAULT_SWAP_CHAIN_FORMAT),
/* harmony export */   Engine: () => (/* reexport safe */ _src_engine_core__WEBPACK_IMPORTED_MODULE_0__.Engine),
/* harmony export */   Entity: () => (/* reexport safe */ _src_engine_core__WEBPACK_IMPORTED_MODULE_0__.Entity),
/* harmony export */   EntityTypes: () => (/* reexport safe */ _src_engine_types__WEBPACK_IMPORTED_MODULE_1__.EntityTypes),
/* harmony export */   GLTFTextureFilter: () => (/* reexport safe */ _src_engine_types__WEBPACK_IMPORTED_MODULE_1__.GLTFTextureFilter),
/* harmony export */   GLTFTextureWrap: () => (/* reexport safe */ _src_engine_types__WEBPACK_IMPORTED_MODULE_1__.GLTFTextureWrap),
/* harmony export */   GameObject: () => (/* reexport safe */ _src_engine_core__WEBPACK_IMPORTED_MODULE_0__.GameObject),
/* harmony export */   ImageStorage: () => (/* reexport safe */ _src_engine_core__WEBPACK_IMPORTED_MODULE_0__.ImageStorage),
/* harmony export */   MSAA_SAMPLE_COUNT: () => (/* reexport safe */ _src_engine_core__WEBPACK_IMPORTED_MODULE_0__.MSAA_SAMPLE_COUNT),
/* harmony export */   MaterialStorage: () => (/* reexport safe */ _src_engine_core__WEBPACK_IMPORTED_MODULE_0__.MaterialStorage),
/* harmony export */   Mesh: () => (/* reexport safe */ _src_engine_core__WEBPACK_IMPORTED_MODULE_0__.Mesh),
/* harmony export */   ObjectManager: () => (/* reexport safe */ _src_engine_core__WEBPACK_IMPORTED_MODULE_0__.ObjectManager),
/* harmony export */   PerspectiveCamera: () => (/* reexport safe */ _src_engine_core__WEBPACK_IMPORTED_MODULE_0__.PerspectiveCamera),
/* harmony export */   PhysicsObject: () => (/* reexport safe */ _src_physics__WEBPACK_IMPORTED_MODULE_2__.PhysicsObject),
/* harmony export */   SamplerStorage: () => (/* reexport safe */ _src_engine_core__WEBPACK_IMPORTED_MODULE_0__.SamplerStorage),
/* harmony export */   Scene: () => (/* reexport safe */ _src_engine_core__WEBPACK_IMPORTED_MODULE_0__.Scene),
/* harmony export */   SceneTree: () => (/* reexport safe */ _src_engine_core__WEBPACK_IMPORTED_MODULE_0__.SceneTree),
/* harmony export */   TextureStorage: () => (/* reexport safe */ _src_engine_core__WEBPACK_IMPORTED_MODULE_0__.TextureStorage),
/* harmony export */   Transform: () => (/* reexport safe */ _src_engine_core__WEBPACK_IMPORTED_MODULE_0__.Transform),
/* harmony export */   VIEW_PARAMS_BUFFER_SIZE: () => (/* reexport safe */ _src_engine_core__WEBPACK_IMPORTED_MODULE_0__.VIEW_PARAMS_BUFFER_SIZE),
/* harmony export */   WheezyGLBLoader: () => (/* reexport safe */ _src_utils__WEBPACK_IMPORTED_MODULE_3__.WheezyGLBLoader),
/* harmony export */   alignTo: () => (/* reexport safe */ _src_engine_core__WEBPACK_IMPORTED_MODULE_0__.alignTo)
/* harmony export */ });
/* harmony import */ var _src_engine_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./src/engine/core */ "../engine/src/engine/core/index.ts");
/* harmony import */ var _src_engine_types__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./src/engine/types */ "../engine/src/engine/types/index.ts");
/* harmony import */ var _src_physics__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./src/physics */ "../engine/src/physics/index.ts");
/* harmony import */ var _src_utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./src/utils */ "../engine/src/utils/index.ts");






/***/ }),

/***/ "../engine/src/engine/core/BufferStorage/BufferStorage.ts":
/*!****************************************************************!*\
  !*** ../engine/src/engine/core/BufferStorage/BufferStorage.ts ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   BufferStorage: () => (/* binding */ BufferStorage)
/* harmony export */ });
class BufferStorage {
    constructor() {
        this._buffers = new Map();
    }
    get buffers() {
        return this._buffers;
    }
}


/***/ }),

/***/ "../engine/src/engine/core/BufferStorage/index.ts":
/*!********************************************************!*\
  !*** ../engine/src/engine/core/BufferStorage/index.ts ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   BufferStorage: () => (/* reexport safe */ _BufferStorage__WEBPACK_IMPORTED_MODULE_0__.BufferStorage)
/* harmony export */ });
/* harmony import */ var _BufferStorage__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./BufferStorage */ "../engine/src/engine/core/BufferStorage/BufferStorage.ts");



/***/ }),

/***/ "../engine/src/engine/core/Component/Component.ts":
/*!********************************************************!*\
  !*** ../engine/src/engine/core/Component/Component.ts ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Component: () => (/* binding */ Component)
/* harmony export */ });
/* harmony import */ var _Entity__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Entity */ "../engine/src/engine/core/Entity/index.ts");

class Component extends _Entity__WEBPACK_IMPORTED_MODULE_0__.Entity {
    constructor(parent, componentType) {
        super(componentType);
        this._parent = parent;
        this._parent.addComponent(this);
    }
    get parent() {
        return this._parent;
    }
}


/***/ }),

/***/ "../engine/src/engine/core/Component/index.ts":
/*!****************************************************!*\
  !*** ../engine/src/engine/core/Component/index.ts ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Component: () => (/* reexport safe */ _Component__WEBPACK_IMPORTED_MODULE_0__.Component)
/* harmony export */ });
/* harmony import */ var _Component__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Component */ "../engine/src/engine/core/Component/Component.ts");



/***/ }),

/***/ "../engine/src/engine/core/Engine/Engine.ts":
/*!**************************************************!*\
  !*** ../engine/src/engine/core/Engine/Engine.ts ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Engine: () => (/* binding */ Engine)
/* harmony export */ });
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./constants */ "../engine/src/engine/core/Engine/constants.ts");

class Engine {
    constructor() {
        this._viewParamsBufferSize = _constants__WEBPACK_IMPORTED_MODULE_0__.VIEW_PARAMS_BUFFER_SIZE;
        this._msaaSampleCount = _constants__WEBPACK_IMPORTED_MODULE_0__.MSAA_SAMPLE_COUNT;
        this._prevFrameTime = 0;
    }
    static async getOrInit({ canvas, swapChainFormat, depthTextureFormat, }) {
        //FIXME: types
        try {
            if (window.WheezyEngine) {
                console.warn('Engine has already been instanced');
                return window.WheezyEngine;
            }
            const engineInstance = new Engine();
            await engineInstance.initializeContext(canvas);
            engineInstance.swapChainFormat =
                swapChainFormat ?? _constants__WEBPACK_IMPORTED_MODULE_0__.DEFAULT_SWAP_CHAIN_FORMAT;
            engineInstance.depthTextureFormat =
                depthTextureFormat ?? _constants__WEBPACK_IMPORTED_MODULE_0__.DEFAULT_DEPTH_FORMAT;
            engineInstance.initializeBindGroupLayouts();
            window.WheezyEngine = engineInstance;
            return engineInstance;
        }
        catch (err) {
            alert(err);
        }
    }
    get adapter() {
        return this._adapter;
    }
    get device() {
        return this._device;
    }
    get context() {
        return this._context;
    }
    get swapChainFormat() {
        return this._swapChainFormat;
    }
    set swapChainFormat(format) {
        this._swapChainFormat = format;
        this._context.configure({
            device: this._device,
            usage: GPUTextureUsage.RENDER_ATTACHMENT,
            format,
        });
    }
    get depthTextureFormat() {
        return this._depthTextureFormat;
    }
    set depthTextureFormat(format) {
        this._depthTextureFormat = format;
        this._depthTexture = this._device.createTexture({
            label: 'depthTexture',
            size: {
                width: this._context.canvas.width,
                height: this._context.canvas.height,
            },
            sampleCount: this._msaaSampleCount,
            format,
            usage: GPUTextureUsage.RENDER_ATTACHMENT,
        });
    }
    get depthTexture() {
        return this._depthTexture;
    }
    get scene() {
        return this._scene;
    }
    set scene(scene) {
        this._scene = scene;
    }
    get uniformsBGLayout() {
        return this._uniformsBGLayout;
    }
    get nodeParamsBGLayout() {
        return this._nodeParamsBGLayout;
    }
    get viewParamsBufferSize() {
        return this._viewParamsBufferSize;
    }
    get msaaSampleCount() {
        return this._msaaSampleCount;
    }
    set msaaSampleCount(value) {
        this._msaaSampleCount = value;
    }
    async initializeContext(canvas) {
        const adapter = await navigator.gpu.requestAdapter();
        if (!adapter) {
            throw new Error('GPU Adapter Unavailable');
        }
        const device = await adapter.requestDevice();
        this._device = device;
        this._adapter = adapter;
        canvas.width = document.body.clientWidth * window.devicePixelRatio;
        canvas.height = document.body.clientHeight * window.devicePixelRatio;
        this._context = canvas.getContext('webgpu');
        if (!this._context) {
            throw new Error('Failed to acquire GpuCanvasContext');
        }
    }
    initializeBindGroupLayouts() {
        this._uniformsBGLayout = this.device.createBindGroupLayout({
            entries: [
                {
                    binding: 0,
                    visibility: GPUShaderStage.VERTEX,
                    buffer: { type: 'uniform' },
                },
            ],
        });
        this._nodeParamsBGLayout = this.device.createBindGroupLayout({
            entries: [
                {
                    binding: 0,
                    visibility: GPUShaderStage.VERTEX,
                    buffer: { type: 'uniform' },
                },
            ],
        });
    }
    render(time = 0) {
        if (!this.scene)
            return;
        const dt = (time - this._prevFrameTime) / 100;
        this._prevFrameTime = time;
        this.scene.render(dt);
        requestAnimationFrame((time) => this.render(time));
    }
}


/***/ }),

/***/ "../engine/src/engine/core/Engine/constants.ts":
/*!*****************************************************!*\
  !*** ../engine/src/engine/core/Engine/constants.ts ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   DEFAULT_DEPTH_FORMAT: () => (/* binding */ DEFAULT_DEPTH_FORMAT),
/* harmony export */   DEFAULT_SWAP_CHAIN_FORMAT: () => (/* binding */ DEFAULT_SWAP_CHAIN_FORMAT),
/* harmony export */   MSAA_SAMPLE_COUNT: () => (/* binding */ MSAA_SAMPLE_COUNT),
/* harmony export */   VIEW_PARAMS_BUFFER_SIZE: () => (/* binding */ VIEW_PARAMS_BUFFER_SIZE)
/* harmony export */ });
const DEFAULT_SWAP_CHAIN_FORMAT = 'bgra8unorm';
const DEFAULT_DEPTH_FORMAT = 'depth24plus-stencil8';
const VIEW_PARAMS_BUFFER_SIZE = 16 * 5;
const MSAA_SAMPLE_COUNT = 4;


/***/ }),

/***/ "../engine/src/engine/core/Engine/index.ts":
/*!*************************************************!*\
  !*** ../engine/src/engine/core/Engine/index.ts ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   DEFAULT_DEPTH_FORMAT: () => (/* reexport safe */ _constants__WEBPACK_IMPORTED_MODULE_1__.DEFAULT_DEPTH_FORMAT),
/* harmony export */   DEFAULT_SWAP_CHAIN_FORMAT: () => (/* reexport safe */ _constants__WEBPACK_IMPORTED_MODULE_1__.DEFAULT_SWAP_CHAIN_FORMAT),
/* harmony export */   Engine: () => (/* reexport safe */ _Engine__WEBPACK_IMPORTED_MODULE_0__.Engine),
/* harmony export */   MSAA_SAMPLE_COUNT: () => (/* reexport safe */ _constants__WEBPACK_IMPORTED_MODULE_1__.MSAA_SAMPLE_COUNT),
/* harmony export */   VIEW_PARAMS_BUFFER_SIZE: () => (/* reexport safe */ _constants__WEBPACK_IMPORTED_MODULE_1__.VIEW_PARAMS_BUFFER_SIZE)
/* harmony export */ });
/* harmony import */ var _Engine__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Engine */ "../engine/src/engine/core/Engine/Engine.ts");
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./constants */ "../engine/src/engine/core/Engine/constants.ts");




/***/ }),

/***/ "../engine/src/engine/core/Entity/Entity.ts":
/*!**************************************************!*\
  !*** ../engine/src/engine/core/Entity/Entity.ts ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Entity: () => (/* binding */ Entity)
/* harmony export */ });
class Entity {
    constructor(type) {
        this._id = this._generateId();
        this._type = type;
    }
    _generateId() {
        return String(Math.random());
    }
    get id() {
        return this._id;
    }
    get type() {
        return this._type;
    }
}


/***/ }),

/***/ "../engine/src/engine/core/Entity/index.ts":
/*!*************************************************!*\
  !*** ../engine/src/engine/core/Entity/index.ts ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Entity: () => (/* reexport safe */ _Entity__WEBPACK_IMPORTED_MODULE_0__.Entity)
/* harmony export */ });
/* harmony import */ var _Entity__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Entity */ "../engine/src/engine/core/Entity/Entity.ts");



/***/ }),

/***/ "../engine/src/engine/core/GameObject/GameObject.ts":
/*!**********************************************************!*\
  !*** ../engine/src/engine/core/GameObject/GameObject.ts ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   GameObject: () => (/* binding */ GameObject)
/* harmony export */ });
/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../types */ "../engine/src/engine/types/index.ts");
/* harmony import */ var _Entity__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Entity */ "../engine/src/engine/core/Entity/index.ts");


class GameObject extends _Entity__WEBPACK_IMPORTED_MODULE_1__.Entity {
    constructor() {
        super(_types__WEBPACK_IMPORTED_MODULE_0__.EntityTypes.gameObject);
        this._components = new Map();
        this._name = `GameObject ${super.id}`;
    }
    get name() {
        return this._name;
    }
    set name(value) {
        this._name = value;
    }
    get components() {
        return this._components;
    }
    get transform() {
        //FIXME: find a less dumb way to do it
        if (this._transform) {
            return this._transform;
        }
        return [...this.components.values()].find((component) => component.type === _types__WEBPACK_IMPORTED_MODULE_0__.EntityTypes.transform);
    }
    addComponent(component) {
        this._components.set(component.id, component);
    }
    removeComponent(id) {
        this._components.delete(id);
    }
}


/***/ }),

/***/ "../engine/src/engine/core/GameObject/index.ts":
/*!*****************************************************!*\
  !*** ../engine/src/engine/core/GameObject/index.ts ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   GameObject: () => (/* reexport safe */ _GameObject__WEBPACK_IMPORTED_MODULE_0__.GameObject)
/* harmony export */ });
/* harmony import */ var _GameObject__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./GameObject */ "../engine/src/engine/core/GameObject/GameObject.ts");



/***/ }),

/***/ "../engine/src/engine/core/ImageStorage/ImageStorage.ts":
/*!**************************************************************!*\
  !*** ../engine/src/engine/core/ImageStorage/ImageStorage.ts ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ImageStorage: () => (/* binding */ ImageStorage)
/* harmony export */ });
class ImageStorage {
    constructor() {
        this._images = new Map();
    }
    get images() {
        return this._images;
    }
}


/***/ }),

/***/ "../engine/src/engine/core/ImageStorage/index.ts":
/*!*******************************************************!*\
  !*** ../engine/src/engine/core/ImageStorage/index.ts ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ImageStorage: () => (/* reexport safe */ _ImageStorage__WEBPACK_IMPORTED_MODULE_0__.ImageStorage)
/* harmony export */ });
/* harmony import */ var _ImageStorage__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ImageStorage */ "../engine/src/engine/core/ImageStorage/ImageStorage.ts");



/***/ }),

/***/ "../engine/src/engine/core/MaterialStorage/MaterialStorage.ts":
/*!********************************************************************!*\
  !*** ../engine/src/engine/core/MaterialStorage/MaterialStorage.ts ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   MaterialStorage: () => (/* binding */ MaterialStorage)
/* harmony export */ });
class MaterialStorage {
    constructor() {
        this._materials = new Map();
    }
    get materials() {
        return this._materials;
    }
}


/***/ }),

/***/ "../engine/src/engine/core/MaterialStorage/index.ts":
/*!**********************************************************!*\
  !*** ../engine/src/engine/core/MaterialStorage/index.ts ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   MaterialStorage: () => (/* reexport safe */ _MaterialStorage__WEBPACK_IMPORTED_MODULE_0__.MaterialStorage)
/* harmony export */ });
/* harmony import */ var _MaterialStorage__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./MaterialStorage */ "../engine/src/engine/core/MaterialStorage/MaterialStorage.ts");



/***/ }),

/***/ "../engine/src/engine/core/Mesh/Mesh.ts":
/*!**********************************************!*\
  !*** ../engine/src/engine/core/Mesh/Mesh.ts ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Mesh: () => (/* binding */ Mesh),
/* harmony export */   alignTo: () => (/* binding */ alignTo)
/* harmony export */ });
/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../types */ "../engine/src/engine/types/index.ts");
/* harmony import */ var _Component__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Component */ "../engine/src/engine/core/Component/index.ts");


const alignTo = (val, align) => {
    return Math.floor((val + align - 1) / align) * align;
};
class Mesh extends _Component__WEBPACK_IMPORTED_MODULE_1__.Component {
    constructor(parent, positions, indices, normals, textureCoordinates, material) {
        super(parent, _types__WEBPACK_IMPORTED_MODULE_0__.EntityTypes.mesh);
        this.mode = 4; // GPU topology mode
        this.positions = positions;
        this.indices = indices;
        this.textureCoordinates = textureCoordinates;
        this.material = material;
        this.normals = normals;
    }
    buildRenderPipeline(device, shaderModule, colorFormat, depthFormat, msaaSampleCount, uniformsBGLayout, nodeParamsBGLayout, bufferStorage) {
        //FIXME: REFACTOR THIS SHIT
        this.materialParamsBuffer = device.createBuffer({
            size: 8 * 4,
            usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.UNIFORM,
            mappedAtCreation: true,
        });
        if (this.material) {
            const params = new Float32Array(this.materialParamsBuffer.getMappedRange());
            params.set(this.material.baseColorFactor, 0);
            params.set([this.material.metallicFactor, this.material.roughnessFactor], 4);
            this.materialParamsBuffer.unmap();
        }
        const sampleType = 'float';
        let materialBindGroupLayoutEntries = [
            {
                binding: 0,
                visibility: GPUShaderStage.FRAGMENT,
                buffer: {
                    type: 'uniform',
                },
            },
        ];
        let samplerBindGroupLayoutEntries = [];
        let samplerBindGroupEntries = [];
        let materialBindGroupEntries = [
            {
                binding: 0,
                resource: {
                    buffer: this.materialParamsBuffer,
                    size: 8 * 4,
                },
            },
        ];
        // If we have a base color texture, add the sampler and texture bindings
        if (this.material?.baseColorTexture) {
            samplerBindGroupLayoutEntries.push({
                binding: 1,
                visibility: GPUShaderStage.FRAGMENT,
                sampler: {},
            });
            materialBindGroupLayoutEntries.push({
                binding: 1,
                visibility: GPUShaderStage.FRAGMENT,
                texture: {
                    sampleType,
                },
            });
            samplerBindGroupEntries.push({
                binding: 1,
                resource: this.material.baseColorTexture.sampler,
            });
            materialBindGroupEntries.push({
                binding: 1,
                resource: this.material.baseColorTexture.view,
            });
        }
        if (this.material?.metallicRoughnessTexture) {
            samplerBindGroupLayoutEntries.push({
                binding: 2,
                visibility: GPUShaderStage.FRAGMENT,
                sampler: {},
            });
            materialBindGroupLayoutEntries.push({
                binding: 2,
                visibility: GPUShaderStage.FRAGMENT,
                texture: {
                    sampleType,
                },
            });
            samplerBindGroupEntries.push({
                binding: 2,
                resource: this.material?.metallicRoughnessTexture.sampler,
            });
            materialBindGroupEntries.push({
                binding: 2,
                resource: this.material?.metallicRoughnessTexture.view,
            });
        }
        if (this.material?.normalTexture) {
            samplerBindGroupLayoutEntries.push({
                binding: 3,
                visibility: GPUShaderStage.FRAGMENT,
                sampler: {},
            });
            materialBindGroupLayoutEntries.push({
                binding: 3,
                visibility: GPUShaderStage.FRAGMENT,
                texture: {
                    sampleType,
                },
            });
            samplerBindGroupEntries.push({
                binding: 3,
                resource: this.material?.normalTexture.sampler,
            });
            materialBindGroupEntries.push({
                binding: 3,
                resource: this.material?.normalTexture.view,
            });
        }
        const vertexState = {
            module: shaderModule,
            entryPoint: 'vertex_main',
            buffers: [
                {
                    arrayStride: this.positions.byteStride,
                    attributes: [
                        {
                            format: this.positions.elementType,
                            offset: 0,
                            shaderLocation: 0,
                        },
                    ],
                },
            ],
        };
        if (this.textureCoordinates) {
            ;
            vertexState.buffers.push({
                arrayStride: this.textureCoordinates.byteStride,
                attributes: [
                    {
                        format: this.textureCoordinates.elementType,
                        offset: 0,
                        shaderLocation: 1,
                    },
                ],
            });
        }
        if (this.normals) {
            ;
            vertexState.buffers.push({
                arrayStride: this.normals.byteStride,
                attributes: [
                    {
                        format: this.normals.elementType,
                        offset: 0,
                        shaderLocation: 2,
                    },
                ],
            });
        }
        const fragmentState = {
            module: shaderModule,
            entryPoint: 'fragment_main',
            targets: [{ format: colorFormat }],
        };
        const primitive = {
            topology: 'triangle-list',
            stripIndexFormat: undefined,
        };
        if (this.mode === 5) {
            primitive.topology = 'triangle-strip';
            primitive.stripIndexFormat = this?.indices
                ?.elementType;
        }
        const samplerBindGroupLayout = device.createBindGroupLayout({
            entries: samplerBindGroupLayoutEntries,
            label: 'samplerBindGroupLayout',
        });
        const materialBindGroupLayout = device.createBindGroupLayout({
            entries: materialBindGroupLayoutEntries,
            label: 'materialBindGroupLayout',
        });
        this.samplerBindGroup = device.createBindGroup({
            layout: samplerBindGroupLayout,
            entries: samplerBindGroupEntries,
        });
        this.materialBindGroup = device.createBindGroup({
            layout: materialBindGroupLayout,
            entries: materialBindGroupEntries,
        });
        const layout = device.createPipelineLayout({
            bindGroupLayouts: [
                uniformsBGLayout,
                nodeParamsBGLayout,
                materialBindGroupLayout,
                samplerBindGroupLayout,
            ],
        });
        this.renderPipeline = device.createRenderPipeline({
            layout: layout,
            vertex: vertexState,
            fragment: fragmentState,
            primitive: primitive,
            depthStencil: {
                format: depthFormat,
                depthWriteEnabled: true,
                depthCompare: 'less',
            },
            multisample: {
                count: msaaSampleCount,
            },
        });
        const positionsView = new Uint8Array(bufferStorage.buffers.get(this.positions.bufferId), this.positions.byteOffset, this.positions.byteLength);
        this.positionsBuffer = device.createBuffer({
            size: alignTo(this.positions.byteLength, 4),
            usage: this.positions.usage,
            mappedAtCreation: true,
        });
        new Uint8Array(this.positionsBuffer.getMappedRange()).set(positionsView);
        this.positionsBuffer.unmap();
        if (this.textureCoordinates) {
            const textureCoordinatesBuffer = bufferStorage.buffers.get(this?.textureCoordinates.bufferId);
            const textureCoordinatesView = new Uint8Array(textureCoordinatesBuffer, this.textureCoordinates.byteOffset, this.textureCoordinates.byteLength);
            this.textureCoordinatesBuffer = device.createBuffer({
                size: alignTo(this.textureCoordinates.byteLength, 4),
                usage: this.textureCoordinates.usage,
                mappedAtCreation: true,
            });
            new Uint8Array(this.textureCoordinatesBuffer.getMappedRange()).set(textureCoordinatesView);
            this.textureCoordinatesBuffer.unmap();
        }
        if (this.normals) {
            const normalsBuffer = bufferStorage.buffers.get(this?.normals.bufferId);
            const normalsView = new Uint8Array(normalsBuffer, this.normals.byteOffset, this.normals.byteLength);
            this.normalsBuffer = device.createBuffer({
                size: alignTo(this.normals.byteLength, 4),
                usage: this.normals.usage,
                mappedAtCreation: true,
            });
            new Uint8Array(this.normalsBuffer.getMappedRange()).set(normalsView);
            this.normalsBuffer.unmap();
        }
        if (this.indices) {
            const indicesBuffer = bufferStorage.buffers.get(this?.indices.bufferId);
            const indicesView = new Uint8Array(indicesBuffer, this.indices.byteOffset, this.indices.byteLength);
            this.indicesBuffer = device.createBuffer({
                size: alignTo(this.indices.byteLength, 4),
                usage: this.indices.usage,
                mappedAtCreation: true,
            });
            new Uint8Array(this.indicesBuffer.getMappedRange()).set(indicesView);
            this.indicesBuffer.unmap();
        }
    }
    render(renderPassEncoder) {
        renderPassEncoder.setPipeline(this.renderPipeline);
        if (this.materialBindGroup) {
            renderPassEncoder.setBindGroup(2, this.materialBindGroup);
        }
        if (this.samplerBindGroup) {
            renderPassEncoder.setBindGroup(3, this.samplerBindGroup);
        }
        renderPassEncoder.setVertexBuffer(0, this.positionsBuffer, 0, this.positions.byteLength);
        if (this.textureCoordinates) {
            renderPassEncoder.setVertexBuffer(1, this.textureCoordinatesBuffer, 0, this.textureCoordinates.byteLength);
        }
        if (this.normals) {
            renderPassEncoder.setVertexBuffer(2, this.normalsBuffer, 0, this.normals.byteLength);
        }
        if (this.indices) {
            renderPassEncoder.setIndexBuffer(this.indicesBuffer, this.indices.elementType, 0, this.indices.byteLength);
            renderPassEncoder.drawIndexed(this.indices.count);
        }
        else {
            renderPassEncoder.draw(this.positions.count);
        }
    }
}


/***/ }),

/***/ "../engine/src/engine/core/Mesh/index.ts":
/*!***********************************************!*\
  !*** ../engine/src/engine/core/Mesh/index.ts ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Mesh: () => (/* reexport safe */ _Mesh__WEBPACK_IMPORTED_MODULE_0__.Mesh),
/* harmony export */   alignTo: () => (/* reexport safe */ _Mesh__WEBPACK_IMPORTED_MODULE_0__.alignTo)
/* harmony export */ });
/* harmony import */ var _Mesh__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Mesh */ "../engine/src/engine/core/Mesh/Mesh.ts");



/***/ }),

/***/ "../engine/src/engine/core/ModelUploader/ModelUploader.ts":
/*!****************************************************************!*\
  !*** ../engine/src/engine/core/ModelUploader/ModelUploader.ts ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ModelUploader: () => (/* binding */ ModelUploader)
/* harmony export */ });
/* harmony import */ var wgpu_matrix__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! wgpu-matrix */ "../../node_modules/wgpu-matrix/dist/3.x/wgpu-matrix.module.js");
/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../types */ "../engine/src/engine/types/index.ts");
/* harmony import */ var _GameObject__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../GameObject */ "../engine/src/engine/core/GameObject/index.ts");
/* harmony import */ var _Mesh__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../Mesh */ "../engine/src/engine/core/Mesh/index.ts");
/* harmony import */ var _Transform__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../Transform */ "../engine/src/engine/core/Transform/index.ts");





class ModelUploader {
    static getTextureFilterMode(filter) {
        switch (filter) {
            case _types__WEBPACK_IMPORTED_MODULE_0__.GLTFTextureFilter.NEAREST_MIPMAP_NEAREST:
            case _types__WEBPACK_IMPORTED_MODULE_0__.GLTFTextureFilter.NEAREST_MIPMAP_LINEAR:
            case _types__WEBPACK_IMPORTED_MODULE_0__.GLTFTextureFilter.NEAREST:
                return 'nearest';
            case _types__WEBPACK_IMPORTED_MODULE_0__.GLTFTextureFilter.LINEAR_MIPMAP_NEAREST:
            case _types__WEBPACK_IMPORTED_MODULE_0__.GLTFTextureFilter.LINEAR_MIPMAP_LINEAR:
            case _types__WEBPACK_IMPORTED_MODULE_0__.GLTFTextureFilter.LINEAR:
                return 'linear';
            default:
                return 'linear';
        }
    }
    static getTextureMipMapMode(filter) {
        switch (filter) {
            case _types__WEBPACK_IMPORTED_MODULE_0__.GLTFTextureFilter.NEAREST_MIPMAP_NEAREST:
            case _types__WEBPACK_IMPORTED_MODULE_0__.GLTFTextureFilter.LINEAR_MIPMAP_NEAREST:
            case _types__WEBPACK_IMPORTED_MODULE_0__.GLTFTextureFilter.NEAREST:
                return 'nearest';
            case _types__WEBPACK_IMPORTED_MODULE_0__.GLTFTextureFilter.LINEAR_MIPMAP_LINEAR:
            case _types__WEBPACK_IMPORTED_MODULE_0__.GLTFTextureFilter.NEAREST_MIPMAP_LINEAR:
            case _types__WEBPACK_IMPORTED_MODULE_0__.GLTFTextureFilter.LINEAR:
                return 'linear';
        }
    }
    static getTextureAddressMode(mode) {
        switch (mode) {
            case _types__WEBPACK_IMPORTED_MODULE_0__.GLTFTextureWrap.REPEAT:
                return 'repeat';
            case _types__WEBPACK_IMPORTED_MODULE_0__.GLTFTextureWrap.CLAMP_TO_EDGE:
                return 'clamp-to-edge';
            case _types__WEBPACK_IMPORTED_MODULE_0__.GLTFTextureWrap.MIRRORED_REPEAT:
                return 'mirror-repeat';
            default:
                return 'repeat';
        }
    }
    static async uploadImages(modelData, bufferStorage, imageStorage) {
        for (let [key, value] of modelData.images.entries()) {
            const { bufferView: { buffer, byteLength, byteOffset }, mimeType, } = value;
            const imageView = new Uint8Array(bufferStorage.buffers.get(buffer), byteOffset, byteLength);
            const blob = new Blob([imageView], { type: mimeType });
            const bitmap = await createImageBitmap(blob);
            imageStorage.images.set(key, bitmap);
        }
    }
    static uploadBuffers(modelData, bufferStorage) {
        modelData.buffers.forEach((value, key) => {
            bufferStorage.buffers.set(key, value);
        });
    }
    static uploadSamplers(modelData, samplerStorage, device) {
        modelData.samplers.forEach((value, key) => {
            const gpuSampler = device.createSampler({
                magFilter: this.getTextureFilterMode(value?.magFilter),
                minFilter: this.getTextureFilterMode(value?.minFilter),
                addressModeU: this.getTextureAddressMode(value?.wrapS),
                addressModeV: this.getTextureAddressMode(value?.wrapT),
                //FIXME: use mipmap filtration
                mipmapFilter: 'nearest',
            });
            samplerStorage.samplers.set(key, gpuSampler);
        });
    }
    static uploadTextures(modelData, textureStorage) {
        modelData.textures.forEach((value, key) => {
            textureStorage.textures.set(key, value);
        });
    }
    static createGPUTexture(device, format, samplerStorage, imageStorage, texturePreloadData) {
        let textureView;
        let textureSampler;
        if (!texturePreloadData) {
            console.warn('No texture data');
            return;
        }
        if (!texturePreloadData.imageId) {
            throw new Error('No image view for this texture');
        }
        if (!texturePreloadData.samplerId) {
            throw new Error('No sampler for this texture');
        }
        textureSampler = samplerStorage.samplers.get(texturePreloadData.samplerId);
        const imageBitmap = imageStorage.images.get(texturePreloadData.imageId);
        const imageSize = [imageBitmap.width, imageBitmap.height, 1];
        const imageTexture = device.createTexture({
            size: imageSize,
            format: format,
            usage: GPUTextureUsage.TEXTURE_BINDING |
                GPUTextureUsage.COPY_DST |
                GPUTextureUsage.RENDER_ATTACHMENT,
        });
        device.queue.copyExternalImageToTexture({ source: imageBitmap }, { texture: imageTexture }, imageSize);
        textureView = imageTexture.createView();
        return { view: textureView, sampler: textureSampler };
    }
    static uploadMaterials(modelData, textureStorage, samplerStorage, imageStorage, materialStorage, device) {
        modelData.materials.forEach((value, key) => {
            const material = {
                name: value.name,
                emissiveFactor: value?.emissiveFactor ?? wgpu_matrix__WEBPACK_IMPORTED_MODULE_4__.vec3.create(1, 1, 1),
                metallicFactor: value?.metallicFactor ?? 1,
                roughnessFactor: value.roughnessFactor ?? 1,
                baseColorFactor: value?.baseColorFactor ?? wgpu_matrix__WEBPACK_IMPORTED_MODULE_4__.vec4.create(1, 1, 1, 1),
            };
            if (value.baseColorTextureId) {
                material.baseColorTexture = this.createGPUTexture(device, 'rgba8unorm-srgb', samplerStorage, imageStorage, textureStorage.textures.get(value.baseColorTextureId));
            }
            if (value.metallicRoughnessTextureId) {
                material.metallicRoughnessTexture = this.createGPUTexture(device, 'rgba8unorm', samplerStorage, imageStorage, textureStorage.textures.get(value.metallicRoughnessTextureId));
            }
            if (value.normalTextureId) {
                material.normalTexture = this.createGPUTexture(device, 'rgba8unorm-srgb', samplerStorage, imageStorage, textureStorage.textures.get(value.normalTextureId));
            }
            materialStorage.materials.set(key, material);
        });
    }
    static traversePreloadNode(node, parentGameObject, objectManager, pipelineParams, bufferStorage, materialStorage) {
        const { trsMatrix, meshes, children } = node;
        const gameObject = new _GameObject__WEBPACK_IMPORTED_MODULE_1__.GameObject();
        objectManager.addObject(gameObject, parentGameObject);
        new _Transform__WEBPACK_IMPORTED_MODULE_3__.Transform(gameObject, trsMatrix);
        const { device, shaderModule, colorFormat: swapChainFormat, depthFormat, msaaSampleCount, uniformsBGLayout: viewParamsBindGroupLayout, nodeParamsBGLayout: nodeParamsBindGroupLayout, } = pipelineParams;
        meshes.forEach((meshData) => {
            const mesh = new _Mesh__WEBPACK_IMPORTED_MODULE_2__.Mesh(gameObject, meshData.positions, meshData.indices, meshData.normals, meshData.textureCoordinates, meshData.materialId
                ? materialStorage.materials.get(meshData.materialId)
                : undefined);
            mesh.buildRenderPipeline(device, shaderModule, swapChainFormat, depthFormat, msaaSampleCount, viewParamsBindGroupLayout, nodeParamsBindGroupLayout, bufferStorage);
        });
        children.forEach((child) => {
            this.traversePreloadNode(child, gameObject, objectManager, pipelineParams, bufferStorage, materialStorage);
        });
    }
    static async uploadModel(modelData, objectManager, pipelineParams, bufferStorage, imageStorage, samplerStorage, materialStorage, textureStorage, sceneObject) {
        const { device, shaderModule, colorFormat: swapChainFormat, depthFormat, uniformsBGLayout: viewParamsBindGroupLayout, nodeParamsBGLayout: nodeParamsBindGroupLayout, msaaSampleCount, } = pipelineParams;
        this.uploadBuffers(modelData, bufferStorage);
        await this.uploadImages(modelData, bufferStorage, imageStorage);
        this.uploadSamplers(modelData, samplerStorage, pipelineParams.device);
        this.uploadTextures(modelData, textureStorage);
        this.uploadMaterials(modelData, textureStorage, samplerStorage, imageStorage, materialStorage, pipelineParams.device);
        const { trsMatrix, meshes, children } = modelData.model;
        const meshObject = new _GameObject__WEBPACK_IMPORTED_MODULE_1__.GameObject();
        objectManager.addObject(meshObject, sceneObject);
        new _Transform__WEBPACK_IMPORTED_MODULE_3__.Transform(meshObject, trsMatrix);
        meshes.forEach((meshData) => {
            const mesh = new _Mesh__WEBPACK_IMPORTED_MODULE_2__.Mesh(meshObject, meshData.positions, meshData.indices, meshData.normals, meshData.textureCoordinates, meshData.materialId
                ? materialStorage.materials.get(meshData.materialId)
                : undefined);
            mesh.buildRenderPipeline(device, shaderModule, swapChainFormat, depthFormat, msaaSampleCount, viewParamsBindGroupLayout, nodeParamsBindGroupLayout, bufferStorage);
        });
        children.forEach((child) => {
            this.traversePreloadNode(child, meshObject, objectManager, pipelineParams, bufferStorage, materialStorage);
        });
        return meshObject;
    }
}


/***/ }),

/***/ "../engine/src/engine/core/ModelUploader/index.ts":
/*!********************************************************!*\
  !*** ../engine/src/engine/core/ModelUploader/index.ts ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ModelUploader: () => (/* reexport safe */ _ModelUploader__WEBPACK_IMPORTED_MODULE_0__.ModelUploader)
/* harmony export */ });
/* harmony import */ var _ModelUploader__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ModelUploader */ "../engine/src/engine/core/ModelUploader/ModelUploader.ts");



/***/ }),

/***/ "../engine/src/engine/core/ObjectManager/ObjectManager.ts":
/*!****************************************************************!*\
  !*** ../engine/src/engine/core/ObjectManager/ObjectManager.ts ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ObjectManager: () => (/* binding */ ObjectManager)
/* harmony export */ });
/* harmony import */ var _SceneTree__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../SceneTree */ "../engine/src/engine/core/SceneTree/index.ts");

class ObjectManager {
    constructor() {
        this._objectPositions = new Map();
        this._sceneTree = new _SceneTree__WEBPACK_IMPORTED_MODULE_0__.SceneTree();
    }
    get sceneTree() {
        return this._sceneTree;
    }
    getObjectPosition(gameObject) {
        return gameObject
            ? this._objectPositions.get(gameObject.id) ?? null
            : null;
    }
    addObject(child, target) {
        const position = this._sceneTree.addNodeAt(this.getObjectPosition(target), {
            gameObject: child,
            children: new Map(),
        });
        this._objectPositions.set(child.id, position);
    }
    reparentObject(child, target) {
        const childPosition = this._objectPositions.get(child.id);
        if (!childPosition) {
            throw new Error(`Position record not found for ${child.id}`);
        }
        const newPosition = this._sceneTree.reparentNode(this.getObjectPosition(target), childPosition);
        this._objectPositions.set(child.id, newPosition);
    }
    destroyObject(gameObject) {
        const childPosition = this._objectPositions.get(gameObject.id);
        if (!childPosition) {
            throw new Error(`Position record not found for ${gameObject.id}`);
        }
        const idsToRemove = this._sceneTree.removeNode(childPosition);
        idsToRemove.forEach((id) => {
            this._objectPositions.delete(id);
        });
    }
}


/***/ }),

/***/ "../engine/src/engine/core/ObjectManager/index.ts":
/*!********************************************************!*\
  !*** ../engine/src/engine/core/ObjectManager/index.ts ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ObjectManager: () => (/* reexport safe */ _ObjectManager__WEBPACK_IMPORTED_MODULE_0__.ObjectManager)
/* harmony export */ });
/* harmony import */ var _ObjectManager__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ObjectManager */ "../engine/src/engine/core/ObjectManager/ObjectManager.ts");



/***/ }),

/***/ "../engine/src/engine/core/SamplerStorage/SamplerStorage.ts":
/*!******************************************************************!*\
  !*** ../engine/src/engine/core/SamplerStorage/SamplerStorage.ts ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   SamplerStorage: () => (/* binding */ SamplerStorage)
/* harmony export */ });
class SamplerStorage {
    constructor() {
        this._samplers = new Map();
    }
    get samplers() {
        return this._samplers;
    }
}


/***/ }),

/***/ "../engine/src/engine/core/SamplerStorage/index.ts":
/*!*********************************************************!*\
  !*** ../engine/src/engine/core/SamplerStorage/index.ts ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   SamplerStorage: () => (/* reexport safe */ _SamplerStorage__WEBPACK_IMPORTED_MODULE_0__.SamplerStorage)
/* harmony export */ });
/* harmony import */ var _SamplerStorage__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./SamplerStorage */ "../engine/src/engine/core/SamplerStorage/SamplerStorage.ts");



/***/ }),

/***/ "../engine/src/engine/core/Scene/Scene.ts":
/*!************************************************!*\
  !*** ../engine/src/engine/core/Scene/Scene.ts ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Scene: () => (/* binding */ Scene)
/* harmony export */ });
/* harmony import */ var wgpu_matrix__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! wgpu-matrix */ "../../node_modules/wgpu-matrix/dist/3.x/wgpu-matrix.module.js");
/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../types */ "../engine/src/engine/types/index.ts");
/* harmony import */ var _BufferStorage__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../BufferStorage */ "../engine/src/engine/core/BufferStorage/index.ts");
/* harmony import */ var _cameras_ArcBallCamera__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../cameras/ArcBallCamera */ "../engine/src/engine/core/cameras/ArcBallCamera/index.ts");
/* harmony import */ var _ImageStorage__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../ImageStorage */ "../engine/src/engine/core/ImageStorage/index.ts");
/* harmony import */ var _MaterialStorage__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../MaterialStorage */ "../engine/src/engine/core/MaterialStorage/index.ts");
/* harmony import */ var _ModelUploader__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../ModelUploader */ "../engine/src/engine/core/ModelUploader/index.ts");
/* harmony import */ var _ObjectManager__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../ObjectManager */ "../engine/src/engine/core/ObjectManager/index.ts");
/* harmony import */ var _SamplerStorage__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../SamplerStorage */ "../engine/src/engine/core/SamplerStorage/index.ts");
/* harmony import */ var _TextureStorage__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../TextureStorage */ "../engine/src/engine/core/TextureStorage/index.ts");
/* harmony import */ var _utils_Stuff__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../../../utils/Stuff */ "../engine/src/utils/Stuff.ts");
/* harmony import */ var _GameObject__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../GameObject */ "../engine/src/engine/core/GameObject/index.ts");












class Scene {
    constructor(props) {
        this._objectManager = new _ObjectManager__WEBPACK_IMPORTED_MODULE_6__.ObjectManager();
        this._bufferStorage = new _BufferStorage__WEBPACK_IMPORTED_MODULE_1__.BufferStorage();
        this._imageStorage = new _ImageStorage__WEBPACK_IMPORTED_MODULE_3__.ImageStorage();
        this._samplerStorage = new _SamplerStorage__WEBPACK_IMPORTED_MODULE_7__.SamplerStorage();
        this._textureStorage = new _TextureStorage__WEBPACK_IMPORTED_MODULE_8__.TextureStorage();
        this._materialStorage = new _MaterialStorage__WEBPACK_IMPORTED_MODULE_4__.MaterialStorage();
        const { camera } = props ?? {};
        //FIXME: types
        this._engine = window.WheezyEngine;
        if (!this._engine) {
            throw new Error('Failed to initialize scene as no instance of Wheezy Engine is found');
        }
        this._root = new _GameObject__WEBPACK_IMPORTED_MODULE_10__.GameObject();
        this._objectManager.addObject(this._root);
        this._initializeViewParams();
        if (this._engine.msaaSampleCount !== 1) {
            this._multisampleTextureView = this._engine.device
                .createTexture({
                size: [
                    this._engine.context.canvas.width,
                    this._engine.context.canvas.height,
                ],
                sampleCount: this._engine.msaaSampleCount,
                format: this._engine.swapChainFormat,
                usage: GPUTextureUsage.RENDER_ATTACHMENT,
            })
                .createView();
        }
        else {
            this._multisampleTextureView = undefined;
        }
        this._renderPassDescriptor = {
            colorAttachments: [
                {
                    view: null,
                    resolveTarget: (this._engine.msaaSampleCount === 1
                        ? undefined
                        : null),
                    loadOp: 'clear',
                    clearValue: [0.0, 0.0, 0.0, 1],
                    storeOp: this._engine.msaaSampleCount === 1
                        ? 'store'
                        : 'discard',
                },
            ],
            depthStencilAttachment: {
                view: this._engine.depthTexture.createView(),
                depthLoadOp: 'clear',
                depthClearValue: 1.0,
                depthStoreOp: 'store',
                stencilLoadOp: 'clear',
                stencilClearValue: 0,
                stencilStoreOp: 'store',
            },
        };
        this.camera =
            camera ??
                new _cameras_ArcBallCamera__WEBPACK_IMPORTED_MODULE_2__.ArcBallCamera({
                    zFar: 1000,
                    zNear: 0.1,
                    canvasWidth: this._engine.context.canvas.width,
                    canvasHeight: this._engine.context.canvas.height,
                    position: wgpu_matrix__WEBPACK_IMPORTED_MODULE_11__.vec3.create(0, 0, 5),
                });
    }
    get objectManager() {
        return this._objectManager;
    }
    get root() {
        return this._root;
    }
    get textureStorage() {
        return this._textureStorage;
    }
    get materialStorage() {
        return this._materialStorage;
    }
    get bufferStorage() {
        return this._bufferStorage;
    }
    get imageStorage() {
        return this._imageStorage;
    }
    get samplerStorage() {
        return this._samplerStorage;
    }
    get renderPassDescriptor() {
        return this._renderPassDescriptor;
    }
    get camera() {
        return this._camera;
    }
    set camera(value) {
        this._camera = value;
    }
    get viewParamsBuffer() {
        return this._viewParamsBuffer;
    }
    get multisampleTextureView() {
        return this._multisampleTextureView;
    }
    get viewParamsBindGroup() {
        return this._viewParamsBindGroup;
    }
    get engine() {
        return this._engine;
    }
    _initializeViewParams() {
        if (!this._engine) {
            throw new Error('Failed to initialize buffers as no instance of Wheezy Engine is found');
        }
        this._viewParamsBuffer = this._engine.device.createBuffer({
            size: this._engine.viewParamsBufferSize,
            usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,
        });
        this._viewParamsBindGroup = this._engine.device.createBindGroup({
            layout: this._engine.uniformsBGLayout,
            entries: [
                { binding: 0, resource: { buffer: this._viewParamsBuffer } },
            ],
        });
    }
    uploadModel(props) {
        if (!this._engine) {
            throw new Error('Failed to upload model as no instance of Wheezy Engine is found');
        }
        return _ModelUploader__WEBPACK_IMPORTED_MODULE_5__.ModelUploader.uploadModel(props.modelData, this._objectManager, {
            device: this._engine.device,
            shaderModule: props.shaderModule,
            colorFormat: this._engine.swapChainFormat,
            depthFormat: this._engine.depthTextureFormat,
            uniformsBGLayout: this._engine.uniformsBGLayout,
            nodeParamsBGLayout: this._engine.nodeParamsBGLayout,
            msaaSampleCount: this._engine.msaaSampleCount,
        }, this._bufferStorage, this._imageStorage, this._samplerStorage, this._materialStorage, this._textureStorage, this._root);
    }
    onRender(deltaTime) {
        throw new Error('onRender method should be redefined in extending class');
    }
    render(deltaTime) {
        if (!this._engine) {
            throw new Error('Failed to render scene as no instance of Wheezy Engine is found');
        }
        this.onRender(deltaTime);
        const meshesToRender = [];
        const viewParamsUploadBuffer = this._engine.device.createBuffer({
            size: this._engine.viewParamsBufferSize,
            usage: GPUBufferUsage.COPY_SRC,
            mappedAtCreation: true,
        });
        const viewMap = new Float32Array(viewParamsUploadBuffer.getMappedRange());
        viewMap.set(this.camera.projectionMatrix);
        viewMap.set(this.camera.position, 16);
        viewParamsUploadBuffer.unmap();
        const iterateNode = (node, worldMatrix) => {
            const nodeTransform = node.gameObject.transform;
            const meshMatrix = nodeTransform
                ? wgpu_matrix__WEBPACK_IMPORTED_MODULE_11__.mat4.mul(worldMatrix, nodeTransform.matrix)
                : worldMatrix;
            node?.gameObject?.components?.forEach((component) => {
                if (!this._engine) {
                    throw new Error('Failed to iterate nodes as no instance of Wheezy Engine is found');
                }
                if (component.type === _types__WEBPACK_IMPORTED_MODULE_0__.EntityTypes.mesh) {
                    //FIXME: this can be done once per node, and only if node contains meshes
                    const viewMatrix = wgpu_matrix__WEBPACK_IMPORTED_MODULE_11__.mat4.copy(this.camera.view);
                    wgpu_matrix__WEBPACK_IMPORTED_MODULE_11__.mat4.translate(viewMatrix, wgpu_matrix__WEBPACK_IMPORTED_MODULE_11__.mat4.getTranslation(meshMatrix), viewMatrix);
                    wgpu_matrix__WEBPACK_IMPORTED_MODULE_11__.mat4.scale(viewMatrix, wgpu_matrix__WEBPACK_IMPORTED_MODULE_11__.mat4.getScaling(meshMatrix), viewMatrix);
                    //FIXME: Do this once on load
                    const meshRotation = _utils_Stuff__WEBPACK_IMPORTED_MODULE_9__.Stuff.extractEulerRotation(meshMatrix);
                    wgpu_matrix__WEBPACK_IMPORTED_MODULE_11__.mat4.rotateX(viewMatrix, meshRotation[0], viewMatrix);
                    wgpu_matrix__WEBPACK_IMPORTED_MODULE_11__.mat4.rotateY(viewMatrix, meshRotation[1], viewMatrix);
                    wgpu_matrix__WEBPACK_IMPORTED_MODULE_11__.mat4.rotateZ(viewMatrix, meshRotation[2], viewMatrix);
                    const nodeParamsUploadBuffer = this._engine.device.createBuffer({
                        size: 16 * 4,
                        usage: GPUBufferUsage.UNIFORM |
                            GPUBufferUsage.COPY_DST,
                        mappedAtCreation: true,
                    });
                    const nodeParamsMap = new Float32Array(nodeParamsUploadBuffer.getMappedRange());
                    nodeParamsMap.set(viewMatrix);
                    nodeParamsUploadBuffer.unmap();
                    component.nodeParamsBindGroup =
                        this._engine.device.createBindGroup({
                            layout: this._engine.nodeParamsBGLayout,
                            entries: [
                                {
                                    binding: 0,
                                    resource: {
                                        buffer: nodeParamsUploadBuffer,
                                    },
                                },
                            ],
                        });
                    meshesToRender.push(component);
                }
            });
            node?.children?.forEach((child) => {
                iterateNode(child, meshMatrix);
            });
        };
        this.objectManager.sceneTree.nodes.forEach((node) => {
            iterateNode(node, wgpu_matrix__WEBPACK_IMPORTED_MODULE_11__.mat4.identity());
        });
        const commandEncoder = this._engine.device.createCommandEncoder();
        commandEncoder.copyBufferToBuffer(viewParamsUploadBuffer, 0, this.viewParamsBuffer, 0, this._engine.viewParamsBufferSize);
        this.renderPassDescriptor.colorAttachments[0].view =
            this._engine.context.getCurrentTexture().createView();
        if (this._engine.msaaSampleCount !== 1) {
            ;
            this.renderPassDescriptor.colorAttachments[0].view =
                this._multisampleTextureView;
            this.renderPassDescriptor.colorAttachments[0].resolveTarget = this._engine.context
                .getCurrentTexture()
                .createView();
        }
        const renderPass = commandEncoder.beginRenderPass(this.renderPassDescriptor);
        renderPass.setBindGroup(0, this.viewParamsBindGroup);
        meshesToRender.forEach((mesh) => {
            renderPass.setBindGroup(1, mesh.nodeParamsBindGroup);
            mesh.render(renderPass);
        });
        renderPass.end();
        this._engine.device.queue.submit([commandEncoder.finish()]);
        viewParamsUploadBuffer.destroy();
    }
}


/***/ }),

/***/ "../engine/src/engine/core/Scene/index.ts":
/*!************************************************!*\
  !*** ../engine/src/engine/core/Scene/index.ts ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Scene: () => (/* reexport safe */ _Scene__WEBPACK_IMPORTED_MODULE_0__.Scene)
/* harmony export */ });
/* harmony import */ var _Scene__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Scene */ "../engine/src/engine/core/Scene/Scene.ts");



/***/ }),

/***/ "../engine/src/engine/core/SceneTree/SceneTree.ts":
/*!********************************************************!*\
  !*** ../engine/src/engine/core/SceneTree/SceneTree.ts ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   SceneTree: () => (/* binding */ SceneTree)
/* harmony export */ });
class SceneTree {
    constructor() {
        this._nodes = new Map();
    }
    getNodeContentAt(position) {
        let currentTreeNode = this._nodes.get(position[0]);
        for (let i = 1; i < position.length; i++) {
            currentTreeNode = currentTreeNode?.children?.get(position[i]);
        }
        return currentTreeNode ?? null;
    }
    addNodeAt(position, nodeContent) {
        if (!position) {
            this._nodes.set(nodeContent.gameObject.id, nodeContent);
            return [nodeContent.gameObject.id];
        }
        let currentTreeNode = this.getNodeContentAt(position);
        currentTreeNode?.children?.set(nodeContent.gameObject.id, nodeContent);
        return [...position, nodeContent.gameObject.id];
    }
    reparentNode(target, child) {
        const nodeContent = this.getNodeContentAt(child);
        if (!nodeContent) {
            throw new Error(`No node found at position ${child.join()}`);
        }
        const newPosition = this.addNodeAt(target, nodeContent);
        this.removeNode(child);
        return newPosition;
    }
    removeNode(targetPosition) {
        const parentPosition = targetPosition.slice(0, targetPosition.length - 1);
        const parentNode = this.getNodeContentAt(parentPosition);
        const childrenIds = [];
        this.traverseNode(parentNode?.children, (nodeId) => {
            childrenIds.push(nodeId);
        });
        parentNode?.children?.delete(targetPosition[targetPosition.length - 1]);
        return childrenIds;
    }
    traverseNode(node, callback) {
        const iterate = (sceneNode) => {
            if (!sceneNode)
                return;
            sceneNode.forEach((value, key) => {
                callback(key, value);
                iterate(value.children);
            });
        };
        iterate(node);
    }
    get nodes() {
        return this._nodes;
    }
}


/***/ }),

/***/ "../engine/src/engine/core/SceneTree/index.ts":
/*!****************************************************!*\
  !*** ../engine/src/engine/core/SceneTree/index.ts ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   SceneTree: () => (/* reexport safe */ _SceneTree__WEBPACK_IMPORTED_MODULE_0__.SceneTree)
/* harmony export */ });
/* harmony import */ var _SceneTree__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./SceneTree */ "../engine/src/engine/core/SceneTree/SceneTree.ts");



/***/ }),

/***/ "../engine/src/engine/core/TextureStorage/TextureStorage.ts":
/*!******************************************************************!*\
  !*** ../engine/src/engine/core/TextureStorage/TextureStorage.ts ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   TextureStorage: () => (/* binding */ TextureStorage)
/* harmony export */ });
class TextureStorage {
    constructor() {
        this._textures = new Map();
    }
    get textures() {
        return this._textures;
    }
}


/***/ }),

/***/ "../engine/src/engine/core/TextureStorage/index.ts":
/*!*********************************************************!*\
  !*** ../engine/src/engine/core/TextureStorage/index.ts ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   TextureStorage: () => (/* reexport safe */ _TextureStorage__WEBPACK_IMPORTED_MODULE_0__.TextureStorage)
/* harmony export */ });
/* harmony import */ var _TextureStorage__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./TextureStorage */ "../engine/src/engine/core/TextureStorage/TextureStorage.ts");



/***/ }),

/***/ "../engine/src/engine/core/Transform/Transform.ts":
/*!********************************************************!*\
  !*** ../engine/src/engine/core/Transform/Transform.ts ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Transform: () => (/* binding */ Transform)
/* harmony export */ });
/* harmony import */ var wgpu_matrix__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! wgpu-matrix */ "../../node_modules/wgpu-matrix/dist/3.x/wgpu-matrix.module.js");
/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../types */ "../engine/src/engine/types/index.ts");
/* harmony import */ var _Component__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Component */ "../engine/src/engine/core/Component/index.ts");



class Transform extends _Component__WEBPACK_IMPORTED_MODULE_1__.Component {
    constructor(parent, matrix) {
        super(parent, _types__WEBPACK_IMPORTED_MODULE_0__.EntityTypes.transform);
        this.matrix = matrix ? wgpu_matrix__WEBPACK_IMPORTED_MODULE_2__.mat4.copy(matrix) : wgpu_matrix__WEBPACK_IMPORTED_MODULE_2__.mat4.identity();
        this._position = new Float32Array(this.matrix.buffer, 4 * 12, 4);
    }
    scale(value) {
        wgpu_matrix__WEBPACK_IMPORTED_MODULE_2__.mat4.scale(this.matrix, value, this.matrix);
    }
    translate(value) {
        this._position = wgpu_matrix__WEBPACK_IMPORTED_MODULE_2__.vec3.copy(value, this._position);
    }
    rotateRadians({ x, y, z }) {
        const newMatrix = wgpu_matrix__WEBPACK_IMPORTED_MODULE_2__.mat4.copy(this.matrix);
        x && wgpu_matrix__WEBPACK_IMPORTED_MODULE_2__.mat4.rotateX(newMatrix, x, newMatrix);
        y && wgpu_matrix__WEBPACK_IMPORTED_MODULE_2__.mat4.rotateY(newMatrix, y, newMatrix);
        z && wgpu_matrix__WEBPACK_IMPORTED_MODULE_2__.mat4.rotateZ(newMatrix, z, newMatrix);
        wgpu_matrix__WEBPACK_IMPORTED_MODULE_2__.mat4.copy(newMatrix, this.matrix);
    }
    rotateDegreesEuler({ x, y, z }) {
        const degreeToRad = 0.01745329252;
        this.rotateRadians({
            x: (x ?? 0) * degreeToRad,
            y: (y ?? 0) * degreeToRad,
            z: (z ?? 0) * degreeToRad,
        });
    }
}


/***/ }),

/***/ "../engine/src/engine/core/Transform/index.ts":
/*!****************************************************!*\
  !*** ../engine/src/engine/core/Transform/index.ts ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Transform: () => (/* reexport safe */ _Transform__WEBPACK_IMPORTED_MODULE_0__.Transform)
/* harmony export */ });
/* harmony import */ var _Transform__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Transform */ "../engine/src/engine/core/Transform/Transform.ts");



/***/ }),

/***/ "../engine/src/engine/core/cameras/ArcBallCamera/ArcBallCamera.ts":
/*!************************************************************************!*\
  !*** ../engine/src/engine/core/cameras/ArcBallCamera/ArcBallCamera.ts ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ArcBallCamera: () => (/* binding */ ArcBallCamera)
/* harmony export */ });
/* harmony import */ var wgpu_matrix__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! wgpu-matrix */ "../../node_modules/wgpu-matrix/dist/3.x/wgpu-matrix.module.js");
/* harmony import */ var _Camera__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Camera */ "../engine/src/engine/core/cameras/Camera/index.ts");


class ArcBallCamera extends _Camera__WEBPACK_IMPORTED_MODULE_0__.Camera {
    constructor(props) {
        super(props);
        this._distance = 0;
        this._axis = wgpu_matrix__WEBPACK_IMPORTED_MODULE_1__.vec3.create();
        const positionVec = props?.position ?? wgpu_matrix__WEBPACK_IMPORTED_MODULE_1__.vec3.create(0, 0, 0);
        super.position = positionVec;
        this._distance = wgpu_matrix__WEBPACK_IMPORTED_MODULE_1__.vec3.len(super.position);
        super.back = wgpu_matrix__WEBPACK_IMPORTED_MODULE_1__.vec3.normalize(super.position);
        this.recalculateRight();
        this.recalculateUp();
        super.view = wgpu_matrix__WEBPACK_IMPORTED_MODULE_1__.mat4.invert(super.matrix);
    }
    get axis() {
        return this._axis;
    }
    set axis(vec) {
        wgpu_matrix__WEBPACK_IMPORTED_MODULE_1__.vec3.copy(vec, this._axis);
    }
    get distance() {
        return this._distance;
    }
    set distance(value) {
        this._distance = value;
    }
    get matrix() {
        return super.matrix;
    }
    set matrix(mat) {
        super.matrix = mat;
        this._distance = wgpu_matrix__WEBPACK_IMPORTED_MODULE_1__.vec3.len(super.position);
    }
    recalculateRight() {
        super.right = wgpu_matrix__WEBPACK_IMPORTED_MODULE_1__.vec3.normalize(wgpu_matrix__WEBPACK_IMPORTED_MODULE_1__.vec3.cross(super.up, super.back));
    }
    recalculateUp() {
        super.up = wgpu_matrix__WEBPACK_IMPORTED_MODULE_1__.vec3.normalize(wgpu_matrix__WEBPACK_IMPORTED_MODULE_1__.vec3.cross(super.back, super.right));
    }
}


/***/ }),

/***/ "../engine/src/engine/core/cameras/ArcBallCamera/index.ts":
/*!****************************************************************!*\
  !*** ../engine/src/engine/core/cameras/ArcBallCamera/index.ts ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ArcBallCamera: () => (/* reexport safe */ _ArcBallCamera__WEBPACK_IMPORTED_MODULE_0__.ArcBallCamera)
/* harmony export */ });
/* harmony import */ var _ArcBallCamera__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ArcBallCamera */ "../engine/src/engine/core/cameras/ArcBallCamera/ArcBallCamera.ts");



/***/ }),

/***/ "../engine/src/engine/core/cameras/Camera/Camera.ts":
/*!**********************************************************!*\
  !*** ../engine/src/engine/core/cameras/Camera/Camera.ts ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Camera: () => (/* binding */ Camera)
/* harmony export */ });
/* harmony import */ var wgpu_matrix__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! wgpu-matrix */ "../../node_modules/wgpu-matrix/dist/3.x/wgpu-matrix.module.js");
/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../types */ "../engine/src/engine/types/index.ts");
/* harmony import */ var _Entity__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../Entity */ "../engine/src/engine/core/Entity/index.ts");



class Camera extends _Entity__WEBPACK_IMPORTED_MODULE_1__.Entity {
    constructor(props) {
        super(_types__WEBPACK_IMPORTED_MODULE_0__.EntityTypes.camera);
        this._view = wgpu_matrix__WEBPACK_IMPORTED_MODULE_2__.mat4.create();
        this._matrix = new Float32Array([
            1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1,
        ]);
        this._right = new Float32Array(this._matrix.buffer, 4 * 0, 4);
        this._up = new Float32Array(this._matrix.buffer, 4 * 4, 4);
        this._back = new Float32Array(this._matrix.buffer, 4 * 8, 4);
        this._position = new Float32Array(this._matrix.buffer, 4 * 12, 4);
        this._zFar = props?.zFar ?? 1000;
        this._zNear = props?.zNear ?? 0.1;
        this._aspectRatio = props.canvasWidth / props.canvasHeight;
        this._projectionMatrix = wgpu_matrix__WEBPACK_IMPORTED_MODULE_2__.mat4.perspective((2 * Math.PI) / 5, this._aspectRatio, this._zNear, this._zFar);
    }
    get aspectRatio() {
        return this._aspectRatio;
    }
    get zFar() {
        return this._zFar;
    }
    get zNear() {
        return this._zNear;
    }
    get projectionMatrix() {
        return this._projectionMatrix;
    }
    get view() {
        return this._view;
    }
    set view(mat) {
        wgpu_matrix__WEBPACK_IMPORTED_MODULE_2__.mat4.copy(mat, this._view);
    }
    get right() {
        return this._right;
    }
    set right(vec) {
        wgpu_matrix__WEBPACK_IMPORTED_MODULE_2__.vec3.copy(vec, this._right);
    }
    get up() {
        return this._up;
    }
    set up(vec) {
        wgpu_matrix__WEBPACK_IMPORTED_MODULE_2__.vec3.copy(vec, this._up);
    }
    get back() {
        return this._back;
    }
    set back(vec) {
        wgpu_matrix__WEBPACK_IMPORTED_MODULE_2__.vec3.copy(vec, this._back);
    }
    get matrix() {
        return this._matrix;
    }
    set matrix(value) {
        this._matrix = wgpu_matrix__WEBPACK_IMPORTED_MODULE_2__.mat4.copy(value, this._matrix);
    }
    get position() {
        return this._position;
    }
    set position(value) {
        wgpu_matrix__WEBPACK_IMPORTED_MODULE_2__.vec3.copy(value, this._position);
    }
}


/***/ }),

/***/ "../engine/src/engine/core/cameras/Camera/index.ts":
/*!*********************************************************!*\
  !*** ../engine/src/engine/core/cameras/Camera/index.ts ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Camera: () => (/* reexport safe */ _Camera__WEBPACK_IMPORTED_MODULE_0__.Camera)
/* harmony export */ });
/* harmony import */ var _Camera__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Camera */ "../engine/src/engine/core/cameras/Camera/Camera.ts");



/***/ }),

/***/ "../engine/src/engine/core/cameras/PerspectiveCamera/PerspectiveCamera.ts":
/*!********************************************************************************!*\
  !*** ../engine/src/engine/core/cameras/PerspectiveCamera/PerspectiveCamera.ts ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   PerspectiveCamera: () => (/* binding */ PerspectiveCamera)
/* harmony export */ });
/* harmony import */ var wgpu_matrix__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! wgpu-matrix */ "../../node_modules/wgpu-matrix/dist/3.x/wgpu-matrix.module.js");
/* harmony import */ var _utils_Stuff__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../../utils/Stuff */ "../engine/src/utils/Stuff.ts");
/* harmony import */ var _Camera_Camera__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Camera/Camera */ "../engine/src/engine/core/cameras/Camera/Camera.ts");



class PerspectiveCamera extends _Camera_Camera__WEBPACK_IMPORTED_MODULE_1__.Camera {
    constructor(props) {
        super(props);
        this.pitch = 0;
        this.yaw = 0;
        const positionVec = props?.position ?? wgpu_matrix__WEBPACK_IMPORTED_MODULE_2__.vec3.create(0, 0, 0);
        const targetVec = props?.target ?? wgpu_matrix__WEBPACK_IMPORTED_MODULE_2__.vec3.copy(positionVec);
        const back = wgpu_matrix__WEBPACK_IMPORTED_MODULE_2__.vec3.normalize(wgpu_matrix__WEBPACK_IMPORTED_MODULE_2__.vec3.sub(positionVec, targetVec));
        this._recalculateAngles(back);
        super.position = positionVec;
    }
    _recalculateAngles(direction) {
        this.yaw = Math.atan2(direction[0], direction[2]);
        this.pitch = -Math.asin(direction[1]);
    }
    update() {
        this.yaw = _utils_Stuff__WEBPACK_IMPORTED_MODULE_0__.Stuff.mod(this.yaw, Math.PI * 2);
        this.pitch = _utils_Stuff__WEBPACK_IMPORTED_MODULE_0__.Stuff.clamp(this.pitch, -Math.PI / 2, Math.PI / 2);
        const position = wgpu_matrix__WEBPACK_IMPORTED_MODULE_2__.vec3.copy(super.position);
        super.matrix = wgpu_matrix__WEBPACK_IMPORTED_MODULE_2__.mat4.rotateX(wgpu_matrix__WEBPACK_IMPORTED_MODULE_2__.mat4.rotationY(this.yaw), this.pitch);
        super.position = position;
        super.view = wgpu_matrix__WEBPACK_IMPORTED_MODULE_2__.mat4.invert(super.matrix);
        return super.view;
    }
}


/***/ }),

/***/ "../engine/src/engine/core/cameras/PerspectiveCamera/index.ts":
/*!********************************************************************!*\
  !*** ../engine/src/engine/core/cameras/PerspectiveCamera/index.ts ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   PerspectiveCamera: () => (/* reexport safe */ _PerspectiveCamera__WEBPACK_IMPORTED_MODULE_0__.PerspectiveCamera)
/* harmony export */ });
/* harmony import */ var _PerspectiveCamera__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./PerspectiveCamera */ "../engine/src/engine/core/cameras/PerspectiveCamera/PerspectiveCamera.ts");



/***/ }),

/***/ "../engine/src/engine/core/index.ts":
/*!******************************************!*\
  !*** ../engine/src/engine/core/index.ts ***!
  \******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   BufferStorage: () => (/* reexport safe */ _BufferStorage__WEBPACK_IMPORTED_MODULE_7__.BufferStorage),
/* harmony export */   Camera: () => (/* reexport safe */ _cameras_Camera__WEBPACK_IMPORTED_MODULE_12__.Camera),
/* harmony export */   Component: () => (/* reexport safe */ _Component__WEBPACK_IMPORTED_MODULE_0__.Component),
/* harmony export */   DEFAULT_DEPTH_FORMAT: () => (/* reexport safe */ _Engine__WEBPACK_IMPORTED_MODULE_14__.DEFAULT_DEPTH_FORMAT),
/* harmony export */   DEFAULT_SWAP_CHAIN_FORMAT: () => (/* reexport safe */ _Engine__WEBPACK_IMPORTED_MODULE_14__.DEFAULT_SWAP_CHAIN_FORMAT),
/* harmony export */   Engine: () => (/* reexport safe */ _Engine__WEBPACK_IMPORTED_MODULE_14__.Engine),
/* harmony export */   Entity: () => (/* reexport safe */ _Entity__WEBPACK_IMPORTED_MODULE_1__.Entity),
/* harmony export */   GameObject: () => (/* reexport safe */ _GameObject__WEBPACK_IMPORTED_MODULE_2__.GameObject),
/* harmony export */   ImageStorage: () => (/* reexport safe */ _ImageStorage__WEBPACK_IMPORTED_MODULE_8__.ImageStorage),
/* harmony export */   MSAA_SAMPLE_COUNT: () => (/* reexport safe */ _Engine__WEBPACK_IMPORTED_MODULE_14__.MSAA_SAMPLE_COUNT),
/* harmony export */   MaterialStorage: () => (/* reexport safe */ _MaterialStorage__WEBPACK_IMPORTED_MODULE_11__.MaterialStorage),
/* harmony export */   Mesh: () => (/* reexport safe */ _Mesh__WEBPACK_IMPORTED_MODULE_6__.Mesh),
/* harmony export */   ObjectManager: () => (/* reexport safe */ _ObjectManager__WEBPACK_IMPORTED_MODULE_3__.ObjectManager),
/* harmony export */   PerspectiveCamera: () => (/* reexport safe */ _cameras_PerspectiveCamera__WEBPACK_IMPORTED_MODULE_13__.PerspectiveCamera),
/* harmony export */   SamplerStorage: () => (/* reexport safe */ _SamplerStorage__WEBPACK_IMPORTED_MODULE_9__.SamplerStorage),
/* harmony export */   Scene: () => (/* reexport safe */ _Scene__WEBPACK_IMPORTED_MODULE_15__.Scene),
/* harmony export */   SceneTree: () => (/* reexport safe */ _SceneTree__WEBPACK_IMPORTED_MODULE_4__.SceneTree),
/* harmony export */   TextureStorage: () => (/* reexport safe */ _TextureStorage__WEBPACK_IMPORTED_MODULE_10__.TextureStorage),
/* harmony export */   Transform: () => (/* reexport safe */ _Transform__WEBPACK_IMPORTED_MODULE_5__.Transform),
/* harmony export */   VIEW_PARAMS_BUFFER_SIZE: () => (/* reexport safe */ _Engine__WEBPACK_IMPORTED_MODULE_14__.VIEW_PARAMS_BUFFER_SIZE),
/* harmony export */   alignTo: () => (/* reexport safe */ _Mesh__WEBPACK_IMPORTED_MODULE_6__.alignTo)
/* harmony export */ });
/* harmony import */ var _Component__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Component */ "../engine/src/engine/core/Component/index.ts");
/* harmony import */ var _Entity__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Entity */ "../engine/src/engine/core/Entity/index.ts");
/* harmony import */ var _GameObject__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./GameObject */ "../engine/src/engine/core/GameObject/index.ts");
/* harmony import */ var _ObjectManager__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./ObjectManager */ "../engine/src/engine/core/ObjectManager/index.ts");
/* harmony import */ var _SceneTree__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./SceneTree */ "../engine/src/engine/core/SceneTree/index.ts");
/* harmony import */ var _Transform__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./Transform */ "../engine/src/engine/core/Transform/index.ts");
/* harmony import */ var _Mesh__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./Mesh */ "../engine/src/engine/core/Mesh/index.ts");
/* harmony import */ var _BufferStorage__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./BufferStorage */ "../engine/src/engine/core/BufferStorage/index.ts");
/* harmony import */ var _ImageStorage__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./ImageStorage */ "../engine/src/engine/core/ImageStorage/index.ts");
/* harmony import */ var _SamplerStorage__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./SamplerStorage */ "../engine/src/engine/core/SamplerStorage/index.ts");
/* harmony import */ var _TextureStorage__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./TextureStorage */ "../engine/src/engine/core/TextureStorage/index.ts");
/* harmony import */ var _MaterialStorage__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./MaterialStorage */ "../engine/src/engine/core/MaterialStorage/index.ts");
/* harmony import */ var _cameras_Camera__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./cameras/Camera */ "../engine/src/engine/core/cameras/Camera/index.ts");
/* harmony import */ var _cameras_PerspectiveCamera__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./cameras/PerspectiveCamera */ "../engine/src/engine/core/cameras/PerspectiveCamera/index.ts");
/* harmony import */ var _Engine__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./Engine */ "../engine/src/engine/core/Engine/index.ts");
/* harmony import */ var _Scene__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./Scene */ "../engine/src/engine/core/Scene/index.ts");


















/***/ }),

/***/ "../engine/src/engine/types/core/BufferStorage/index.ts":
/*!**************************************************************!*\
  !*** ../engine/src/engine/types/core/BufferStorage/index.ts ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);



/***/ }),

/***/ "../engine/src/engine/types/core/Component/index.ts":
/*!**********************************************************!*\
  !*** ../engine/src/engine/types/core/Component/index.ts ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);



/***/ }),

/***/ "../engine/src/engine/types/core/Engine/index.ts":
/*!*******************************************************!*\
  !*** ../engine/src/engine/types/core/Engine/index.ts ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);



/***/ }),

/***/ "../engine/src/engine/types/core/Entity/index.ts":
/*!*******************************************************!*\
  !*** ../engine/src/engine/types/core/Entity/index.ts ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   EntityTypes: () => (/* binding */ EntityTypes)
/* harmony export */ });
var EntityTypes;
(function (EntityTypes) {
    EntityTypes["gameObject"] = "gameObject";
    EntityTypes["mesh"] = "mesh";
    EntityTypes["material"] = "material";
    EntityTypes["transform"] = "transform";
    EntityTypes["camera"] = "camera";
    EntityTypes["collider"] = "collider";
    EntityTypes["physicsObject"] = "physicsObject";
})(EntityTypes || (EntityTypes = {}));


/***/ }),

/***/ "../engine/src/engine/types/core/GameObject/index.ts":
/*!***********************************************************!*\
  !*** ../engine/src/engine/types/core/GameObject/index.ts ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);



/***/ }),

/***/ "../engine/src/engine/types/core/ImageStorage/index.ts":
/*!*************************************************************!*\
  !*** ../engine/src/engine/types/core/ImageStorage/index.ts ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);



/***/ }),

/***/ "../engine/src/engine/types/core/Mesh/index.ts":
/*!*****************************************************!*\
  !*** ../engine/src/engine/types/core/Mesh/index.ts ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);



/***/ }),

/***/ "../engine/src/engine/types/core/ObjectManager/index.ts":
/*!**************************************************************!*\
  !*** ../engine/src/engine/types/core/ObjectManager/index.ts ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);



/***/ }),

/***/ "../engine/src/engine/types/core/SamplerStorage/index.ts":
/*!***************************************************************!*\
  !*** ../engine/src/engine/types/core/SamplerStorage/index.ts ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);



/***/ }),

/***/ "../engine/src/engine/types/core/Scene/Scene.ts":
/*!******************************************************!*\
  !*** ../engine/src/engine/types/core/Scene/Scene.ts ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);



/***/ }),

/***/ "../engine/src/engine/types/core/Scene/index.ts":
/*!******************************************************!*\
  !*** ../engine/src/engine/types/core/Scene/index.ts ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _Scene__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Scene */ "../engine/src/engine/types/core/Scene/Scene.ts");



/***/ }),

/***/ "../engine/src/engine/types/core/SceneTree/index.ts":
/*!**********************************************************!*\
  !*** ../engine/src/engine/types/core/SceneTree/index.ts ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);



/***/ }),

/***/ "../engine/src/engine/types/core/TextureStorage/index.ts":
/*!***************************************************************!*\
  !*** ../engine/src/engine/types/core/TextureStorage/index.ts ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);



/***/ }),

/***/ "../engine/src/engine/types/core/Transform/index.ts":
/*!**********************************************************!*\
  !*** ../engine/src/engine/types/core/Transform/index.ts ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);



/***/ }),

/***/ "../engine/src/engine/types/index.ts":
/*!*******************************************!*\
  !*** ../engine/src/engine/types/index.ts ***!
  \*******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   EntityTypes: () => (/* reexport safe */ _core_Entity__WEBPACK_IMPORTED_MODULE_0__.EntityTypes),
/* harmony export */   GLTFTextureFilter: () => (/* binding */ GLTFTextureFilter),
/* harmony export */   GLTFTextureWrap: () => (/* binding */ GLTFTextureWrap)
/* harmony export */ });
/* harmony import */ var _core_Entity__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./core/Entity */ "../engine/src/engine/types/core/Entity/index.ts");
/* harmony import */ var _core_GameObject__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./core/GameObject */ "../engine/src/engine/types/core/GameObject/index.ts");
/* harmony import */ var _core_Component__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./core/Component */ "../engine/src/engine/types/core/Component/index.ts");
/* harmony import */ var _core_SceneTree__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./core/SceneTree */ "../engine/src/engine/types/core/SceneTree/index.ts");
/* harmony import */ var _core_ObjectManager__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./core/ObjectManager */ "../engine/src/engine/types/core/ObjectManager/index.ts");
/* harmony import */ var _core_Mesh__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./core/Mesh */ "../engine/src/engine/types/core/Mesh/index.ts");
/* harmony import */ var _core_Transform__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./core/Transform */ "../engine/src/engine/types/core/Transform/index.ts");
/* harmony import */ var _core_BufferStorage__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./core/BufferStorage */ "../engine/src/engine/types/core/BufferStorage/index.ts");
/* harmony import */ var _core_ImageStorage__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./core/ImageStorage */ "../engine/src/engine/types/core/ImageStorage/index.ts");
/* harmony import */ var _core_SamplerStorage__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./core/SamplerStorage */ "../engine/src/engine/types/core/SamplerStorage/index.ts");
/* harmony import */ var _core_TextureStorage__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./core/TextureStorage */ "../engine/src/engine/types/core/TextureStorage/index.ts");
/* harmony import */ var _core_Scene__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./core/Scene */ "../engine/src/engine/types/core/Scene/index.ts");
/* harmony import */ var _core_Engine__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./core/Engine */ "../engine/src/engine/types/core/Engine/index.ts");













var GLTFTextureFilter;
(function (GLTFTextureFilter) {
    GLTFTextureFilter[GLTFTextureFilter["NEAREST"] = 9728] = "NEAREST";
    GLTFTextureFilter[GLTFTextureFilter["LINEAR"] = 9729] = "LINEAR";
    GLTFTextureFilter[GLTFTextureFilter["NEAREST_MIPMAP_NEAREST"] = 9984] = "NEAREST_MIPMAP_NEAREST";
    GLTFTextureFilter[GLTFTextureFilter["LINEAR_MIPMAP_NEAREST"] = 9985] = "LINEAR_MIPMAP_NEAREST";
    GLTFTextureFilter[GLTFTextureFilter["NEAREST_MIPMAP_LINEAR"] = 9986] = "NEAREST_MIPMAP_LINEAR";
    GLTFTextureFilter[GLTFTextureFilter["LINEAR_MIPMAP_LINEAR"] = 9987] = "LINEAR_MIPMAP_LINEAR";
})(GLTFTextureFilter || (GLTFTextureFilter = {}));
var GLTFTextureWrap;
(function (GLTFTextureWrap) {
    GLTFTextureWrap[GLTFTextureWrap["REPEAT"] = 10497] = "REPEAT";
    GLTFTextureWrap[GLTFTextureWrap["CLAMP_TO_EDGE"] = 33071] = "CLAMP_TO_EDGE";
    GLTFTextureWrap[GLTFTextureWrap["MIRRORED_REPEAT"] = 33648] = "MIRRORED_REPEAT";
})(GLTFTextureWrap || (GLTFTextureWrap = {}));


/***/ }),

/***/ "../engine/src/physics/Collider/index.ts":
/*!***********************************************!*\
  !*** ../engine/src/physics/Collider/index.ts ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Collider: () => (/* binding */ Collider)
/* harmony export */ });
/* harmony import */ var _engine_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../engine/core */ "../engine/src/engine/core/index.ts");
/* harmony import */ var _engine_types__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../engine/types */ "../engine/src/engine/types/index.ts");


class Collider extends _engine_core__WEBPACK_IMPORTED_MODULE_0__.Component {
    constructor(parent) {
        super(parent, _engine_types__WEBPACK_IMPORTED_MODULE_1__.EntityTypes.collider);
    }
}


/***/ }),

/***/ "../engine/src/physics/PhysicsObject/index.ts":
/*!****************************************************!*\
  !*** ../engine/src/physics/PhysicsObject/index.ts ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   PhysicsObject: () => (/* binding */ PhysicsObject)
/* harmony export */ });
/* harmony import */ var wgpu_matrix__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! wgpu-matrix */ "../../node_modules/wgpu-matrix/dist/3.x/wgpu-matrix.module.js");
/* harmony import */ var _engine_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../engine/core */ "../engine/src/engine/core/index.ts");
/* harmony import */ var _engine_types__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../engine/types */ "../engine/src/engine/types/index.ts");



class PhysicsObject extends _engine_core__WEBPACK_IMPORTED_MODULE_0__.Component {
    constructor(parent) {
        super(parent, _engine_types__WEBPACK_IMPORTED_MODULE_1__.EntityTypes.physicsObject);
        this.velocity = wgpu_matrix__WEBPACK_IMPORTED_MODULE_2__.vec3.create(0);
    }
}


/***/ }),

/***/ "../engine/src/physics/index.ts":
/*!**************************************!*\
  !*** ../engine/src/physics/index.ts ***!
  \**************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Collider: () => (/* reexport safe */ _Collider__WEBPACK_IMPORTED_MODULE_0__.Collider),
/* harmony export */   PhysicsObject: () => (/* reexport safe */ _PhysicsObject__WEBPACK_IMPORTED_MODULE_1__.PhysicsObject)
/* harmony export */ });
/* harmony import */ var _Collider__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Collider */ "../engine/src/physics/Collider/index.ts");
/* harmony import */ var _PhysicsObject__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./PhysicsObject */ "../engine/src/physics/PhysicsObject/index.ts");




/***/ }),

/***/ "../engine/src/utils/Stuff.ts":
/*!************************************!*\
  !*** ../engine/src/utils/Stuff.ts ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Stuff: () => (/* binding */ Stuff)
/* harmony export */ });
/* harmony import */ var wgpu_matrix__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! wgpu-matrix */ "../../node_modules/wgpu-matrix/dist/3.x/wgpu-matrix.module.js");

class Stuff {
    static clamp(x, min, max) {
        return Math.min(Math.max(x, min), max);
    }
    static mod(x, div) {
        return x - Math.floor(Math.abs(x) / div) * div * Math.sign(x);
    }
    static lerp(a, b, s) {
        return wgpu_matrix__WEBPACK_IMPORTED_MODULE_0__.vec3.addScaled(a, wgpu_matrix__WEBPACK_IMPORTED_MODULE_0__.vec3.sub(b, a), s);
    }
    static rotate(vec, axis, angle) {
        return wgpu_matrix__WEBPACK_IMPORTED_MODULE_0__.vec3.transformMat4Upper3x3(vec, wgpu_matrix__WEBPACK_IMPORTED_MODULE_0__.mat4.rotation(axis, angle));
    }
    static extractEulerRotation(mat) {
        // [
        //     x1, x2, x3, x4,  // <- column 0
        //     y1, y2, y3, y4,  // <- column 1
        //     z1, z2, z3, z4,  // <- column 2
        //     w1, w2, w3, w4,  // <- column 3
        //   ]
        const rotXangle = Math.atan2(-mat[9], mat[10]);
        const cosYangle = Math.sqrt(Math.pow(mat[0], 2) + Math.pow(mat[4], 2));
        const rotYangle = Math.atan2(mat[8], cosYangle);
        const sinXangle = Math.sin(rotXangle);
        const cosXangle = Math.cos(rotXangle);
        const rotZangle = Math.atan2(cosXangle * mat[1] + sinXangle * mat[2], cosXangle * mat[5] + sinXangle * mat[6]);
        return wgpu_matrix__WEBPACK_IMPORTED_MODULE_0__.vec3.create(rotXangle, rotYangle, rotZangle);
    }
}


/***/ }),

/***/ "../engine/src/utils/WheezyGLBLoader/WheezyGLBLoader.ts":
/*!**************************************************************!*\
  !*** ../engine/src/utils/WheezyGLBLoader/WheezyGLBLoader.ts ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   WheezyGLBLoader: () => (/* binding */ WheezyGLBLoader)
/* harmony export */ });
/* harmony import */ var _loaders_gl_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @loaders.gl/core */ "../../node_modules/@loaders.gl/core/dist/lib/api/load.js");
/* harmony import */ var _loaders_gl_gltf__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @loaders.gl/gltf */ "../../node_modules/@loaders.gl/gltf/dist/glb-loader.js");
/* harmony import */ var _helpers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./helpers */ "../engine/src/utils/WheezyGLBLoader/helpers.ts");
/* harmony import */ var wgpu_matrix__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! wgpu-matrix */ "../../node_modules/wgpu-matrix/dist/3.x/wgpu-matrix.module.js");




const generateId = () => {
    return String(Math.random());
};
class WheezyGLBLoader {
    static loadImages(modelData, bufferIndexMap) {
        const imagesIndexMap = new Map();
        const imagesMap = new Map();
        modelData.json?.images?.forEach(({ bufferView, mimeType, }, index) => {
            const bufferViewData = modelData.json.bufferViews[bufferView];
            const bufferId = bufferIndexMap.get(bufferViewData.buffer);
            const bufferOffset = modelData.binChunks[bufferViewData.buffer].byteOffset ?? 0;
            bufferViewData.buffer = bufferId;
            bufferViewData.byteOffset += bufferOffset;
            const id = generateId();
            imagesIndexMap.set(index, id);
            imagesMap.set(id, { bufferView: bufferViewData, mimeType });
        });
        return { imagesIndexMap, imagesMap };
    }
    static async loadFromUrl(url) {
        const modelData = await (0,_loaders_gl_core__WEBPACK_IMPORTED_MODULE_1__.load)(url, _loaders_gl_gltf__WEBPACK_IMPORTED_MODULE_2__.GLBLoader);
        console.log(modelData);
        const { bufferIndexMap, bufferMap } = this.loadBuffers(modelData);
        const { imagesIndexMap, imagesMap } = this.loadImages(modelData, bufferIndexMap);
        const { samplersIndexMap, samplersMap } = this.loadSamplers(modelData);
        const { texturesIndexMap, texturesMap } = this.loadTextures(modelData, samplersIndexMap, imagesIndexMap);
        const { materialsIndexMap, materialsMap } = this.loadMaterials(modelData, texturesIndexMap);
        const modelPreload = {
            trsMatrix: wgpu_matrix__WEBPACK_IMPORTED_MODULE_3__.mat4.identity(),
            meshes: [],
            children: [],
        };
        modelData?.json?.scenes?.forEach((scene) => {
            scene?.nodes?.forEach((nodeIndex) => {
                modelPreload.children.push(this.loadNode(nodeIndex, modelData, bufferIndexMap, materialsIndexMap));
            });
        });
        return {
            model: modelPreload,
            buffers: bufferMap,
            images: imagesMap,
            samplers: samplersMap,
            textures: texturesMap,
            materials: materialsMap,
        };
    }
    static loadNode(nodeIndex, modelData, bufferIndexMap, materialsIndexMap) {
        const nodeJsonData = modelData?.json?.nodes[nodeIndex];
        const dataStructEntry = {
            trsMatrix: nodeJsonData.matrix ?? wgpu_matrix__WEBPACK_IMPORTED_MODULE_3__.mat4.identity(),
            meshes: [],
            children: [],
        };
        if (nodeJsonData.mesh !== undefined) {
            const meshJsonData = modelData.json.meshes[nodeJsonData.mesh];
            meshJsonData.primitives.forEach((primitive) => {
                dataStructEntry.meshes.push({
                    positions: WheezyGLBLoader.parseAccessor(modelData, primitive.attributes.POSITION, GPUBufferUsage.VERTEX, bufferIndexMap),
                    indices: WheezyGLBLoader.parseAccessor(modelData, primitive.indices, GPUBufferUsage.INDEX, bufferIndexMap),
                    normals: WheezyGLBLoader.parseAccessor(modelData, primitive.attributes.NORMAL, GPUBufferUsage.VERTEX, bufferIndexMap),
                    textureCoordinates: WheezyGLBLoader.parseAccessor(modelData, primitive.attributes.TEXCOORD_0, GPUBufferUsage.VERTEX, bufferIndexMap),
                    materialId: primitive.material !== undefined
                        ? materialsIndexMap.get(primitive.material)
                        : undefined,
                    mode: primitive.mode ?? 4,
                });
            });
        }
        nodeJsonData?.children?.forEach((childIndex) => {
            dataStructEntry.children.push(this.loadNode(childIndex, modelData, bufferIndexMap, materialsIndexMap));
        });
        return dataStructEntry;
    }
}
WheezyGLBLoader.loadSamplers = (modelData) => {
    const samplersIndexMap = new Map();
    const samplersMap = new Map();
    modelData.json?.samplers?.forEach((sampler, index) => {
        const id = generateId();
        samplersIndexMap.set(index, id);
        samplersMap.set(id, sampler);
    });
    return { samplersIndexMap, samplersMap };
};
WheezyGLBLoader.loadTextures = (modelData, samplersIndexMap, imagesIndexMap) => {
    const texturesIndexMap = new Map();
    const texturesMap = new Map();
    modelData.json?.textures?.forEach((textureData, index) => {
        const id = generateId();
        const texture = {
            samplerId: samplersIndexMap.get(textureData.sampler),
            imageId: imagesIndexMap.get(textureData.source),
        };
        texturesIndexMap.set(index, id);
        texturesMap.set(id, texture);
    });
    return { texturesIndexMap, texturesMap };
};
WheezyGLBLoader.loadMaterials = (modelData, texturesIndexMap) => {
    const materialsIndexMap = new Map();
    const materialsMap = new Map();
    modelData.json?.materials?.forEach((
    //FIXME: check types
    materialData, index) => {
        const material = {
            name: materialData.name,
            baseColorFactor: materialData?.pbrMetallicRoughness?.baseColorFactor,
            emissiveFactor: materialData.emissiveFactor,
            metallicFactor: materialData?.pbrMetallicRoughness?.metallicFactor,
            roughnessFactor: materialData?.pbrMetallicRoughness?.roughnessFactor,
            baseColorTextureId: materialData?.pbrMetallicRoughness?.baseColorTexture
                ?.index !== undefined
                ? texturesIndexMap.get(materialData?.pbrMetallicRoughness
                    ?.baseColorTexture?.index)
                : undefined,
            metallicRoughnessTextureId: materialData?.pbrMetallicRoughness
                ?.metallicRoughnessTexture?.index !== undefined
                ? texturesIndexMap.get(materialData?.pbrMetallicRoughness
                    ?.metallicRoughnessTexture?.index)
                : undefined,
            normalTextureId: materialData?.normalTexture?.index !== undefined
                ? texturesIndexMap.get(materialData?.normalTexture?.index)
                : undefined,
            occlusionTextureId: materialData?.occlusionTexture?.index !== undefined
                ? texturesIndexMap.get(materialData?.occlusionTexture?.index)
                : undefined,
            emissiveTextureId: materialData?.emissiveTexture?.index !== undefined
                ? texturesIndexMap.get(materialData?.emissiveTexture?.index)
                : undefined,
        };
        const id = generateId();
        materialsIndexMap.set(index, id);
        materialsMap.set(id, material);
    });
    return { materialsIndexMap, materialsMap };
};
WheezyGLBLoader.loadBuffers = (modelData) => {
    const bufferIndexMap = new Map();
    const bufferMap = new Map();
    modelData.binChunks.forEach((chunk, index) => {
        if (chunk.arrayBuffer) {
            const id = generateId();
            bufferIndexMap.set(index, id);
            bufferMap.set(id, chunk.arrayBuffer);
        }
    });
    return { bufferIndexMap, bufferMap };
};
WheezyGLBLoader.parseAccessor = (modelData, accessorId, usage, bufferIndexMap) => {
    if (accessorId !== 0 && !accessorId) {
        return undefined;
    }
    const rawAccessor = modelData.json.accessors[accessorId];
    const rawBufferView = modelData.json.bufferViews[rawAccessor.bufferView];
    const buffer = modelData.binChunks[rawBufferView.buffer];
    const elementSize = (0,_helpers__WEBPACK_IMPORTED_MODULE_0__.getTypeSize)(rawAccessor.componentType, rawAccessor.type);
    const byteStride = Math.max(elementSize, rawBufferView.byteStride ?? 0);
    return {
        bufferId: bufferIndexMap.get(rawBufferView.buffer),
        byteStride: byteStride,
        byteLength: rawAccessor.count * (byteStride ?? 1),
        byteOffset: (rawAccessor?.byteOffset ?? 0) +
            (rawBufferView?.byteOffset ?? 0) +
            (buffer?.byteOffset ?? 0),
        count: rawAccessor.count,
        componentType: rawAccessor.componentType,
        elementType: (0,_helpers__WEBPACK_IMPORTED_MODULE_0__.getVertexType)(rawAccessor.componentType, rawAccessor.type),
        min: rawAccessor.min,
        max: rawAccessor.max,
        usage: usage,
    };
};


/***/ }),

/***/ "../engine/src/utils/WheezyGLBLoader/helpers.ts":
/*!******************************************************!*\
  !*** ../engine/src/utils/WheezyGLBLoader/helpers.ts ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   GLTFComponentType: () => (/* binding */ GLTFComponentType),
/* harmony export */   ImageUsage: () => (/* binding */ ImageUsage),
/* harmony export */   getTypeComponentsAmount: () => (/* binding */ getTypeComponentsAmount),
/* harmony export */   getTypeSize: () => (/* binding */ getTypeSize),
/* harmony export */   getVertexType: () => (/* binding */ getVertexType)
/* harmony export */ });
var GLTFComponentType;
(function (GLTFComponentType) {
    GLTFComponentType[GLTFComponentType["BYTE"] = 5120] = "BYTE";
    GLTFComponentType[GLTFComponentType["UNSIGNED_BYTE"] = 5121] = "UNSIGNED_BYTE";
    GLTFComponentType[GLTFComponentType["SHORT"] = 5122] = "SHORT";
    GLTFComponentType[GLTFComponentType["UNSIGNED_SHORT"] = 5123] = "UNSIGNED_SHORT";
    GLTFComponentType[GLTFComponentType["INT"] = 5124] = "INT";
    GLTFComponentType[GLTFComponentType["UNSIGNED_INT"] = 5125] = "UNSIGNED_INT";
    GLTFComponentType[GLTFComponentType["FLOAT"] = 5126] = "FLOAT";
    GLTFComponentType[GLTFComponentType["DOUBLE"] = 5130] = "DOUBLE";
})(GLTFComponentType || (GLTFComponentType = {}));
const getTypeComponentsAmount = (type) => {
    switch (type) {
        case 'SCALAR':
            return 1;
        case 'VEC2':
            return 2;
        case 'VEC3':
            return 3;
        case 'VEC4':
            return 4;
        case 'MAT2':
            return 4;
        case 'MAT3':
            return 9;
        case 'MAT4':
            return 16;
        default:
            throw Error(`Invalid gltf type ${type}`);
    }
};
const getVertexType = (componentType, type) => {
    let typeStr = null;
    switch (componentType) {
        case GLTFComponentType.BYTE:
            typeStr = 'sint8';
            break;
        case GLTFComponentType.UNSIGNED_BYTE:
            typeStr = 'uint8';
            break;
        case GLTFComponentType.SHORT:
            typeStr = 'sint16';
            break;
        case GLTFComponentType.UNSIGNED_SHORT:
            typeStr = 'uint16';
            break;
        case GLTFComponentType.INT:
            typeStr = 'int32';
            break;
        case GLTFComponentType.UNSIGNED_INT:
            typeStr = 'uint32';
            break;
        case GLTFComponentType.FLOAT:
            typeStr = 'float32';
            break;
        default:
            throw Error(`Unrecognized or unsupported gltf type ${componentType}`);
    }
    switch (getTypeComponentsAmount(type)) {
        case 1:
            break;
        case 2:
            typeStr += 'x2';
            break;
        case 3:
            typeStr += 'x3';
            break;
        case 4:
            typeStr += 'x4';
            break;
        default:
            throw Error(`Invalid number of components for gltf type: ${type}`);
    }
    return typeStr;
};
const getTypeSize = (componentType, type) => {
    let componentSize = 0;
    switch (componentType) {
        case GLTFComponentType.BYTE:
            componentSize = 1;
            break;
        case GLTFComponentType.UNSIGNED_BYTE:
            componentSize = 1;
            break;
        case GLTFComponentType.SHORT:
            componentSize = 2;
            break;
        case GLTFComponentType.UNSIGNED_SHORT:
            componentSize = 2;
            break;
        case GLTFComponentType.INT:
            componentSize = 4;
            break;
        case GLTFComponentType.UNSIGNED_INT:
            componentSize = 4;
            break;
        case GLTFComponentType.FLOAT:
            componentSize = 4;
            break;
        case GLTFComponentType.DOUBLE:
            componentSize = 8;
            break;
        default:
            throw Error('Unrecognized GLTF Component Type?');
    }
    return getTypeComponentsAmount(type) * componentSize;
};
var ImageUsage;
(function (ImageUsage) {
    ImageUsage[ImageUsage["BASE_COLOR"] = 0] = "BASE_COLOR";
    ImageUsage[ImageUsage["METALLIC_ROUGHNESS"] = 1] = "METALLIC_ROUGHNESS";
    ImageUsage[ImageUsage["NORMAL"] = 2] = "NORMAL";
    ImageUsage[ImageUsage["OCCLUSION"] = 3] = "OCCLUSION";
    ImageUsage[ImageUsage["EMISSION"] = 4] = "EMISSION";
})(ImageUsage || (ImageUsage = {}));


/***/ }),

/***/ "../engine/src/utils/index.ts":
/*!************************************!*\
  !*** ../engine/src/utils/index.ts ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   WheezyGLBLoader: () => (/* reexport safe */ _WheezyGLBLoader_WheezyGLBLoader__WEBPACK_IMPORTED_MODULE_0__.WheezyGLBLoader)
/* harmony export */ });
/* harmony import */ var _WheezyGLBLoader_WheezyGLBLoader__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./WheezyGLBLoader/WheezyGLBLoader */ "../engine/src/utils/WheezyGLBLoader/WheezyGLBLoader.ts");



/***/ }),

/***/ "./shaders/testShader.wgsl":
/*!*********************************!*\
  !*** ./shaders/testShader.wgsl ***!
  \*********************************/
/***/ ((module) => {

module.exports = "alias float4 = vec4<f32>;\nalias float3 = vec3<f32>;\nalias float2 = vec2<f32>;\n\nstruct VertexInput {\n    @location(0) position: float3,\n    @location(1) texcoords: float2,\n    @location(2) object_normal: float3\n};\n\nstruct VertexOutput {\n    @builtin(position) position: float4,\n    @location(0) world_pos: float3,\n    @location(1) texcoords: float2,\n    @location(2) object_normal: float3,\n    @location(3) camera_position: float3\n};\n\nstruct ViewParams {\n    view_proj: mat4x4<f32>,\n    camera_position: vec4f\n};\n\nstruct NodeParams {\n    transform: mat4x4<f32>,\n};\n\nstruct MaterialParams {\n    base_color_factor: float4,\n    metallic_factor: f32,\n    roughness_factor: f32,\n};\n\n@group(0) @binding(0)\nvar<uniform> view_params: ViewParams;\n\n@group(1) @binding(0)\nvar<uniform> node_params: NodeParams;\n\n@group(2) @binding(0)\nvar<uniform> material_params: MaterialParams;\n\n@group(3) @binding(1)\nvar base_color_sampler: sampler;\n\n@group(2) @binding(1)\nvar base_color_texture: texture_2d<f32>;\n\n@group(3) @binding(2)\nvar metallic_roughness_sampler: sampler;\n\n@group(2) @binding(2)\nvar metallic_roughness_texture: texture_2d<f32>;\n\n@group(3) @binding(3)\nvar tangent_normal_sampler: sampler;\n\n@group(2) @binding(3)\nvar tangent_normal_texture: texture_2d<f32>;\n\n@vertex\nfn vertex_main(vert: VertexInput) -> VertexOutput {\n    var out: VertexOutput;\n    out.position = view_params.view_proj * node_params.transform * float4(vert.position, 1.0);\n    out.world_pos = vert.position.xyz;\n    out.texcoords = vert.texcoords;\n    out.object_normal = vert.object_normal;\n    out.camera_position = view_params.camera_position.xyz;\n\n    return out;\n};\n\nfn linear_to_srgb(x: f32) -> f32 {\n    if (x <= 0.0031308) {\n        return 12.92 * x;\n    }\n    return 1.055 * pow(x, 1.0 / 2.4) - 0.055;\n}\n\nfn decode_color(color: vec4f) -> vec4f {\n    return vec4f(linear_to_srgb(color.x), linear_to_srgb(color.y), linear_to_srgb(color.z), 1.0);\n}\n\n@fragment\nfn fragment_main(in: VertexOutput) -> @location(0) float4 {\n    let color = decode_color(\n        textureSample(base_color_texture, base_color_sampler, in.texcoords) \n            * material_params.base_color_factor\n    );\n\n    return color;\n};\n";

/***/ }),

/***/ "../../node_modules/@loaders.gl/core/dist/iterators/make-iterator/make-array-buffer-iterator.js":
/*!******************************************************************************************************!*\
  !*** ../../node_modules/@loaders.gl/core/dist/iterators/make-iterator/make-array-buffer-iterator.js ***!
  \******************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   makeArrayBufferIterator: () => (/* binding */ makeArrayBufferIterator)
/* harmony export */ });
const DEFAULT_CHUNK_SIZE = 256 * 1024;
function makeArrayBufferIterator(arrayBuffer) {
  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  return function* () {
    const {
      chunkSize = DEFAULT_CHUNK_SIZE
    } = options;
    let byteOffset = 0;
    while (byteOffset < arrayBuffer.byteLength) {
      const chunkByteLength = Math.min(arrayBuffer.byteLength - byteOffset, chunkSize);
      const chunk = new ArrayBuffer(chunkByteLength);
      const sourceArray = new Uint8Array(arrayBuffer, byteOffset, chunkByteLength);
      const chunkArray = new Uint8Array(chunk);
      chunkArray.set(sourceArray);
      byteOffset += chunkByteLength;
      yield chunk;
    }
  }();
}
//# sourceMappingURL=make-array-buffer-iterator.js.map

/***/ }),

/***/ "../../node_modules/@loaders.gl/core/dist/iterators/make-iterator/make-blob-iterator.js":
/*!**********************************************************************************************!*\
  !*** ../../node_modules/@loaders.gl/core/dist/iterators/make-iterator/make-blob-iterator.js ***!
  \**********************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   makeBlobIterator: () => (/* binding */ makeBlobIterator)
/* harmony export */ });
const DEFAULT_CHUNK_SIZE = 1024 * 1024;
async function* makeBlobIterator(blob, options) {
  const chunkSize = (options === null || options === void 0 ? void 0 : options.chunkSize) || DEFAULT_CHUNK_SIZE;
  let offset = 0;
  while (offset < blob.size) {
    const end = offset + chunkSize;
    const chunk = await blob.slice(offset, end).arrayBuffer();
    offset = end;
    yield chunk;
  }
}
//# sourceMappingURL=make-blob-iterator.js.map

/***/ }),

/***/ "../../node_modules/@loaders.gl/core/dist/iterators/make-iterator/make-iterator.js":
/*!*****************************************************************************************!*\
  !*** ../../node_modules/@loaders.gl/core/dist/iterators/make-iterator/make-iterator.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   makeIterator: () => (/* binding */ makeIterator)
/* harmony export */ });
/* harmony import */ var _make_string_iterator_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./make-string-iterator.js */ "../../node_modules/@loaders.gl/core/dist/iterators/make-iterator/make-string-iterator.js");
/* harmony import */ var _make_array_buffer_iterator_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./make-array-buffer-iterator.js */ "../../node_modules/@loaders.gl/core/dist/iterators/make-iterator/make-array-buffer-iterator.js");
/* harmony import */ var _make_blob_iterator_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./make-blob-iterator.js */ "../../node_modules/@loaders.gl/core/dist/iterators/make-iterator/make-blob-iterator.js");
/* harmony import */ var _make_stream_iterator_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./make-stream-iterator.js */ "../../node_modules/@loaders.gl/core/dist/iterators/make-iterator/make-stream-iterator.js");
/* harmony import */ var _javascript_utils_is_type_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../javascript-utils/is-type.js */ "../../node_modules/@loaders.gl/core/dist/javascript-utils/is-type.js");





function makeIterator(data, options) {
  if (typeof data === 'string') {
    return (0,_make_string_iterator_js__WEBPACK_IMPORTED_MODULE_0__.makeStringIterator)(data, options);
  }
  if (data instanceof ArrayBuffer) {
    return (0,_make_array_buffer_iterator_js__WEBPACK_IMPORTED_MODULE_1__.makeArrayBufferIterator)(data, options);
  }
  if ((0,_javascript_utils_is_type_js__WEBPACK_IMPORTED_MODULE_2__.isBlob)(data)) {
    return (0,_make_blob_iterator_js__WEBPACK_IMPORTED_MODULE_3__.makeBlobIterator)(data, options);
  }
  if ((0,_javascript_utils_is_type_js__WEBPACK_IMPORTED_MODULE_2__.isReadableStream)(data)) {
    return (0,_make_stream_iterator_js__WEBPACK_IMPORTED_MODULE_4__.makeStreamIterator)(data, options);
  }
  if ((0,_javascript_utils_is_type_js__WEBPACK_IMPORTED_MODULE_2__.isResponse)(data)) {
    const response = data;
    return (0,_make_stream_iterator_js__WEBPACK_IMPORTED_MODULE_4__.makeStreamIterator)(response.body, options);
  }
  throw new Error('makeIterator');
}
//# sourceMappingURL=make-iterator.js.map

/***/ }),

/***/ "../../node_modules/@loaders.gl/core/dist/iterators/make-iterator/make-stream-iterator.js":
/*!************************************************************************************************!*\
  !*** ../../node_modules/@loaders.gl/core/dist/iterators/make-iterator/make-stream-iterator.js ***!
  \************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   makeStreamIterator: () => (/* binding */ makeStreamIterator)
/* harmony export */ });
/* harmony import */ var _loaders_gl_loader_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @loaders.gl/loader-utils */ "../../node_modules/@loaders.gl/loader-utils/dist/lib/env-utils/globals.js");
/* harmony import */ var _loaders_gl_loader_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @loaders.gl/loader-utils */ "../../node_modules/@loaders.gl/loader-utils/dist/lib/binary-utils/memory-conversion-utils.js");

function makeStreamIterator(stream, options) {
  return _loaders_gl_loader_utils__WEBPACK_IMPORTED_MODULE_0__.isBrowser ? makeBrowserStreamIterator(stream, options) : makeNodeStreamIterator(stream, options);
}
async function* makeBrowserStreamIterator(stream, options) {
  const reader = stream.getReader();
  let nextBatchPromise;
  try {
    while (true) {
      const currentBatchPromise = nextBatchPromise || reader.read();
      if (options !== null && options !== void 0 && options._streamReadAhead) {
        nextBatchPromise = reader.read();
      }
      const {
        done,
        value
      } = await currentBatchPromise;
      if (done) {
        return;
      }
      yield (0,_loaders_gl_loader_utils__WEBPACK_IMPORTED_MODULE_1__.toArrayBuffer)(value);
    }
  } catch (error) {
    reader.releaseLock();
  }
}
async function* makeNodeStreamIterator(stream, options) {
  for await (const chunk of stream) {
    yield (0,_loaders_gl_loader_utils__WEBPACK_IMPORTED_MODULE_1__.toArrayBuffer)(chunk);
  }
}
//# sourceMappingURL=make-stream-iterator.js.map

/***/ }),

/***/ "../../node_modules/@loaders.gl/core/dist/iterators/make-iterator/make-string-iterator.js":
/*!************************************************************************************************!*\
  !*** ../../node_modules/@loaders.gl/core/dist/iterators/make-iterator/make-string-iterator.js ***!
  \************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   makeStringIterator: () => (/* binding */ makeStringIterator)
/* harmony export */ });
const DEFAULT_CHUNK_SIZE = 256 * 1024;
function* makeStringIterator(string, options) {
  const chunkSize = (options === null || options === void 0 ? void 0 : options.chunkSize) || DEFAULT_CHUNK_SIZE;
  let offset = 0;
  const textEncoder = new TextEncoder();
  while (offset < string.length) {
    const chunkLength = Math.min(string.length - offset, chunkSize);
    const chunk = string.slice(offset, offset + chunkLength);
    offset += chunkLength;
    yield textEncoder.encode(chunk);
  }
}
//# sourceMappingURL=make-string-iterator.js.map

/***/ }),

/***/ "../../node_modules/@loaders.gl/core/dist/javascript-utils/is-type.js":
/*!****************************************************************************!*\
  !*** ../../node_modules/@loaders.gl/core/dist/javascript-utils/is-type.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   isAsyncIterable: () => (/* binding */ isAsyncIterable),
/* harmony export */   isBlob: () => (/* binding */ isBlob),
/* harmony export */   isBuffer: () => (/* binding */ isBuffer),
/* harmony export */   isFile: () => (/* binding */ isFile),
/* harmony export */   isIterable: () => (/* binding */ isIterable),
/* harmony export */   isIterator: () => (/* binding */ isIterator),
/* harmony export */   isObject: () => (/* binding */ isObject),
/* harmony export */   isPromise: () => (/* binding */ isPromise),
/* harmony export */   isPureObject: () => (/* binding */ isPureObject),
/* harmony export */   isReadableDOMStream: () => (/* binding */ isReadableDOMStream),
/* harmony export */   isReadableNodeStream: () => (/* binding */ isReadableNodeStream),
/* harmony export */   isReadableStream: () => (/* binding */ isReadableStream),
/* harmony export */   isResponse: () => (/* binding */ isResponse),
/* harmony export */   isWritableDOMStream: () => (/* binding */ isWritableDOMStream),
/* harmony export */   isWritableNodeStream: () => (/* binding */ isWritableNodeStream),
/* harmony export */   isWritableStream: () => (/* binding */ isWritableStream)
/* harmony export */ });
const isBoolean = x => typeof x === 'boolean';
const isFunction = x => typeof x === 'function';
const isObject = x => x !== null && typeof x === 'object';
const isPureObject = x => isObject(x) && x.constructor === {}.constructor;
const isPromise = x => isObject(x) && isFunction(x.then);
const isIterable = x => Boolean(x) && typeof x[Symbol.iterator] === 'function';
const isAsyncIterable = x => x && typeof x[Symbol.asyncIterator] === 'function';
const isIterator = x => x && isFunction(x.next);
const isResponse = x => typeof Response !== 'undefined' && x instanceof Response || x && x.arrayBuffer && x.text && x.json;
const isFile = x => typeof File !== 'undefined' && x instanceof File;
const isBlob = x => typeof Blob !== 'undefined' && x instanceof Blob;
const isBuffer = x => x && typeof x === 'object' && x.isBuffer;
const isWritableDOMStream = x => isObject(x) && isFunction(x.abort) && isFunction(x.getWriter);
const isReadableDOMStream = x => typeof ReadableStream !== 'undefined' && x instanceof ReadableStream || isObject(x) && isFunction(x.tee) && isFunction(x.cancel) && isFunction(x.getReader);
const isWritableNodeStream = x => isObject(x) && isFunction(x.end) && isFunction(x.write) && isBoolean(x.writable);
const isReadableNodeStream = x => isObject(x) && isFunction(x.read) && isFunction(x.pipe) && isBoolean(x.readable);
const isReadableStream = x => isReadableDOMStream(x) || isReadableNodeStream(x);
const isWritableStream = x => isWritableDOMStream(x) || isWritableNodeStream(x);
//# sourceMappingURL=is-type.js.map

/***/ }),

/***/ "../../node_modules/@loaders.gl/core/dist/lib/api/load.js":
/*!****************************************************************!*\
  !*** ../../node_modules/@loaders.gl/core/dist/lib/api/load.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   load: () => (/* binding */ load)
/* harmony export */ });
/* harmony import */ var _javascript_utils_is_type_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../javascript-utils/is-type.js */ "../../node_modules/@loaders.gl/core/dist/javascript-utils/is-type.js");
/* harmony import */ var _loader_utils_normalize_loader_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../loader-utils/normalize-loader.js */ "../../node_modules/@loaders.gl/core/dist/lib/loader-utils/normalize-loader.js");
/* harmony import */ var _loader_utils_get_fetch_function_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../loader-utils/get-fetch-function.js */ "../../node_modules/@loaders.gl/core/dist/lib/loader-utils/get-fetch-function.js");
/* harmony import */ var _parse_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./parse.js */ "../../node_modules/@loaders.gl/core/dist/lib/api/parse.js");




async function load(url, loaders, options, context) {
  let resolvedLoaders;
  let resolvedOptions;
  if (!Array.isArray(loaders) && !(0,_loader_utils_normalize_loader_js__WEBPACK_IMPORTED_MODULE_0__.isLoaderObject)(loaders)) {
    resolvedLoaders = [];
    resolvedOptions = loaders;
    context = undefined;
  } else {
    resolvedLoaders = loaders;
    resolvedOptions = options;
  }
  const fetch = (0,_loader_utils_get_fetch_function_js__WEBPACK_IMPORTED_MODULE_1__.getFetchFunction)(resolvedOptions);
  let data = url;
  if (typeof url === 'string') {
    data = await fetch(url);
  }
  if ((0,_javascript_utils_is_type_js__WEBPACK_IMPORTED_MODULE_2__.isBlob)(url)) {
    data = await fetch(url);
  }
  return Array.isArray(resolvedLoaders) ? await (0,_parse_js__WEBPACK_IMPORTED_MODULE_3__.parse)(data, resolvedLoaders, resolvedOptions) : await (0,_parse_js__WEBPACK_IMPORTED_MODULE_3__.parse)(data, resolvedLoaders, resolvedOptions);
}
//# sourceMappingURL=load.js.map

/***/ }),

/***/ "../../node_modules/@loaders.gl/core/dist/lib/api/parse.js":
/*!*****************************************************************!*\
  !*** ../../node_modules/@loaders.gl/core/dist/lib/api/parse.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   parse: () => (/* binding */ parse)
/* harmony export */ });
/* harmony import */ var _loaders_gl_loader_utils__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! @loaders.gl/loader-utils */ "../../node_modules/@loaders.gl/loader-utils/dist/lib/worker-loader-utils/parse-with-worker.js");
/* harmony import */ var _loaders_gl_worker_utils__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @loaders.gl/worker-utils */ "../../node_modules/@loaders.gl/worker-utils/dist/lib/worker-api/validate-worker-version.js");
/* harmony import */ var _loaders_gl_worker_utils__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! @loaders.gl/worker-utils */ "../../node_modules/@loaders.gl/worker-utils/dist/lib/env-utils/assert.js");
/* harmony import */ var _loader_utils_normalize_loader_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../loader-utils/normalize-loader.js */ "../../node_modules/@loaders.gl/core/dist/lib/loader-utils/normalize-loader.js");
/* harmony import */ var _javascript_utils_is_type_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../javascript-utils/is-type.js */ "../../node_modules/@loaders.gl/core/dist/javascript-utils/is-type.js");
/* harmony import */ var _loader_utils_option_utils_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../loader-utils/option-utils.js */ "../../node_modules/@loaders.gl/core/dist/lib/loader-utils/option-utils.js");
/* harmony import */ var _loaders_gl_loader_utils__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @loaders.gl/loader-utils */ "../../node_modules/@loaders.gl/loader-utils/dist/lib/option-utils/merge-loader-options.js");
/* harmony import */ var _loader_utils_get_data_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../loader-utils/get-data.js */ "../../node_modules/@loaders.gl/core/dist/lib/loader-utils/get-data.js");
/* harmony import */ var _loader_utils_loader_context_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../loader-utils/loader-context.js */ "../../node_modules/@loaders.gl/core/dist/lib/loader-utils/loader-context.js");
/* harmony import */ var _utils_resource_utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/resource-utils.js */ "../../node_modules/@loaders.gl/core/dist/lib/utils/resource-utils.js");
/* harmony import */ var _select_loader_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./select-loader.js */ "../../node_modules/@loaders.gl/core/dist/lib/api/select-loader.js");










async function parse(data, loaders, options, context) {
  if (loaders && !Array.isArray(loaders) && !(0,_loader_utils_normalize_loader_js__WEBPACK_IMPORTED_MODULE_0__.isLoaderObject)(loaders)) {
    context = undefined;
    options = loaders;
    loaders = undefined;
  }
  data = await data;
  options = options || {};
  const url = (0,_utils_resource_utils_js__WEBPACK_IMPORTED_MODULE_1__.getResourceUrl)(data);
  const typedLoaders = loaders;
  const candidateLoaders = (0,_loader_utils_loader_context_js__WEBPACK_IMPORTED_MODULE_2__.getLoadersFromContext)(typedLoaders, context);
  const loader = await (0,_select_loader_js__WEBPACK_IMPORTED_MODULE_3__.selectLoader)(data, candidateLoaders, options);
  if (!loader) {
    return null;
  }
  options = (0,_loader_utils_option_utils_js__WEBPACK_IMPORTED_MODULE_4__.normalizeOptions)(options, loader, candidateLoaders, url);
  context = (0,_loader_utils_loader_context_js__WEBPACK_IMPORTED_MODULE_2__.getLoaderContext)({
    url,
    _parse: parse,
    loaders: candidateLoaders
  }, options, context || null);
  return await parseWithLoader(loader, data, options, context);
}
async function parseWithLoader(loader, data, options, context) {
  (0,_loaders_gl_worker_utils__WEBPACK_IMPORTED_MODULE_5__.validateWorkerVersion)(loader);
  options = (0,_loaders_gl_loader_utils__WEBPACK_IMPORTED_MODULE_6__.mergeLoaderOptions)(loader.options, options);
  if ((0,_javascript_utils_is_type_js__WEBPACK_IMPORTED_MODULE_7__.isResponse)(data)) {
    const response = data;
    const {
      ok,
      redirected,
      status,
      statusText,
      type,
      url
    } = response;
    const headers = Object.fromEntries(response.headers.entries());
    context.response = {
      headers,
      ok,
      redirected,
      status,
      statusText,
      type,
      url
    };
  }
  data = await (0,_loader_utils_get_data_js__WEBPACK_IMPORTED_MODULE_8__.getArrayBufferOrStringFromData)(data, loader, options);
  const loaderWithParser = loader;
  if (loaderWithParser.parseTextSync && typeof data === 'string') {
    return loaderWithParser.parseTextSync(data, options, context);
  }
  if ((0,_loaders_gl_loader_utils__WEBPACK_IMPORTED_MODULE_9__.canParseWithWorker)(loader, options)) {
    return await (0,_loaders_gl_loader_utils__WEBPACK_IMPORTED_MODULE_9__.parseWithWorker)(loader, data, options, context, parse);
  }
  if (loaderWithParser.parseText && typeof data === 'string') {
    return await loaderWithParser.parseText(data, options, context);
  }
  if (loaderWithParser.parse) {
    return await loaderWithParser.parse(data, options, context);
  }
  (0,_loaders_gl_worker_utils__WEBPACK_IMPORTED_MODULE_10__.assert)(!loaderWithParser.parseSync);
  throw new Error(`${loader.id} loader - no parser found and worker is disabled`);
}
//# sourceMappingURL=parse.js.map

/***/ }),

/***/ "../../node_modules/@loaders.gl/core/dist/lib/api/register-loaders.js":
/*!****************************************************************************!*\
  !*** ../../node_modules/@loaders.gl/core/dist/lib/api/register-loaders.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   _unregisterLoaders: () => (/* binding */ _unregisterLoaders),
/* harmony export */   getRegisteredLoaders: () => (/* binding */ getRegisteredLoaders),
/* harmony export */   registerLoaders: () => (/* binding */ registerLoaders)
/* harmony export */ });
/* harmony import */ var _loader_utils_normalize_loader_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../loader-utils/normalize-loader.js */ "../../node_modules/@loaders.gl/core/dist/lib/loader-utils/normalize-loader.js");
/* harmony import */ var _loader_utils_option_utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../loader-utils/option-utils.js */ "../../node_modules/@loaders.gl/core/dist/lib/loader-utils/option-utils.js");


const getGlobalLoaderRegistry = () => {
  const state = (0,_loader_utils_option_utils_js__WEBPACK_IMPORTED_MODULE_0__.getGlobalLoaderState)();
  state.loaderRegistry = state.loaderRegistry || [];
  return state.loaderRegistry;
};
function registerLoaders(loaders) {
  const loaderRegistry = getGlobalLoaderRegistry();
  loaders = Array.isArray(loaders) ? loaders : [loaders];
  for (const loader of loaders) {
    const normalizedLoader = (0,_loader_utils_normalize_loader_js__WEBPACK_IMPORTED_MODULE_1__.normalizeLoader)(loader);
    if (!loaderRegistry.find(registeredLoader => normalizedLoader === registeredLoader)) {
      loaderRegistry.unshift(normalizedLoader);
    }
  }
}
function getRegisteredLoaders() {
  return getGlobalLoaderRegistry();
}
function _unregisterLoaders() {
  const state = (0,_loader_utils_option_utils_js__WEBPACK_IMPORTED_MODULE_0__.getGlobalLoaderState)();
  state.loaderRegistry = [];
}
//# sourceMappingURL=register-loaders.js.map

/***/ }),

/***/ "../../node_modules/@loaders.gl/core/dist/lib/api/select-loader.js":
/*!*************************************************************************!*\
  !*** ../../node_modules/@loaders.gl/core/dist/lib/api/select-loader.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   selectLoader: () => (/* binding */ selectLoader),
/* harmony export */   selectLoaderSync: () => (/* binding */ selectLoaderSync)
/* harmony export */ });
/* harmony import */ var _loaders_gl_loader_utils__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @loaders.gl/loader-utils */ "../../node_modules/@loaders.gl/loader-utils/dist/lib/path-utils/path.js");
/* harmony import */ var _loaders_gl_loader_utils__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @loaders.gl/loader-utils */ "../../node_modules/@loaders.gl/loader-utils/dist/lib/binary-utils/array-buffer-utils.js");
/* harmony import */ var _loader_utils_normalize_loader_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../loader-utils/normalize-loader.js */ "../../node_modules/@loaders.gl/core/dist/lib/loader-utils/normalize-loader.js");
/* harmony import */ var _utils_log_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../utils/log.js */ "../../node_modules/@loaders.gl/core/dist/lib/utils/log.js");
/* harmony import */ var _utils_resource_utils_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utils/resource-utils.js */ "../../node_modules/@loaders.gl/core/dist/lib/utils/resource-utils.js");
/* harmony import */ var _register_loaders_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./register-loaders.js */ "../../node_modules/@loaders.gl/core/dist/lib/api/register-loaders.js");
/* harmony import */ var _javascript_utils_is_type_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../javascript-utils/is-type.js */ "../../node_modules/@loaders.gl/core/dist/javascript-utils/is-type.js");
/* harmony import */ var _utils_url_utils_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../utils/url-utils.js */ "../../node_modules/@loaders.gl/core/dist/lib/utils/url-utils.js");







const EXT_PATTERN = /\.([^.]+)$/;
async function selectLoader(data) {
  let loaders = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
  let options = arguments.length > 2 ? arguments[2] : undefined;
  let context = arguments.length > 3 ? arguments[3] : undefined;
  if (!validHTTPResponse(data)) {
    return null;
  }
  let loader = selectLoaderSync(data, loaders, {
    ...options,
    nothrow: true
  }, context);
  if (loader) {
    return loader;
  }
  if ((0,_javascript_utils_is_type_js__WEBPACK_IMPORTED_MODULE_0__.isBlob)(data)) {
    data = await data.slice(0, 10).arrayBuffer();
    loader = selectLoaderSync(data, loaders, options, context);
  }
  if (!loader && !(options !== null && options !== void 0 && options.nothrow)) {
    throw new Error(getNoValidLoaderMessage(data));
  }
  return loader;
}
function selectLoaderSync(data) {
  let loaders = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
  let options = arguments.length > 2 ? arguments[2] : undefined;
  let context = arguments.length > 3 ? arguments[3] : undefined;
  if (!validHTTPResponse(data)) {
    return null;
  }
  if (loaders && !Array.isArray(loaders)) {
    return (0,_loader_utils_normalize_loader_js__WEBPACK_IMPORTED_MODULE_1__.normalizeLoader)(loaders);
  }
  let candidateLoaders = [];
  if (loaders) {
    candidateLoaders = candidateLoaders.concat(loaders);
  }
  if (!(options !== null && options !== void 0 && options.ignoreRegisteredLoaders)) {
    candidateLoaders.push(...(0,_register_loaders_js__WEBPACK_IMPORTED_MODULE_2__.getRegisteredLoaders)());
  }
  normalizeLoaders(candidateLoaders);
  const loader = selectLoaderInternal(data, candidateLoaders, options, context);
  if (!loader && !(options !== null && options !== void 0 && options.nothrow)) {
    throw new Error(getNoValidLoaderMessage(data));
  }
  return loader;
}
function selectLoaderInternal(data, loaders, options, context) {
  const url = (0,_utils_resource_utils_js__WEBPACK_IMPORTED_MODULE_3__.getResourceUrl)(data);
  const type = (0,_utils_resource_utils_js__WEBPACK_IMPORTED_MODULE_3__.getResourceMIMEType)(data);
  const testUrl = (0,_utils_url_utils_js__WEBPACK_IMPORTED_MODULE_4__.stripQueryString)(url) || (context === null || context === void 0 ? void 0 : context.url);
  let loader = null;
  let reason = '';
  if (options !== null && options !== void 0 && options.mimeType) {
    loader = findLoaderByMIMEType(loaders, options === null || options === void 0 ? void 0 : options.mimeType);
    reason = `match forced by supplied MIME type ${options === null || options === void 0 ? void 0 : options.mimeType}`;
  }
  loader = loader || findLoaderByUrl(loaders, testUrl);
  reason = reason || (loader ? `matched url ${testUrl}` : '');
  loader = loader || findLoaderByMIMEType(loaders, type);
  reason = reason || (loader ? `matched MIME type ${type}` : '');
  loader = loader || findLoaderByInitialBytes(loaders, data);
  reason = reason || (loader ? `matched initial data ${getFirstCharacters(data)}` : '');
  if (options !== null && options !== void 0 && options.fallbackMimeType) {
    loader = loader || findLoaderByMIMEType(loaders, options === null || options === void 0 ? void 0 : options.fallbackMimeType);
    reason = reason || (loader ? `matched fallback MIME type ${type}` : '');
  }
  if (reason) {
    var _loader;
    _utils_log_js__WEBPACK_IMPORTED_MODULE_5__.log.log(1, `selectLoader selected ${(_loader = loader) === null || _loader === void 0 ? void 0 : _loader.name}: ${reason}.`);
  }
  return loader;
}
function validHTTPResponse(data) {
  if (data instanceof Response) {
    if (data.status === 204) {
      return false;
    }
  }
  return true;
}
function getNoValidLoaderMessage(data) {
  const url = (0,_utils_resource_utils_js__WEBPACK_IMPORTED_MODULE_3__.getResourceUrl)(data);
  const type = (0,_utils_resource_utils_js__WEBPACK_IMPORTED_MODULE_3__.getResourceMIMEType)(data);
  let message = 'No valid loader found (';
  message += url ? `${_loaders_gl_loader_utils__WEBPACK_IMPORTED_MODULE_6__.filename(url)}, ` : 'no url provided, ';
  message += `MIME type: ${type ? `"${type}"` : 'not provided'}, `;
  const firstCharacters = data ? getFirstCharacters(data) : '';
  message += firstCharacters ? ` first bytes: "${firstCharacters}"` : 'first bytes: not available';
  message += ')';
  return message;
}
function normalizeLoaders(loaders) {
  for (const loader of loaders) {
    (0,_loader_utils_normalize_loader_js__WEBPACK_IMPORTED_MODULE_1__.normalizeLoader)(loader);
  }
}
function findLoaderByUrl(loaders, url) {
  const match = url && EXT_PATTERN.exec(url);
  const extension = match && match[1];
  return extension ? findLoaderByExtension(loaders, extension) : null;
}
function findLoaderByExtension(loaders, extension) {
  extension = extension.toLowerCase();
  for (const loader of loaders) {
    for (const loaderExtension of loader.extensions) {
      if (loaderExtension.toLowerCase() === extension) {
        return loader;
      }
    }
  }
  return null;
}
function findLoaderByMIMEType(loaders, mimeType) {
  for (const loader of loaders) {
    if (loader.mimeTypes && loader.mimeTypes.includes(mimeType)) {
      return loader;
    }
    if (mimeType === `application/x.${loader.id}`) {
      return loader;
    }
  }
  return null;
}
function findLoaderByInitialBytes(loaders, data) {
  if (!data) {
    return null;
  }
  for (const loader of loaders) {
    if (typeof data === 'string') {
      if (testDataAgainstText(data, loader)) {
        return loader;
      }
    } else if (ArrayBuffer.isView(data)) {
      if (testDataAgainstBinary(data.buffer, data.byteOffset, loader)) {
        return loader;
      }
    } else if (data instanceof ArrayBuffer) {
      const byteOffset = 0;
      if (testDataAgainstBinary(data, byteOffset, loader)) {
        return loader;
      }
    }
  }
  return null;
}
function testDataAgainstText(data, loader) {
  if (loader.testText) {
    return loader.testText(data);
  }
  const tests = Array.isArray(loader.tests) ? loader.tests : [loader.tests];
  return tests.some(test => data.startsWith(test));
}
function testDataAgainstBinary(data, byteOffset, loader) {
  const tests = Array.isArray(loader.tests) ? loader.tests : [loader.tests];
  return tests.some(test => testBinary(data, byteOffset, loader, test));
}
function testBinary(data, byteOffset, loader, test) {
  if (test instanceof ArrayBuffer) {
    return (0,_loaders_gl_loader_utils__WEBPACK_IMPORTED_MODULE_7__.compareArrayBuffers)(test, data, test.byteLength);
  }
  switch (typeof test) {
    case 'function':
      return test(data);
    case 'string':
      const magic = getMagicString(data, byteOffset, test.length);
      return test === magic;
    default:
      return false;
  }
}
function getFirstCharacters(data) {
  let length = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 5;
  if (typeof data === 'string') {
    return data.slice(0, length);
  } else if (ArrayBuffer.isView(data)) {
    return getMagicString(data.buffer, data.byteOffset, length);
  } else if (data instanceof ArrayBuffer) {
    const byteOffset = 0;
    return getMagicString(data, byteOffset, length);
  }
  return '';
}
function getMagicString(arrayBuffer, byteOffset, length) {
  if (arrayBuffer.byteLength < byteOffset + length) {
    return '';
  }
  const dataView = new DataView(arrayBuffer);
  let magic = '';
  for (let i = 0; i < length; i++) {
    magic += String.fromCharCode(dataView.getUint8(byteOffset + i));
  }
  return magic;
}
//# sourceMappingURL=select-loader.js.map

/***/ }),

/***/ "../../node_modules/@loaders.gl/core/dist/lib/fetch/fetch-file.js":
/*!************************************************************************!*\
  !*** ../../node_modules/@loaders.gl/core/dist/lib/fetch/fetch-file.js ***!
  \************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   fetchFile: () => (/* binding */ fetchFile),
/* harmony export */   isDataURL: () => (/* binding */ isDataURL),
/* harmony export */   isNodePath: () => (/* binding */ isNodePath),
/* harmony export */   isRequestURL: () => (/* binding */ isRequestURL)
/* harmony export */ });
/* harmony import */ var _loaders_gl_loader_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @loaders.gl/loader-utils */ "../../node_modules/@loaders.gl/loader-utils/dist/lib/path-utils/file-aliases.js");
/* harmony import */ var _utils_response_utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/response-utils.js */ "../../node_modules/@loaders.gl/core/dist/lib/utils/response-utils.js");


function isNodePath(url) {
  return !isRequestURL(url) && !isDataURL(url);
}
function isRequestURL(url) {
  return url.startsWith('http:') || url.startsWith('https:');
}
function isDataURL(url) {
  return url.startsWith('data:');
}
async function fetchFile(urlOrData, fetchOptions) {
  if (typeof urlOrData === 'string') {
    const url = (0,_loaders_gl_loader_utils__WEBPACK_IMPORTED_MODULE_0__.resolvePath)(urlOrData);
    if (isNodePath(url)) {
      var _globalThis$loaders;
      if ((_globalThis$loaders = globalThis.loaders) !== null && _globalThis$loaders !== void 0 && _globalThis$loaders.fetchNode) {
        var _globalThis$loaders2;
        return (_globalThis$loaders2 = globalThis.loaders) === null || _globalThis$loaders2 === void 0 ? void 0 : _globalThis$loaders2.fetchNode(url, fetchOptions);
      }
    }
    return await fetch(url, fetchOptions);
  }
  return await (0,_utils_response_utils_js__WEBPACK_IMPORTED_MODULE_1__.makeResponse)(urlOrData);
}
//# sourceMappingURL=fetch-file.js.map

/***/ }),

/***/ "../../node_modules/@loaders.gl/core/dist/lib/loader-utils/get-data.js":
/*!*****************************************************************************!*\
  !*** ../../node_modules/@loaders.gl/core/dist/lib/loader-utils/get-data.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   getArrayBufferOrStringFromData: () => (/* binding */ getArrayBufferOrStringFromData),
/* harmony export */   getArrayBufferOrStringFromDataSync: () => (/* binding */ getArrayBufferOrStringFromDataSync),
/* harmony export */   getAsyncIterableFromData: () => (/* binding */ getAsyncIterableFromData),
/* harmony export */   getReadableStream: () => (/* binding */ getReadableStream)
/* harmony export */ });
/* harmony import */ var _loaders_gl_loader_utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @loaders.gl/loader-utils */ "../../node_modules/@loaders.gl/loader-utils/dist/lib/iterators/async-iteration.js");
/* harmony import */ var _javascript_utils_is_type_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../javascript-utils/is-type.js */ "../../node_modules/@loaders.gl/core/dist/javascript-utils/is-type.js");
/* harmony import */ var _iterators_make_iterator_make_iterator_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../iterators/make-iterator/make-iterator.js */ "../../node_modules/@loaders.gl/core/dist/iterators/make-iterator/make-iterator.js");
/* harmony import */ var _utils_response_utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/response-utils.js */ "../../node_modules/@loaders.gl/core/dist/lib/utils/response-utils.js");




const ERR_DATA = 'Cannot convert supplied data type';
function getArrayBufferOrStringFromDataSync(data, loader, options) {
  if (loader.text && typeof data === 'string') {
    return data;
  }
  if ((0,_javascript_utils_is_type_js__WEBPACK_IMPORTED_MODULE_0__.isBuffer)(data)) {
    data = data.buffer;
  }
  if (data instanceof ArrayBuffer) {
    const arrayBuffer = data;
    if (loader.text && !loader.binary) {
      const textDecoder = new TextDecoder('utf8');
      return textDecoder.decode(arrayBuffer);
    }
    return arrayBuffer;
  }
  if (ArrayBuffer.isView(data)) {
    if (loader.text && !loader.binary) {
      const textDecoder = new TextDecoder('utf8');
      return textDecoder.decode(data);
    }
    let arrayBuffer = data.buffer;
    const byteLength = data.byteLength || data.length;
    if (data.byteOffset !== 0 || byteLength !== arrayBuffer.byteLength) {
      arrayBuffer = arrayBuffer.slice(data.byteOffset, data.byteOffset + byteLength);
    }
    return arrayBuffer;
  }
  throw new Error(ERR_DATA);
}
async function getArrayBufferOrStringFromData(data, loader, options) {
  const isArrayBuffer = data instanceof ArrayBuffer || ArrayBuffer.isView(data);
  if (typeof data === 'string' || isArrayBuffer) {
    return getArrayBufferOrStringFromDataSync(data, loader, options);
  }
  if ((0,_javascript_utils_is_type_js__WEBPACK_IMPORTED_MODULE_0__.isBlob)(data)) {
    data = await (0,_utils_response_utils_js__WEBPACK_IMPORTED_MODULE_1__.makeResponse)(data);
  }
  if ((0,_javascript_utils_is_type_js__WEBPACK_IMPORTED_MODULE_0__.isResponse)(data)) {
    const response = data;
    await (0,_utils_response_utils_js__WEBPACK_IMPORTED_MODULE_1__.checkResponse)(response);
    return loader.binary ? await response.arrayBuffer() : await response.text();
  }
  if ((0,_javascript_utils_is_type_js__WEBPACK_IMPORTED_MODULE_0__.isReadableStream)(data)) {
    data = (0,_iterators_make_iterator_make_iterator_js__WEBPACK_IMPORTED_MODULE_2__.makeIterator)(data, options);
  }
  if ((0,_javascript_utils_is_type_js__WEBPACK_IMPORTED_MODULE_0__.isIterable)(data) || (0,_javascript_utils_is_type_js__WEBPACK_IMPORTED_MODULE_0__.isAsyncIterable)(data)) {
    return (0,_loaders_gl_loader_utils__WEBPACK_IMPORTED_MODULE_3__.concatenateArrayBuffersAsync)(data);
  }
  throw new Error(ERR_DATA);
}
async function getAsyncIterableFromData(data, options) {
  if ((0,_javascript_utils_is_type_js__WEBPACK_IMPORTED_MODULE_0__.isIterator)(data)) {
    return data;
  }
  if ((0,_javascript_utils_is_type_js__WEBPACK_IMPORTED_MODULE_0__.isResponse)(data)) {
    const response = data;
    await (0,_utils_response_utils_js__WEBPACK_IMPORTED_MODULE_1__.checkResponse)(response);
    const body = await response.body;
    return (0,_iterators_make_iterator_make_iterator_js__WEBPACK_IMPORTED_MODULE_2__.makeIterator)(body, options);
  }
  if ((0,_javascript_utils_is_type_js__WEBPACK_IMPORTED_MODULE_0__.isBlob)(data) || (0,_javascript_utils_is_type_js__WEBPACK_IMPORTED_MODULE_0__.isReadableStream)(data)) {
    return (0,_iterators_make_iterator_make_iterator_js__WEBPACK_IMPORTED_MODULE_2__.makeIterator)(data, options);
  }
  if ((0,_javascript_utils_is_type_js__WEBPACK_IMPORTED_MODULE_0__.isAsyncIterable)(data)) {
    return data;
  }
  return getIterableFromData(data);
}
async function getReadableStream(data) {
  if ((0,_javascript_utils_is_type_js__WEBPACK_IMPORTED_MODULE_0__.isReadableStream)(data)) {
    return data;
  }
  if ((0,_javascript_utils_is_type_js__WEBPACK_IMPORTED_MODULE_0__.isResponse)(data)) {
    return data.body;
  }
  const response = await (0,_utils_response_utils_js__WEBPACK_IMPORTED_MODULE_1__.makeResponse)(data);
  return response.body;
}
function getIterableFromData(data) {
  if (ArrayBuffer.isView(data)) {
    return function* oneChunk() {
      yield data.buffer;
    }();
  }
  if (data instanceof ArrayBuffer) {
    return function* oneChunk() {
      yield data;
    }();
  }
  if ((0,_javascript_utils_is_type_js__WEBPACK_IMPORTED_MODULE_0__.isIterator)(data)) {
    return data;
  }
  if ((0,_javascript_utils_is_type_js__WEBPACK_IMPORTED_MODULE_0__.isIterable)(data)) {
    return data[Symbol.iterator]();
  }
  throw new Error(ERR_DATA);
}
//# sourceMappingURL=get-data.js.map

/***/ }),

/***/ "../../node_modules/@loaders.gl/core/dist/lib/loader-utils/get-fetch-function.js":
/*!***************************************************************************************!*\
  !*** ../../node_modules/@loaders.gl/core/dist/lib/loader-utils/get-fetch-function.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   getFetchFunction: () => (/* binding */ getFetchFunction)
/* harmony export */ });
/* harmony import */ var _javascript_utils_is_type_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../javascript-utils/is-type.js */ "../../node_modules/@loaders.gl/core/dist/javascript-utils/is-type.js");
/* harmony import */ var _fetch_fetch_file_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../fetch/fetch-file.js */ "../../node_modules/@loaders.gl/core/dist/lib/fetch/fetch-file.js");
/* harmony import */ var _option_utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./option-utils.js */ "../../node_modules/@loaders.gl/core/dist/lib/loader-utils/option-utils.js");



function getFetchFunction(options, context) {
  const globalOptions = (0,_option_utils_js__WEBPACK_IMPORTED_MODULE_0__.getGlobalLoaderOptions)();
  const loaderOptions = options || globalOptions;
  if (typeof loaderOptions.fetch === 'function') {
    return loaderOptions.fetch;
  }
  if ((0,_javascript_utils_is_type_js__WEBPACK_IMPORTED_MODULE_1__.isObject)(loaderOptions.fetch)) {
    return url => (0,_fetch_fetch_file_js__WEBPACK_IMPORTED_MODULE_2__.fetchFile)(url, loaderOptions.fetch);
  }
  if (context !== null && context !== void 0 && context.fetch) {
    return context === null || context === void 0 ? void 0 : context.fetch;
  }
  return _fetch_fetch_file_js__WEBPACK_IMPORTED_MODULE_2__.fetchFile;
}
//# sourceMappingURL=get-fetch-function.js.map

/***/ }),

/***/ "../../node_modules/@loaders.gl/core/dist/lib/loader-utils/loader-context.js":
/*!***********************************************************************************!*\
  !*** ../../node_modules/@loaders.gl/core/dist/lib/loader-utils/loader-context.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   getLoaderContext: () => (/* binding */ getLoaderContext),
/* harmony export */   getLoadersFromContext: () => (/* binding */ getLoadersFromContext)
/* harmony export */ });
/* harmony import */ var _get_fetch_function_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./get-fetch-function.js */ "../../node_modules/@loaders.gl/core/dist/lib/loader-utils/get-fetch-function.js");
/* harmony import */ var _utils_url_utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/url-utils.js */ "../../node_modules/@loaders.gl/core/dist/lib/utils/url-utils.js");
/* harmony import */ var _loaders_gl_loader_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @loaders.gl/loader-utils */ "../../node_modules/@loaders.gl/loader-utils/dist/lib/path-utils/path.js");



function getLoaderContext(context, options, parentContext) {
  if (parentContext) {
    return parentContext;
  }
  const newContext = {
    fetch: (0,_get_fetch_function_js__WEBPACK_IMPORTED_MODULE_0__.getFetchFunction)(options, context),
    ...context
  };
  if (newContext.url) {
    const baseUrl = (0,_utils_url_utils_js__WEBPACK_IMPORTED_MODULE_1__.stripQueryString)(newContext.url);
    newContext.baseUrl = baseUrl;
    newContext.queryString = (0,_utils_url_utils_js__WEBPACK_IMPORTED_MODULE_1__.extractQueryString)(newContext.url);
    newContext.filename = _loaders_gl_loader_utils__WEBPACK_IMPORTED_MODULE_2__.filename(baseUrl);
    newContext.baseUrl = _loaders_gl_loader_utils__WEBPACK_IMPORTED_MODULE_2__.dirname(baseUrl);
  }
  if (!Array.isArray(newContext.loaders)) {
    newContext.loaders = null;
  }
  return newContext;
}
function getLoadersFromContext(loaders, context) {
  if (loaders && !Array.isArray(loaders)) {
    return loaders;
  }
  let candidateLoaders;
  if (loaders) {
    candidateLoaders = Array.isArray(loaders) ? loaders : [loaders];
  }
  if (context && context.loaders) {
    const contextLoaders = Array.isArray(context.loaders) ? context.loaders : [context.loaders];
    candidateLoaders = candidateLoaders ? [...candidateLoaders, ...contextLoaders] : contextLoaders;
  }
  return candidateLoaders && candidateLoaders.length ? candidateLoaders : undefined;
}
//# sourceMappingURL=loader-context.js.map

/***/ }),

/***/ "../../node_modules/@loaders.gl/core/dist/lib/loader-utils/loggers.js":
/*!****************************************************************************!*\
  !*** ../../node_modules/@loaders.gl/core/dist/lib/loader-utils/loggers.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ConsoleLog: () => (/* binding */ ConsoleLog),
/* harmony export */   NullLog: () => (/* binding */ NullLog),
/* harmony export */   probeLog: () => (/* binding */ probeLog)
/* harmony export */ });
/* harmony import */ var _probe_gl_log__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @probe.gl/log */ "../../node_modules/@probe.gl/log/dist/log.js");

const probeLog = new _probe_gl_log__WEBPACK_IMPORTED_MODULE_0__.Log({
  id: 'loaders.gl'
});
class NullLog {
  log() {
    return () => {};
  }
  info() {
    return () => {};
  }
  warn() {
    return () => {};
  }
  error() {
    return () => {};
  }
}
class ConsoleLog {
  constructor() {
    this.console = void 0;
    this.console = console;
  }
  log() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    return this.console.log.bind(this.console, ...args);
  }
  info() {
    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      args[_key2] = arguments[_key2];
    }
    return this.console.info.bind(this.console, ...args);
  }
  warn() {
    for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
      args[_key3] = arguments[_key3];
    }
    return this.console.warn.bind(this.console, ...args);
  }
  error() {
    for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
      args[_key4] = arguments[_key4];
    }
    return this.console.error.bind(this.console, ...args);
  }
}
//# sourceMappingURL=loggers.js.map

/***/ }),

/***/ "../../node_modules/@loaders.gl/core/dist/lib/loader-utils/normalize-loader.js":
/*!*************************************************************************************!*\
  !*** ../../node_modules/@loaders.gl/core/dist/lib/loader-utils/normalize-loader.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   isLoaderObject: () => (/* binding */ isLoaderObject),
/* harmony export */   normalizeLoader: () => (/* binding */ normalizeLoader)
/* harmony export */ });
/* harmony import */ var _loaders_gl_loader_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @loaders.gl/loader-utils */ "../../node_modules/@loaders.gl/loader-utils/dist/lib/env-utils/assert.js");

function isLoaderObject(loader) {
  var _loader;
  if (!loader) {
    return false;
  }
  if (Array.isArray(loader)) {
    loader = loader[0];
  }
  const hasExtensions = Array.isArray((_loader = loader) === null || _loader === void 0 ? void 0 : _loader.extensions);
  return hasExtensions;
}
function normalizeLoader(loader) {
  var _loader2, _loader3;
  (0,_loaders_gl_loader_utils__WEBPACK_IMPORTED_MODULE_0__.assert)(loader, 'null loader');
  (0,_loaders_gl_loader_utils__WEBPACK_IMPORTED_MODULE_0__.assert)(isLoaderObject(loader), 'invalid loader');
  let options;
  if (Array.isArray(loader)) {
    options = loader[1];
    loader = loader[0];
    loader = {
      ...loader,
      options: {
        ...loader.options,
        ...options
      }
    };
  }
  if ((_loader2 = loader) !== null && _loader2 !== void 0 && _loader2.parseTextSync || (_loader3 = loader) !== null && _loader3 !== void 0 && _loader3.parseText) {
    loader.text = true;
  }
  if (!loader.text) {
    loader.binary = true;
  }
  return loader;
}
//# sourceMappingURL=normalize-loader.js.map

/***/ }),

/***/ "../../node_modules/@loaders.gl/core/dist/lib/loader-utils/option-defaults.js":
/*!************************************************************************************!*\
  !*** ../../node_modules/@loaders.gl/core/dist/lib/loader-utils/option-defaults.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   DEFAULT_LOADER_OPTIONS: () => (/* binding */ DEFAULT_LOADER_OPTIONS),
/* harmony export */   REMOVED_LOADER_OPTIONS: () => (/* binding */ REMOVED_LOADER_OPTIONS)
/* harmony export */ });
/* harmony import */ var _loaders_gl_loader_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @loaders.gl/loader-utils */ "../../node_modules/@loaders.gl/loader-utils/dist/lib/env-utils/globals.js");
/* harmony import */ var _loggers_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./loggers.js */ "../../node_modules/@loaders.gl/core/dist/lib/loader-utils/loggers.js");


const DEFAULT_LOADER_OPTIONS = {
  fetch: null,
  mimeType: undefined,
  nothrow: false,
  log: new _loggers_js__WEBPACK_IMPORTED_MODULE_0__.ConsoleLog(),
  useLocalLibraries: false,
  CDN: 'https://unpkg.com/@loaders.gl',
  worker: true,
  maxConcurrency: 3,
  maxMobileConcurrency: 1,
  reuseWorkers: _loaders_gl_loader_utils__WEBPACK_IMPORTED_MODULE_1__.isBrowser,
  _nodeWorkers: false,
  _workerType: '',
  limit: 0,
  _limitMB: 0,
  batchSize: 'auto',
  batchDebounceMs: 0,
  metadata: false,
  transforms: []
};
const REMOVED_LOADER_OPTIONS = {
  throws: 'nothrow',
  dataType: '(no longer used)',
  uri: 'baseUri',
  method: 'fetch.method',
  headers: 'fetch.headers',
  body: 'fetch.body',
  mode: 'fetch.mode',
  credentials: 'fetch.credentials',
  cache: 'fetch.cache',
  redirect: 'fetch.redirect',
  referrer: 'fetch.referrer',
  referrerPolicy: 'fetch.referrerPolicy',
  integrity: 'fetch.integrity',
  keepalive: 'fetch.keepalive',
  signal: 'fetch.signal'
};
//# sourceMappingURL=option-defaults.js.map

/***/ }),

/***/ "../../node_modules/@loaders.gl/core/dist/lib/loader-utils/option-utils.js":
/*!*********************************************************************************!*\
  !*** ../../node_modules/@loaders.gl/core/dist/lib/loader-utils/option-utils.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   getGlobalLoaderOptions: () => (/* binding */ getGlobalLoaderOptions),
/* harmony export */   getGlobalLoaderState: () => (/* binding */ getGlobalLoaderState),
/* harmony export */   normalizeOptions: () => (/* binding */ normalizeOptions),
/* harmony export */   setGlobalOptions: () => (/* binding */ setGlobalOptions)
/* harmony export */ });
/* harmony import */ var _javascript_utils_is_type_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../javascript-utils/is-type.js */ "../../node_modules/@loaders.gl/core/dist/javascript-utils/is-type.js");
/* harmony import */ var _loggers_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./loggers.js */ "../../node_modules/@loaders.gl/core/dist/lib/loader-utils/loggers.js");
/* harmony import */ var _option_defaults_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./option-defaults.js */ "../../node_modules/@loaders.gl/core/dist/lib/loader-utils/option-defaults.js");



function getGlobalLoaderState() {
  globalThis.loaders = globalThis.loaders || {};
  const {
    loaders
  } = globalThis;
  loaders._state = loaders._state || {};
  return loaders._state;
}
function getGlobalLoaderOptions() {
  const state = getGlobalLoaderState();
  state.globalOptions = state.globalOptions || {
    ..._option_defaults_js__WEBPACK_IMPORTED_MODULE_0__.DEFAULT_LOADER_OPTIONS
  };
  return state.globalOptions;
}
function setGlobalOptions(options) {
  const state = getGlobalLoaderState();
  const globalOptions = getGlobalLoaderOptions();
  state.globalOptions = normalizeOptionsInternal(globalOptions, options);
}
function normalizeOptions(options, loader, loaders, url) {
  loaders = loaders || [];
  loaders = Array.isArray(loaders) ? loaders : [loaders];
  validateOptions(options, loaders);
  return normalizeOptionsInternal(loader, options, url);
}
function validateOptions(options, loaders) {
  validateOptionsObject(options, null, _option_defaults_js__WEBPACK_IMPORTED_MODULE_0__.DEFAULT_LOADER_OPTIONS, _option_defaults_js__WEBPACK_IMPORTED_MODULE_0__.REMOVED_LOADER_OPTIONS, loaders);
  for (const loader of loaders) {
    const idOptions = options && options[loader.id] || {};
    const loaderOptions = loader.options && loader.options[loader.id] || {};
    const deprecatedOptions = loader.deprecatedOptions && loader.deprecatedOptions[loader.id] || {};
    validateOptionsObject(idOptions, loader.id, loaderOptions, deprecatedOptions, loaders);
  }
}
function validateOptionsObject(options, id, defaultOptions, deprecatedOptions, loaders) {
  const loaderName = id || 'Top level';
  const prefix = id ? `${id}.` : '';
  for (const key in options) {
    const isSubOptions = !id && (0,_javascript_utils_is_type_js__WEBPACK_IMPORTED_MODULE_1__.isObject)(options[key]);
    const isBaseUriOption = key === 'baseUri' && !id;
    const isWorkerUrlOption = key === 'workerUrl' && id;
    if (!(key in defaultOptions) && !isBaseUriOption && !isWorkerUrlOption) {
      if (key in deprecatedOptions) {
        _loggers_js__WEBPACK_IMPORTED_MODULE_2__.probeLog.warn(`${loaderName} loader option \'${prefix}${key}\' no longer supported, use \'${deprecatedOptions[key]}\'`)();
      } else if (!isSubOptions) {
        const suggestion = findSimilarOption(key, loaders);
        _loggers_js__WEBPACK_IMPORTED_MODULE_2__.probeLog.warn(`${loaderName} loader option \'${prefix}${key}\' not recognized. ${suggestion}`)();
      }
    }
  }
}
function findSimilarOption(optionKey, loaders) {
  const lowerCaseOptionKey = optionKey.toLowerCase();
  let bestSuggestion = '';
  for (const loader of loaders) {
    for (const key in loader.options) {
      if (optionKey === key) {
        return `Did you mean \'${loader.id}.${key}\'?`;
      }
      const lowerCaseKey = key.toLowerCase();
      const isPartialMatch = lowerCaseOptionKey.startsWith(lowerCaseKey) || lowerCaseKey.startsWith(lowerCaseOptionKey);
      if (isPartialMatch) {
        bestSuggestion = bestSuggestion || `Did you mean \'${loader.id}.${key}\'?`;
      }
    }
  }
  return bestSuggestion;
}
function normalizeOptionsInternal(loader, options, url) {
  const loaderDefaultOptions = loader.options || {};
  const mergedOptions = {
    ...loaderDefaultOptions
  };
  addUrlOptions(mergedOptions, url);
  if (mergedOptions.log === null) {
    mergedOptions.log = new _loggers_js__WEBPACK_IMPORTED_MODULE_2__.NullLog();
  }
  mergeNestedFields(mergedOptions, getGlobalLoaderOptions());
  mergeNestedFields(mergedOptions, options);
  return mergedOptions;
}
function mergeNestedFields(mergedOptions, options) {
  for (const key in options) {
    if (key in options) {
      const value = options[key];
      if ((0,_javascript_utils_is_type_js__WEBPACK_IMPORTED_MODULE_1__.isPureObject)(value) && (0,_javascript_utils_is_type_js__WEBPACK_IMPORTED_MODULE_1__.isPureObject)(mergedOptions[key])) {
        mergedOptions[key] = {
          ...mergedOptions[key],
          ...options[key]
        };
      } else {
        mergedOptions[key] = options[key];
      }
    }
  }
}
function addUrlOptions(options, url) {
  if (url && !('baseUri' in options)) {
    options.baseUri = url;
  }
}
//# sourceMappingURL=option-utils.js.map

/***/ }),

/***/ "../../node_modules/@loaders.gl/core/dist/lib/utils/log.js":
/*!*****************************************************************!*\
  !*** ../../node_modules/@loaders.gl/core/dist/lib/utils/log.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   log: () => (/* binding */ log)
/* harmony export */ });
/* harmony import */ var _probe_gl_log__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @probe.gl/log */ "../../node_modules/@probe.gl/log/dist/log.js");

const log = new _probe_gl_log__WEBPACK_IMPORTED_MODULE_0__.Log({
  id: 'loaders.gl'
});
//# sourceMappingURL=log.js.map

/***/ }),

/***/ "../../node_modules/@loaders.gl/core/dist/lib/utils/mime-type-utils.js":
/*!*****************************************************************************!*\
  !*** ../../node_modules/@loaders.gl/core/dist/lib/utils/mime-type-utils.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   parseMIMEType: () => (/* binding */ parseMIMEType),
/* harmony export */   parseMIMETypeFromURL: () => (/* binding */ parseMIMETypeFromURL)
/* harmony export */ });
const DATA_URL_PATTERN = /^data:([-\w.]+\/[-\w.+]+)(;|,)/;
const MIME_TYPE_PATTERN = /^([-\w.]+\/[-\w.+]+)/;
function parseMIMEType(mimeString) {
  const matches = MIME_TYPE_PATTERN.exec(mimeString);
  if (matches) {
    return matches[1];
  }
  return mimeString;
}
function parseMIMETypeFromURL(url) {
  const matches = DATA_URL_PATTERN.exec(url);
  if (matches) {
    return matches[1];
  }
  return '';
}
//# sourceMappingURL=mime-type-utils.js.map

/***/ }),

/***/ "../../node_modules/@loaders.gl/core/dist/lib/utils/resource-utils.js":
/*!****************************************************************************!*\
  !*** ../../node_modules/@loaders.gl/core/dist/lib/utils/resource-utils.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   getResourceContentLength: () => (/* binding */ getResourceContentLength),
/* harmony export */   getResourceMIMEType: () => (/* binding */ getResourceMIMEType),
/* harmony export */   getResourceUrl: () => (/* binding */ getResourceUrl)
/* harmony export */ });
/* harmony import */ var _javascript_utils_is_type_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../javascript-utils/is-type.js */ "../../node_modules/@loaders.gl/core/dist/javascript-utils/is-type.js");
/* harmony import */ var _mime_type_utils_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./mime-type-utils.js */ "../../node_modules/@loaders.gl/core/dist/lib/utils/mime-type-utils.js");
/* harmony import */ var _url_utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./url-utils.js */ "../../node_modules/@loaders.gl/core/dist/lib/utils/url-utils.js");



function getResourceUrl(resource) {
  if ((0,_javascript_utils_is_type_js__WEBPACK_IMPORTED_MODULE_0__.isResponse)(resource)) {
    const response = resource;
    return response.url;
  }
  if ((0,_javascript_utils_is_type_js__WEBPACK_IMPORTED_MODULE_0__.isBlob)(resource)) {
    const blob = resource;
    return blob.name || '';
  }
  if (typeof resource === 'string') {
    return resource;
  }
  return '';
}
function getResourceMIMEType(resource) {
  if ((0,_javascript_utils_is_type_js__WEBPACK_IMPORTED_MODULE_0__.isResponse)(resource)) {
    const response = resource;
    const contentTypeHeader = response.headers.get('content-type') || '';
    const noQueryUrl = (0,_url_utils_js__WEBPACK_IMPORTED_MODULE_1__.stripQueryString)(response.url);
    return (0,_mime_type_utils_js__WEBPACK_IMPORTED_MODULE_2__.parseMIMEType)(contentTypeHeader) || (0,_mime_type_utils_js__WEBPACK_IMPORTED_MODULE_2__.parseMIMETypeFromURL)(noQueryUrl);
  }
  if ((0,_javascript_utils_is_type_js__WEBPACK_IMPORTED_MODULE_0__.isBlob)(resource)) {
    const blob = resource;
    return blob.type || '';
  }
  if (typeof resource === 'string') {
    return (0,_mime_type_utils_js__WEBPACK_IMPORTED_MODULE_2__.parseMIMETypeFromURL)(resource);
  }
  return '';
}
function getResourceContentLength(resource) {
  if ((0,_javascript_utils_is_type_js__WEBPACK_IMPORTED_MODULE_0__.isResponse)(resource)) {
    const response = resource;
    return response.headers['content-length'] || -1;
  }
  if ((0,_javascript_utils_is_type_js__WEBPACK_IMPORTED_MODULE_0__.isBlob)(resource)) {
    const blob = resource;
    return blob.size;
  }
  if (typeof resource === 'string') {
    return resource.length;
  }
  if (resource instanceof ArrayBuffer) {
    return resource.byteLength;
  }
  if (ArrayBuffer.isView(resource)) {
    return resource.byteLength;
  }
  return -1;
}
//# sourceMappingURL=resource-utils.js.map

/***/ }),

/***/ "../../node_modules/@loaders.gl/core/dist/lib/utils/response-utils.js":
/*!****************************************************************************!*\
  !*** ../../node_modules/@loaders.gl/core/dist/lib/utils/response-utils.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   checkResponse: () => (/* binding */ checkResponse),
/* harmony export */   checkResponseSync: () => (/* binding */ checkResponseSync),
/* harmony export */   makeResponse: () => (/* binding */ makeResponse)
/* harmony export */ });
/* harmony import */ var _javascript_utils_is_type_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../javascript-utils/is-type.js */ "../../node_modules/@loaders.gl/core/dist/javascript-utils/is-type.js");
/* harmony import */ var _resource_utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./resource-utils.js */ "../../node_modules/@loaders.gl/core/dist/lib/utils/resource-utils.js");


async function makeResponse(resource) {
  if ((0,_javascript_utils_is_type_js__WEBPACK_IMPORTED_MODULE_0__.isResponse)(resource)) {
    return resource;
  }
  const headers = {};
  const contentLength = (0,_resource_utils_js__WEBPACK_IMPORTED_MODULE_1__.getResourceContentLength)(resource);
  if (contentLength >= 0) {
    headers['content-length'] = String(contentLength);
  }
  const url = (0,_resource_utils_js__WEBPACK_IMPORTED_MODULE_1__.getResourceUrl)(resource);
  const type = (0,_resource_utils_js__WEBPACK_IMPORTED_MODULE_1__.getResourceMIMEType)(resource);
  if (type) {
    headers['content-type'] = type;
  }
  const initialDataUrl = await getInitialDataUrl(resource);
  if (initialDataUrl) {
    headers['x-first-bytes'] = initialDataUrl;
  }
  if (typeof resource === 'string') {
    resource = new TextEncoder().encode(resource);
  }
  const response = new Response(resource, {
    headers
  });
  Object.defineProperty(response, 'url', {
    value: url
  });
  return response;
}
async function checkResponse(response) {
  if (!response.ok) {
    const message = await getResponseError(response);
    throw new Error(message);
  }
}
function checkResponseSync(response) {
  if (!response.ok) {
    let message = `${response.status} ${response.statusText}`;
    message = message.length > 60 ? `${message.slice(0, 60)}...` : message;
    throw new Error(message);
  }
}
async function getResponseError(response) {
  let message = `Failed to fetch resource ${response.url} (${response.status}): `;
  try {
    const contentType = response.headers.get('Content-Type');
    let text = response.statusText;
    if (contentType !== null && contentType !== void 0 && contentType.includes('application/json')) {
      text += ` ${await response.text()}`;
    }
    message += text;
    message = message.length > 60 ? `${message.slice(0, 60)}...` : message;
  } catch (error) {}
  return message;
}
async function getInitialDataUrl(resource) {
  const INITIAL_DATA_LENGTH = 5;
  if (typeof resource === 'string') {
    return `data:,${resource.slice(0, INITIAL_DATA_LENGTH)}`;
  }
  if (resource instanceof Blob) {
    const blobSlice = resource.slice(0, 5);
    return await new Promise(resolve => {
      const reader = new FileReader();
      reader.onload = event => {
        var _event$target;
        return resolve(event === null || event === void 0 ? void 0 : (_event$target = event.target) === null || _event$target === void 0 ? void 0 : _event$target.result);
      };
      reader.readAsDataURL(blobSlice);
    });
  }
  if (resource instanceof ArrayBuffer) {
    const slice = resource.slice(0, INITIAL_DATA_LENGTH);
    const base64 = arrayBufferToBase64(slice);
    return `data:base64,${base64}`;
  }
  return null;
}
function arrayBufferToBase64(buffer) {
  let binary = '';
  const bytes = new Uint8Array(buffer);
  for (let i = 0; i < bytes.byteLength; i++) {
    binary += String.fromCharCode(bytes[i]);
  }
  return btoa(binary);
}
//# sourceMappingURL=response-utils.js.map

/***/ }),

/***/ "../../node_modules/@loaders.gl/core/dist/lib/utils/url-utils.js":
/*!***********************************************************************!*\
  !*** ../../node_modules/@loaders.gl/core/dist/lib/utils/url-utils.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   extractQueryString: () => (/* binding */ extractQueryString),
/* harmony export */   stripQueryString: () => (/* binding */ stripQueryString)
/* harmony export */ });
const QUERY_STRING_PATTERN = /\?.*/;
function extractQueryString(url) {
  const matches = url.match(QUERY_STRING_PATTERN);
  return matches && matches[0];
}
function stripQueryString(url) {
  return url.replace(QUERY_STRING_PATTERN, '');
}
//# sourceMappingURL=url-utils.js.map

/***/ }),

/***/ "../../node_modules/@loaders.gl/gltf/dist/glb-loader.js":
/*!**************************************************************!*\
  !*** ../../node_modules/@loaders.gl/gltf/dist/glb-loader.js ***!
  \**************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   GLBLoader: () => (/* binding */ GLBLoader)
/* harmony export */ });
/* harmony import */ var _lib_utils_version_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./lib/utils/version.js */ "../../node_modules/@loaders.gl/gltf/dist/lib/utils/version.js");
/* harmony import */ var _lib_parsers_parse_glb_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./lib/parsers/parse-glb.js */ "../../node_modules/@loaders.gl/gltf/dist/lib/parsers/parse-glb.js");


const GLBLoader = {
  name: 'GLB',
  id: 'glb',
  module: 'gltf',
  version: _lib_utils_version_js__WEBPACK_IMPORTED_MODULE_0__.VERSION,
  extensions: ['glb'],
  mimeTypes: ['model/gltf-binary'],
  binary: true,
  parse,
  parseSync,
  options: {
    glb: {
      strict: false
    }
  }
};
async function parse(arrayBuffer, options) {
  return parseSync(arrayBuffer, options);
}
function parseSync(arrayBuffer, options) {
  const {
    byteOffset = 0
  } = options || {};
  const glb = {};
  (0,_lib_parsers_parse_glb_js__WEBPACK_IMPORTED_MODULE_1__.parseGLBSync)(glb, arrayBuffer, byteOffset, options === null || options === void 0 ? void 0 : options.glb);
  return glb;
}
//# sourceMappingURL=glb-loader.js.map

/***/ }),

/***/ "../../node_modules/@loaders.gl/gltf/dist/lib/parsers/parse-glb.js":
/*!*************************************************************************!*\
  !*** ../../node_modules/@loaders.gl/gltf/dist/lib/parsers/parse-glb.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   isGLB: () => (/* binding */ isGLB),
/* harmony export */   parseGLBSync: () => (/* binding */ parseGLBSync)
/* harmony export */ });
/* harmony import */ var _loaders_gl_loader_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @loaders.gl/loader-utils */ "../../node_modules/@loaders.gl/loader-utils/dist/lib/env-utils/assert.js");
/* harmony import */ var _loaders_gl_loader_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @loaders.gl/loader-utils */ "../../node_modules/@loaders.gl/loader-utils/dist/lib/binary-utils/memory-copy-utils.js");

const LITTLE_ENDIAN = true;
const MAGIC_glTF = 0x676c5446;
const GLB_FILE_HEADER_SIZE = 12;
const GLB_CHUNK_HEADER_SIZE = 8;
const GLB_CHUNK_TYPE_JSON = 0x4e4f534a;
const GLB_CHUNK_TYPE_BIN = 0x004e4942;
const GLB_V1_CONTENT_FORMAT_JSON = 0x0;
const GLB_CHUNK_TYPE_JSON_XVIZ_DEPRECATED = 0;
const GLB_CHUNK_TYPE_BIX_XVIZ_DEPRECATED = 1;
function getMagicString(dataView) {
  let byteOffset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
  return `\
${String.fromCharCode(dataView.getUint8(byteOffset + 0))}\
${String.fromCharCode(dataView.getUint8(byteOffset + 1))}\
${String.fromCharCode(dataView.getUint8(byteOffset + 2))}\
${String.fromCharCode(dataView.getUint8(byteOffset + 3))}`;
}
function isGLB(arrayBuffer) {
  let byteOffset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
  let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  const dataView = new DataView(arrayBuffer);
  const {
    magic = MAGIC_glTF
  } = options;
  const magic1 = dataView.getUint32(byteOffset, false);
  return magic1 === magic || magic1 === MAGIC_glTF;
}
function parseGLBSync(glb, arrayBuffer) {
  let byteOffset = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
  let options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
  const dataView = new DataView(arrayBuffer);
  const type = getMagicString(dataView, byteOffset + 0);
  const version = dataView.getUint32(byteOffset + 4, LITTLE_ENDIAN);
  const byteLength = dataView.getUint32(byteOffset + 8, LITTLE_ENDIAN);
  Object.assign(glb, {
    header: {
      byteOffset,
      byteLength,
      hasBinChunk: false
    },
    type,
    version,
    json: {},
    binChunks: []
  });
  byteOffset += GLB_FILE_HEADER_SIZE;
  switch (glb.version) {
    case 1:
      return parseGLBV1(glb, dataView, byteOffset);
    case 2:
      return parseGLBV2(glb, dataView, byteOffset, options = {});
    default:
      throw new Error(`Invalid GLB version ${glb.version}. Only supports version 1 and 2.`);
  }
}
function parseGLBV1(glb, dataView, byteOffset) {
  (0,_loaders_gl_loader_utils__WEBPACK_IMPORTED_MODULE_0__.assert)(glb.header.byteLength > GLB_FILE_HEADER_SIZE + GLB_CHUNK_HEADER_SIZE);
  const contentLength = dataView.getUint32(byteOffset + 0, LITTLE_ENDIAN);
  const contentFormat = dataView.getUint32(byteOffset + 4, LITTLE_ENDIAN);
  byteOffset += GLB_CHUNK_HEADER_SIZE;
  (0,_loaders_gl_loader_utils__WEBPACK_IMPORTED_MODULE_0__.assert)(contentFormat === GLB_V1_CONTENT_FORMAT_JSON);
  parseJSONChunk(glb, dataView, byteOffset, contentLength);
  byteOffset += contentLength;
  byteOffset += parseBINChunk(glb, dataView, byteOffset, glb.header.byteLength);
  return byteOffset;
}
function parseGLBV2(glb, dataView, byteOffset, options) {
  (0,_loaders_gl_loader_utils__WEBPACK_IMPORTED_MODULE_0__.assert)(glb.header.byteLength > GLB_FILE_HEADER_SIZE + GLB_CHUNK_HEADER_SIZE);
  parseGLBChunksSync(glb, dataView, byteOffset, options);
  return byteOffset + glb.header.byteLength;
}
function parseGLBChunksSync(glb, dataView, byteOffset, options) {
  while (byteOffset + 8 <= glb.header.byteLength) {
    const chunkLength = dataView.getUint32(byteOffset + 0, LITTLE_ENDIAN);
    const chunkFormat = dataView.getUint32(byteOffset + 4, LITTLE_ENDIAN);
    byteOffset += GLB_CHUNK_HEADER_SIZE;
    switch (chunkFormat) {
      case GLB_CHUNK_TYPE_JSON:
        parseJSONChunk(glb, dataView, byteOffset, chunkLength);
        break;
      case GLB_CHUNK_TYPE_BIN:
        parseBINChunk(glb, dataView, byteOffset, chunkLength);
        break;
      case GLB_CHUNK_TYPE_JSON_XVIZ_DEPRECATED:
        if (!options.strict) {
          parseJSONChunk(glb, dataView, byteOffset, chunkLength);
        }
        break;
      case GLB_CHUNK_TYPE_BIX_XVIZ_DEPRECATED:
        if (!options.strict) {
          parseBINChunk(glb, dataView, byteOffset, chunkLength);
        }
        break;
      default:
        break;
    }
    byteOffset += (0,_loaders_gl_loader_utils__WEBPACK_IMPORTED_MODULE_1__.padToNBytes)(chunkLength, 4);
  }
  return byteOffset;
}
function parseJSONChunk(glb, dataView, byteOffset, chunkLength) {
  const jsonChunk = new Uint8Array(dataView.buffer, byteOffset, chunkLength);
  const textDecoder = new TextDecoder('utf8');
  const jsonText = textDecoder.decode(jsonChunk);
  glb.json = JSON.parse(jsonText);
  return (0,_loaders_gl_loader_utils__WEBPACK_IMPORTED_MODULE_1__.padToNBytes)(chunkLength, 4);
}
function parseBINChunk(glb, dataView, byteOffset, chunkLength) {
  glb.header.hasBinChunk = true;
  glb.binChunks.push({
    byteOffset,
    byteLength: chunkLength,
    arrayBuffer: dataView.buffer
  });
  return (0,_loaders_gl_loader_utils__WEBPACK_IMPORTED_MODULE_1__.padToNBytes)(chunkLength, 4);
}
//# sourceMappingURL=parse-glb.js.map

/***/ }),

/***/ "../../node_modules/@loaders.gl/gltf/dist/lib/utils/version.js":
/*!*********************************************************************!*\
  !*** ../../node_modules/@loaders.gl/gltf/dist/lib/utils/version.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   VERSION: () => (/* binding */ VERSION)
/* harmony export */ });
const VERSION =  true ? "4.1.3" : 0;
//# sourceMappingURL=version.js.map

/***/ }),

/***/ "../../node_modules/@loaders.gl/loader-utils/dist/lib/binary-utils/array-buffer-utils.js":
/*!***********************************************************************************************!*\
  !*** ../../node_modules/@loaders.gl/loader-utils/dist/lib/binary-utils/array-buffer-utils.js ***!
  \***********************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   compareArrayBuffers: () => (/* binding */ compareArrayBuffers),
/* harmony export */   concatenateArrayBuffers: () => (/* binding */ concatenateArrayBuffers),
/* harmony export */   concatenateArrayBuffersFromArray: () => (/* binding */ concatenateArrayBuffersFromArray),
/* harmony export */   concatenateTypedArrays: () => (/* binding */ concatenateTypedArrays),
/* harmony export */   sliceArrayBuffer: () => (/* binding */ sliceArrayBuffer)
/* harmony export */ });
function compareArrayBuffers(arrayBuffer1, arrayBuffer2, byteLength) {
  byteLength = byteLength || arrayBuffer1.byteLength;
  if (arrayBuffer1.byteLength < byteLength || arrayBuffer2.byteLength < byteLength) {
    return false;
  }
  const array1 = new Uint8Array(arrayBuffer1);
  const array2 = new Uint8Array(arrayBuffer2);
  for (let i = 0; i < array1.length; ++i) {
    if (array1[i] !== array2[i]) {
      return false;
    }
  }
  return true;
}
function concatenateArrayBuffers() {
  for (var _len = arguments.length, sources = new Array(_len), _key = 0; _key < _len; _key++) {
    sources[_key] = arguments[_key];
  }
  return concatenateArrayBuffersFromArray(sources);
}
function concatenateArrayBuffersFromArray(sources) {
  const sourceArrays = sources.map(source2 => source2 instanceof ArrayBuffer ? new Uint8Array(source2) : source2);
  const byteLength = sourceArrays.reduce((length, typedArray) => length + typedArray.byteLength, 0);
  const result = new Uint8Array(byteLength);
  let offset = 0;
  for (const sourceArray of sourceArrays) {
    result.set(sourceArray, offset);
    offset += sourceArray.byteLength;
  }
  return result.buffer;
}
function concatenateTypedArrays() {
  for (var _len2 = arguments.length, typedArrays = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
    typedArrays[_key2] = arguments[_key2];
  }
  const arrays = typedArrays;
  const TypedArrayConstructor = arrays && arrays.length > 1 && arrays[0].constructor || null;
  if (!TypedArrayConstructor) {
    throw new Error('"concatenateTypedArrays" - incorrect quantity of arguments or arguments have incompatible data types');
  }
  const sumLength = arrays.reduce((acc, value) => acc + value.length, 0);
  const result = new TypedArrayConstructor(sumLength);
  let offset = 0;
  for (const array of arrays) {
    result.set(array, offset);
    offset += array.length;
  }
  return result;
}
function sliceArrayBuffer(arrayBuffer, byteOffset, byteLength) {
  const subArray = byteLength !== undefined ? new Uint8Array(arrayBuffer).subarray(byteOffset, byteOffset + byteLength) : new Uint8Array(arrayBuffer).subarray(byteOffset);
  const arrayCopy = new Uint8Array(subArray);
  return arrayCopy.buffer;
}
//# sourceMappingURL=array-buffer-utils.js.map

/***/ }),

/***/ "../../node_modules/@loaders.gl/loader-utils/dist/lib/binary-utils/memory-conversion-utils.js":
/*!****************************************************************************************************!*\
  !*** ../../node_modules/@loaders.gl/loader-utils/dist/lib/binary-utils/memory-conversion-utils.js ***!
  \****************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   isBuffer: () => (/* binding */ isBuffer),
/* harmony export */   toArrayBuffer: () => (/* binding */ toArrayBuffer),
/* harmony export */   toBuffer: () => (/* binding */ toBuffer)
/* harmony export */ });
/* harmony import */ var _node_buffer_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../node/buffer.js */ "../../node_modules/@loaders.gl/loader-utils/dist/lib/node/buffer.browser.js");

function isBuffer(value) {
  return value && typeof value === 'object' && value.isBuffer;
}
function toBuffer(data) {
  return _node_buffer_js__WEBPACK_IMPORTED_MODULE_0__.toBuffer ? _node_buffer_js__WEBPACK_IMPORTED_MODULE_0__.toBuffer(data) : data;
}
function toArrayBuffer(data) {
  if (isBuffer(data)) {
    return _node_buffer_js__WEBPACK_IMPORTED_MODULE_0__.toArrayBuffer(data);
  }
  if (data instanceof ArrayBuffer) {
    return data;
  }
  if (ArrayBuffer.isView(data)) {
    if (data.byteOffset === 0 && data.byteLength === data.buffer.byteLength) {
      return data.buffer;
    }
    return data.buffer.slice(data.byteOffset, data.byteOffset + data.byteLength);
  }
  if (typeof data === 'string') {
    const text = data;
    const uint8Array = new TextEncoder().encode(text);
    return uint8Array.buffer;
  }
  if (data && typeof data === 'object' && data._toArrayBuffer) {
    return data._toArrayBuffer();
  }
  throw new Error('toArrayBuffer');
}
//# sourceMappingURL=memory-conversion-utils.js.map

/***/ }),

/***/ "../../node_modules/@loaders.gl/loader-utils/dist/lib/binary-utils/memory-copy-utils.js":
/*!**********************************************************************************************!*\
  !*** ../../node_modules/@loaders.gl/loader-utils/dist/lib/binary-utils/memory-copy-utils.js ***!
  \**********************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   copyArrayBuffer: () => (/* binding */ copyArrayBuffer),
/* harmony export */   copyToArray: () => (/* binding */ copyToArray),
/* harmony export */   padToNBytes: () => (/* binding */ padToNBytes)
/* harmony export */ });
/* harmony import */ var _env_utils_assert_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../env-utils/assert.js */ "../../node_modules/@loaders.gl/loader-utils/dist/lib/env-utils/assert.js");

function padToNBytes(byteLength, padding) {
  (0,_env_utils_assert_js__WEBPACK_IMPORTED_MODULE_0__.assert)(byteLength >= 0);
  (0,_env_utils_assert_js__WEBPACK_IMPORTED_MODULE_0__.assert)(padding > 0);
  return byteLength + (padding - 1) & ~(padding - 1);
}
function copyArrayBuffer(targetBuffer, sourceBuffer, byteOffset) {
  let byteLength = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : sourceBuffer.byteLength;
  const targetArray = new Uint8Array(targetBuffer, byteOffset, byteLength);
  const sourceArray = new Uint8Array(sourceBuffer);
  targetArray.set(sourceArray);
  return targetBuffer;
}
function copyToArray(source, target, targetOffset) {
  let sourceArray;
  if (source instanceof ArrayBuffer) {
    sourceArray = new Uint8Array(source);
  } else {
    const srcByteOffset = source.byteOffset;
    const srcByteLength = source.byteLength;
    sourceArray = new Uint8Array(source.buffer || source.arrayBuffer, srcByteOffset, srcByteLength);
  }
  target.set(sourceArray, targetOffset);
  return targetOffset + padToNBytes(sourceArray.byteLength, 4);
}
//# sourceMappingURL=memory-copy-utils.js.map

/***/ }),

/***/ "../../node_modules/@loaders.gl/loader-utils/dist/lib/env-utils/assert.js":
/*!********************************************************************************!*\
  !*** ../../node_modules/@loaders.gl/loader-utils/dist/lib/env-utils/assert.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   assert: () => (/* binding */ assert)
/* harmony export */ });
function assert(condition, message) {
  if (!condition) {
    throw new Error(message || 'loader assertion failed.');
  }
}
//# sourceMappingURL=assert.js.map

/***/ }),

/***/ "../../node_modules/@loaders.gl/loader-utils/dist/lib/env-utils/globals.js":
/*!*********************************************************************************!*\
  !*** ../../node_modules/@loaders.gl/loader-utils/dist/lib/env-utils/globals.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   document: () => (/* binding */ document_),
/* harmony export */   global: () => (/* binding */ global_),
/* harmony export */   isBrowser: () => (/* binding */ isBrowser),
/* harmony export */   isWorker: () => (/* binding */ isWorker),
/* harmony export */   nodeVersion: () => (/* binding */ nodeVersion),
/* harmony export */   self: () => (/* binding */ self_),
/* harmony export */   window: () => (/* binding */ window_)
/* harmony export */ });
const globals = {
  self: typeof self !== 'undefined' && self,
  window: typeof window !== 'undefined' && window,
  global: typeof global !== 'undefined' && global,
  document: typeof document !== 'undefined' && document
};
const self_ = globals.self || globals.window || globals.global || {};
const window_ = globals.window || globals.self || globals.global || {};
const global_ = globals.global || globals.self || globals.window || {};
const document_ = globals.document || {};

const isBrowser = Boolean(typeof process !== 'object' || String(process) !== '[object process]' || process.browser);
const isWorker = typeof importScripts === 'function';
const matches = typeof process !== 'undefined' && process.version && /v([0-9]*)/.exec(process.version);
const nodeVersion = matches && parseFloat(matches[1]) || 0;
//# sourceMappingURL=globals.js.map

/***/ }),

/***/ "../../node_modules/@loaders.gl/loader-utils/dist/lib/iterators/async-iteration.js":
/*!*****************************************************************************************!*\
  !*** ../../node_modules/@loaders.gl/loader-utils/dist/lib/iterators/async-iteration.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   concatenateArrayBuffersAsync: () => (/* binding */ concatenateArrayBuffersAsync),
/* harmony export */   concatenateStringsAsync: () => (/* binding */ concatenateStringsAsync),
/* harmony export */   forEach: () => (/* binding */ forEach)
/* harmony export */ });
/* harmony import */ var _binary_utils_array_buffer_utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../binary-utils/array-buffer-utils.js */ "../../node_modules/@loaders.gl/loader-utils/dist/lib/binary-utils/array-buffer-utils.js");

async function forEach(iterator, visitor) {
  while (true) {
    const {
      done,
      value
    } = await iterator.next();
    if (done) {
      iterator.return();
      return;
    }
    const cancel = visitor(value);
    if (cancel) {
      return;
    }
  }
}
async function concatenateArrayBuffersAsync(asyncIterator) {
  const arrayBuffers = [];
  for await (const chunk of asyncIterator) {
    arrayBuffers.push(chunk);
  }
  return (0,_binary_utils_array_buffer_utils_js__WEBPACK_IMPORTED_MODULE_0__.concatenateArrayBuffers)(...arrayBuffers);
}
async function concatenateStringsAsync(asyncIterator) {
  const strings = [];
  for await (const chunk of asyncIterator) {
    strings.push(chunk);
  }
  return strings.join('');
}
//# sourceMappingURL=async-iteration.js.map

/***/ }),

/***/ "../../node_modules/@loaders.gl/loader-utils/dist/lib/node/buffer.browser.js":
/*!***********************************************************************************!*\
  !*** ../../node_modules/@loaders.gl/loader-utils/dist/lib/node/buffer.browser.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   toArrayBuffer: () => (/* binding */ toArrayBuffer),
/* harmony export */   toBuffer: () => (/* binding */ toBuffer)
/* harmony export */ });
function toArrayBuffer(buffer) {
  return buffer;
}
function toBuffer(binaryData) {
  throw new Error('Buffer not supported in browser');
}
//# sourceMappingURL=buffer.browser.js.map

/***/ }),

/***/ "../../node_modules/@loaders.gl/loader-utils/dist/lib/option-utils/merge-loader-options.js":
/*!*************************************************************************************************!*\
  !*** ../../node_modules/@loaders.gl/loader-utils/dist/lib/option-utils/merge-loader-options.js ***!
  \*************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   mergeLoaderOptions: () => (/* binding */ mergeLoaderOptions)
/* harmony export */ });
function mergeLoaderOptions(baseOptions, newOptions) {
  return mergeOptionsRecursively(baseOptions || {}, newOptions);
}
function mergeOptionsRecursively(baseOptions, newOptions) {
  let level = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
  if (level > 3) {
    return newOptions;
  }
  const options = {
    ...baseOptions
  };
  for (const [key, newValue] of Object.entries(newOptions)) {
    if (newValue && typeof newValue === 'object' && !Array.isArray(newValue)) {
      options[key] = mergeOptionsRecursively(options[key] || {}, newOptions[key], level + 1);
    } else {
      options[key] = newOptions[key];
    }
  }
  return options;
}
//# sourceMappingURL=merge-loader-options.js.map

/***/ }),

/***/ "../../node_modules/@loaders.gl/loader-utils/dist/lib/path-utils/file-aliases.js":
/*!***************************************************************************************!*\
  !*** ../../node_modules/@loaders.gl/loader-utils/dist/lib/path-utils/file-aliases.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   addAliases: () => (/* binding */ addAliases),
/* harmony export */   getPathPrefix: () => (/* binding */ getPathPrefix),
/* harmony export */   resolvePath: () => (/* binding */ resolvePath),
/* harmony export */   setPathPrefix: () => (/* binding */ setPathPrefix)
/* harmony export */ });
let pathPrefix = '';
const fileAliases = {};
function setPathPrefix(prefix) {
  pathPrefix = prefix;
}
function getPathPrefix() {
  return pathPrefix;
}
function addAliases(aliases) {
  Object.assign(fileAliases, aliases);
}
function resolvePath(filename) {
  for (const alias in fileAliases) {
    if (filename.startsWith(alias)) {
      const replacement = fileAliases[alias];
      filename = filename.replace(alias, replacement);
    }
  }
  if (!filename.startsWith('http://') && !filename.startsWith('https://')) {
    filename = `${pathPrefix}${filename}`;
  }
  return filename;
}
//# sourceMappingURL=file-aliases.js.map

/***/ }),

/***/ "../../node_modules/@loaders.gl/loader-utils/dist/lib/path-utils/get-cwd.js":
/*!**********************************************************************************!*\
  !*** ../../node_modules/@loaders.gl/loader-utils/dist/lib/path-utils/get-cwd.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   getCWD: () => (/* binding */ getCWD)
/* harmony export */ });
function getCWD() {
  var _window$location;
  if (typeof process !== 'undefined' && typeof process.cwd !== 'undefined') {
    return process.cwd();
  }
  const pathname = (_window$location = window.location) === null || _window$location === void 0 ? void 0 : _window$location.pathname;
  return (pathname === null || pathname === void 0 ? void 0 : pathname.slice(0, pathname.lastIndexOf('/') + 1)) || '';
}
//# sourceMappingURL=get-cwd.js.map

/***/ }),

/***/ "../../node_modules/@loaders.gl/loader-utils/dist/lib/path-utils/path.js":
/*!*******************************************************************************!*\
  !*** ../../node_modules/@loaders.gl/loader-utils/dist/lib/path-utils/path.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   dirname: () => (/* binding */ dirname),
/* harmony export */   filename: () => (/* binding */ filename),
/* harmony export */   join: () => (/* binding */ join),
/* harmony export */   resolve: () => (/* binding */ resolve)
/* harmony export */ });
/* harmony import */ var _get_cwd_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./get-cwd.js */ "../../node_modules/@loaders.gl/loader-utils/dist/lib/path-utils/get-cwd.js");

function filename(url) {
  const slashIndex = url ? url.lastIndexOf('/') : -1;
  return slashIndex >= 0 ? url.substr(slashIndex + 1) : '';
}
function dirname(url) {
  const slashIndex = url ? url.lastIndexOf('/') : -1;
  return slashIndex >= 0 ? url.substr(0, slashIndex) : '';
}
function join() {
  for (var _len = arguments.length, parts = new Array(_len), _key = 0; _key < _len; _key++) {
    parts[_key] = arguments[_key];
  }
  const separator = '/';
  parts = parts.map((part, index) => {
    if (index) {
      part = part.replace(new RegExp(`^${separator}`), '');
    }
    if (index !== parts.length - 1) {
      part = part.replace(new RegExp(`${separator}$`), '');
    }
    return part;
  });
  return parts.join(separator);
}
function resolve() {
  const paths = [];
  for (let _i = 0; _i < arguments.length; _i++) {
    paths[_i] = _i < 0 || arguments.length <= _i ? undefined : arguments[_i];
  }
  let resolvedPath = '';
  let resolvedAbsolute = false;
  let cwd;
  for (let i = paths.length - 1; i >= -1 && !resolvedAbsolute; i--) {
    let path;
    if (i >= 0) {
      path = paths[i];
    } else {
      if (cwd === undefined) {
        cwd = (0,_get_cwd_js__WEBPACK_IMPORTED_MODULE_0__.getCWD)();
      }
      path = cwd;
    }
    if (path.length === 0) {
      continue;
    }
    resolvedPath = `${path}/${resolvedPath}`;
    resolvedAbsolute = path.charCodeAt(0) === SLASH;
  }
  resolvedPath = normalizeStringPosix(resolvedPath, !resolvedAbsolute);
  if (resolvedAbsolute) {
    return `/${resolvedPath}`;
  } else if (resolvedPath.length > 0) {
    return resolvedPath;
  }
  return '.';
}
const SLASH = 47;
const DOT = 46;
function normalizeStringPosix(path, allowAboveRoot) {
  let res = '';
  let lastSlash = -1;
  let dots = 0;
  let code;
  let isAboveRoot = false;
  for (let i = 0; i <= path.length; ++i) {
    if (i < path.length) {
      code = path.charCodeAt(i);
    } else if (code === SLASH) {
      break;
    } else {
      code = SLASH;
    }
    if (code === SLASH) {
      if (lastSlash === i - 1 || dots === 1) {} else if (lastSlash !== i - 1 && dots === 2) {
        if (res.length < 2 || !isAboveRoot || res.charCodeAt(res.length - 1) !== DOT || res.charCodeAt(res.length - 2) !== DOT) {
          if (res.length > 2) {
            const start = res.length - 1;
            let j = start;
            for (; j >= 0; --j) {
              if (res.charCodeAt(j) === SLASH) {
                break;
              }
            }
            if (j !== start) {
              res = j === -1 ? '' : res.slice(0, j);
              lastSlash = i;
              dots = 0;
              isAboveRoot = false;
              continue;
            }
          } else if (res.length === 2 || res.length === 1) {
            res = '';
            lastSlash = i;
            dots = 0;
            isAboveRoot = false;
            continue;
          }
        }
        if (allowAboveRoot) {
          if (res.length > 0) {
            res += '/..';
          } else {
            res = '..';
          }
          isAboveRoot = true;
        }
      } else {
        const slice = path.slice(lastSlash + 1, i);
        if (res.length > 0) {
          res += `/${slice}`;
        } else {
          res = slice;
        }
        isAboveRoot = false;
      }
      lastSlash = i;
      dots = 0;
    } else if (code === DOT && dots !== -1) {
      ++dots;
    } else {
      dots = -1;
    }
  }
  return res;
}
//# sourceMappingURL=path.js.map

/***/ }),

/***/ "../../node_modules/@loaders.gl/loader-utils/dist/lib/worker-loader-utils/parse-with-worker.js":
/*!*****************************************************************************************************!*\
  !*** ../../node_modules/@loaders.gl/loader-utils/dist/lib/worker-loader-utils/parse-with-worker.js ***!
  \*****************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   canParseWithWorker: () => (/* binding */ canParseWithWorker),
/* harmony export */   parseWithWorker: () => (/* binding */ parseWithWorker)
/* harmony export */ });
/* harmony import */ var _loaders_gl_worker_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @loaders.gl/worker-utils */ "../../node_modules/@loaders.gl/worker-utils/dist/lib/env-utils/globals.js");
/* harmony import */ var _loaders_gl_worker_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @loaders.gl/worker-utils */ "../../node_modules/@loaders.gl/worker-utils/dist/lib/worker-farm/worker-farm.js");
/* harmony import */ var _loaders_gl_worker_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @loaders.gl/worker-utils */ "../../node_modules/@loaders.gl/worker-utils/dist/lib/worker-api/get-worker-url.js");


function canParseWithWorker(loader, options) {
  if (!_loaders_gl_worker_utils__WEBPACK_IMPORTED_MODULE_0__["default"].isSupported()) {
    return false;
  }
  if (!_loaders_gl_worker_utils__WEBPACK_IMPORTED_MODULE_1__.isBrowser && !(options !== null && options !== void 0 && options._nodeWorkers)) {
    return false;
  }
  return loader.worker && (options === null || options === void 0 ? void 0 : options.worker);
}
async function parseWithWorker(loader, data, options, context, parseOnMainThread) {
  const name = loader.id;
  const url = (0,_loaders_gl_worker_utils__WEBPACK_IMPORTED_MODULE_2__.getWorkerURL)(loader, options);
  const workerFarm = _loaders_gl_worker_utils__WEBPACK_IMPORTED_MODULE_0__["default"].getWorkerFarm(options);
  const workerPool = workerFarm.getWorkerPool({
    name,
    url
  });
  options = JSON.parse(JSON.stringify(options));
  context = JSON.parse(JSON.stringify(context || {}));
  const job = await workerPool.startJob('process-on-worker', onMessage.bind(null, parseOnMainThread));
  job.postMessage('process', {
    input: data,
    options,
    context
  });
  const result = await job.result;
  return await result.result;
}
async function onMessage(parseOnMainThread, job, type, payload) {
  switch (type) {
    case 'done':
      job.done(payload);
      break;
    case 'error':
      job.error(new Error(payload.error));
      break;
    case 'process':
      const {
        id,
        input,
        options
      } = payload;
      try {
        const result = await parseOnMainThread(input, options);
        job.postMessage('done', {
          id,
          result
        });
      } catch (error) {
        const message = error instanceof Error ? error.message : 'unknown error';
        job.postMessage('error', {
          id,
          error: message
        });
      }
      break;
    default:
      console.warn(`parse-with-worker unknown message ${type}`);
  }
}
//# sourceMappingURL=parse-with-worker.js.map

/***/ }),

/***/ "../../node_modules/@loaders.gl/worker-utils/dist/lib/env-utils/assert.js":
/*!********************************************************************************!*\
  !*** ../../node_modules/@loaders.gl/worker-utils/dist/lib/env-utils/assert.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   assert: () => (/* binding */ assert)
/* harmony export */ });
function assert(condition, message) {
  if (!condition) {
    throw new Error(message || 'loaders.gl assertion failed.');
  }
}
//# sourceMappingURL=assert.js.map

/***/ }),

/***/ "../../node_modules/@loaders.gl/worker-utils/dist/lib/env-utils/globals.js":
/*!*********************************************************************************!*\
  !*** ../../node_modules/@loaders.gl/worker-utils/dist/lib/env-utils/globals.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   document: () => (/* binding */ document_),
/* harmony export */   global: () => (/* binding */ global_),
/* harmony export */   isBrowser: () => (/* binding */ isBrowser),
/* harmony export */   isMobile: () => (/* binding */ isMobile),
/* harmony export */   isWorker: () => (/* binding */ isWorker),
/* harmony export */   nodeVersion: () => (/* binding */ nodeVersion),
/* harmony export */   self: () => (/* binding */ self_),
/* harmony export */   window: () => (/* binding */ window_)
/* harmony export */ });
const globals = {
  self: typeof self !== 'undefined' && self,
  window: typeof window !== 'undefined' && window,
  global: typeof global !== 'undefined' && global,
  document: typeof document !== 'undefined' && document
};
const self_ = globals.self || globals.window || globals.global || {};
const window_ = globals.window || globals.self || globals.global || {};
const global_ = globals.global || globals.self || globals.window || {};
const document_ = globals.document || {};

const isBrowser = typeof process !== 'object' || String(process) !== '[object process]' || process.browser;
const isWorker = typeof importScripts === 'function';
const isMobile = typeof window !== 'undefined' && typeof window.orientation !== 'undefined';
const matches = typeof process !== 'undefined' && process.version && /v([0-9]*)/.exec(process.version);
const nodeVersion = matches && parseFloat(matches[1]) || 0;
//# sourceMappingURL=globals.js.map

/***/ }),

/***/ "../../node_modules/@loaders.gl/worker-utils/dist/lib/env-utils/version.js":
/*!*********************************************************************************!*\
  !*** ../../node_modules/@loaders.gl/worker-utils/dist/lib/env-utils/version.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   NPM_TAG: () => (/* binding */ NPM_TAG),
/* harmony export */   VERSION: () => (/* binding */ VERSION)
/* harmony export */ });
const NPM_TAG = 'latest';
function getVersion() {
  var _globalThis$_loadersg;
  if (!((_globalThis$_loadersg = globalThis._loadersgl_) !== null && _globalThis$_loadersg !== void 0 && _globalThis$_loadersg.version)) {
    globalThis._loadersgl_ = globalThis._loadersgl_ || {};
    if (false) {} else {
      globalThis._loadersgl_.version = "4.1.3";
    }
  }
  return globalThis._loadersgl_.version;
}
const VERSION = getVersion();
//# sourceMappingURL=version.js.map

/***/ }),

/***/ "../../node_modules/@loaders.gl/worker-utils/dist/lib/node/worker_threads-browser.js":
/*!*******************************************************************************************!*\
  !*** ../../node_modules/@loaders.gl/worker-utils/dist/lib/node/worker_threads-browser.js ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   NodeWorker: () => (/* binding */ NodeWorker),
/* harmony export */   parentPort: () => (/* binding */ parentPort)
/* harmony export */ });
class NodeWorker {
  terminate() {}
}
const parentPort = null;
//# sourceMappingURL=worker_threads-browser.js.map

/***/ }),

/***/ "../../node_modules/@loaders.gl/worker-utils/dist/lib/worker-api/get-worker-url.js":
/*!*****************************************************************************************!*\
  !*** ../../node_modules/@loaders.gl/worker-utils/dist/lib/worker-api/get-worker-url.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   getWorkerName: () => (/* binding */ getWorkerName),
/* harmony export */   getWorkerURL: () => (/* binding */ getWorkerURL)
/* harmony export */ });
/* harmony import */ var _env_utils_assert_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../env-utils/assert.js */ "../../node_modules/@loaders.gl/worker-utils/dist/lib/env-utils/assert.js");
/* harmony import */ var _env_utils_globals_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../env-utils/globals.js */ "../../node_modules/@loaders.gl/worker-utils/dist/lib/env-utils/globals.js");
/* harmony import */ var _env_utils_version_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../env-utils/version.js */ "../../node_modules/@loaders.gl/worker-utils/dist/lib/env-utils/version.js");



function getWorkerName(worker) {
  const warning = worker.version !== _env_utils_version_js__WEBPACK_IMPORTED_MODULE_0__.VERSION ? ` (worker-utils@${_env_utils_version_js__WEBPACK_IMPORTED_MODULE_0__.VERSION})` : '';
  return `${worker.name}@${worker.version}${warning}`;
}
function getWorkerURL(worker) {
  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  const workerOptions = options[worker.id] || {};
  const workerFile = _env_utils_globals_js__WEBPACK_IMPORTED_MODULE_1__.isBrowser ? `${worker.id}-worker.js` : `${worker.id}-worker-node.js`;
  let url = workerOptions.workerUrl;
  if (!url && worker.id === 'compression') {
    url = options.workerUrl;
  }
  if (options._workerType === 'test') {
    if (_env_utils_globals_js__WEBPACK_IMPORTED_MODULE_1__.isBrowser) {
      url = `modules/${worker.module}/dist/${workerFile}`;
    } else {
      url = `modules/${worker.module}/src/workers/${worker.id}-worker-node.ts`;
    }
  }
  if (!url) {
    let version = worker.version;
    if (version === 'latest') {
      version = _env_utils_version_js__WEBPACK_IMPORTED_MODULE_0__.NPM_TAG;
    }
    const versionTag = version ? `@${version}` : '';
    url = `https://unpkg.com/@loaders.gl/${worker.module}${versionTag}/dist/${workerFile}`;
  }
  (0,_env_utils_assert_js__WEBPACK_IMPORTED_MODULE_2__.assert)(url);
  return url;
}
//# sourceMappingURL=get-worker-url.js.map

/***/ }),

/***/ "../../node_modules/@loaders.gl/worker-utils/dist/lib/worker-api/validate-worker-version.js":
/*!**************************************************************************************************!*\
  !*** ../../node_modules/@loaders.gl/worker-utils/dist/lib/worker-api/validate-worker-version.js ***!
  \**************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   validateWorkerVersion: () => (/* binding */ validateWorkerVersion)
/* harmony export */ });
/* harmony import */ var _env_utils_assert_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../env-utils/assert.js */ "../../node_modules/@loaders.gl/worker-utils/dist/lib/env-utils/assert.js");
/* harmony import */ var _env_utils_version_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../env-utils/version.js */ "../../node_modules/@loaders.gl/worker-utils/dist/lib/env-utils/version.js");


function validateWorkerVersion(worker) {
  let coreVersion = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _env_utils_version_js__WEBPACK_IMPORTED_MODULE_0__.VERSION;
  (0,_env_utils_assert_js__WEBPACK_IMPORTED_MODULE_1__.assert)(worker, 'no worker provided');
  const workerVersion = worker.version;
  if (!coreVersion || !workerVersion) {
    return false;
  }
  return true;
}
function parseVersion(version) {
  const parts = version.split('.').map(Number);
  return {
    major: parts[0],
    minor: parts[1]
  };
}
//# sourceMappingURL=validate-worker-version.js.map

/***/ }),

/***/ "../../node_modules/@loaders.gl/worker-utils/dist/lib/worker-farm/worker-farm.js":
/*!***************************************************************************************!*\
  !*** ../../node_modules/@loaders.gl/worker-utils/dist/lib/worker-farm/worker-farm.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ WorkerFarm)
/* harmony export */ });
/* harmony import */ var _worker_pool_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./worker-pool.js */ "../../node_modules/@loaders.gl/worker-utils/dist/lib/worker-farm/worker-pool.js");
/* harmony import */ var _worker_thread_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./worker-thread.js */ "../../node_modules/@loaders.gl/worker-utils/dist/lib/worker-farm/worker-thread.js");


const DEFAULT_PROPS = {
  maxConcurrency: 3,
  maxMobileConcurrency: 1,
  reuseWorkers: true,
  onDebug: () => {}
};
class WorkerFarm {
  static isSupported() {
    return _worker_thread_js__WEBPACK_IMPORTED_MODULE_0__["default"].isSupported();
  }
  static getWorkerFarm() {
    let props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    WorkerFarm._workerFarm = WorkerFarm._workerFarm || new WorkerFarm({});
    WorkerFarm._workerFarm.setProps(props);
    return WorkerFarm._workerFarm;
  }
  constructor(props) {
    this.props = void 0;
    this.workerPools = new Map();
    this.props = {
      ...DEFAULT_PROPS
    };
    this.setProps(props);
    this.workerPools = new Map();
  }
  destroy() {
    for (const workerPool of this.workerPools.values()) {
      workerPool.destroy();
    }
    this.workerPools = new Map();
  }
  setProps(props) {
    this.props = {
      ...this.props,
      ...props
    };
    for (const workerPool of this.workerPools.values()) {
      workerPool.setProps(this._getWorkerPoolProps());
    }
  }
  getWorkerPool(options) {
    const {
      name,
      source,
      url
    } = options;
    let workerPool = this.workerPools.get(name);
    if (!workerPool) {
      workerPool = new _worker_pool_js__WEBPACK_IMPORTED_MODULE_1__["default"]({
        name,
        source,
        url
      });
      workerPool.setProps(this._getWorkerPoolProps());
      this.workerPools.set(name, workerPool);
    }
    return workerPool;
  }
  _getWorkerPoolProps() {
    return {
      maxConcurrency: this.props.maxConcurrency,
      maxMobileConcurrency: this.props.maxMobileConcurrency,
      reuseWorkers: this.props.reuseWorkers,
      onDebug: this.props.onDebug
    };
  }
}
WorkerFarm._workerFarm = void 0;
//# sourceMappingURL=worker-farm.js.map

/***/ }),

/***/ "../../node_modules/@loaders.gl/worker-utils/dist/lib/worker-farm/worker-job.js":
/*!**************************************************************************************!*\
  !*** ../../node_modules/@loaders.gl/worker-utils/dist/lib/worker-farm/worker-job.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ WorkerJob)
/* harmony export */ });
/* harmony import */ var _env_utils_assert_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../env-utils/assert.js */ "../../node_modules/@loaders.gl/worker-utils/dist/lib/env-utils/assert.js");

class WorkerJob {
  constructor(jobName, workerThread) {
    this.name = void 0;
    this.workerThread = void 0;
    this.isRunning = true;
    this.result = void 0;
    this._resolve = () => {};
    this._reject = () => {};
    this.name = jobName;
    this.workerThread = workerThread;
    this.result = new Promise((resolve, reject) => {
      this._resolve = resolve;
      this._reject = reject;
    });
  }
  postMessage(type, payload) {
    this.workerThread.postMessage({
      source: 'loaders.gl',
      type,
      payload
    });
  }
  done(value) {
    (0,_env_utils_assert_js__WEBPACK_IMPORTED_MODULE_0__.assert)(this.isRunning);
    this.isRunning = false;
    this._resolve(value);
  }
  error(error) {
    (0,_env_utils_assert_js__WEBPACK_IMPORTED_MODULE_0__.assert)(this.isRunning);
    this.isRunning = false;
    this._reject(error);
  }
}
//# sourceMappingURL=worker-job.js.map

/***/ }),

/***/ "../../node_modules/@loaders.gl/worker-utils/dist/lib/worker-farm/worker-pool.js":
/*!***************************************************************************************!*\
  !*** ../../node_modules/@loaders.gl/worker-utils/dist/lib/worker-farm/worker-pool.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ WorkerPool)
/* harmony export */ });
/* harmony import */ var _env_utils_globals_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../env-utils/globals.js */ "../../node_modules/@loaders.gl/worker-utils/dist/lib/env-utils/globals.js");
/* harmony import */ var _worker_thread_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./worker-thread.js */ "../../node_modules/@loaders.gl/worker-utils/dist/lib/worker-farm/worker-thread.js");
/* harmony import */ var _worker_job_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./worker-job.js */ "../../node_modules/@loaders.gl/worker-utils/dist/lib/worker-farm/worker-job.js");



class WorkerPool {
  static isSupported() {
    return _worker_thread_js__WEBPACK_IMPORTED_MODULE_0__["default"].isSupported();
  }
  constructor(props) {
    this.name = 'unnamed';
    this.source = void 0;
    this.url = void 0;
    this.maxConcurrency = 1;
    this.maxMobileConcurrency = 1;
    this.onDebug = () => {};
    this.reuseWorkers = true;
    this.props = {};
    this.jobQueue = [];
    this.idleQueue = [];
    this.count = 0;
    this.isDestroyed = false;
    this.source = props.source;
    this.url = props.url;
    this.setProps(props);
  }
  destroy() {
    this.idleQueue.forEach(worker => worker.destroy());
    this.isDestroyed = true;
  }
  setProps(props) {
    this.props = {
      ...this.props,
      ...props
    };
    if (props.name !== undefined) {
      this.name = props.name;
    }
    if (props.maxConcurrency !== undefined) {
      this.maxConcurrency = props.maxConcurrency;
    }
    if (props.maxMobileConcurrency !== undefined) {
      this.maxMobileConcurrency = props.maxMobileConcurrency;
    }
    if (props.reuseWorkers !== undefined) {
      this.reuseWorkers = props.reuseWorkers;
    }
    if (props.onDebug !== undefined) {
      this.onDebug = props.onDebug;
    }
  }
  async startJob(name) {
    let onMessage = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : (job, type, data) => job.done(data);
    let onError = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : (job, error) => job.error(error);
    const startPromise = new Promise(onStart => {
      this.jobQueue.push({
        name,
        onMessage,
        onError,
        onStart
      });
      return this;
    });
    this._startQueuedJob();
    return await startPromise;
  }
  async _startQueuedJob() {
    if (!this.jobQueue.length) {
      return;
    }
    const workerThread = this._getAvailableWorker();
    if (!workerThread) {
      return;
    }
    const queuedJob = this.jobQueue.shift();
    if (queuedJob) {
      this.onDebug({
        message: 'Starting job',
        name: queuedJob.name,
        workerThread,
        backlog: this.jobQueue.length
      });
      const job = new _worker_job_js__WEBPACK_IMPORTED_MODULE_1__["default"](queuedJob.name, workerThread);
      workerThread.onMessage = data => queuedJob.onMessage(job, data.type, data.payload);
      workerThread.onError = error => queuedJob.onError(job, error);
      queuedJob.onStart(job);
      try {
        await job.result;
      } catch (error) {
        console.error(`Worker exception: ${error}`);
      } finally {
        this.returnWorkerToQueue(workerThread);
      }
    }
  }
  returnWorkerToQueue(worker) {
    const shouldDestroyWorker = !_env_utils_globals_js__WEBPACK_IMPORTED_MODULE_2__.isBrowser || this.isDestroyed || !this.reuseWorkers || this.count > this._getMaxConcurrency();
    if (shouldDestroyWorker) {
      worker.destroy();
      this.count--;
    } else {
      this.idleQueue.push(worker);
    }
    if (!this.isDestroyed) {
      this._startQueuedJob();
    }
  }
  _getAvailableWorker() {
    if (this.idleQueue.length > 0) {
      return this.idleQueue.shift() || null;
    }
    if (this.count < this._getMaxConcurrency()) {
      this.count++;
      const name = `${this.name.toLowerCase()} (#${this.count} of ${this.maxConcurrency})`;
      return new _worker_thread_js__WEBPACK_IMPORTED_MODULE_0__["default"]({
        name,
        source: this.source,
        url: this.url
      });
    }
    return null;
  }
  _getMaxConcurrency() {
    return _env_utils_globals_js__WEBPACK_IMPORTED_MODULE_2__.isMobile ? this.maxMobileConcurrency : this.maxConcurrency;
  }
}
//# sourceMappingURL=worker-pool.js.map

/***/ }),

/***/ "../../node_modules/@loaders.gl/worker-utils/dist/lib/worker-farm/worker-thread.js":
/*!*****************************************************************************************!*\
  !*** ../../node_modules/@loaders.gl/worker-utils/dist/lib/worker-farm/worker-thread.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ WorkerThread)
/* harmony export */ });
/* harmony import */ var _node_worker_threads_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../node/worker_threads.js */ "../../node_modules/@loaders.gl/worker-utils/dist/lib/node/worker_threads-browser.js");
/* harmony import */ var _env_utils_globals_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../env-utils/globals.js */ "../../node_modules/@loaders.gl/worker-utils/dist/lib/env-utils/globals.js");
/* harmony import */ var _env_utils_assert_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../env-utils/assert.js */ "../../node_modules/@loaders.gl/worker-utils/dist/lib/env-utils/assert.js");
/* harmony import */ var _worker_utils_get_loadable_worker_url_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../worker-utils/get-loadable-worker-url.js */ "../../node_modules/@loaders.gl/worker-utils/dist/lib/worker-utils/get-loadable-worker-url.js");
/* harmony import */ var _worker_utils_get_transfer_list_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../worker-utils/get-transfer-list.js */ "../../node_modules/@loaders.gl/worker-utils/dist/lib/worker-utils/get-transfer-list.js");





const NOOP = () => {};
class WorkerThread {
  static isSupported() {
    return typeof Worker !== 'undefined' && _env_utils_globals_js__WEBPACK_IMPORTED_MODULE_0__.isBrowser || typeof _node_worker_threads_js__WEBPACK_IMPORTED_MODULE_1__.NodeWorker !== 'undefined' && !_env_utils_globals_js__WEBPACK_IMPORTED_MODULE_0__.isBrowser;
  }
  constructor(props) {
    this.name = void 0;
    this.source = void 0;
    this.url = void 0;
    this.terminated = false;
    this.worker = void 0;
    this.onMessage = void 0;
    this.onError = void 0;
    this._loadableURL = '';
    const {
      name,
      source,
      url
    } = props;
    (0,_env_utils_assert_js__WEBPACK_IMPORTED_MODULE_2__.assert)(source || url);
    this.name = name;
    this.source = source;
    this.url = url;
    this.onMessage = NOOP;
    this.onError = error => console.log(error);
    this.worker = _env_utils_globals_js__WEBPACK_IMPORTED_MODULE_0__.isBrowser ? this._createBrowserWorker() : this._createNodeWorker();
  }
  destroy() {
    this.onMessage = NOOP;
    this.onError = NOOP;
    this.worker.terminate();
    this.terminated = true;
  }
  get isRunning() {
    return Boolean(this.onMessage);
  }
  postMessage(data, transferList) {
    transferList = transferList || (0,_worker_utils_get_transfer_list_js__WEBPACK_IMPORTED_MODULE_3__.getTransferList)(data);
    this.worker.postMessage(data, transferList);
  }
  _getErrorFromErrorEvent(event) {
    let message = 'Failed to load ';
    message += `worker ${this.name} from ${this.url}. `;
    if (event.message) {
      message += `${event.message} in `;
    }
    if (event.lineno) {
      message += `:${event.lineno}:${event.colno}`;
    }
    return new Error(message);
  }
  _createBrowserWorker() {
    this._loadableURL = (0,_worker_utils_get_loadable_worker_url_js__WEBPACK_IMPORTED_MODULE_4__.getLoadableWorkerURL)({
      source: this.source,
      url: this.url
    });
    const worker = new Worker(this._loadableURL, {
      name: this.name
    });
    worker.onmessage = event => {
      if (!event.data) {
        this.onError(new Error('No data received'));
      } else {
        this.onMessage(event.data);
      }
    };
    worker.onerror = error => {
      this.onError(this._getErrorFromErrorEvent(error));
      this.terminated = true;
    };
    worker.onmessageerror = event => console.error(event);
    return worker;
  }
  _createNodeWorker() {
    let worker;
    if (this.url) {
      const absolute = this.url.includes(':/') || this.url.startsWith('/');
      const url = absolute ? this.url : `./${this.url}`;
      worker = new _node_worker_threads_js__WEBPACK_IMPORTED_MODULE_1__.NodeWorker(url, {
        eval: false
      });
    } else if (this.source) {
      worker = new _node_worker_threads_js__WEBPACK_IMPORTED_MODULE_1__.NodeWorker(this.source, {
        eval: true
      });
    } else {
      throw new Error('no worker');
    }
    worker.on('message', data => {
      this.onMessage(data);
    });
    worker.on('error', error => {
      this.onError(error);
    });
    worker.on('exit', code => {});
    return worker;
  }
}
//# sourceMappingURL=worker-thread.js.map

/***/ }),

/***/ "../../node_modules/@loaders.gl/worker-utils/dist/lib/worker-utils/get-loadable-worker-url.js":
/*!****************************************************************************************************!*\
  !*** ../../node_modules/@loaders.gl/worker-utils/dist/lib/worker-utils/get-loadable-worker-url.js ***!
  \****************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   getLoadableWorkerURL: () => (/* binding */ getLoadableWorkerURL)
/* harmony export */ });
/* harmony import */ var _env_utils_assert_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../env-utils/assert.js */ "../../node_modules/@loaders.gl/worker-utils/dist/lib/env-utils/assert.js");

const workerURLCache = new Map();
function getLoadableWorkerURL(props) {
  (0,_env_utils_assert_js__WEBPACK_IMPORTED_MODULE_0__.assert)(props.source && !props.url || !props.source && props.url);
  let workerURL = workerURLCache.get(props.source || props.url);
  if (!workerURL) {
    if (props.url) {
      workerURL = getLoadableWorkerURLFromURL(props.url);
      workerURLCache.set(props.url, workerURL);
    }
    if (props.source) {
      workerURL = getLoadableWorkerURLFromSource(props.source);
      workerURLCache.set(props.source, workerURL);
    }
  }
  (0,_env_utils_assert_js__WEBPACK_IMPORTED_MODULE_0__.assert)(workerURL);
  return workerURL;
}
function getLoadableWorkerURLFromURL(url) {
  if (!url.startsWith('http')) {
    return url;
  }
  const workerSource = buildScriptSource(url);
  return getLoadableWorkerURLFromSource(workerSource);
}
function getLoadableWorkerURLFromSource(workerSource) {
  const blob = new Blob([workerSource], {
    type: 'application/javascript'
  });
  return URL.createObjectURL(blob);
}
function buildScriptSource(workerUrl) {
  return `\
try {
  importScripts('${workerUrl}');
} catch (error) {
  console.error(error);
  throw error;
}`;
}
//# sourceMappingURL=get-loadable-worker-url.js.map

/***/ }),

/***/ "../../node_modules/@loaders.gl/worker-utils/dist/lib/worker-utils/get-transfer-list.js":
/*!**********************************************************************************************!*\
  !*** ../../node_modules/@loaders.gl/worker-utils/dist/lib/worker-utils/get-transfer-list.js ***!
  \**********************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   getTransferList: () => (/* binding */ getTransferList),
/* harmony export */   getTransferListForWriter: () => (/* binding */ getTransferListForWriter)
/* harmony export */ });
function getTransferList(object) {
  let recursive = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
  let transfers = arguments.length > 2 ? arguments[2] : undefined;
  const transfersSet = transfers || new Set();
  if (!object) {} else if (isTransferable(object)) {
    transfersSet.add(object);
  } else if (isTransferable(object.buffer)) {
    transfersSet.add(object.buffer);
  } else if (ArrayBuffer.isView(object)) {} else if (recursive && typeof object === 'object') {
    for (const key in object) {
      getTransferList(object[key], recursive, transfersSet);
    }
  }
  return transfers === undefined ? Array.from(transfersSet) : [];
}
function isTransferable(object) {
  if (!object) {
    return false;
  }
  if (object instanceof ArrayBuffer) {
    return true;
  }
  if (typeof MessagePort !== 'undefined' && object instanceof MessagePort) {
    return true;
  }
  if (typeof ImageBitmap !== 'undefined' && object instanceof ImageBitmap) {
    return true;
  }
  if (typeof OffscreenCanvas !== 'undefined' && object instanceof OffscreenCanvas) {
    return true;
  }
  return false;
}
function getTransferListForWriter(object) {
  if (object === null) {
    return {};
  }
  const clone = Object.assign({}, object);
  Object.keys(clone).forEach(key => {
    if (typeof object[key] === 'object' && !ArrayBuffer.isView(object[key]) && !(object[key] instanceof Array)) {
      clone[key] = getTransferListForWriter(object[key]);
    } else if (typeof clone[key] === 'function' || clone[key] instanceof RegExp) {
      clone[key] = {};
    } else {
      clone[key] = object[key];
    }
  });
  return clone;
}
//# sourceMappingURL=get-transfer-list.js.map

/***/ }),

/***/ "../../node_modules/@probe.gl/env/dist/index.js":
/*!******************************************************!*\
  !*** ../../node_modules/@probe.gl/env/dist/index.js ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   VERSION: () => (/* binding */ VERSION),
/* harmony export */   assert: () => (/* reexport safe */ _utils_assert_js__WEBPACK_IMPORTED_MODULE_4__.assert),
/* harmony export */   console: () => (/* reexport safe */ _lib_globals_js__WEBPACK_IMPORTED_MODULE_0__.console),
/* harmony export */   document: () => (/* reexport safe */ _lib_globals_js__WEBPACK_IMPORTED_MODULE_0__.document),
/* harmony export */   getBrowser: () => (/* reexport safe */ _lib_get_browser_js__WEBPACK_IMPORTED_MODULE_2__.getBrowser),
/* harmony export */   global: () => (/* reexport safe */ _lib_globals_js__WEBPACK_IMPORTED_MODULE_0__.global),
/* harmony export */   isBrowser: () => (/* reexport safe */ _lib_is_browser_js__WEBPACK_IMPORTED_MODULE_1__.isBrowser),
/* harmony export */   isElectron: () => (/* reexport safe */ _lib_is_electron_js__WEBPACK_IMPORTED_MODULE_3__.isElectron),
/* harmony export */   isMobile: () => (/* reexport safe */ _lib_get_browser_js__WEBPACK_IMPORTED_MODULE_2__.isMobile),
/* harmony export */   process: () => (/* reexport safe */ _lib_globals_js__WEBPACK_IMPORTED_MODULE_0__.process),
/* harmony export */   self: () => (/* reexport safe */ _lib_globals_js__WEBPACK_IMPORTED_MODULE_0__.self),
/* harmony export */   window: () => (/* reexport safe */ _lib_globals_js__WEBPACK_IMPORTED_MODULE_0__.window)
/* harmony export */ });
/* harmony import */ var _lib_globals_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./lib/globals.js */ "../../node_modules/@probe.gl/env/dist/lib/globals.js");
/* harmony import */ var _lib_is_browser_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./lib/is-browser.js */ "../../node_modules/@probe.gl/env/dist/lib/is-browser.js");
/* harmony import */ var _lib_get_browser_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./lib/get-browser.js */ "../../node_modules/@probe.gl/env/dist/lib/get-browser.js");
/* harmony import */ var _lib_is_electron_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./lib/is-electron.js */ "../../node_modules/@probe.gl/env/dist/lib/is-electron.js");
/* harmony import */ var _utils_assert_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./utils/assert.js */ "../../node_modules/@probe.gl/env/dist/utils/assert.js");
// Extract injected version from package.json (injected by babel plugin)
// @ts-expect-error
const VERSION =  true ? "4.0.7" : 0;
// ENVIRONMENT




// ENVIRONMENT'S ASSERT IS 5-15KB, SO WE PROVIDE OUR OWN

// TODO - wish we could just export a constant
// export const isBrowser = checkIfBrowser();


/***/ }),

/***/ "../../node_modules/@probe.gl/env/dist/lib/get-browser.js":
/*!****************************************************************!*\
  !*** ../../node_modules/@probe.gl/env/dist/lib/get-browser.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   getBrowser: () => (/* binding */ getBrowser),
/* harmony export */   isMobile: () => (/* binding */ isMobile)
/* harmony export */ });
/* harmony import */ var _is_browser_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./is-browser.js */ "../../node_modules/@probe.gl/env/dist/lib/is-browser.js");
/* harmony import */ var _is_electron_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./is-electron.js */ "../../node_modules/@probe.gl/env/dist/lib/is-electron.js");
/* harmony import */ var _globals_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./globals.js */ "../../node_modules/@probe.gl/env/dist/lib/globals.js");
// Copyright (c) 2017 Uber Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.
// This function is needed in initialization stages,
// make sure it can be imported in isolation



function isMobile() {
    return typeof globalThis.orientation !== 'undefined';
}
// Simple browser detection
// `mockUserAgent` parameter allows user agent to be overridden for testing
/* eslint-disable complexity */
function getBrowser(mockUserAgent) {
    if (!mockUserAgent && !(0,_is_browser_js__WEBPACK_IMPORTED_MODULE_0__.isBrowser)()) {
        return 'Node';
    }
    if ((0,_is_electron_js__WEBPACK_IMPORTED_MODULE_1__.isElectron)(mockUserAgent)) {
        return 'Electron';
    }
    const userAgent = mockUserAgent || _globals_js__WEBPACK_IMPORTED_MODULE_2__.navigator.userAgent || '';
    // NOTE: Order of tests matter, as many agents list Chrome etc.
    if (userAgent.indexOf('Edge') > -1) {
        return 'Edge';
    }
    if (globalThis.chrome) {
        return 'Chrome';
    }
    if (globalThis.safari) {
        return 'Safari';
    }
    if (globalThis.mozInnerScreenX) {
        return 'Firefox';
    }
    return 'Unknown';
}


/***/ }),

/***/ "../../node_modules/@probe.gl/env/dist/lib/globals.js":
/*!************************************************************!*\
  !*** ../../node_modules/@probe.gl/env/dist/lib/globals.js ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   console: () => (/* binding */ console_),
/* harmony export */   document: () => (/* binding */ document_),
/* harmony export */   global: () => (/* binding */ global_),
/* harmony export */   navigator: () => (/* binding */ navigator_),
/* harmony export */   process: () => (/* binding */ process_),
/* harmony export */   self: () => (/* binding */ global_),
/* harmony export */   window: () => (/* binding */ window_)
/* harmony export */ });
// Do not name these variables the same as the global objects - will break bundling
const global_ = globalThis;
const window_ = globalThis;
const document_ = globalThis.document || {};
const process_ = globalThis.process || {};
const console_ = globalThis.console;
const navigator_ = globalThis.navigator || {};



/***/ }),

/***/ "../../node_modules/@probe.gl/env/dist/lib/is-browser.js":
/*!***************************************************************!*\
  !*** ../../node_modules/@probe.gl/env/dist/lib/is-browser.js ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   isBrowser: () => (/* binding */ isBrowser)
/* harmony export */ });
/* harmony import */ var _is_electron_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./is-electron.js */ "../../node_modules/@probe.gl/env/dist/lib/is-electron.js");
// This function is needed in initialization stages,
// make sure it can be imported in isolation

/** Check if in browser by duck-typing Node context */
function isBrowser() {
    const isNode = 
    // @ts-expect-error
    typeof process === 'object' && String(process) === '[object process]' && !process?.browser;
    return !isNode || (0,_is_electron_js__WEBPACK_IMPORTED_MODULE_0__.isElectron)();
}


/***/ }),

/***/ "../../node_modules/@probe.gl/env/dist/lib/is-electron.js":
/*!****************************************************************!*\
  !*** ../../node_modules/@probe.gl/env/dist/lib/is-electron.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   isElectron: () => (/* binding */ isElectron)
/* harmony export */ });
// based on https://github.com/cheton/is-electron
// https://github.com/electron/electron/issues/2288
/* eslint-disable complexity */
function isElectron(mockUserAgent) {
    // Renderer process
    // @ts-expect-error
    if (typeof window !== 'undefined' && window.process?.type === 'renderer') {
        return true;
    }
    // Main process
    // eslint-disable-next-line
    if (typeof process !== 'undefined' && Boolean(process.versions?.['electron'])) {
        return true;
    }
    // Detect the user agent when the `nodeIntegration` option is set to true
    const realUserAgent = typeof navigator !== 'undefined' && navigator.userAgent;
    const userAgent = mockUserAgent || realUserAgent;
    return Boolean(userAgent && userAgent.indexOf('Electron') >= 0);
}


/***/ }),

/***/ "../../node_modules/@probe.gl/env/dist/utils/assert.js":
/*!*************************************************************!*\
  !*** ../../node_modules/@probe.gl/env/dist/utils/assert.js ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   assert: () => (/* binding */ assert)
/* harmony export */ });
function assert(condition, message) {
    if (!condition) {
        throw new Error(message || 'Assertion failed');
    }
}


/***/ }),

/***/ "../../node_modules/@probe.gl/log/dist/log.js":
/*!****************************************************!*\
  !*** ../../node_modules/@probe.gl/log/dist/log.js ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Log: () => (/* binding */ Log),
/* harmony export */   normalizeArguments: () => (/* binding */ normalizeArguments)
/* harmony export */ });
/* harmony import */ var _probe_gl_env__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @probe.gl/env */ "../../node_modules/@probe.gl/env/dist/lib/is-browser.js");
/* harmony import */ var _probe_gl_env__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @probe.gl/env */ "../../node_modules/@probe.gl/env/dist/index.js");
/* harmony import */ var _utils_local_storage_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./utils/local-storage.js */ "../../node_modules/@probe.gl/log/dist/utils/local-storage.js");
/* harmony import */ var _utils_formatters_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./utils/formatters.js */ "../../node_modules/@probe.gl/log/dist/utils/formatters.js");
/* harmony import */ var _utils_color_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./utils/color.js */ "../../node_modules/@probe.gl/log/dist/utils/color.js");
/* harmony import */ var _utils_autobind_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./utils/autobind.js */ "../../node_modules/@probe.gl/log/dist/utils/autobind.js");
/* harmony import */ var _utils_assert_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./utils/assert.js */ "../../node_modules/@probe.gl/log/dist/utils/assert.js");
/* harmony import */ var _utils_hi_res_timestamp_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils/hi-res-timestamp.js */ "../../node_modules/@probe.gl/log/dist/utils/hi-res-timestamp.js");
// probe.gl, MIT license
/* eslint-disable no-console */







// Instrumentation in other packages may override console methods, so preserve them here
const originalConsole = {
    debug: (0,_probe_gl_env__WEBPACK_IMPORTED_MODULE_0__.isBrowser)() ? console.debug || console.log : console.log,
    log: console.log,
    info: console.info,
    warn: console.warn,
    error: console.error
};
const DEFAULT_LOG_CONFIGURATION = {
    enabled: true,
    level: 0
};
function noop() { } // eslint-disable-line @typescript-eslint/no-empty-function
const cache = {};
const ONCE = { once: true };
/** A console wrapper */
class Log {
    constructor({ id } = { id: '' }) {
        this.VERSION = _probe_gl_env__WEBPACK_IMPORTED_MODULE_1__.VERSION;
        this._startTs = (0,_utils_hi_res_timestamp_js__WEBPACK_IMPORTED_MODULE_2__.getHiResTimestamp)();
        this._deltaTs = (0,_utils_hi_res_timestamp_js__WEBPACK_IMPORTED_MODULE_2__.getHiResTimestamp)();
        this.userData = {};
        // TODO - fix support from throttling groups
        this.LOG_THROTTLE_TIMEOUT = 0; // Time before throttled messages are logged again
        this.id = id;
        this.userData = {};
        this._storage = new _utils_local_storage_js__WEBPACK_IMPORTED_MODULE_3__.LocalStorage(`__probe-${this.id}__`, DEFAULT_LOG_CONFIGURATION);
        this.timeStamp(`${this.id} started`);
        (0,_utils_autobind_js__WEBPACK_IMPORTED_MODULE_4__.autobind)(this);
        Object.seal(this);
    }
    set level(newLevel) {
        this.setLevel(newLevel);
    }
    get level() {
        return this.getLevel();
    }
    isEnabled() {
        return this._storage.config.enabled;
    }
    getLevel() {
        return this._storage.config.level;
    }
    /** @return milliseconds, with fractions */
    getTotal() {
        return Number(((0,_utils_hi_res_timestamp_js__WEBPACK_IMPORTED_MODULE_2__.getHiResTimestamp)() - this._startTs).toPrecision(10));
    }
    /** @return milliseconds, with fractions */
    getDelta() {
        return Number(((0,_utils_hi_res_timestamp_js__WEBPACK_IMPORTED_MODULE_2__.getHiResTimestamp)() - this._deltaTs).toPrecision(10));
    }
    /** @deprecated use logLevel */
    set priority(newPriority) {
        this.level = newPriority;
    }
    /** @deprecated use logLevel */
    get priority() {
        return this.level;
    }
    /** @deprecated use logLevel */
    getPriority() {
        return this.level;
    }
    // Configure
    enable(enabled = true) {
        this._storage.setConfiguration({ enabled });
        return this;
    }
    setLevel(level) {
        this._storage.setConfiguration({ level });
        return this;
    }
    /** return the current status of the setting */
    get(setting) {
        return this._storage.config[setting];
    }
    // update the status of the setting
    set(setting, value) {
        this._storage.setConfiguration({ [setting]: value });
    }
    /** Logs the current settings as a table */
    settings() {
        if (console.table) {
            console.table(this._storage.config);
        }
        else {
            console.log(this._storage.config);
        }
    }
    // Unconditional logging
    assert(condition, message) {
        if (!condition) {
            throw new Error(message || 'Assertion failed');
        }
    }
    warn(message) {
        return this._getLogFunction(0, message, originalConsole.warn, arguments, ONCE);
    }
    error(message) {
        return this._getLogFunction(0, message, originalConsole.error, arguments);
    }
    /** Print a deprecation warning */
    deprecated(oldUsage, newUsage) {
        return this.warn(`\`${oldUsage}\` is deprecated and will be removed \
in a later version. Use \`${newUsage}\` instead`);
    }
    /** Print a removal warning */
    removed(oldUsage, newUsage) {
        return this.error(`\`${oldUsage}\` has been removed. Use \`${newUsage}\` instead`);
    }
    probe(logLevel, message) {
        return this._getLogFunction(logLevel, message, originalConsole.log, arguments, {
            time: true,
            once: true
        });
    }
    log(logLevel, message) {
        return this._getLogFunction(logLevel, message, originalConsole.debug, arguments);
    }
    info(logLevel, message) {
        return this._getLogFunction(logLevel, message, console.info, arguments);
    }
    once(logLevel, message) {
        return this._getLogFunction(logLevel, message, originalConsole.debug || originalConsole.info, arguments, ONCE);
    }
    /** Logs an object as a table */
    table(logLevel, table, columns) {
        if (table) {
            return this._getLogFunction(logLevel, table, console.table || noop, (columns && [columns]), {
                tag: getTableHeader(table)
            });
        }
        return noop;
    }
    time(logLevel, message) {
        return this._getLogFunction(logLevel, message, console.time ? console.time : console.info);
    }
    timeEnd(logLevel, message) {
        return this._getLogFunction(logLevel, message, console.timeEnd ? console.timeEnd : console.info);
    }
    timeStamp(logLevel, message) {
        return this._getLogFunction(logLevel, message, console.timeStamp || noop);
    }
    group(logLevel, message, opts = { collapsed: false }) {
        const options = normalizeArguments({ logLevel, message, opts });
        const { collapsed } = opts;
        // @ts-expect-error
        options.method = (collapsed ? console.groupCollapsed : console.group) || console.info;
        return this._getLogFunction(options);
    }
    groupCollapsed(logLevel, message, opts = {}) {
        return this.group(logLevel, message, Object.assign({}, opts, { collapsed: true }));
    }
    groupEnd(logLevel) {
        return this._getLogFunction(logLevel, '', console.groupEnd || noop);
    }
    // EXPERIMENTAL
    withGroup(logLevel, message, func) {
        this.group(logLevel, message)();
        try {
            func();
        }
        finally {
            this.groupEnd(logLevel)();
        }
    }
    trace() {
        if (console.trace) {
            console.trace();
        }
    }
    // PRIVATE METHODS
    /** Deduces log level from a variety of arguments */
    _shouldLog(logLevel) {
        return this.isEnabled() && this.getLevel() >= normalizeLogLevel(logLevel);
    }
    _getLogFunction(logLevel, message, method, args, opts) {
        if (this._shouldLog(logLevel)) {
            // normalized opts + timings
            opts = normalizeArguments({ logLevel, message, args, opts });
            method = method || opts.method;
            (0,_utils_assert_js__WEBPACK_IMPORTED_MODULE_5__["default"])(method);
            opts.total = this.getTotal();
            opts.delta = this.getDelta();
            // reset delta timer
            this._deltaTs = (0,_utils_hi_res_timestamp_js__WEBPACK_IMPORTED_MODULE_2__.getHiResTimestamp)();
            const tag = opts.tag || opts.message;
            if (opts.once && tag) {
                if (!cache[tag]) {
                    cache[tag] = (0,_utils_hi_res_timestamp_js__WEBPACK_IMPORTED_MODULE_2__.getHiResTimestamp)();
                }
                else {
                    return noop;
                }
            }
            // TODO - Make throttling work with groups
            // if (opts.nothrottle || !throttle(tag, this.LOG_THROTTLE_TIMEOUT)) {
            //   return noop;
            // }
            message = decorateMessage(this.id, opts.message, opts);
            // Bind console function so that it can be called after being returned
            return method.bind(console, message, ...opts.args);
        }
        return noop;
    }
}
Log.VERSION = _probe_gl_env__WEBPACK_IMPORTED_MODULE_1__.VERSION;
/**
 * Get logLevel from first argument:
 * - log(logLevel, message, args) => logLevel
 * - log(message, args) => 0
 * - log({logLevel, ...}, message, args) => logLevel
 * - log({logLevel, message, args}) => logLevel
 */
function normalizeLogLevel(logLevel) {
    if (!logLevel) {
        return 0;
    }
    let resolvedLevel;
    switch (typeof logLevel) {
        case 'number':
            resolvedLevel = logLevel;
            break;
        case 'object':
            // Backward compatibility
            // TODO - deprecate `priority`
            // @ts-expect-error
            resolvedLevel = logLevel.logLevel || logLevel.priority || 0;
            break;
        default:
            return 0;
    }
    // 'log level must be a number'
    (0,_utils_assert_js__WEBPACK_IMPORTED_MODULE_5__["default"])(Number.isFinite(resolvedLevel) && resolvedLevel >= 0);
    return resolvedLevel;
}
/**
 * "Normalizes" the various argument patterns into an object with known types
 * - log(logLevel, message, args) => {logLevel, message, args}
 * - log(message, args) => {logLevel: 0, message, args}
 * - log({logLevel, ...}, message, args) => {logLevel, message, args}
 * - log({logLevel, message, args}) => {logLevel, message, args}
 */
function normalizeArguments(opts) {
    const { logLevel, message } = opts;
    opts.logLevel = normalizeLogLevel(logLevel);
    // We use `arguments` instead of rest parameters (...args) because IE
    // does not support the syntax. Rest parameters is transpiled to code with
    // perf impact. Doing it here instead avoids constructing args when logging is
    // disabled.
    // TODO - remove when/if IE support is dropped
    const args = opts.args ? Array.from(opts.args) : [];
    // args should only contain arguments that appear after `message`
    // eslint-disable-next-line no-empty
    while (args.length && args.shift() !== message) { }
    switch (typeof logLevel) {
        case 'string':
        case 'function':
            if (message !== undefined) {
                args.unshift(message);
            }
            opts.message = logLevel;
            break;
        case 'object':
            Object.assign(opts, logLevel);
            break;
        default:
    }
    // Resolve functions into strings by calling them
    if (typeof opts.message === 'function') {
        opts.message = opts.message();
    }
    const messageType = typeof opts.message;
    // 'log message must be a string' or object
    (0,_utils_assert_js__WEBPACK_IMPORTED_MODULE_5__["default"])(messageType === 'string' || messageType === 'object');
    // original opts + normalized opts + opts arg + fixed up message
    return Object.assign(opts, { args }, opts.opts);
}
function decorateMessage(id, message, opts) {
    if (typeof message === 'string') {
        const time = opts.time ? (0,_utils_formatters_js__WEBPACK_IMPORTED_MODULE_6__.leftPad)((0,_utils_formatters_js__WEBPACK_IMPORTED_MODULE_6__.formatTime)(opts.total)) : '';
        message = opts.time ? `${id}: ${time}  ${message}` : `${id}: ${message}`;
        message = (0,_utils_color_js__WEBPACK_IMPORTED_MODULE_7__.addColor)(message, opts.color, opts.background);
    }
    return message;
}
function getTableHeader(table) {
    for (const key in table) {
        for (const title in table[key]) {
            return title || 'untitled';
        }
    }
    return 'empty';
}


/***/ }),

/***/ "../../node_modules/@probe.gl/log/dist/utils/assert.js":
/*!*************************************************************!*\
  !*** ../../node_modules/@probe.gl/log/dist/utils/assert.js ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ assert)
/* harmony export */ });
function assert(condition, message) {
    if (!condition) {
        throw new Error(message || 'Assertion failed');
    }
}


/***/ }),

/***/ "../../node_modules/@probe.gl/log/dist/utils/autobind.js":
/*!***************************************************************!*\
  !*** ../../node_modules/@probe.gl/log/dist/utils/autobind.js ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   autobind: () => (/* binding */ autobind)
/* harmony export */ });
// Copyright (c) 2015 - 2017 Uber Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.
/**
 * Binds the "this" argument of all functions on a class instance to the instance
 * @param obj - class instance (typically a react component)
 */
function autobind(obj, predefined = ['constructor']) {
    const proto = Object.getPrototypeOf(obj);
    const propNames = Object.getOwnPropertyNames(proto);
    const object = obj;
    for (const key of propNames) {
        const value = object[key];
        if (typeof value === 'function') {
            if (!predefined.find(name => key === name)) {
                object[key] = value.bind(obj);
            }
        }
    }
}


/***/ }),

/***/ "../../node_modules/@probe.gl/log/dist/utils/color.js":
/*!************************************************************!*\
  !*** ../../node_modules/@probe.gl/log/dist/utils/color.js ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   COLOR: () => (/* binding */ COLOR),
/* harmony export */   addColor: () => (/* binding */ addColor)
/* harmony export */ });
/* harmony import */ var _probe_gl_env__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @probe.gl/env */ "../../node_modules/@probe.gl/env/dist/lib/is-browser.js");

var COLOR;
(function (COLOR) {
    COLOR[COLOR["BLACK"] = 30] = "BLACK";
    COLOR[COLOR["RED"] = 31] = "RED";
    COLOR[COLOR["GREEN"] = 32] = "GREEN";
    COLOR[COLOR["YELLOW"] = 33] = "YELLOW";
    COLOR[COLOR["BLUE"] = 34] = "BLUE";
    COLOR[COLOR["MAGENTA"] = 35] = "MAGENTA";
    COLOR[COLOR["CYAN"] = 36] = "CYAN";
    COLOR[COLOR["WHITE"] = 37] = "WHITE";
    COLOR[COLOR["BRIGHT_BLACK"] = 90] = "BRIGHT_BLACK";
    COLOR[COLOR["BRIGHT_RED"] = 91] = "BRIGHT_RED";
    COLOR[COLOR["BRIGHT_GREEN"] = 92] = "BRIGHT_GREEN";
    COLOR[COLOR["BRIGHT_YELLOW"] = 93] = "BRIGHT_YELLOW";
    COLOR[COLOR["BRIGHT_BLUE"] = 94] = "BRIGHT_BLUE";
    COLOR[COLOR["BRIGHT_MAGENTA"] = 95] = "BRIGHT_MAGENTA";
    COLOR[COLOR["BRIGHT_CYAN"] = 96] = "BRIGHT_CYAN";
    COLOR[COLOR["BRIGHT_WHITE"] = 97] = "BRIGHT_WHITE";
})(COLOR || (COLOR = {}));
const BACKGROUND_INCREMENT = 10;
function getColor(color) {
    if (typeof color !== 'string') {
        return color;
    }
    color = color.toUpperCase();
    return COLOR[color] || COLOR.WHITE;
}
function addColor(string, color, background) {
    if (!_probe_gl_env__WEBPACK_IMPORTED_MODULE_0__.isBrowser && typeof string === 'string') {
        if (color) {
            const colorCode = getColor(color);
            string = `\u001b[${colorCode}m${string}\u001b[39m`;
        }
        if (background) {
            // background colors values are +10
            const colorCode = getColor(background);
            string = `\u001b[${colorCode + BACKGROUND_INCREMENT}m${string}\u001b[49m`;
        }
    }
    return string;
}


/***/ }),

/***/ "../../node_modules/@probe.gl/log/dist/utils/formatters.js":
/*!*****************************************************************!*\
  !*** ../../node_modules/@probe.gl/log/dist/utils/formatters.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   formatTime: () => (/* binding */ formatTime),
/* harmony export */   formatValue: () => (/* binding */ formatValue),
/* harmony export */   leftPad: () => (/* binding */ leftPad),
/* harmony export */   rightPad: () => (/* binding */ rightPad)
/* harmony export */ });
// probe.gl, MIT license
/**
 * Format time
 */
function formatTime(ms) {
    let formatted;
    if (ms < 10) {
        formatted = `${ms.toFixed(2)}ms`;
    }
    else if (ms < 100) {
        formatted = `${ms.toFixed(1)}ms`;
    }
    else if (ms < 1000) {
        formatted = `${ms.toFixed(0)}ms`;
    }
    else {
        formatted = `${(ms / 1000).toFixed(2)}s`;
    }
    return formatted;
}
function leftPad(string, length = 8) {
    const padLength = Math.max(length - string.length, 0);
    return `${' '.repeat(padLength)}${string}`;
}
function rightPad(string, length = 8) {
    const padLength = Math.max(length - string.length, 0);
    return `${string}${' '.repeat(padLength)}`;
}
function formatValue(v, options = {}) {
    const EPSILON = 1e-16;
    const { isInteger = false } = options;
    if (Array.isArray(v) || ArrayBuffer.isView(v)) {
        return formatArrayValue(v, options);
    }
    if (!Number.isFinite(v)) {
        return String(v);
    }
    // @ts-expect-error
    if (Math.abs(v) < EPSILON) {
        return isInteger ? '0' : '0.';
    }
    if (isInteger) {
        // @ts-expect-error
        return v.toFixed(0);
    }
    // @ts-expect-error
    if (Math.abs(v) > 100 && Math.abs(v) < 10000) {
        // @ts-expect-error
        return v.toFixed(0);
    }
    // @ts-expect-error
    const string = v.toPrecision(2);
    const decimal = string.indexOf('.0');
    return decimal === string.length - 2 ? string.slice(0, -1) : string;
}
/** Helper to formatValue */
function formatArrayValue(v, options) {
    const { maxElts = 16, size = 1 } = options;
    let string = '[';
    for (let i = 0; i < v.length && i < maxElts; ++i) {
        if (i > 0) {
            string += `,${i % size === 0 ? ' ' : ''}`;
        }
        string += formatValue(v[i], options);
    }
    const terminator = v.length > maxElts ? '...' : ']';
    return `${string}${terminator}`;
}


/***/ }),

/***/ "../../node_modules/@probe.gl/log/dist/utils/hi-res-timestamp.js":
/*!***********************************************************************!*\
  !*** ../../node_modules/@probe.gl/log/dist/utils/hi-res-timestamp.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   getHiResTimestamp: () => (/* binding */ getHiResTimestamp)
/* harmony export */ });
/* harmony import */ var _probe_gl_env__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @probe.gl/env */ "../../node_modules/@probe.gl/env/dist/lib/is-browser.js");
/* harmony import */ var _probe_gl_env__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @probe.gl/env */ "../../node_modules/@probe.gl/env/dist/lib/globals.js");
// probe.gl, MIT license

/** Get best timer available. */
function getHiResTimestamp() {
    let timestamp;
    if ((0,_probe_gl_env__WEBPACK_IMPORTED_MODULE_0__.isBrowser)() && _probe_gl_env__WEBPACK_IMPORTED_MODULE_1__.window.performance) {
        timestamp = _probe_gl_env__WEBPACK_IMPORTED_MODULE_1__.window?.performance?.now?.();
    }
    else if ("hrtime" in _probe_gl_env__WEBPACK_IMPORTED_MODULE_1__.process) {
        // @ts-ignore
        const timeParts = _probe_gl_env__WEBPACK_IMPORTED_MODULE_1__.process?.hrtime?.();
        timestamp = timeParts[0] * 1000 + timeParts[1] / 1e6;
    }
    else {
        timestamp = Date.now();
    }
    return timestamp;
}


/***/ }),

/***/ "../../node_modules/@probe.gl/log/dist/utils/local-storage.js":
/*!********************************************************************!*\
  !*** ../../node_modules/@probe.gl/log/dist/utils/local-storage.js ***!
  \********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   LocalStorage: () => (/* binding */ LocalStorage)
/* harmony export */ });
// probe.gl, MIT license
function getStorage(type) {
    try {
        const storage = window[type];
        const x = '__storage_test__';
        storage.setItem(x, x);
        storage.removeItem(x);
        return storage;
    }
    catch (e) {
        return null;
    }
}
// Store keys in local storage via simple interface
class LocalStorage {
    constructor(id, defaultConfig, type = 'sessionStorage') {
        this.storage = getStorage(type);
        this.id = id;
        this.config = defaultConfig;
        this._loadConfiguration();
    }
    getConfiguration() {
        return this.config;
    }
    setConfiguration(configuration) {
        Object.assign(this.config, configuration);
        if (this.storage) {
            const serialized = JSON.stringify(this.config);
            this.storage.setItem(this.id, serialized);
        }
    }
    // Get config from persistent store, if available
    _loadConfiguration() {
        let configuration = {};
        if (this.storage) {
            const serializedConfiguration = this.storage.getItem(this.id);
            configuration = serializedConfiguration ? JSON.parse(serializedConfiguration) : {};
        }
        Object.assign(this.config, configuration);
        return this;
    }
}


/***/ }),

/***/ "../../node_modules/wgpu-matrix/dist/3.x/wgpu-matrix.module.js":
/*!*********************************************************************!*\
  !*** ../../node_modules/wgpu-matrix/dist/3.x/wgpu-matrix.module.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   mat3: () => (/* binding */ mat3),
/* harmony export */   mat3d: () => (/* binding */ mat3d),
/* harmony export */   mat3n: () => (/* binding */ mat3n),
/* harmony export */   mat4: () => (/* binding */ mat4),
/* harmony export */   mat4d: () => (/* binding */ mat4d),
/* harmony export */   mat4n: () => (/* binding */ mat4n),
/* harmony export */   quat: () => (/* binding */ quat),
/* harmony export */   quatd: () => (/* binding */ quatd),
/* harmony export */   quatn: () => (/* binding */ quatn),
/* harmony export */   utils: () => (/* binding */ utils),
/* harmony export */   vec2: () => (/* binding */ vec2),
/* harmony export */   vec2d: () => (/* binding */ vec2d),
/* harmony export */   vec2n: () => (/* binding */ vec2n),
/* harmony export */   vec3: () => (/* binding */ vec3),
/* harmony export */   vec3d: () => (/* binding */ vec3d),
/* harmony export */   vec3n: () => (/* binding */ vec3n),
/* harmony export */   vec4: () => (/* binding */ vec4),
/* harmony export */   vec4d: () => (/* binding */ vec4d),
/* harmony export */   vec4n: () => (/* binding */ vec4n)
/* harmony export */ });
/* wgpu-matrix@3.0.1, license MIT */
function wrapConstructor(OriginalConstructor, modifier) {
    return class extends OriginalConstructor {
        constructor(...args) {
            super(...args);
            modifier(this);
        }
    }; // Type assertion is necessary here
}
const ZeroArray = wrapConstructor((Array), a => a.fill(0));

/*
 * Copyright 2022 Gregg Tavares
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */
let EPSILON = 0.000001;
/**
 * Set the value for EPSILON for various checks
 * @param v - Value to use for EPSILON.
 * @returns previous value of EPSILON;
 */
function setEpsilon(v) {
    const old = EPSILON;
    EPSILON = v;
    return old;
}
/**
 * Convert degrees to radians
 * @param degrees - Angle in degrees
 * @returns angle converted to radians
 */
function degToRad(degrees) {
    return degrees * Math.PI / 180;
}
/**
 * Convert radians to degrees
 * @param radians - Angle in radians
 * @returns angle converted to degrees
 */
function radToDeg(radians) {
    return radians * 180 / Math.PI;
}
/**
 * Lerps between a and b via t
 * @param a - starting value
 * @param b - ending value
 * @param t - value where 0 = a and 1 = b
 * @returns a + (b - a) * t
 */
function lerp(a, b, t) {
    return a + (b - a) * t;
}
/**
 * Compute the opposite of lerp. Given a and b and a value between
 * a and b returns a value between 0 and 1. 0 if a, 1 if b.
 * Note: no clamping is done.
 * @param a - start value
 * @param b - end value
 * @param v - value between a and b
 * @returns (v - a) / (b - a)
 */
function inverseLerp(a, b, v) {
    const d = b - a;
    return (Math.abs(b - a) < EPSILON)
        ? a
        : (v - a) / d;
}
/**
 * Compute the euclidean modulo
 *
 * ```
 * // table for n / 3
 * -5, -4, -3, -2, -1,  0,  1,  2,  3,  4,  5   <- n
 * ------------------------------------
 * -2  -1  -0  -2  -1   0,  1,  2,  0,  1,  2   <- n % 3
 *  1   2   0   1   2   0,  1,  2,  0,  1,  2   <- euclideanModule(n, 3)
 * ```
 *
 * @param n - dividend
 * @param m - divisor
 * @returns the euclidean modulo of n / m
 */
function euclideanModulo(n, m) {
    return ((n % m) + m) % m;
}

var utils = {
    __proto__: null,
    get EPSILON () { return EPSILON; },
    degToRad: degToRad,
    euclideanModulo: euclideanModulo,
    inverseLerp: inverseLerp,
    lerp: lerp,
    radToDeg: radToDeg,
    setEpsilon: setEpsilon
};

/*
 * Copyright 2022 Gregg Tavares
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */
/**
 * Generates am typed API for Vec3
 */
function getAPIImpl$5(Ctor) {
    /**
     * Creates a Vec2; may be called with x, y, z to set initial values.
     *
     * Note: Since passing in a raw JavaScript array
     * is valid in all circumstances, if you want to
     * force a JavaScript array into a Vec2's specified type
     * it would be faster to use
     *
     * ```
     * const v = vec2.clone(someJSArray);
     * ```
     *
     * @param x - Initial x value.
     * @param y - Initial y value.
     * @returns the created vector
     */
    function create(x = 0, y = 0) {
        const newDst = new Ctor(2);
        if (x !== undefined) {
            newDst[0] = x;
            if (y !== undefined) {
                newDst[1] = y;
            }
        }
        return newDst;
    }
    /**
     * Creates a Vec2; may be called with x, y, z to set initial values. (same as create)
     * @param x - Initial x value.
     * @param y - Initial y value.
     * @returns the created vector
     */
    const fromValues = create;
    /**
     * Sets the values of a Vec2
     * Also see {@link vec2.create} and {@link vec2.copy}
     *
     * @param x first value
     * @param y second value
     * @param dst - vector to hold result. If not passed in a new one is created.
     * @returns A vector with its elements set.
     */
    function set(x, y, dst) {
        const newDst = (dst ?? new Ctor(2));
        newDst[0] = x;
        newDst[1] = y;
        return newDst;
    }
    /**
     * Applies Math.ceil to each element of vector
     * @param v - Operand vector.
     * @param dst - vector to hold result. If not passed in a new one is created.
     * @returns A vector that is the ceil of each element of v.
     */
    function ceil(v, dst) {
        const newDst = (dst ?? new Ctor(2));
        newDst[0] = Math.ceil(v[0]);
        newDst[1] = Math.ceil(v[1]);
        return newDst;
    }
    /**
     * Applies Math.floor to each element of vector
     * @param v - Operand vector.
     * @param dst - vector to hold result. If not passed in a new one is created.
     * @returns A vector that is the floor of each element of v.
     */
    function floor(v, dst) {
        const newDst = (dst ?? new Ctor(2));
        newDst[0] = Math.floor(v[0]);
        newDst[1] = Math.floor(v[1]);
        return newDst;
    }
    /**
     * Applies Math.round to each element of vector
     * @param v - Operand vector.
     * @param dst - vector to hold result. If not passed in a new one is created.
     * @returns A vector that is the round of each element of v.
     */
    function round(v, dst) {
        const newDst = (dst ?? new Ctor(2));
        newDst[0] = Math.round(v[0]);
        newDst[1] = Math.round(v[1]);
        return newDst;
    }
    /**
     * Clamp each element of vector between min and max
     * @param v - Operand vector.
     * @param max - Min value, default 0
     * @param min - Max value, default 1
     * @param dst - vector to hold result. If not passed in a new one is created.
     * @returns A vector that the clamped value of each element of v.
     */
    function clamp(v, min = 0, max = 1, dst) {
        const newDst = (dst ?? new Ctor(2));
        newDst[0] = Math.min(max, Math.max(min, v[0]));
        newDst[1] = Math.min(max, Math.max(min, v[1]));
        return newDst;
    }
    /**
     * Adds two vectors; assumes a and b have the same dimension.
     * @param a - Operand vector.
     * @param b - Operand vector.
     * @param dst - vector to hold result. If not passed in a new one is created.
     * @returns A vector that is the sum of a and b.
     */
    function add(a, b, dst) {
        const newDst = (dst ?? new Ctor(2));
        newDst[0] = a[0] + b[0];
        newDst[1] = a[1] + b[1];
        return newDst;
    }
    /**
     * Adds two vectors, scaling the 2nd; assumes a and b have the same dimension.
     * @param a - Operand vector.
     * @param b - Operand vector.
     * @param scale - Amount to scale b
     * @param dst - vector to hold result. If not passed in a new one is created.
     * @returns A vector that is the sum of a + b * scale.
     */
    function addScaled(a, b, scale, dst) {
        const newDst = (dst ?? new Ctor(2));
        newDst[0] = a[0] + b[0] * scale;
        newDst[1] = a[1] + b[1] * scale;
        return newDst;
    }
    /**
     * Returns the angle in radians between two vectors.
     * @param a - Operand vector.
     * @param b - Operand vector.
     * @returns The angle in radians between the 2 vectors.
     */
    function angle(a, b) {
        const ax = a[0];
        const ay = a[1];
        const bx = b[0];
        const by = b[1];
        const mag1 = Math.sqrt(ax * ax + ay * ay);
        const mag2 = Math.sqrt(bx * bx + by * by);
        const mag = mag1 * mag2;
        const cosine = mag && dot(a, b) / mag;
        return Math.acos(cosine);
    }
    /**
     * Subtracts two vectors.
     * @param a - Operand vector.
     * @param b - Operand vector.
     * @param dst - vector to hold result. If not passed in a new one is created.
     * @returns A vector that is the difference of a and b.
     */
    function subtract(a, b, dst) {
        const newDst = (dst ?? new Ctor(2));
        newDst[0] = a[0] - b[0];
        newDst[1] = a[1] - b[1];
        return newDst;
    }
    /**
     * Subtracts two vectors.
     * @param a - Operand vector.
     * @param b - Operand vector.
     * @param dst - vector to hold result. If not passed in a new one is created.
     * @returns A vector that is the difference of a and b.
     */
    const sub = subtract;
    /**
     * Check if 2 vectors are approximately equal
     * @param a - Operand vector.
     * @param b - Operand vector.
     * @returns true if vectors are approximately equal
     */
    function equalsApproximately(a, b) {
        return Math.abs(a[0] - b[0]) < EPSILON &&
            Math.abs(a[1] - b[1]) < EPSILON;
    }
    /**
     * Check if 2 vectors are exactly equal
     * @param a - Operand vector.
     * @param b - Operand vector.
     * @returns true if vectors are exactly equal
     */
    function equals(a, b) {
        return a[0] === b[0] && a[1] === b[1];
    }
    /**
     * Performs linear interpolation on two vectors.
     * Given vectors a and b and interpolation coefficient t, returns
     * a + t * (b - a).
     * @param a - Operand vector.
     * @param b - Operand vector.
     * @param t - Interpolation coefficient.
     * @param dst - vector to hold result. If not passed in a new one is created.
     * @returns The linear interpolated result.
     */
    function lerp(a, b, t, dst) {
        const newDst = (dst ?? new Ctor(2));
        newDst[0] = a[0] + t * (b[0] - a[0]);
        newDst[1] = a[1] + t * (b[1] - a[1]);
        return newDst;
    }
    /**
     * Performs linear interpolation on two vectors.
     * Given vectors a and b and interpolation coefficient vector t, returns
     * a + t * (b - a).
     * @param a - Operand vector.
     * @param b - Operand vector.
     * @param t - Interpolation coefficients vector.
     * @param dst - vector to hold result. If not passed in a new one is created.
     * @returns the linear interpolated result.
     */
    function lerpV(a, b, t, dst) {
        const newDst = (dst ?? new Ctor(2));
        newDst[0] = a[0] + t[0] * (b[0] - a[0]);
        newDst[1] = a[1] + t[1] * (b[1] - a[1]);
        return newDst;
    }
    /**
     * Return max values of two vectors.
     * Given vectors a and b returns
     * [max(a[0], b[0]), max(a[1], b[1]), max(a[2], b[2])].
     * @param a - Operand vector.
     * @param b - Operand vector.
     * @param dst - vector to hold result. If not passed in a new one is created.
     * @returns The max components vector.
     */
    function max(a, b, dst) {
        const newDst = (dst ?? new Ctor(2));
        newDst[0] = Math.max(a[0], b[0]);
        newDst[1] = Math.max(a[1], b[1]);
        return newDst;
    }
    /**
     * Return min values of two vectors.
     * Given vectors a and b returns
     * [min(a[0], b[0]), min(a[1], b[1]), min(a[2], b[2])].
     * @param a - Operand vector.
     * @param b - Operand vector.
     * @param dst - vector to hold result. If not passed in a new one is created.
     * @returns The min components vector.
     */
    function min(a, b, dst) {
        const newDst = (dst ?? new Ctor(2));
        newDst[0] = Math.min(a[0], b[0]);
        newDst[1] = Math.min(a[1], b[1]);
        return newDst;
    }
    /**
     * Multiplies a vector by a scalar.
     * @param v - The vector.
     * @param k - The scalar.
     * @param dst - vector to hold result. If not passed in a new one is created.
     * @returns The scaled vector.
     */
    function mulScalar(v, k, dst) {
        const newDst = (dst ?? new Ctor(2));
        newDst[0] = v[0] * k;
        newDst[1] = v[1] * k;
        return newDst;
    }
    /**
     * Multiplies a vector by a scalar. (same as mulScalar)
     * @param v - The vector.
     * @param k - The scalar.
     * @param dst - vector to hold result. If not passed in a new one is created.
     * @returns The scaled vector.
     */
    const scale = mulScalar;
    /**
     * Divides a vector by a scalar.
     * @param v - The vector.
     * @param k - The scalar.
     * @param dst - vector to hold result. If not passed in a new one is created.
     * @returns The scaled vector.
     */
    function divScalar(v, k, dst) {
        const newDst = (dst ?? new Ctor(2));
        newDst[0] = v[0] / k;
        newDst[1] = v[1] / k;
        return newDst;
    }
    /**
     * Inverse a vector.
     * @param v - The vector.
     * @param dst - vector to hold result. If not passed in a new one is created.
     * @returns The inverted vector.
     */
    function inverse(v, dst) {
        const newDst = (dst ?? new Ctor(2));
        newDst[0] = 1 / v[0];
        newDst[1] = 1 / v[1];
        return newDst;
    }
    /**
     * Invert a vector. (same as inverse)
     * @param v - The vector.
     * @param dst - vector to hold result. If not passed in a new one is created.
     * @returns The inverted vector.
     */
    const invert = inverse;
    /**
     * Computes the cross product of two vectors; assumes both vectors have
     * three entries.
     * @param a - Operand vector.
     * @param b - Operand vector.
     * @param dst - vector to hold result. If not passed in a new one is created.
     * @returns The vector of a cross b.
     */
    function cross(a, b, dst) {
        const newDst = (dst ?? new Ctor(3));
        const z = a[0] * b[1] - a[1] * b[0];
        newDst[0] = 0;
        newDst[1] = 0;
        newDst[2] = z;
        return newDst;
    }
    /**
     * Computes the dot product of two vectors; assumes both vectors have
     * three entries.
     * @param a - Operand vector.
     * @param b - Operand vector.
     * @returns dot product
     */
    function dot(a, b) {
        return a[0] * b[0] + a[1] * b[1];
    }
    /**
     * Computes the length of vector
     * @param v - vector.
     * @returns length of vector.
     */
    function length(v) {
        const v0 = v[0];
        const v1 = v[1];
        return Math.sqrt(v0 * v0 + v1 * v1);
    }
    /**
     * Computes the length of vector (same as length)
     * @param v - vector.
     * @returns length of vector.
     */
    const len = length;
    /**
     * Computes the square of the length of vector
     * @param v - vector.
     * @returns square of the length of vector.
     */
    function lengthSq(v) {
        const v0 = v[0];
        const v1 = v[1];
        return v0 * v0 + v1 * v1;
    }
    /**
     * Computes the square of the length of vector (same as lengthSq)
     * @param v - vector.
     * @returns square of the length of vector.
     */
    const lenSq = lengthSq;
    /**
     * Computes the distance between 2 points
     * @param a - vector.
     * @param b - vector.
     * @returns distance between a and b
     */
    function distance(a, b) {
        const dx = a[0] - b[0];
        const dy = a[1] - b[1];
        return Math.sqrt(dx * dx + dy * dy);
    }
    /**
     * Computes the distance between 2 points (same as distance)
     * @param a - vector.
     * @param b - vector.
     * @returns distance between a and b
     */
    const dist = distance;
    /**
     * Computes the square of the distance between 2 points
     * @param a - vector.
     * @param b - vector.
     * @returns square of the distance between a and b
     */
    function distanceSq(a, b) {
        const dx = a[0] - b[0];
        const dy = a[1] - b[1];
        return dx * dx + dy * dy;
    }
    /**
     * Computes the square of the distance between 2 points (same as distanceSq)
     * @param a - vector.
     * @param b - vector.
     * @returns square of the distance between a and b
     */
    const distSq = distanceSq;
    /**
     * Divides a vector by its Euclidean length and returns the quotient.
     * @param v - The vector.
     * @param dst - vector to hold result. If not passed in a new one is created.
     * @returns The normalized vector.
     */
    function normalize(v, dst) {
        const newDst = (dst ?? new Ctor(2));
        const v0 = v[0];
        const v1 = v[1];
        const len = Math.sqrt(v0 * v0 + v1 * v1);
        if (len > 0.00001) {
            newDst[0] = v0 / len;
            newDst[1] = v1 / len;
        }
        else {
            newDst[0] = 0;
            newDst[1] = 0;
        }
        return newDst;
    }
    /**
     * Negates a vector.
     * @param v - The vector.
     * @param dst - vector to hold result. If not passed in a new one is created.
     * @returns -v.
     */
    function negate(v, dst) {
        const newDst = (dst ?? new Ctor(2));
        newDst[0] = -v[0];
        newDst[1] = -v[1];
        return newDst;
    }
    /**
     * Copies a vector. (same as {@link vec2.clone})
     * Also see {@link vec2.create} and {@link vec2.set}
     * @param v - The vector.
     * @param dst - vector to hold result. If not passed in a new one is created.
     * @returns A copy of v.
     */
    function copy(v, dst) {
        const newDst = (dst ?? new Ctor(2));
        newDst[0] = v[0];
        newDst[1] = v[1];
        return newDst;
    }
    /**
     * Clones a vector. (same as {@link vec2.copy})
     * Also see {@link vec2.create} and {@link vec2.set}
     * @param v - The vector.
     * @param dst - vector to hold result. If not passed in a new one is created.
     * @returns A copy of v.
     */
    const clone = copy;
    /**
     * Multiplies a vector by another vector (component-wise); assumes a and
     * b have the same length.
     * @param a - Operand vector.
     * @param b - Operand vector.
     * @param dst - vector to hold result. If not passed in a new one is created.
     * @returns The vector of products of entries of a and b.
     */
    function multiply(a, b, dst) {
        const newDst = (dst ?? new Ctor(2));
        newDst[0] = a[0] * b[0];
        newDst[1] = a[1] * b[1];
        return newDst;
    }
    /**
     * Multiplies a vector by another vector (component-wise); assumes a and
     * b have the same length. (same as mul)
     * @param a - Operand vector.
     * @param b - Operand vector.
     * @param dst - vector to hold result. If not passed in a new one is created.
     * @returns The vector of products of entries of a and b.
     */
    const mul = multiply;
    /**
     * Divides a vector by another vector (component-wise); assumes a and
     * b have the same length.
     * @param a - Operand vector.
     * @param b - Operand vector.
     * @param dst - vector to hold result. If not passed in a new one is created.
     * @returns The vector of quotients of entries of a and b.
     */
    function divide(a, b, dst) {
        const newDst = (dst ?? new Ctor(2));
        newDst[0] = a[0] / b[0];
        newDst[1] = a[1] / b[1];
        return newDst;
    }
    /**
     * Divides a vector by another vector (component-wise); assumes a and
     * b have the same length. (same as divide)
     * @param a - Operand vector.
     * @param b - Operand vector.
     * @param dst - vector to hold result. If not passed in a new one is created.
     * @returns The vector of quotients of entries of a and b.
     */
    const div = divide;
    /**
     * Creates a random unit vector * scale
     * @param scale - Default 1
     * @param dst - vector to hold result. If not passed in a new one is created.
     * @returns The random vector.
     */
    function random(scale = 1, dst) {
        const newDst = (dst ?? new Ctor(2));
        const angle = Math.random() * 2 * Math.PI;
        newDst[0] = Math.cos(angle) * scale;
        newDst[1] = Math.sin(angle) * scale;
        return newDst;
    }
    /**
     * Zero's a vector
     * @param dst - vector to hold result. If not passed in a new one is created.
     * @returns The zeroed vector.
     */
    function zero(dst) {
        const newDst = (dst ?? new Ctor(2));
        newDst[0] = 0;
        newDst[1] = 0;
        return newDst;
    }
    /**
     * transform Vec2 by 4x4 matrix
     * @param v - the vector
     * @param m - The matrix.
     * @param dst - optional Vec2 to store result. If not passed a new one is created.
     * @returns the transformed vector
     */
    function transformMat4(v, m, dst) {
        const newDst = (dst ?? new Ctor(2));
        const x = v[0];
        const y = v[1];
        newDst[0] = x * m[0] + y * m[4] + m[12];
        newDst[1] = x * m[1] + y * m[5] + m[13];
        return newDst;
    }
    /**
     * Transforms vec4 by 3x3 matrix
     *
     * @param v - the vector
     * @param m - The matrix.
     * @param dst - optional Vec2 to store result. If not passed a new one is created.
     * @returns the transformed vector
     */
    function transformMat3(v, m, dst) {
        const newDst = (dst ?? new Ctor(2));
        const x = v[0];
        const y = v[1];
        newDst[0] = m[0] * x + m[4] * y + m[8];
        newDst[1] = m[1] * x + m[5] * y + m[9];
        return newDst;
    }
    /**
     * Rotate a 2D vector
     *
     * @param a The vec2 point to rotate
     * @param b The origin of the rotation
     * @param rad The angle of rotation in radians
     * @returns the rotated vector
     */
    function rotate(a, b, rad, dst) {
        const newDst = (dst ?? new Ctor(2));
        // Translate point to the origin
        const p0 = a[0] - b[0];
        const p1 = a[1] - b[1];
        const sinC = Math.sin(rad);
        const cosC = Math.cos(rad);
        //perform rotation and translate to correct position
        newDst[0] = p0 * cosC - p1 * sinC + b[0];
        newDst[1] = p0 * sinC + p1 * cosC + b[1];
        return newDst;
    }
    /**
     * Treat a 2D vector as a direction and set it's length
     *
     * @param a The vec2 to lengthen
     * @param len The length of the resulting vector
     * @returns The lengthened vector
     */
    function setLength(a, len, dst) {
        const newDst = (dst ?? new Ctor(2));
        normalize(a, newDst);
        return mulScalar(newDst, len, newDst);
    }
    /**
     * Ensure a vector is not longer than a max length
     *
     * @param a The vec2 to limit
     * @param maxLen The longest length of the resulting vector
     * @returns The vector, shortened to maxLen if it's too long
     */
    function truncate(a, maxLen, dst) {
        const newDst = (dst ?? new Ctor(2));
        if (length(a) > maxLen) {
            return setLength(a, maxLen, newDst);
        }
        return copy(a, newDst);
    }
    /**
     * Return the vector exactly between 2 endpoint vectors
     *
     * @param a Endpoint 1
     * @param b Endpoint 2
     * @returns The vector exactly residing between endpoints 1 and 2
     */
    function midpoint(a, b, dst) {
        const newDst = (dst ?? new Ctor(2));
        return lerp(a, b, 0.5, newDst);
    }
    return {
        create,
        fromValues,
        set,
        ceil,
        floor,
        round,
        clamp,
        add,
        addScaled,
        angle,
        subtract,
        sub,
        equalsApproximately,
        equals,
        lerp,
        lerpV,
        max,
        min,
        mulScalar,
        scale,
        divScalar,
        inverse,
        invert,
        cross,
        dot,
        length,
        len,
        lengthSq,
        lenSq,
        distance,
        dist,
        distanceSq,
        distSq,
        normalize,
        negate,
        copy,
        clone,
        multiply,
        mul,
        divide,
        div,
        random,
        zero,
        transformMat4,
        transformMat3,
        rotate,
        setLength,
        truncate,
        midpoint,
    };
}
const cache$5 = new Map();
function getAPI$5(Ctor) {
    let api = cache$5.get(Ctor);
    if (!api) {
        api = getAPIImpl$5(Ctor);
        cache$5.set(Ctor, api);
    }
    return api;
}

/*
 * Copyright 2022 Gregg Tavares
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */
/**
 * Generates a typed API for Mat3
 * */
function getAPIImpl$4(Ctor) {
    const vec2 = getAPI$5(Ctor);
    /**
     * Create a Mat3 from values
     *
     * Note: Since passing in a raw JavaScript array
     * is valid in all circumstances, if you want to
     * force a JavaScript array into a Mat3's specified type
     * it would be faster to use
     *
     * ```
     * const m = mat3.clone(someJSArray);
     * ```
     *
     * @param v0 - value for element 0
     * @param v1 - value for element 1
     * @param v2 - value for element 2
     * @param v3 - value for element 3
     * @param v4 - value for element 4
     * @param v5 - value for element 5
     * @param v6 - value for element 6
     * @param v7 - value for element 7
     * @param v8 - value for element 8
     * @returns matrix created from values.
     */
    function create(v0, v1, v2, v3, v4, v5, v6, v7, v8) {
        const newDst = new Ctor(12);
        // to make the array homogenous
        newDst[3] = 0;
        newDst[7] = 0;
        newDst[11] = 0;
        if (v0 !== undefined) {
            newDst[0] = v0;
            if (v1 !== undefined) {
                newDst[1] = v1;
                if (v2 !== undefined) {
                    newDst[2] = v2;
                    if (v3 !== undefined) {
                        newDst[4] = v3;
                        if (v4 !== undefined) {
                            newDst[5] = v4;
                            if (v5 !== undefined) {
                                newDst[6] = v5;
                                if (v6 !== undefined) {
                                    newDst[8] = v6;
                                    if (v7 !== undefined) {
                                        newDst[9] = v7;
                                        if (v8 !== undefined) {
                                            newDst[10] = v8;
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
        return newDst;
    }
    /**
     * Sets the values of a Mat3
     * Also see {@link mat3.create} and {@link mat3.copy}
     *
     * @param v0 - value for element 0
     * @param v1 - value for element 1
     * @param v2 - value for element 2
     * @param v3 - value for element 3
     * @param v4 - value for element 4
     * @param v5 - value for element 5
     * @param v6 - value for element 6
     * @param v7 - value for element 7
     * @param v8 - value for element 8
     * @param dst - matrix to hold result. If not passed a new one is created.
     * @returns Mat3 set from values.
     */
    function set(v0, v1, v2, v3, v4, v5, v6, v7, v8, dst) {
        const newDst = (dst ?? new Ctor(12));
        newDst[0] = v0;
        newDst[1] = v1;
        newDst[2] = v2;
        newDst[3] = 0;
        newDst[4] = v3;
        newDst[5] = v4;
        newDst[6] = v5;
        newDst[7] = 0;
        newDst[8] = v6;
        newDst[9] = v7;
        newDst[10] = v8;
        newDst[11] = 0;
        return newDst;
    }
    /**
     * Creates a Mat3 from the upper left 3x3 part of a Mat4
     * @param m4 - source matrix
     * @param dst - matrix to hold result. If not passed a new one is created.
     * @returns Mat3 made from m4
     */
    function fromMat4(m4, dst) {
        const newDst = (dst ?? new Ctor(12));
        newDst[0] = m4[0];
        newDst[1] = m4[1];
        newDst[2] = m4[2];
        newDst[3] = 0;
        newDst[4] = m4[4];
        newDst[5] = m4[5];
        newDst[6] = m4[6];
        newDst[7] = 0;
        newDst[8] = m4[8];
        newDst[9] = m4[9];
        newDst[10] = m4[10];
        newDst[11] = 0;
        return newDst;
    }
    /**
     * Creates a Mat3 rotation matrix from a quaternion
     * @param q - quaternion to create matrix from
     * @param dst - matrix to hold result. If not passed a new one is created.
     * @returns Mat3 made from q
     */
    function fromQuat(q, dst) {
        const newDst = (dst ?? new Ctor(12));
        const x = q[0];
        const y = q[1];
        const z = q[2];
        const w = q[3];
        const x2 = x + x;
        const y2 = y + y;
        const z2 = z + z;
        const xx = x * x2;
        const yx = y * x2;
        const yy = y * y2;
        const zx = z * x2;
        const zy = z * y2;
        const zz = z * z2;
        const wx = w * x2;
        const wy = w * y2;
        const wz = w * z2;
        newDst[0] = 1 - yy - zz;
        newDst[1] = yx + wz;
        newDst[2] = zx - wy;
        newDst[3] = 0;
        newDst[4] = yx - wz;
        newDst[5] = 1 - xx - zz;
        newDst[6] = zy + wx;
        newDst[7] = 0;
        newDst[8] = zx + wy;
        newDst[9] = zy - wx;
        newDst[10] = 1 - xx - yy;
        newDst[11] = 0;
        return newDst;
    }
    /**
     * Negates a matrix.
     * @param m - The matrix.
     * @param dst - matrix to hold result. If not passed a new one is created.
     * @returns -m.
     */
    function negate(m, dst) {
        const newDst = (dst ?? new Ctor(12));
        newDst[0] = -m[0];
        newDst[1] = -m[1];
        newDst[2] = -m[2];
        newDst[4] = -m[4];
        newDst[5] = -m[5];
        newDst[6] = -m[6];
        newDst[8] = -m[8];
        newDst[9] = -m[9];
        newDst[10] = -m[10];
        return newDst;
    }
    /**
     * Copies a matrix. (same as {@link mat3.clone})
     * Also see {@link mat3.create} and {@link mat3.set}
     * @param m - The matrix.
     * @param dst - The matrix. If not passed a new one is created.
     * @returns A copy of m.
     */
    function copy(m, dst) {
        const newDst = (dst ?? new Ctor(12));
        newDst[0] = m[0];
        newDst[1] = m[1];
        newDst[2] = m[2];
        newDst[4] = m[4];
        newDst[5] = m[5];
        newDst[6] = m[6];
        newDst[8] = m[8];
        newDst[9] = m[9];
        newDst[10] = m[10];
        return newDst;
    }
    /**
     * Copies a matrix (same as {@link mat3.copy})
     * Also see {@link mat3.create} and {@link mat3.set}
     * @param m - The matrix.
     * @param dst - The matrix. If not passed a new one is created.
     * @returns A copy of m.
     */
    const clone = copy;
    /**
     * Check if 2 matrices are approximately equal
     * @param a Operand matrix.
     * @param b Operand matrix.
     * @returns true if matrices are approximately equal
     */
    function equalsApproximately(a, b) {
        return Math.abs(a[0] - b[0]) < EPSILON &&
            Math.abs(a[1] - b[1]) < EPSILON &&
            Math.abs(a[2] - b[2]) < EPSILON &&
            Math.abs(a[4] - b[4]) < EPSILON &&
            Math.abs(a[5] - b[5]) < EPSILON &&
            Math.abs(a[6] - b[6]) < EPSILON &&
            Math.abs(a[8] - b[8]) < EPSILON &&
            Math.abs(a[9] - b[9]) < EPSILON &&
            Math.abs(a[10] - b[10]) < EPSILON;
    }
    /**
     * Check if 2 matrices are exactly equal
     * @param a Operand matrix.
     * @param b Operand matrix.
     * @returns true if matrices are exactly equal
     */
    function equals(a, b) {
        return a[0] === b[0] &&
            a[1] === b[1] &&
            a[2] === b[2] &&
            a[4] === b[4] &&
            a[5] === b[5] &&
            a[6] === b[6] &&
            a[8] === b[8] &&
            a[9] === b[9] &&
            a[10] === b[10];
    }
    /**
     * Creates a 3-by-3 identity matrix.
     *
     * @param dst - matrix to hold result. If not passed a new one is created.
     * @returns A 3-by-3 identity matrix.
     */
    function identity(dst) {
        const newDst = (dst ?? new Ctor(12));
        newDst[0] = 1;
        newDst[1] = 0;
        newDst[2] = 0;
        newDst[4] = 0;
        newDst[5] = 1;
        newDst[6] = 0;
        newDst[8] = 0;
        newDst[9] = 0;
        newDst[10] = 1;
        return newDst;
    }
    /**
     * Takes the transpose of a matrix.
     * @param m - The matrix.
     * @param dst - matrix to hold result. If not passed a new one is created.
     * @returns The transpose of m.
     */
    function transpose(m, dst) {
        const newDst = (dst ?? new Ctor(12));
        if (newDst === m) {
            let t;
            // 0 1 2
            // 4 5 6
            // 8 9 10
            t = m[1];
            m[1] = m[4];
            m[4] = t;
            t = m[2];
            m[2] = m[8];
            m[8] = t;
            t = m[6];
            m[6] = m[9];
            m[9] = t;
            return newDst;
        }
        const m00 = m[0 * 4 + 0];
        const m01 = m[0 * 4 + 1];
        const m02 = m[0 * 4 + 2];
        const m10 = m[1 * 4 + 0];
        const m11 = m[1 * 4 + 1];
        const m12 = m[1 * 4 + 2];
        const m20 = m[2 * 4 + 0];
        const m21 = m[2 * 4 + 1];
        const m22 = m[2 * 4 + 2];
        newDst[0] = m00;
        newDst[1] = m10;
        newDst[2] = m20;
        newDst[4] = m01;
        newDst[5] = m11;
        newDst[6] = m21;
        newDst[8] = m02;
        newDst[9] = m12;
        newDst[10] = m22;
        return newDst;
    }
    /**
     * Computes the inverse of a 3-by-3 matrix.
     * @param m - The matrix.
     * @param dst - matrix to hold result. If not passed a new one is created.
     * @returns The inverse of m.
     */
    function inverse(m, dst) {
        const newDst = (dst ?? new Ctor(12));
        const m00 = m[0 * 4 + 0];
        const m01 = m[0 * 4 + 1];
        const m02 = m[0 * 4 + 2];
        const m10 = m[1 * 4 + 0];
        const m11 = m[1 * 4 + 1];
        const m12 = m[1 * 4 + 2];
        const m20 = m[2 * 4 + 0];
        const m21 = m[2 * 4 + 1];
        const m22 = m[2 * 4 + 2];
        const b01 = m22 * m11 - m12 * m21;
        const b11 = -m22 * m10 + m12 * m20;
        const b21 = m21 * m10 - m11 * m20;
        const invDet = 1 / (m00 * b01 + m01 * b11 + m02 * b21);
        newDst[0] = b01 * invDet;
        newDst[1] = (-m22 * m01 + m02 * m21) * invDet;
        newDst[2] = (m12 * m01 - m02 * m11) * invDet;
        newDst[4] = b11 * invDet;
        newDst[5] = (m22 * m00 - m02 * m20) * invDet;
        newDst[6] = (-m12 * m00 + m02 * m10) * invDet;
        newDst[8] = b21 * invDet;
        newDst[9] = (-m21 * m00 + m01 * m20) * invDet;
        newDst[10] = (m11 * m00 - m01 * m10) * invDet;
        return newDst;
    }
    /**
     * Compute the determinant of a matrix
     * @param m - the matrix
     * @returns the determinant
     */
    function determinant(m) {
        const m00 = m[0 * 4 + 0];
        const m01 = m[0 * 4 + 1];
        const m02 = m[0 * 4 + 2];
        const m10 = m[1 * 4 + 0];
        const m11 = m[1 * 4 + 1];
        const m12 = m[1 * 4 + 2];
        const m20 = m[2 * 4 + 0];
        const m21 = m[2 * 4 + 1];
        const m22 = m[2 * 4 + 2];
        return m00 * (m11 * m22 - m21 * m12) -
            m10 * (m01 * m22 - m21 * m02) +
            m20 * (m01 * m12 - m11 * m02);
    }
    /**
     * Computes the inverse of a 3-by-3 matrix. (same as inverse)
     * @param m - The matrix.
     * @param dst - matrix to hold result. If not passed a new one is created.
     * @returns The inverse of m.
     */
    const invert = inverse;
    /**
     * Multiplies two 3-by-3 matrices with a on the left and b on the right
     * @param a - The matrix on the left.
     * @param b - The matrix on the right.
     * @param dst - matrix to hold result. If not passed a new one is created.
     * @returns The matrix product of a and b.
     */
    function multiply(a, b, dst) {
        const newDst = (dst ?? new Ctor(12));
        const a00 = a[0];
        const a01 = a[1];
        const a02 = a[2];
        const a10 = a[4 + 0];
        const a11 = a[4 + 1];
        const a12 = a[4 + 2];
        const a20 = a[8 + 0];
        const a21 = a[8 + 1];
        const a22 = a[8 + 2];
        const b00 = b[0];
        const b01 = b[1];
        const b02 = b[2];
        const b10 = b[4 + 0];
        const b11 = b[4 + 1];
        const b12 = b[4 + 2];
        const b20 = b[8 + 0];
        const b21 = b[8 + 1];
        const b22 = b[8 + 2];
        newDst[0] = a00 * b00 + a10 * b01 + a20 * b02;
        newDst[1] = a01 * b00 + a11 * b01 + a21 * b02;
        newDst[2] = a02 * b00 + a12 * b01 + a22 * b02;
        newDst[4] = a00 * b10 + a10 * b11 + a20 * b12;
        newDst[5] = a01 * b10 + a11 * b11 + a21 * b12;
        newDst[6] = a02 * b10 + a12 * b11 + a22 * b12;
        newDst[8] = a00 * b20 + a10 * b21 + a20 * b22;
        newDst[9] = a01 * b20 + a11 * b21 + a21 * b22;
        newDst[10] = a02 * b20 + a12 * b21 + a22 * b22;
        return newDst;
    }
    /**
     * Multiplies two 3-by-3 matrices with a on the left and b on the right (same as multiply)
     * @param a - The matrix on the left.
     * @param b - The matrix on the right.
     * @param dst - matrix to hold result. If not passed a new one is created.
     * @returns The matrix product of a and b.
     */
    const mul = multiply;
    /**
     * Sets the translation component of a 3-by-3 matrix to the given
     * vector.
     * @param a - The matrix.
     * @param v - The vector.
     * @param dst - matrix to hold result. If not passed a new one is created.
     * @returns The matrix with translation set.
     */
    function setTranslation(a, v, dst) {
        const newDst = (dst ?? identity());
        if (a !== newDst) {
            newDst[0] = a[0];
            newDst[1] = a[1];
            newDst[2] = a[2];
            newDst[4] = a[4];
            newDst[5] = a[5];
            newDst[6] = a[6];
        }
        newDst[8] = v[0];
        newDst[9] = v[1];
        newDst[10] = 1;
        return newDst;
    }
    /**
     * Returns the translation component of a 3-by-3 matrix as a vector with 3
     * entries.
     * @param m - The matrix.
     * @param dst - vector to hold result. If not passed a new one is created.
     * @returns The translation component of m.
     */
    function getTranslation(m, dst) {
        const newDst = (dst ?? vec2.create());
        newDst[0] = m[8];
        newDst[1] = m[9];
        return newDst;
    }
    /**
     * Returns an axis of a 3x3 matrix as a vector with 2 entries
     * @param m - The matrix.
     * @param axis - The axis 0 = x, 1 = y,
     * @returns The axis component of m.
     */
    function getAxis(m, axis, dst) {
        const newDst = (dst ?? vec2.create());
        const off = axis * 4;
        newDst[0] = m[off + 0];
        newDst[1] = m[off + 1];
        return newDst;
    }
    /**
     * Sets an axis of a 3x3 matrix as a vector with 2 entries
     * @param m - The matrix.
     * @param v - the axis vector
     * @param axis - The axis  0 = x, 1 = y;
     * @param dst - The matrix to set. If not passed a new one is created.
     * @returns The matrix with axis set.
     */
    function setAxis(m, v, axis, dst) {
        const newDst = (dst === m ? m : copy(m, dst));
        const off = axis * 4;
        newDst[off + 0] = v[0];
        newDst[off + 1] = v[1];
        return newDst;
    }
    ///**
    // * Returns the scaling component of the matrix
    // * @param m - The Matrix
    // * @param dst - The vector to set. If not passed a new one is created.
    // */
    function getScaling(m, dst) {
        const newDst = (dst ?? vec2.create());
        const xx = m[0];
        const xy = m[1];
        const yx = m[4];
        const yy = m[5];
        newDst[0] = Math.sqrt(xx * xx + xy * xy);
        newDst[1] = Math.sqrt(yx * yx + yy * yy);
        return newDst;
    }
    /**
     * Creates a 3-by-3 matrix which translates by the given vector v.
     * @param v - The vector by which to translate.
     * @param dst - matrix to hold result. If not passed a new one is created.
     * @returns The translation matrix.
     */
    function translation(v, dst) {
        const newDst = (dst ?? new Ctor(12));
        newDst[0] = 1;
        newDst[1] = 0;
        newDst[2] = 0;
        newDst[4] = 0;
        newDst[5] = 1;
        newDst[6] = 0;
        newDst[8] = v[0];
        newDst[9] = v[1];
        newDst[10] = 1;
        return newDst;
    }
    /**
     * Translates the given 3-by-3 matrix by the given vector v.
     * @param m - The matrix.
     * @param v - The vector by which to translate.
     * @param dst - matrix to hold result. If not passed a new one is created.
     * @returns The translated matrix.
     */
    function translate(m, v, dst) {
        const newDst = (dst ?? new Ctor(12));
        const v0 = v[0];
        const v1 = v[1];
        const m00 = m[0];
        const m01 = m[1];
        const m02 = m[2];
        const m10 = m[1 * 4 + 0];
        const m11 = m[1 * 4 + 1];
        const m12 = m[1 * 4 + 2];
        const m20 = m[2 * 4 + 0];
        const m21 = m[2 * 4 + 1];
        const m22 = m[2 * 4 + 2];
        if (m !== newDst) {
            newDst[0] = m00;
            newDst[1] = m01;
            newDst[2] = m02;
            newDst[4] = m10;
            newDst[5] = m11;
            newDst[6] = m12;
        }
        newDst[8] = m00 * v0 + m10 * v1 + m20;
        newDst[9] = m01 * v0 + m11 * v1 + m21;
        newDst[10] = m02 * v0 + m12 * v1 + m22;
        return newDst;
    }
    /**
     * Creates a 3-by-3 matrix which rotates  by the given angle.
     * @param angleInRadians - The angle by which to rotate (in radians).
     * @param dst - matrix to hold result. If not passed a new one is created.
     * @returns The rotation matrix.
     */
    function rotation(angleInRadians, dst) {
        const newDst = (dst ?? new Ctor(12));
        const c = Math.cos(angleInRadians);
        const s = Math.sin(angleInRadians);
        newDst[0] = c;
        newDst[1] = s;
        newDst[2] = 0;
        newDst[4] = -s;
        newDst[5] = c;
        newDst[6] = 0;
        newDst[8] = 0;
        newDst[9] = 0;
        newDst[10] = 1;
        return newDst;
    }
    /**
     * Rotates the given 3-by-3 matrix  by the given angle.
     * @param m - The matrix.
     * @param angleInRadians - The angle by which to rotate (in radians).
     * @param dst - matrix to hold result. If not passed a new one is created.
     * @returns The rotated matrix.
     */
    function rotate(m, angleInRadians, dst) {
        const newDst = (dst ?? new Ctor(12));
        const m00 = m[0 * 4 + 0];
        const m01 = m[0 * 4 + 1];
        const m02 = m[0 * 4 + 2];
        const m10 = m[1 * 4 + 0];
        const m11 = m[1 * 4 + 1];
        const m12 = m[1 * 4 + 2];
        const c = Math.cos(angleInRadians);
        const s = Math.sin(angleInRadians);
        newDst[0] = c * m00 + s * m10;
        newDst[1] = c * m01 + s * m11;
        newDst[2] = c * m02 + s * m12;
        newDst[4] = c * m10 - s * m00;
        newDst[5] = c * m11 - s * m01;
        newDst[6] = c * m12 - s * m02;
        if (m !== newDst) {
            newDst[8] = m[8];
            newDst[9] = m[9];
            newDst[10] = m[10];
        }
        return newDst;
    }
    /**
     * Creates a 3-by-3 matrix which scales in each dimension by an amount given by
     * the corresponding entry in the given vector; assumes the vector has three
     * entries.
     * @param v - A vector of
     *     2 entries specifying the factor by which to scale in each dimension.
     * @param dst - matrix to hold result. If not passed a new one is created.
     * @returns The scaling matrix.
     */
    function scaling(v, dst) {
        const newDst = (dst ?? new Ctor(12));
        newDst[0] = v[0];
        newDst[1] = 0;
        newDst[2] = 0;
        newDst[4] = 0;
        newDst[5] = v[1];
        newDst[6] = 0;
        newDst[8] = 0;
        newDst[9] = 0;
        newDst[10] = 1;
        return newDst;
    }
    /**
     * Scales the given 3-by-3 matrix in each dimension by an amount
     * given by the corresponding entry in the given vector; assumes the vector has
     * three entries.
     * @param m - The matrix to be modified.
     * @param v - A vector of 2 entries specifying the
     *     factor by which to scale in each dimension.
     * @param dst - matrix to hold result. If not passed a new one is created.
     * @returns The scaled matrix.
     */
    function scale(m, v, dst) {
        const newDst = (dst ?? new Ctor(12));
        const v0 = v[0];
        const v1 = v[1];
        newDst[0] = v0 * m[0 * 4 + 0];
        newDst[1] = v0 * m[0 * 4 + 1];
        newDst[2] = v0 * m[0 * 4 + 2];
        newDst[4] = v1 * m[1 * 4 + 0];
        newDst[5] = v1 * m[1 * 4 + 1];
        newDst[6] = v1 * m[1 * 4 + 2];
        if (m !== newDst) {
            newDst[8] = m[8];
            newDst[9] = m[9];
            newDst[10] = m[10];
        }
        return newDst;
    }
    /**
     * Creates a 3-by-3 matrix which scales uniformly in each dimension
     * @param s - Amount to scale
     * @param dst - matrix to hold result. If not passed a new one is created.
     * @returns The scaling matrix.
     */
    function uniformScaling(s, dst) {
        const newDst = (dst ?? new Ctor(12));
        newDst[0] = s;
        newDst[1] = 0;
        newDst[2] = 0;
        newDst[4] = 0;
        newDst[5] = s;
        newDst[6] = 0;
        newDst[8] = 0;
        newDst[9] = 0;
        newDst[10] = 1;
        return newDst;
    }
    /**
     * Scales the given 3-by-3 matrix in each dimension by an amount
     * given.
     * @param m - The matrix to be modified.
     * @param s - Amount to scale.
     * @param dst - matrix to hold result. If not passed a new one is created.
     * @returns The scaled matrix.
     */
    function uniformScale(m, s, dst) {
        const newDst = (dst ?? new Ctor(12));
        newDst[0] = s * m[0 * 4 + 0];
        newDst[1] = s * m[0 * 4 + 1];
        newDst[2] = s * m[0 * 4 + 2];
        newDst[4] = s * m[1 * 4 + 0];
        newDst[5] = s * m[1 * 4 + 1];
        newDst[6] = s * m[1 * 4 + 2];
        if (m !== newDst) {
            newDst[8] = m[8];
            newDst[9] = m[9];
            newDst[10] = m[10];
        }
        return newDst;
    }
    return {
        clone,
        create,
        set,
        fromMat4,
        fromQuat,
        negate,
        copy,
        equalsApproximately,
        equals,
        identity,
        transpose,
        inverse,
        invert,
        determinant,
        mul,
        multiply,
        setTranslation,
        getTranslation,
        getAxis,
        setAxis,
        getScaling,
        translation,
        translate,
        rotation,
        rotate,
        scaling,
        scale,
        uniformScaling,
        uniformScale,
    };
}
const cache$4 = new Map();
function getAPI$4(Ctor) {
    let api = cache$4.get(Ctor);
    if (!api) {
        api = getAPIImpl$4(Ctor);
        cache$4.set(Ctor, api);
    }
    return api;
}

/*
 * Copyright 2022 Gregg Tavares
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */
/**
 * Generates am typed API for Vec3
 * */
function getAPIImpl$3(Ctor) {
    /**
     * Creates a vec3; may be called with x, y, z to set initial values.
     * @param x - Initial x value.
     * @param y - Initial y value.
     * @param z - Initial z value.
     * @returns the created vector
     */
    function create(x, y, z) {
        const newDst = new Ctor(3);
        if (x !== undefined) {
            newDst[0] = x;
            if (y !== undefined) {
                newDst[1] = y;
                if (z !== undefined) {
                    newDst[2] = z;
                }
            }
        }
        return newDst;
    }
    /**
     * Creates a vec3; may be called with x, y, z to set initial values. (same as create)
     * @param x - Initial x value.
     * @param y - Initial y value.
     * @param z - Initial z value.
     * @returns the created vector
     */
    const fromValues = create;
    /**
     * Sets the values of a Vec3
     * Also see {@link vec3.create} and {@link vec3.copy}
     *
     * @param x first value
     * @param y second value
     * @param z third value
     * @param dst - vector to hold result. If not passed in a new one is created.
     * @returns A vector with its elements set.
     */
    function set(x, y, z, dst) {
        const newDst = (dst ?? new Ctor(3));
        newDst[0] = x;
        newDst[1] = y;
        newDst[2] = z;
        return newDst;
    }
    /**
     * Applies Math.ceil to each element of vector
     * @param v - Operand vector.
     * @param dst - vector to hold result. If not passed in a new one is created.
     * @returns A vector that is the ceil of each element of v.
     */
    function ceil(v, dst) {
        const newDst = (dst ?? new Ctor(3));
        newDst[0] = Math.ceil(v[0]);
        newDst[1] = Math.ceil(v[1]);
        newDst[2] = Math.ceil(v[2]);
        return newDst;
    }
    /**
     * Applies Math.floor to each element of vector
     * @param v - Operand vector.
     * @param dst - vector to hold result. If not passed in a new one is created.
     * @returns A vector that is the floor of each element of v.
     */
    function floor(v, dst) {
        const newDst = (dst ?? new Ctor(3));
        newDst[0] = Math.floor(v[0]);
        newDst[1] = Math.floor(v[1]);
        newDst[2] = Math.floor(v[2]);
        return newDst;
    }
    /**
     * Applies Math.round to each element of vector
     * @param v - Operand vector.
     * @param dst - vector to hold result. If not passed in a new one is created.
     * @returns A vector that is the round of each element of v.
     */
    function round(v, dst) {
        const newDst = (dst ?? new Ctor(3));
        newDst[0] = Math.round(v[0]);
        newDst[1] = Math.round(v[1]);
        newDst[2] = Math.round(v[2]);
        return newDst;
    }
    /**
     * Clamp each element of vector between min and max
     * @param v - Operand vector.
     * @param max - Min value, default 0
     * @param min - Max value, default 1
     * @param dst - vector to hold result. If not passed in a new one is created.
     * @returns A vector that the clamped value of each element of v.
     */
    function clamp(v, min = 0, max = 1, dst) {
        const newDst = (dst ?? new Ctor(3));
        newDst[0] = Math.min(max, Math.max(min, v[0]));
        newDst[1] = Math.min(max, Math.max(min, v[1]));
        newDst[2] = Math.min(max, Math.max(min, v[2]));
        return newDst;
    }
    /**
     * Adds two vectors; assumes a and b have the same dimension.
     * @param a - Operand vector.
     * @param b - Operand vector.
     * @param dst - vector to hold result. If not passed in a new one is created.
     * @returns A vector that is the sum of a and b.
     */
    function add(a, b, dst) {
        const newDst = (dst ?? new Ctor(3));
        newDst[0] = a[0] + b[0];
        newDst[1] = a[1] + b[1];
        newDst[2] = a[2] + b[2];
        return newDst;
    }
    /**
     * Adds two vectors, scaling the 2nd; assumes a and b have the same dimension.
     * @param a - Operand vector.
     * @param b - Operand vector.
     * @param scale - Amount to scale b
     * @param dst - vector to hold result. If not passed in a new one is created.
     * @returns A vector that is the sum of a + b * scale.
     */
    function addScaled(a, b, scale, dst) {
        const newDst = (dst ?? new Ctor(3));
        newDst[0] = a[0] + b[0] * scale;
        newDst[1] = a[1] + b[1] * scale;
        newDst[2] = a[2] + b[2] * scale;
        return newDst;
    }
    /**
     * Returns the angle in radians between two vectors.
     * @param a - Operand vector.
     * @param b - Operand vector.
     * @returns The angle in radians between the 2 vectors.
     */
    function angle(a, b) {
        const ax = a[0];
        const ay = a[1];
        const az = a[2];
        const bx = b[0];
        const by = b[1];
        const bz = b[2];
        const mag1 = Math.sqrt(ax * ax + ay * ay + az * az);
        const mag2 = Math.sqrt(bx * bx + by * by + bz * bz);
        const mag = mag1 * mag2;
        const cosine = mag && dot(a, b) / mag;
        return Math.acos(cosine);
    }
    /**
     * Subtracts two vectors.
     * @param a - Operand vector.
     * @param b - Operand vector.
     * @param dst - vector to hold result. If not passed in a new one is created.
     * @returns A vector that is the difference of a and b.
     */
    function subtract(a, b, dst) {
        const newDst = (dst ?? new Ctor(3));
        newDst[0] = a[0] - b[0];
        newDst[1] = a[1] - b[1];
        newDst[2] = a[2] - b[2];
        return newDst;
    }
    /**
     * Subtracts two vectors.
     * @param a - Operand vector.
     * @param b - Operand vector.
     * @param dst - vector to hold result. If not passed in a new one is created.
     * @returns A vector that is the difference of a and b.
     */
    const sub = subtract;
    /**
     * Check if 2 vectors are approximately equal
     * @param a - Operand vector.
     * @param b - Operand vector.
     * @returns true if vectors are approximately equal
     */
    function equalsApproximately(a, b) {
        return Math.abs(a[0] - b[0]) < EPSILON &&
            Math.abs(a[1] - b[1]) < EPSILON &&
            Math.abs(a[2] - b[2]) < EPSILON;
    }
    /**
     * Check if 2 vectors are exactly equal
     * @param a - Operand vector.
     * @param b - Operand vector.
     * @returns true if vectors are exactly equal
     */
    function equals(a, b) {
        return a[0] === b[0] && a[1] === b[1] && a[2] === b[2];
    }
    /**
     * Performs linear interpolation on two vectors.
     * Given vectors a and b and interpolation coefficient t, returns
     * a + t * (b - a).
     * @param a - Operand vector.
     * @param b - Operand vector.
     * @param t - Interpolation coefficient.
     * @param dst - vector to hold result. If not passed in a new one is created.
     * @returns The linear interpolated result.
     */
    function lerp(a, b, t, dst) {
        const newDst = (dst ?? new Ctor(3));
        newDst[0] = a[0] + t * (b[0] - a[0]);
        newDst[1] = a[1] + t * (b[1] - a[1]);
        newDst[2] = a[2] + t * (b[2] - a[2]);
        return newDst;
    }
    /**
     * Performs linear interpolation on two vectors.
     * Given vectors a and b and interpolation coefficient vector t, returns
     * a + t * (b - a).
     * @param a - Operand vector.
     * @param b - Operand vector.
     * @param t - Interpolation coefficients vector.
     * @param dst - vector to hold result. If not passed in a new one is created.
     * @returns the linear interpolated result.
     */
    function lerpV(a, b, t, dst) {
        const newDst = (dst ?? new Ctor(3));
        newDst[0] = a[0] + t[0] * (b[0] - a[0]);
        newDst[1] = a[1] + t[1] * (b[1] - a[1]);
        newDst[2] = a[2] + t[2] * (b[2] - a[2]);
        return newDst;
    }
    /**
     * Return max values of two vectors.
     * Given vectors a and b returns
     * [max(a[0], b[0]), max(a[1], b[1]), max(a[2], b[2])].
     * @param a - Operand vector.
     * @param b - Operand vector.
     * @param dst - vector to hold result. If not passed in a new one is created.
     * @returns The max components vector.
     */
    function max(a, b, dst) {
        const newDst = (dst ?? new Ctor(3));
        newDst[0] = Math.max(a[0], b[0]);
        newDst[1] = Math.max(a[1], b[1]);
        newDst[2] = Math.max(a[2], b[2]);
        return newDst;
    }
    /**
     * Return min values of two vectors.
     * Given vectors a and b returns
     * [min(a[0], b[0]), min(a[1], b[1]), min(a[2], b[2])].
     * @param a - Operand vector.
     * @param b - Operand vector.
     * @param dst - vector to hold result. If not passed in a new one is created.
     * @returns The min components vector.
     */
    function min(a, b, dst) {
        const newDst = (dst ?? new Ctor(3));
        newDst[0] = Math.min(a[0], b[0]);
        newDst[1] = Math.min(a[1], b[1]);
        newDst[2] = Math.min(a[2], b[2]);
        return newDst;
    }
    /**
     * Multiplies a vector by a scalar.
     * @param v - The vector.
     * @param k - The scalar.
     * @param dst - vector to hold result. If not passed in a new one is created.
     * @returns The scaled vector.
     */
    function mulScalar(v, k, dst) {
        const newDst = (dst ?? new Ctor(3));
        newDst[0] = v[0] * k;
        newDst[1] = v[1] * k;
        newDst[2] = v[2] * k;
        return newDst;
    }
    /**
     * Multiplies a vector by a scalar. (same as mulScalar)
     * @param v - The vector.
     * @param k - The scalar.
     * @param dst - vector to hold result. If not passed in a new one is created.
     * @returns The scaled vector.
     */
    const scale = mulScalar;
    /**
     * Divides a vector by a scalar.
     * @param v - The vector.
     * @param k - The scalar.
     * @param dst - vector to hold result. If not passed in a new one is created.
     * @returns The scaled vector.
     */
    function divScalar(v, k, dst) {
        const newDst = (dst ?? new Ctor(3));
        newDst[0] = v[0] / k;
        newDst[1] = v[1] / k;
        newDst[2] = v[2] / k;
        return newDst;
    }
    /**
     * Inverse a vector.
     * @param v - The vector.
     * @param dst - vector to hold result. If not passed in a new one is created.
     * @returns The inverted vector.
     */
    function inverse(v, dst) {
        const newDst = (dst ?? new Ctor(3));
        newDst[0] = 1 / v[0];
        newDst[1] = 1 / v[1];
        newDst[2] = 1 / v[2];
        return newDst;
    }
    /**
     * Invert a vector. (same as inverse)
     * @param v - The vector.
     * @param dst - vector to hold result. If not passed in a new one is created.
     * @returns The inverted vector.
     */
    const invert = inverse;
    /**
     * Computes the cross product of two vectors; assumes both vectors have
     * three entries.
     * @param a - Operand vector.
     * @param b - Operand vector.
     * @param dst - vector to hold result. If not passed in a new one is created.
     * @returns The vector of a cross b.
     */
    function cross(a, b, dst) {
        const newDst = (dst ?? new Ctor(3));
        const t1 = a[2] * b[0] - a[0] * b[2];
        const t2 = a[0] * b[1] - a[1] * b[0];
        newDst[0] = a[1] * b[2] - a[2] * b[1];
        newDst[1] = t1;
        newDst[2] = t2;
        return newDst;
    }
    /**
     * Computes the dot product of two vectors; assumes both vectors have
     * three entries.
     * @param a - Operand vector.
     * @param b - Operand vector.
     * @returns dot product
     */
    function dot(a, b) {
        return (a[0] * b[0]) + (a[1] * b[1]) + (a[2] * b[2]);
    }
    /**
     * Computes the length of vector
     * @param v - vector.
     * @returns length of vector.
     */
    function length(v) {
        const v0 = v[0];
        const v1 = v[1];
        const v2 = v[2];
        return Math.sqrt(v0 * v0 + v1 * v1 + v2 * v2);
    }
    /**
     * Computes the length of vector (same as length)
     * @param v - vector.
     * @returns length of vector.
     */
    const len = length;
    /**
     * Computes the square of the length of vector
     * @param v - vector.
     * @returns square of the length of vector.
     */
    function lengthSq(v) {
        const v0 = v[0];
        const v1 = v[1];
        const v2 = v[2];
        return v0 * v0 + v1 * v1 + v2 * v2;
    }
    /**
     * Computes the square of the length of vector (same as lengthSq)
     * @param v - vector.
     * @returns square of the length of vector.
     */
    const lenSq = lengthSq;
    /**
     * Computes the distance between 2 points
     * @param a - vector.
     * @param b - vector.
     * @returns distance between a and b
     */
    function distance(a, b) {
        const dx = a[0] - b[0];
        const dy = a[1] - b[1];
        const dz = a[2] - b[2];
        return Math.sqrt(dx * dx + dy * dy + dz * dz);
    }
    /**
     * Computes the distance between 2 points (same as distance)
     * @param a - vector.
     * @param b - vector.
     * @returns distance between a and b
     */
    const dist = distance;
    /**
     * Computes the square of the distance between 2 points
     * @param a - vector.
     * @param b - vector.
     * @returns square of the distance between a and b
     */
    function distanceSq(a, b) {
        const dx = a[0] - b[0];
        const dy = a[1] - b[1];
        const dz = a[2] - b[2];
        return dx * dx + dy * dy + dz * dz;
    }
    /**
     * Computes the square of the distance between 2 points (same as distanceSq)
     * @param a - vector.
     * @param b - vector.
     * @returns square of the distance between a and b
     */
    const distSq = distanceSq;
    /**
     * Divides a vector by its Euclidean length and returns the quotient.
     * @param v - The vector.
     * @param dst - vector to hold result. If not passed in a new one is created.
     * @returns The normalized vector.
     */
    function normalize(v, dst) {
        const newDst = (dst ?? new Ctor(3));
        const v0 = v[0];
        const v1 = v[1];
        const v2 = v[2];
        const len = Math.sqrt(v0 * v0 + v1 * v1 + v2 * v2);
        if (len > 0.00001) {
            newDst[0] = v0 / len;
            newDst[1] = v1 / len;
            newDst[2] = v2 / len;
        }
        else {
            newDst[0] = 0;
            newDst[1] = 0;
            newDst[2] = 0;
        }
        return newDst;
    }
    /**
     * Negates a vector.
     * @param v - The vector.
     * @param dst - vector to hold result. If not passed in a new one is created.
     * @returns -v.
     */
    function negate(v, dst) {
        const newDst = (dst ?? new Ctor(3));
        newDst[0] = -v[0];
        newDst[1] = -v[1];
        newDst[2] = -v[2];
        return newDst;
    }
    /**
     * Copies a vector. (same as {@link vec3.clone})
     * Also see {@link vec3.create} and {@link vec3.set}
     * @param v - The vector.
     * @param dst - vector to hold result. If not passed in a new one is created.
     * @returns A copy of v.
     */
    function copy(v, dst) {
        const newDst = (dst ?? new Ctor(3));
        newDst[0] = v[0];
        newDst[1] = v[1];
        newDst[2] = v[2];
        return newDst;
    }
    /**
     * Clones a vector. (same as {@link vec3.copy})
     * Also see {@link vec3.create} and {@link vec3.set}
     * @param v - The vector.
     * @param dst - vector to hold result. If not passed in a new one is created.
     * @returns A copy of v.
     */
    const clone = copy;
    /**
     * Multiplies a vector by another vector (component-wise); assumes a and
     * b have the same length.
     * @param a - Operand vector.
     * @param b - Operand vector.
     * @param dst - vector to hold result. If not passed in a new one is created.
     * @returns The vector of products of entries of a and b.
     */
    function multiply(a, b, dst) {
        const newDst = (dst ?? new Ctor(3));
        newDst[0] = a[0] * b[0];
        newDst[1] = a[1] * b[1];
        newDst[2] = a[2] * b[2];
        return newDst;
    }
    /**
     * Multiplies a vector by another vector (component-wise); assumes a and
     * b have the same length. (same as mul)
     * @param a - Operand vector.
     * @param b - Operand vector.
     * @param dst - vector to hold result. If not passed in a new one is created.
     * @returns The vector of products of entries of a and b.
     */
    const mul = multiply;
    /**
     * Divides a vector by another vector (component-wise); assumes a and
     * b have the same length.
     * @param a - Operand vector.
     * @param b - Operand vector.
     * @param dst - vector to hold result. If not passed in a new one is created.
     * @returns The vector of quotients of entries of a and b.
     */
    function divide(a, b, dst) {
        const newDst = (dst ?? new Ctor(3));
        newDst[0] = a[0] / b[0];
        newDst[1] = a[1] / b[1];
        newDst[2] = a[2] / b[2];
        return newDst;
    }
    /**
     * Divides a vector by another vector (component-wise); assumes a and
     * b have the same length. (same as divide)
     * @param a - Operand vector.
     * @param b - Operand vector.
     * @param dst - vector to hold result. If not passed in a new one is created.
     * @returns The vector of quotients of entries of a and b.
     */
    const div = divide;
    /**
     * Creates a random vector
     * @param scale - Default 1
     * @param dst - vector to hold result. If not passed in a new one is created.
     * @returns The random vector.
     */
    function random(scale = 1, dst) {
        const newDst = (dst ?? new Ctor(3));
        const angle = Math.random() * 2 * Math.PI;
        const z = Math.random() * 2 - 1;
        const zScale = Math.sqrt(1 - z * z) * scale;
        newDst[0] = Math.cos(angle) * zScale;
        newDst[1] = Math.sin(angle) * zScale;
        newDst[2] = z * scale;
        return newDst;
    }
    /**
     * Zero's a vector
     * @param dst - vector to hold result. If not passed in a new one is created.
     * @returns The zeroed vector.
     */
    function zero(dst) {
        const newDst = (dst ?? new Ctor(3));
        newDst[0] = 0;
        newDst[1] = 0;
        newDst[2] = 0;
        return newDst;
    }
    /**
     * transform vec3 by 4x4 matrix
     * @param v - the vector
     * @param m - The matrix.
     * @param dst - optional vec3 to store result. If not passed a new one is created.
     * @returns the transformed vector
     */
    function transformMat4(v, m, dst) {
        const newDst = (dst ?? new Ctor(3));
        const x = v[0];
        const y = v[1];
        const z = v[2];
        const w = (m[3] * x + m[7] * y + m[11] * z + m[15]) || 1;
        newDst[0] = (m[0] * x + m[4] * y + m[8] * z + m[12]) / w;
        newDst[1] = (m[1] * x + m[5] * y + m[9] * z + m[13]) / w;
        newDst[2] = (m[2] * x + m[6] * y + m[10] * z + m[14]) / w;
        return newDst;
    }
    /**
     * Transform vec3 by upper 3x3 matrix inside 4x4 matrix.
     * @param v - The direction.
     * @param m - The matrix.
     * @param dst - optional vec3 to store result. If not passed a new one is created.
     * @returns The transformed vector.
     */
    function transformMat4Upper3x3(v, m, dst) {
        const newDst = (dst ?? new Ctor(3));
        const v0 = v[0];
        const v1 = v[1];
        const v2 = v[2];
        newDst[0] = v0 * m[0 * 4 + 0] + v1 * m[1 * 4 + 0] + v2 * m[2 * 4 + 0];
        newDst[1] = v0 * m[0 * 4 + 1] + v1 * m[1 * 4 + 1] + v2 * m[2 * 4 + 1];
        newDst[2] = v0 * m[0 * 4 + 2] + v1 * m[1 * 4 + 2] + v2 * m[2 * 4 + 2];
        return newDst;
    }
    /**
     * Transforms vec3 by 3x3 matrix
     *
     * @param v - the vector
     * @param m - The matrix.
     * @param dst - optional vec3 to store result. If not passed a new one is created.
     * @returns the transformed vector
     */
    function transformMat3(v, m, dst) {
        const newDst = (dst ?? new Ctor(3));
        const x = v[0];
        const y = v[1];
        const z = v[2];
        newDst[0] = x * m[0] + y * m[4] + z * m[8];
        newDst[1] = x * m[1] + y * m[5] + z * m[9];
        newDst[2] = x * m[2] + y * m[6] + z * m[10];
        return newDst;
    }
    /**
     * Transforms vec3 by Quaternion
     * @param v - the vector to transform
     * @param q - the quaternion to transform by
     * @param dst - optional vec3 to store result. If not passed a new one is created.
     * @returns the transformed
     */
    function transformQuat(v, q, dst) {
        const newDst = (dst ?? new Ctor(3));
        const qx = q[0];
        const qy = q[1];
        const qz = q[2];
        const w2 = q[3] * 2;
        const x = v[0];
        const y = v[1];
        const z = v[2];
        const uvX = qy * z - qz * y;
        const uvY = qz * x - qx * z;
        const uvZ = qx * y - qy * x;
        newDst[0] = x + uvX * w2 + (qy * uvZ - qz * uvY) * 2;
        newDst[1] = y + uvY * w2 + (qz * uvX - qx * uvZ) * 2;
        newDst[2] = z + uvZ * w2 + (qx * uvY - qy * uvX) * 2;
        return newDst;
    }
    /**
     * Returns the translation component of a 4-by-4 matrix as a vector with 3
     * entries.
     * @param m - The matrix.
     * @param dst - vector to hold result. If not passed a new one is created.
     * @returns The translation component of m.
     */
    function getTranslation(m, dst) {
        const newDst = (dst ?? new Ctor(3));
        newDst[0] = m[12];
        newDst[1] = m[13];
        newDst[2] = m[14];
        return newDst;
    }
    /**
     * Returns an axis of a 4x4 matrix as a vector with 3 entries
     * @param m - The matrix.
     * @param axis - The axis 0 = x, 1 = y, 2 = z;
     * @returns The axis component of m.
     */
    function getAxis(m, axis, dst) {
        const newDst = (dst ?? new Ctor(3));
        const off = axis * 4;
        newDst[0] = m[off + 0];
        newDst[1] = m[off + 1];
        newDst[2] = m[off + 2];
        return newDst;
    }
    /**
     * Returns the scaling component of the matrix
     * @param m - The Matrix
     * @param dst - The vector to set. If not passed a new one is created.
     */
    function getScaling(m, dst) {
        const newDst = (dst ?? new Ctor(3));
        const xx = m[0];
        const xy = m[1];
        const xz = m[2];
        const yx = m[4];
        const yy = m[5];
        const yz = m[6];
        const zx = m[8];
        const zy = m[9];
        const zz = m[10];
        newDst[0] = Math.sqrt(xx * xx + xy * xy + xz * xz);
        newDst[1] = Math.sqrt(yx * yx + yy * yy + yz * yz);
        newDst[2] = Math.sqrt(zx * zx + zy * zy + zz * zz);
        return newDst;
    }
    /**
     * Rotate a 3D vector around the x-axis
     *
     * @param {ReadonlyVec3} a The vec3 point to rotate
     * @param {ReadonlyVec3} b The origin of the rotation
     * @param {Number} rad The angle of rotation in radians
     * @param dst - The vector to set. If not passed a new one is created.
     * @returns the rotated vector
     */
    function rotateX(a, b, rad, dst) {
        const newDst = (dst ?? new Ctor(3));
        const p = [];
        const r = [];
        //Translate point to the origin
        p[0] = a[0] - b[0];
        p[1] = a[1] - b[1];
        p[2] = a[2] - b[2];
        //perform rotation
        r[0] = p[0];
        r[1] = p[1] * Math.cos(rad) - p[2] * Math.sin(rad);
        r[2] = p[1] * Math.sin(rad) + p[2] * Math.cos(rad);
        //translate to correct position
        newDst[0] = r[0] + b[0];
        newDst[1] = r[1] + b[1];
        newDst[2] = r[2] + b[2];
        return newDst;
    }
    /**
     * Rotate a 3D vector around the y-axis
     *
     * @param {ReadonlyVec3} a The vec3 point to rotate
     * @param {ReadonlyVec3} b The origin of the rotation
     * @param {Number} rad The angle of rotation in radians
     * @param dst - The vector to set. If not passed a new one is created.
     * @returns the rotated vector
     */
    function rotateY(a, b, rad, dst) {
        const newDst = (dst ?? new Ctor(3));
        const p = [];
        const r = [];
        // translate point to the origin
        p[0] = a[0] - b[0];
        p[1] = a[1] - b[1];
        p[2] = a[2] - b[2];
        // perform rotation
        r[0] = p[2] * Math.sin(rad) + p[0] * Math.cos(rad);
        r[1] = p[1];
        r[2] = p[2] * Math.cos(rad) - p[0] * Math.sin(rad);
        // translate to correct position
        newDst[0] = r[0] + b[0];
        newDst[1] = r[1] + b[1];
        newDst[2] = r[2] + b[2];
        return newDst;
    }
    /**
     * Rotate a 3D vector around the z-axis
     *
     * @param {ReadonlyVec3} a The vec3 point to rotate
     * @param {ReadonlyVec3} b The origin of the rotation
     * @param {Number} rad The angle of rotation in radians
     * @param dst - The vector to set. If not passed a new one is created.
     * @returns {vec3} out
     */
    function rotateZ(a, b, rad, dst) {
        const newDst = (dst ?? new Ctor(3));
        const p = [];
        const r = [];
        // translate point to the origin
        p[0] = a[0] - b[0];
        p[1] = a[1] - b[1];
        p[2] = a[2] - b[2];
        // perform rotation
        r[0] = p[0] * Math.cos(rad) - p[1] * Math.sin(rad);
        r[1] = p[0] * Math.sin(rad) + p[1] * Math.cos(rad);
        r[2] = p[2];
        // translate to correct position
        newDst[0] = r[0] + b[0];
        newDst[1] = r[1] + b[1];
        newDst[2] = r[2] + b[2];
        return newDst;
    }
    /**
     * Treat a 3D vector as a direction and set it's length
     *
     * @param a The vec3 to lengthen
     * @param len The length of the resulting vector
     * @returns The lengthened vector
     */
    function setLength(a, len, dst) {
        const newDst = (dst ?? new Ctor(3));
        normalize(a, newDst);
        return mulScalar(newDst, len, newDst);
    }
    /**
     * Ensure a vector is not longer than a max length
     *
     * @param a The vec3 to limit
     * @param maxLen The longest length of the resulting vector
     * @returns The vector, shortened to maxLen if it's too long
     */
    function truncate(a, maxLen, dst) {
        const newDst = (dst ?? new Ctor(3));
        if (length(a) > maxLen) {
            return setLength(a, maxLen, newDst);
        }
        return copy(a, newDst);
    }
    /**
     * Return the vector exactly between 2 endpoint vectors
     *
     * @param a Endpoint 1
     * @param b Endpoint 2
     * @returns The vector exactly residing between endpoints 1 and 2
     */
    function midpoint(a, b, dst) {
        const newDst = (dst ?? new Ctor(3));
        return lerp(a, b, 0.5, newDst);
    }
    return {
        create,
        fromValues,
        set,
        ceil,
        floor,
        round,
        clamp,
        add,
        addScaled,
        angle,
        subtract,
        sub,
        equalsApproximately,
        equals,
        lerp,
        lerpV,
        max,
        min,
        mulScalar,
        scale,
        divScalar,
        inverse,
        invert,
        cross,
        dot,
        length,
        len,
        lengthSq,
        lenSq,
        distance,
        dist,
        distanceSq,
        distSq,
        normalize,
        negate,
        copy,
        clone,
        multiply,
        mul,
        divide,
        div,
        random,
        zero,
        transformMat4,
        transformMat4Upper3x3,
        transformMat3,
        transformQuat,
        getTranslation,
        getAxis,
        getScaling,
        rotateX,
        rotateY,
        rotateZ,
        setLength,
        truncate,
        midpoint,
    };
}
const cache$3 = new Map();
function getAPI$3(Ctor) {
    let api = cache$3.get(Ctor);
    if (!api) {
        api = getAPIImpl$3(Ctor);
        cache$3.set(Ctor, api);
    }
    return api;
}

/**
 * Generates a typed API for Mat4
 * */
function getAPIImpl$2(Ctor) {
    const vec3 = getAPI$3(Ctor);
    /**
     * 4x4 Matrix math math functions.
     *
     * Almost all functions take an optional `newDst` argument. If it is not passed in the
     * functions will create a new matrix. In other words you can do this
     *
     *     const mat = mat4.translation([1, 2, 3]);  // Creates a new translation matrix
     *
     * or
     *
     *     const mat = mat4.create();
     *     mat4.translation([1, 2, 3], mat);  // Puts translation matrix in mat.
     *
     * The first style is often easier but depending on where it's used it generates garbage where
     * as there is almost never allocation with the second style.
     *
     * It is always save to pass any matrix as the destination. So for example
     *
     *     const mat = mat4.identity();
     *     const trans = mat4.translation([1, 2, 3]);
     *     mat4.multiply(mat, trans, mat);  // Multiplies mat * trans and puts result in mat.
     *
     */
    /**
     * Create a Mat4 from values
     *
     * Note: Since passing in a raw JavaScript array
     * is valid in all circumstances, if you want to
     * force a JavaScript array into a Mat4's specified type
     * it would be faster to use
     *
     * ```
     * const m = mat4.clone(someJSArray);
     * ```
     *
     * @param v0 - value for element 0
     * @param v1 - value for element 1
     * @param v2 - value for element 2
     * @param v3 - value for element 3
     * @param v4 - value for element 4
     * @param v5 - value for element 5
     * @param v6 - value for element 6
     * @param v7 - value for element 7
     * @param v8 - value for element 8
     * @param v9 - value for element 9
     * @param v10 - value for element 10
     * @param v11 - value for element 11
     * @param v12 - value for element 12
     * @param v13 - value for element 13
     * @param v14 - value for element 14
     * @param v15 - value for element 15
     * @returns created from values.
     */
    function create(v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15) {
        const newDst = new Ctor(16);
        if (v0 !== undefined) {
            newDst[0] = v0;
            if (v1 !== undefined) {
                newDst[1] = v1;
                if (v2 !== undefined) {
                    newDst[2] = v2;
                    if (v3 !== undefined) {
                        newDst[3] = v3;
                        if (v4 !== undefined) {
                            newDst[4] = v4;
                            if (v5 !== undefined) {
                                newDst[5] = v5;
                                if (v6 !== undefined) {
                                    newDst[6] = v6;
                                    if (v7 !== undefined) {
                                        newDst[7] = v7;
                                        if (v8 !== undefined) {
                                            newDst[8] = v8;
                                            if (v9 !== undefined) {
                                                newDst[9] = v9;
                                                if (v10 !== undefined) {
                                                    newDst[10] = v10;
                                                    if (v11 !== undefined) {
                                                        newDst[11] = v11;
                                                        if (v12 !== undefined) {
                                                            newDst[12] = v12;
                                                            if (v13 !== undefined) {
                                                                newDst[13] = v13;
                                                                if (v14 !== undefined) {
                                                                    newDst[14] = v14;
                                                                    if (v15 !== undefined) {
                                                                        newDst[15] = v15;
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
        return newDst;
    }
    /**
     * Sets the values of a Mat4
     * Also see {@link mat4.create} and {@link mat4.copy}
     *
     * @param v0 - value for element 0
     * @param v1 - value for element 1
     * @param v2 - value for element 2
     * @param v3 - value for element 3
     * @param v4 - value for element 4
     * @param v5 - value for element 5
     * @param v6 - value for element 6
     * @param v7 - value for element 7
     * @param v8 - value for element 8
     * @param v9 - value for element 9
     * @param v10 - value for element 10
     * @param v11 - value for element 11
     * @param v12 - value for element 12
     * @param v13 - value for element 13
     * @param v14 - value for element 14
     * @param v15 - value for element 15
     * @param dst - matrix to hold result. If not passed a new one is created.
     * @returns Mat4 created from values.
     */
    function set(v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, dst) {
        const newDst = (dst ?? new Ctor(16));
        newDst[0] = v0;
        newDst[1] = v1;
        newDst[2] = v2;
        newDst[3] = v3;
        newDst[4] = v4;
        newDst[5] = v5;
        newDst[6] = v6;
        newDst[7] = v7;
        newDst[8] = v8;
        newDst[9] = v9;
        newDst[10] = v10;
        newDst[11] = v11;
        newDst[12] = v12;
        newDst[13] = v13;
        newDst[14] = v14;
        newDst[15] = v15;
        return newDst;
    }
    /**
     * Creates a Mat4 from a Mat3
     * @param m3 - source matrix
     * @param dst - matrix to hold result. If not passed a new one is created.
     * @returns Mat4 made from m3
     */
    function fromMat3(m3, dst) {
        const newDst = (dst ?? new Ctor(16));
        newDst[0] = m3[0];
        newDst[1] = m3[1];
        newDst[2] = m3[2];
        newDst[3] = 0;
        newDst[4] = m3[4];
        newDst[5] = m3[5];
        newDst[6] = m3[6];
        newDst[7] = 0;
        newDst[8] = m3[8];
        newDst[9] = m3[9];
        newDst[10] = m3[10];
        newDst[11] = 0;
        newDst[12] = 0;
        newDst[13] = 0;
        newDst[14] = 0;
        newDst[15] = 1;
        return newDst;
    }
    /**
     * Creates a Mat4 rotation matrix from a quaternion
     * @param q - quaternion to create matrix from
     * @param dst - matrix to hold result. If not passed a new one is created.
     * @returns Mat4 made from q
     */
    function fromQuat(q, dst) {
        const newDst = (dst ?? new Ctor(16));
        const x = q[0];
        const y = q[1];
        const z = q[2];
        const w = q[3];
        const x2 = x + x;
        const y2 = y + y;
        const z2 = z + z;
        const xx = x * x2;
        const yx = y * x2;
        const yy = y * y2;
        const zx = z * x2;
        const zy = z * y2;
        const zz = z * z2;
        const wx = w * x2;
        const wy = w * y2;
        const wz = w * z2;
        newDst[0] = 1 - yy - zz;
        newDst[1] = yx + wz;
        newDst[2] = zx - wy;
        newDst[3] = 0;
        newDst[4] = yx - wz;
        newDst[5] = 1 - xx - zz;
        newDst[6] = zy + wx;
        newDst[7] = 0;
        newDst[8] = zx + wy;
        newDst[9] = zy - wx;
        newDst[10] = 1 - xx - yy;
        newDst[11] = 0;
        newDst[12] = 0;
        newDst[13] = 0;
        newDst[14] = 0;
        newDst[15] = 1;
        return newDst;
    }
    /**
     * Negates a matrix.
     * @param m - The matrix.
     * @param dst - matrix to hold result. If not passed a new one is created.
     * @returns -m.
     */
    function negate(m, dst) {
        const newDst = (dst ?? new Ctor(16));
        newDst[0] = -m[0];
        newDst[1] = -m[1];
        newDst[2] = -m[2];
        newDst[3] = -m[3];
        newDst[4] = -m[4];
        newDst[5] = -m[5];
        newDst[6] = -m[6];
        newDst[7] = -m[7];
        newDst[8] = -m[8];
        newDst[9] = -m[9];
        newDst[10] = -m[10];
        newDst[11] = -m[11];
        newDst[12] = -m[12];
        newDst[13] = -m[13];
        newDst[14] = -m[14];
        newDst[15] = -m[15];
        return newDst;
    }
    /**
     * Copies a matrix. (same as {@link mat4.clone})
     * Also see {@link mat4.create} and {@link mat4.set}
     * @param m - The matrix.
     * @param dst - The matrix. If not passed a new one is created.
     * @returns A copy of m.
     */
    function copy(m, dst) {
        const newDst = (dst ?? new Ctor(16));
        newDst[0] = m[0];
        newDst[1] = m[1];
        newDst[2] = m[2];
        newDst[3] = m[3];
        newDst[4] = m[4];
        newDst[5] = m[5];
        newDst[6] = m[6];
        newDst[7] = m[7];
        newDst[8] = m[8];
        newDst[9] = m[9];
        newDst[10] = m[10];
        newDst[11] = m[11];
        newDst[12] = m[12];
        newDst[13] = m[13];
        newDst[14] = m[14];
        newDst[15] = m[15];
        return newDst;
    }
    /**
     * Copies a matrix (same as {@link mat4.copy})
     * Also see {@link mat4.create} and {@link mat4.set}
     * @param m - The matrix.
     * @param dst - The matrix. If not passed a new one is created.
     * @returns A copy of m.
     */
    const clone = copy;
    /**
     * Check if 2 matrices are approximately equal
     * @param a - Operand matrix.
     * @param b - Operand matrix.
     * @returns true if matrices are approximately equal
     */
    function equalsApproximately(a, b) {
        return Math.abs(a[0] - b[0]) < EPSILON &&
            Math.abs(a[1] - b[1]) < EPSILON &&
            Math.abs(a[2] - b[2]) < EPSILON &&
            Math.abs(a[3] - b[3]) < EPSILON &&
            Math.abs(a[4] - b[4]) < EPSILON &&
            Math.abs(a[5] - b[5]) < EPSILON &&
            Math.abs(a[6] - b[6]) < EPSILON &&
            Math.abs(a[7] - b[7]) < EPSILON &&
            Math.abs(a[8] - b[8]) < EPSILON &&
            Math.abs(a[9] - b[9]) < EPSILON &&
            Math.abs(a[10] - b[10]) < EPSILON &&
            Math.abs(a[11] - b[11]) < EPSILON &&
            Math.abs(a[12] - b[12]) < EPSILON &&
            Math.abs(a[13] - b[13]) < EPSILON &&
            Math.abs(a[14] - b[14]) < EPSILON &&
            Math.abs(a[15] - b[15]) < EPSILON;
    }
    /**
     * Check if 2 matrices are exactly equal
     * @param a - Operand matrix.
     * @param b - Operand matrix.
     * @returns true if matrices are exactly equal
     */
    function equals(a, b) {
        return a[0] === b[0] &&
            a[1] === b[1] &&
            a[2] === b[2] &&
            a[3] === b[3] &&
            a[4] === b[4] &&
            a[5] === b[5] &&
            a[6] === b[6] &&
            a[7] === b[7] &&
            a[8] === b[8] &&
            a[9] === b[9] &&
            a[10] === b[10] &&
            a[11] === b[11] &&
            a[12] === b[12] &&
            a[13] === b[13] &&
            a[14] === b[14] &&
            a[15] === b[15];
    }
    /**
     * Creates a 4-by-4 identity matrix.
     *
     * @param dst - matrix to hold result. If not passed a new one is created.
     * @returns A 4-by-4 identity matrix.
     */
    function identity(dst) {
        const newDst = (dst ?? new Ctor(16));
        newDst[0] = 1;
        newDst[1] = 0;
        newDst[2] = 0;
        newDst[3] = 0;
        newDst[4] = 0;
        newDst[5] = 1;
        newDst[6] = 0;
        newDst[7] = 0;
        newDst[8] = 0;
        newDst[9] = 0;
        newDst[10] = 1;
        newDst[11] = 0;
        newDst[12] = 0;
        newDst[13] = 0;
        newDst[14] = 0;
        newDst[15] = 1;
        return newDst;
    }
    /**
     * Takes the transpose of a matrix.
     * @param m - The matrix.
     * @param dst - matrix to hold result. If not passed a new one is created.
     * @returns The transpose of m.
     */
    function transpose(m, dst) {
        const newDst = (dst ?? new Ctor(16));
        if (newDst === m) {
            let t;
            t = m[1];
            m[1] = m[4];
            m[4] = t;
            t = m[2];
            m[2] = m[8];
            m[8] = t;
            t = m[3];
            m[3] = m[12];
            m[12] = t;
            t = m[6];
            m[6] = m[9];
            m[9] = t;
            t = m[7];
            m[7] = m[13];
            m[13] = t;
            t = m[11];
            m[11] = m[14];
            m[14] = t;
            return newDst;
        }
        const m00 = m[0 * 4 + 0];
        const m01 = m[0 * 4 + 1];
        const m02 = m[0 * 4 + 2];
        const m03 = m[0 * 4 + 3];
        const m10 = m[1 * 4 + 0];
        const m11 = m[1 * 4 + 1];
        const m12 = m[1 * 4 + 2];
        const m13 = m[1 * 4 + 3];
        const m20 = m[2 * 4 + 0];
        const m21 = m[2 * 4 + 1];
        const m22 = m[2 * 4 + 2];
        const m23 = m[2 * 4 + 3];
        const m30 = m[3 * 4 + 0];
        const m31 = m[3 * 4 + 1];
        const m32 = m[3 * 4 + 2];
        const m33 = m[3 * 4 + 3];
        newDst[0] = m00;
        newDst[1] = m10;
        newDst[2] = m20;
        newDst[3] = m30;
        newDst[4] = m01;
        newDst[5] = m11;
        newDst[6] = m21;
        newDst[7] = m31;
        newDst[8] = m02;
        newDst[9] = m12;
        newDst[10] = m22;
        newDst[11] = m32;
        newDst[12] = m03;
        newDst[13] = m13;
        newDst[14] = m23;
        newDst[15] = m33;
        return newDst;
    }
    /**
     * Computes the inverse of a 4-by-4 matrix.
     * @param m - The matrix.
     * @param dst - matrix to hold result. If not passed a new one is created.
     * @returns The inverse of m.
     */
    function inverse(m, dst) {
        const newDst = (dst ?? new Ctor(16));
        const m00 = m[0 * 4 + 0];
        const m01 = m[0 * 4 + 1];
        const m02 = m[0 * 4 + 2];
        const m03 = m[0 * 4 + 3];
        const m10 = m[1 * 4 + 0];
        const m11 = m[1 * 4 + 1];
        const m12 = m[1 * 4 + 2];
        const m13 = m[1 * 4 + 3];
        const m20 = m[2 * 4 + 0];
        const m21 = m[2 * 4 + 1];
        const m22 = m[2 * 4 + 2];
        const m23 = m[2 * 4 + 3];
        const m30 = m[3 * 4 + 0];
        const m31 = m[3 * 4 + 1];
        const m32 = m[3 * 4 + 2];
        const m33 = m[3 * 4 + 3];
        const tmp0 = m22 * m33;
        const tmp1 = m32 * m23;
        const tmp2 = m12 * m33;
        const tmp3 = m32 * m13;
        const tmp4 = m12 * m23;
        const tmp5 = m22 * m13;
        const tmp6 = m02 * m33;
        const tmp7 = m32 * m03;
        const tmp8 = m02 * m23;
        const tmp9 = m22 * m03;
        const tmp10 = m02 * m13;
        const tmp11 = m12 * m03;
        const tmp12 = m20 * m31;
        const tmp13 = m30 * m21;
        const tmp14 = m10 * m31;
        const tmp15 = m30 * m11;
        const tmp16 = m10 * m21;
        const tmp17 = m20 * m11;
        const tmp18 = m00 * m31;
        const tmp19 = m30 * m01;
        const tmp20 = m00 * m21;
        const tmp21 = m20 * m01;
        const tmp22 = m00 * m11;
        const tmp23 = m10 * m01;
        const t0 = (tmp0 * m11 + tmp3 * m21 + tmp4 * m31) -
            (tmp1 * m11 + tmp2 * m21 + tmp5 * m31);
        const t1 = (tmp1 * m01 + tmp6 * m21 + tmp9 * m31) -
            (tmp0 * m01 + tmp7 * m21 + tmp8 * m31);
        const t2 = (tmp2 * m01 + tmp7 * m11 + tmp10 * m31) -
            (tmp3 * m01 + tmp6 * m11 + tmp11 * m31);
        const t3 = (tmp5 * m01 + tmp8 * m11 + tmp11 * m21) -
            (tmp4 * m01 + tmp9 * m11 + tmp10 * m21);
        const d = 1 / (m00 * t0 + m10 * t1 + m20 * t2 + m30 * t3);
        newDst[0] = d * t0;
        newDst[1] = d * t1;
        newDst[2] = d * t2;
        newDst[3] = d * t3;
        newDst[4] = d * ((tmp1 * m10 + tmp2 * m20 + tmp5 * m30) -
            (tmp0 * m10 + tmp3 * m20 + tmp4 * m30));
        newDst[5] = d * ((tmp0 * m00 + tmp7 * m20 + tmp8 * m30) -
            (tmp1 * m00 + tmp6 * m20 + tmp9 * m30));
        newDst[6] = d * ((tmp3 * m00 + tmp6 * m10 + tmp11 * m30) -
            (tmp2 * m00 + tmp7 * m10 + tmp10 * m30));
        newDst[7] = d * ((tmp4 * m00 + tmp9 * m10 + tmp10 * m20) -
            (tmp5 * m00 + tmp8 * m10 + tmp11 * m20));
        newDst[8] = d * ((tmp12 * m13 + tmp15 * m23 + tmp16 * m33) -
            (tmp13 * m13 + tmp14 * m23 + tmp17 * m33));
        newDst[9] = d * ((tmp13 * m03 + tmp18 * m23 + tmp21 * m33) -
            (tmp12 * m03 + tmp19 * m23 + tmp20 * m33));
        newDst[10] = d * ((tmp14 * m03 + tmp19 * m13 + tmp22 * m33) -
            (tmp15 * m03 + tmp18 * m13 + tmp23 * m33));
        newDst[11] = d * ((tmp17 * m03 + tmp20 * m13 + tmp23 * m23) -
            (tmp16 * m03 + tmp21 * m13 + tmp22 * m23));
        newDst[12] = d * ((tmp14 * m22 + tmp17 * m32 + tmp13 * m12) -
            (tmp16 * m32 + tmp12 * m12 + tmp15 * m22));
        newDst[13] = d * ((tmp20 * m32 + tmp12 * m02 + tmp19 * m22) -
            (tmp18 * m22 + tmp21 * m32 + tmp13 * m02));
        newDst[14] = d * ((tmp18 * m12 + tmp23 * m32 + tmp15 * m02) -
            (tmp22 * m32 + tmp14 * m02 + tmp19 * m12));
        newDst[15] = d * ((tmp22 * m22 + tmp16 * m02 + tmp21 * m12) -
            (tmp20 * m12 + tmp23 * m22 + tmp17 * m02));
        return newDst;
    }
    /**
     * Compute the determinant of a matrix
     * @param m - the matrix
     * @returns the determinant
     */
    function determinant(m) {
        const m00 = m[0 * 4 + 0];
        const m01 = m[0 * 4 + 1];
        const m02 = m[0 * 4 + 2];
        const m03 = m[0 * 4 + 3];
        const m10 = m[1 * 4 + 0];
        const m11 = m[1 * 4 + 1];
        const m12 = m[1 * 4 + 2];
        const m13 = m[1 * 4 + 3];
        const m20 = m[2 * 4 + 0];
        const m21 = m[2 * 4 + 1];
        const m22 = m[2 * 4 + 2];
        const m23 = m[2 * 4 + 3];
        const m30 = m[3 * 4 + 0];
        const m31 = m[3 * 4 + 1];
        const m32 = m[3 * 4 + 2];
        const m33 = m[3 * 4 + 3];
        const tmp0 = m22 * m33;
        const tmp1 = m32 * m23;
        const tmp2 = m12 * m33;
        const tmp3 = m32 * m13;
        const tmp4 = m12 * m23;
        const tmp5 = m22 * m13;
        const tmp6 = m02 * m33;
        const tmp7 = m32 * m03;
        const tmp8 = m02 * m23;
        const tmp9 = m22 * m03;
        const tmp10 = m02 * m13;
        const tmp11 = m12 * m03;
        const t0 = (tmp0 * m11 + tmp3 * m21 + tmp4 * m31) -
            (tmp1 * m11 + tmp2 * m21 + tmp5 * m31);
        const t1 = (tmp1 * m01 + tmp6 * m21 + tmp9 * m31) -
            (tmp0 * m01 + tmp7 * m21 + tmp8 * m31);
        const t2 = (tmp2 * m01 + tmp7 * m11 + tmp10 * m31) -
            (tmp3 * m01 + tmp6 * m11 + tmp11 * m31);
        const t3 = (tmp5 * m01 + tmp8 * m11 + tmp11 * m21) -
            (tmp4 * m01 + tmp9 * m11 + tmp10 * m21);
        return m00 * t0 + m10 * t1 + m20 * t2 + m30 * t3;
    }
    /**
     * Computes the inverse of a 4-by-4 matrix. (same as inverse)
     * @param m - The matrix.
     * @param dst - matrix to hold result. If not passed a new one is created.
     * @returns The inverse of m.
     */
    const invert = inverse;
    /**
     * Multiplies two 4-by-4 matrices with a on the left and b on the right
     * @param a - The matrix on the left.
     * @param b - The matrix on the right.
     * @param dst - matrix to hold result. If not passed a new one is created.
     * @returns The matrix product of a and b.
     */
    function multiply(a, b, dst) {
        const newDst = (dst ?? new Ctor(16));
        const a00 = a[0];
        const a01 = a[1];
        const a02 = a[2];
        const a03 = a[3];
        const a10 = a[4 + 0];
        const a11 = a[4 + 1];
        const a12 = a[4 + 2];
        const a13 = a[4 + 3];
        const a20 = a[8 + 0];
        const a21 = a[8 + 1];
        const a22 = a[8 + 2];
        const a23 = a[8 + 3];
        const a30 = a[12 + 0];
        const a31 = a[12 + 1];
        const a32 = a[12 + 2];
        const a33 = a[12 + 3];
        const b00 = b[0];
        const b01 = b[1];
        const b02 = b[2];
        const b03 = b[3];
        const b10 = b[4 + 0];
        const b11 = b[4 + 1];
        const b12 = b[4 + 2];
        const b13 = b[4 + 3];
        const b20 = b[8 + 0];
        const b21 = b[8 + 1];
        const b22 = b[8 + 2];
        const b23 = b[8 + 3];
        const b30 = b[12 + 0];
        const b31 = b[12 + 1];
        const b32 = b[12 + 2];
        const b33 = b[12 + 3];
        newDst[0] = a00 * b00 + a10 * b01 + a20 * b02 + a30 * b03;
        newDst[1] = a01 * b00 + a11 * b01 + a21 * b02 + a31 * b03;
        newDst[2] = a02 * b00 + a12 * b01 + a22 * b02 + a32 * b03;
        newDst[3] = a03 * b00 + a13 * b01 + a23 * b02 + a33 * b03;
        newDst[4] = a00 * b10 + a10 * b11 + a20 * b12 + a30 * b13;
        newDst[5] = a01 * b10 + a11 * b11 + a21 * b12 + a31 * b13;
        newDst[6] = a02 * b10 + a12 * b11 + a22 * b12 + a32 * b13;
        newDst[7] = a03 * b10 + a13 * b11 + a23 * b12 + a33 * b13;
        newDst[8] = a00 * b20 + a10 * b21 + a20 * b22 + a30 * b23;
        newDst[9] = a01 * b20 + a11 * b21 + a21 * b22 + a31 * b23;
        newDst[10] = a02 * b20 + a12 * b21 + a22 * b22 + a32 * b23;
        newDst[11] = a03 * b20 + a13 * b21 + a23 * b22 + a33 * b23;
        newDst[12] = a00 * b30 + a10 * b31 + a20 * b32 + a30 * b33;
        newDst[13] = a01 * b30 + a11 * b31 + a21 * b32 + a31 * b33;
        newDst[14] = a02 * b30 + a12 * b31 + a22 * b32 + a32 * b33;
        newDst[15] = a03 * b30 + a13 * b31 + a23 * b32 + a33 * b33;
        return newDst;
    }
    /**
     * Multiplies two 4-by-4 matrices with a on the left and b on the right (same as multiply)
     * @param a - The matrix on the left.
     * @param b - The matrix on the right.
     * @param dst - matrix to hold result. If not passed a new one is created.
     * @returns The matrix product of a and b.
     */
    const mul = multiply;
    /**
     * Sets the translation component of a 4-by-4 matrix to the given
     * vector.
     * @param a - The matrix.
     * @param v - The vector.
     * @param dst - matrix to hold result. If not passed a new one is created.
     * @returns The matrix with translation set.
     */
    function setTranslation(a, v, dst) {
        const newDst = (dst ?? identity());
        if (a !== newDst) {
            newDst[0] = a[0];
            newDst[1] = a[1];
            newDst[2] = a[2];
            newDst[3] = a[3];
            newDst[4] = a[4];
            newDst[5] = a[5];
            newDst[6] = a[6];
            newDst[7] = a[7];
            newDst[8] = a[8];
            newDst[9] = a[9];
            newDst[10] = a[10];
            newDst[11] = a[11];
        }
        newDst[12] = v[0];
        newDst[13] = v[1];
        newDst[14] = v[2];
        newDst[15] = 1;
        return newDst;
    }
    ///**
    // * Returns the translation component of a 4-by-4 matrix as a vector with 3
    // * entries.
    // * @param m - The matrix.
    // * @param dst - vector to hold result. If not passed a new one is created.
    // * @returns The translation component of m.
    // */
    function getTranslation(m, dst) {
        const newDst = (dst ?? vec3.create());
        newDst[0] = m[12];
        newDst[1] = m[13];
        newDst[2] = m[14];
        return newDst;
    }
    /**
     * Returns an axis of a 4x4 matrix as a vector with 3 entries
     * @param m - The matrix.
     * @param axis - The axis 0 = x, 1 = y, 2 = z;
     * @returns The axis component of m.
     */
    function getAxis(m, axis, dst) {
        const newDst = (dst ?? vec3.create());
        const off = axis * 4;
        newDst[0] = m[off + 0];
        newDst[1] = m[off + 1];
        newDst[2] = m[off + 2];
        return newDst;
    }
    /**
     * Sets an axis of a 4x4 matrix as a vector with 3 entries
     * @param m - The matrix.
     * @param v - the axis vector
     * @param axis - The axis  0 = x, 1 = y, 2 = z;
     * @param dst - The matrix to set. If not passed a new one is created.
     * @returns The matrix with axis set.
     */
    function setAxis(m, v, axis, dst) {
        const newDst = (dst === m) ? dst : copy(m, dst);
        const off = axis * 4;
        newDst[off + 0] = v[0];
        newDst[off + 1] = v[1];
        newDst[off + 2] = v[2];
        return newDst;
    }
    ///**
    // * Returns the scaling component of the matrix
    // * @param m - The Matrix
    // * @param dst - The vector to set. If not passed a new one is created.
    // */
    function getScaling(m, dst) {
        const newDst = (dst ?? vec3.create());
        const xx = m[0];
        const xy = m[1];
        const xz = m[2];
        const yx = m[4];
        const yy = m[5];
        const yz = m[6];
        const zx = m[8];
        const zy = m[9];
        const zz = m[10];
        newDst[0] = Math.sqrt(xx * xx + xy * xy + xz * xz);
        newDst[1] = Math.sqrt(yx * yx + yy * yy + yz * yz);
        newDst[2] = Math.sqrt(zx * zx + zy * zy + zz * zz);
        return newDst;
    }
    /**
     * Computes a 4-by-4 perspective transformation matrix given the angular height
     * of the frustum, the aspect ratio, and the near and far clipping planes.  The
     * arguments define a frustum extending in the negative z direction.  The given
     * angle is the vertical angle of the frustum, and the horizontal angle is
     * determined to produce the given aspect ratio.  The arguments near and far are
     * the distances to the near and far clipping planes.  Note that near and far
     * are not z coordinates, but rather they are distances along the negative
     * z-axis.  The matrix generated sends the viewing frustum to the unit box.
     * We assume a unit box extending from -1 to 1 in the x and y dimensions and
     * from 0 to 1 in the z dimension.
     *
     * Note: If you pass `Infinity` for zFar then it will produce a projection matrix
     * returns -Infinity for Z when transforming coordinates with Z <= 0 and +Infinity for Z
     * otherwise.
     *
     * @param fieldOfViewYInRadians - The camera angle from top to bottom (in radians).
     * @param aspect - The aspect ratio width / height.
     * @param zNear - The depth (negative z coordinate)
     *     of the near clipping plane.
     * @param zFar - The depth (negative z coordinate)
     *     of the far clipping plane.
     * @param dst - matrix to hold result. If not passed a new one is created.
     * @returns The perspective matrix.
     */
    function perspective(fieldOfViewYInRadians, aspect, zNear, zFar, dst) {
        const newDst = (dst ?? new Ctor(16));
        const f = Math.tan(Math.PI * 0.5 - 0.5 * fieldOfViewYInRadians);
        newDst[0] = f / aspect;
        newDst[1] = 0;
        newDst[2] = 0;
        newDst[3] = 0;
        newDst[4] = 0;
        newDst[5] = f;
        newDst[6] = 0;
        newDst[7] = 0;
        newDst[8] = 0;
        newDst[9] = 0;
        newDst[11] = -1;
        newDst[12] = 0;
        newDst[13] = 0;
        newDst[15] = 0;
        if (Number.isFinite(zFar)) {
            const rangeInv = 1 / (zNear - zFar);
            newDst[10] = zFar * rangeInv;
            newDst[14] = zFar * zNear * rangeInv;
        }
        else {
            newDst[10] = -1;
            newDst[14] = -zNear;
        }
        return newDst;
    }
    /**
     * Computes a 4-by-4 reverse-z perspective transformation matrix given the angular height
     * of the frustum, the aspect ratio, and the near and far clipping planes.  The
     * arguments define a frustum extending in the negative z direction.  The given
     * angle is the vertical angle of the frustum, and the horizontal angle is
     * determined to produce the given aspect ratio.  The arguments near and far are
     * the distances to the near and far clipping planes.  Note that near and far
     * are not z coordinates, but rather they are distances along the negative
     * z-axis.  The matrix generated sends the viewing frustum to the unit box.
     * We assume a unit box extending from -1 to 1 in the x and y dimensions and
     * from 1 (at -zNear) to 0 (at -zFar) in the z dimension.
     *
     * @param fieldOfViewYInRadians - The camera angle from top to bottom (in radians).
     * @param aspect - The aspect ratio width / height.
     * @param zNear - The depth (negative z coordinate)
     *     of the near clipping plane.
     * @param zFar - The depth (negative z coordinate)
     *     of the far clipping plane. (default = Infinity)
     * @param dst - matrix to hold result. If not passed a new one is created.
     * @returns The perspective matrix.
     */ function perspectiveReverseZ(fieldOfViewYInRadians, aspect, zNear, zFar = Infinity, dst) {
        const newDst = (dst ?? new Ctor(16));
        const f = 1 / Math.tan(fieldOfViewYInRadians * 0.5);
        newDst[0] = f / aspect;
        newDst[1] = 0;
        newDst[2] = 0;
        newDst[3] = 0;
        newDst[4] = 0;
        newDst[5] = f;
        newDst[6] = 0;
        newDst[7] = 0;
        newDst[8] = 0;
        newDst[9] = 0;
        newDst[11] = -1;
        newDst[12] = 0;
        newDst[13] = 0;
        newDst[15] = 0;
        if (zFar === Infinity) {
            newDst[10] = 0;
            newDst[14] = zNear;
        }
        else {
            const rangeInv = 1 / (zFar - zNear);
            newDst[10] = zNear * rangeInv;
            newDst[14] = zFar * zNear * rangeInv;
        }
        return newDst;
    }
    /**
     * Computes a 4-by-4 orthogonal transformation matrix that transforms from
     * the given the left, right, bottom, and top dimensions to -1 +1 in x, and y
     * and 0 to +1 in z.
     * @param left - Left side of the near clipping plane viewport.
     * @param right - Right side of the near clipping plane viewport.
     * @param bottom - Bottom of the near clipping plane viewport.
     * @param top - Top of the near clipping plane viewport.
     * @param near - The depth (negative z coordinate)
     *     of the near clipping plane.
     * @param far - The depth (negative z coordinate)
     *     of the far clipping plane.
     * @param dst - Output matrix. If not passed a new one is created.
     * @returns The orthographic projection matrix.
     */
    function ortho(left, right, bottom, top, near, far, dst) {
        const newDst = (dst ?? new Ctor(16));
        newDst[0] = 2 / (right - left);
        newDst[1] = 0;
        newDst[2] = 0;
        newDst[3] = 0;
        newDst[4] = 0;
        newDst[5] = 2 / (top - bottom);
        newDst[6] = 0;
        newDst[7] = 0;
        newDst[8] = 0;
        newDst[9] = 0;
        newDst[10] = 1 / (near - far);
        newDst[11] = 0;
        newDst[12] = (right + left) / (left - right);
        newDst[13] = (top + bottom) / (bottom - top);
        newDst[14] = near / (near - far);
        newDst[15] = 1;
        return newDst;
    }
    /**
     * Computes a 4-by-4 perspective transformation matrix given the left, right,
     * top, bottom, near and far clipping planes. The arguments define a frustum
     * extending in the negative z direction. The arguments near and far are the
     * distances to the near and far clipping planes. Note that near and far are not
     * z coordinates, but rather they are distances along the negative z-axis. The
     * matrix generated sends the viewing frustum to the unit box. We assume a unit
     * box extending from -1 to 1 in the x and y dimensions and from 0 to 1 in the z
     * dimension.
     * @param left - The x coordinate of the left plane of the box.
     * @param right - The x coordinate of the right plane of the box.
     * @param bottom - The y coordinate of the bottom plane of the box.
     * @param top - The y coordinate of the right plane of the box.
     * @param near - The negative z coordinate of the near plane of the box.
     * @param far - The negative z coordinate of the far plane of the box.
     * @param dst - Output matrix. If not passed a new one is created.
     * @returns The perspective projection matrix.
     */
    function frustum(left, right, bottom, top, near, far, dst) {
        const newDst = (dst ?? new Ctor(16));
        const dx = (right - left);
        const dy = (top - bottom);
        const dz = (near - far);
        newDst[0] = 2 * near / dx;
        newDst[1] = 0;
        newDst[2] = 0;
        newDst[3] = 0;
        newDst[4] = 0;
        newDst[5] = 2 * near / dy;
        newDst[6] = 0;
        newDst[7] = 0;
        newDst[8] = (left + right) / dx;
        newDst[9] = (top + bottom) / dy;
        newDst[10] = far / dz;
        newDst[11] = -1;
        newDst[12] = 0;
        newDst[13] = 0;
        newDst[14] = near * far / dz;
        newDst[15] = 0;
        return newDst;
    }
    /**
     * Computes a 4-by-4 reverse-z perspective transformation matrix given the left, right,
     * top, bottom, near and far clipping planes. The arguments define a frustum
     * extending in the negative z direction. The arguments near and far are the
     * distances to the near and far clipping planes. Note that near and far are not
     * z coordinates, but rather they are distances along the negative z-axis. The
     * matrix generated sends the viewing frustum to the unit box. We assume a unit
     * box extending from -1 to 1 in the x and y dimensions and from 1 (-near) to 0 (-far) in the z
     * dimension.
     * @param left - The x coordinate of the left plane of the box.
     * @param right - The x coordinate of the right plane of the box.
     * @param bottom - The y coordinate of the bottom plane of the box.
     * @param top - The y coordinate of the right plane of the box.
     * @param near - The negative z coordinate of the near plane of the box.
     * @param far - The negative z coordinate of the far plane of the box.
     * @param dst - Output matrix. If not passed a new one is created.
     * @returns The perspective projection matrix.
     */
    function frustumReverseZ(left, right, bottom, top, near, far = Infinity, dst) {
        const newDst = (dst ?? new Ctor(16));
        const dx = (right - left);
        const dy = (top - bottom);
        newDst[0] = 2 * near / dx;
        newDst[1] = 0;
        newDst[2] = 0;
        newDst[3] = 0;
        newDst[4] = 0;
        newDst[5] = 2 * near / dy;
        newDst[6] = 0;
        newDst[7] = 0;
        newDst[8] = (left + right) / dx;
        newDst[9] = (top + bottom) / dy;
        newDst[11] = -1;
        newDst[12] = 0;
        newDst[13] = 0;
        newDst[15] = 0;
        if (far === Infinity) {
            newDst[10] = 0;
            newDst[14] = near;
        }
        else {
            const rangeInv = 1 / (far - near);
            newDst[10] = near * rangeInv;
            newDst[14] = far * near * rangeInv;
        }
        return newDst;
    }
    const xAxis = vec3.create();
    const yAxis = vec3.create();
    const zAxis = vec3.create();
    /**
     * Computes a 4-by-4 aim transformation.
     *
     * This is a matrix which positions an object aiming down positive Z.
     * toward the target.
     *
     * Note: this is **NOT** the inverse of lookAt as lookAt looks at negative Z.
     *
     * @param position - The position of the object.
     * @param target - The position meant to be aimed at.
     * @param up - A vector pointing up.
     * @param dst - matrix to hold result. If not passed a new one is created.
     * @returns The aim matrix.
     */
    function aim(position, target, up, dst) {
        const newDst = (dst ?? new Ctor(16));
        vec3.normalize(vec3.subtract(target, position, zAxis), zAxis);
        vec3.normalize(vec3.cross(up, zAxis, xAxis), xAxis);
        vec3.normalize(vec3.cross(zAxis, xAxis, yAxis), yAxis);
        newDst[0] = xAxis[0];
        newDst[1] = xAxis[1];
        newDst[2] = xAxis[2];
        newDst[3] = 0;
        newDst[4] = yAxis[0];
        newDst[5] = yAxis[1];
        newDst[6] = yAxis[2];
        newDst[7] = 0;
        newDst[8] = zAxis[0];
        newDst[9] = zAxis[1];
        newDst[10] = zAxis[2];
        newDst[11] = 0;
        newDst[12] = position[0];
        newDst[13] = position[1];
        newDst[14] = position[2];
        newDst[15] = 1;
        return newDst;
    }
    /**
     * Computes a 4-by-4 camera aim transformation.
     *
     * This is a matrix which positions an object aiming down negative Z.
     * toward the target.
     *
     * Note: this is the inverse of `lookAt`
     *
     * @param eye - The position of the object.
     * @param target - The position meant to be aimed at.
     * @param up - A vector pointing up.
     * @param dst - matrix to hold result. If not passed a new one is created.
     * @returns The aim matrix.
     */
    function cameraAim(eye, target, up, dst) {
        const newDst = (dst ?? new Ctor(16));
        vec3.normalize(vec3.subtract(eye, target, zAxis), zAxis);
        vec3.normalize(vec3.cross(up, zAxis, xAxis), xAxis);
        vec3.normalize(vec3.cross(zAxis, xAxis, yAxis), yAxis);
        newDst[0] = xAxis[0];
        newDst[1] = xAxis[1];
        newDst[2] = xAxis[2];
        newDst[3] = 0;
        newDst[4] = yAxis[0];
        newDst[5] = yAxis[1];
        newDst[6] = yAxis[2];
        newDst[7] = 0;
        newDst[8] = zAxis[0];
        newDst[9] = zAxis[1];
        newDst[10] = zAxis[2];
        newDst[11] = 0;
        newDst[12] = eye[0];
        newDst[13] = eye[1];
        newDst[14] = eye[2];
        newDst[15] = 1;
        return newDst;
    }
    /**
     * Computes a 4-by-4 view transformation.
     *
     * This is a view matrix which transforms all other objects
     * to be in the space of the view defined by the parameters.
     *
     * @param eye - The position of the object.
     * @param target - The position meant to be aimed at.
     * @param up - A vector pointing up.
     * @param dst - matrix to hold result. If not passed a new one is created.
     * @returns The look-at matrix.
     */
    function lookAt(eye, target, up, dst) {
        const newDst = (dst ?? new Ctor(16));
        vec3.normalize(vec3.subtract(eye, target, zAxis), zAxis);
        vec3.normalize(vec3.cross(up, zAxis, xAxis), xAxis);
        vec3.normalize(vec3.cross(zAxis, xAxis, yAxis), yAxis);
        newDst[0] = xAxis[0];
        newDst[1] = yAxis[0];
        newDst[2] = zAxis[0];
        newDst[3] = 0;
        newDst[4] = xAxis[1];
        newDst[5] = yAxis[1];
        newDst[6] = zAxis[1];
        newDst[7] = 0;
        newDst[8] = xAxis[2];
        newDst[9] = yAxis[2];
        newDst[10] = zAxis[2];
        newDst[11] = 0;
        newDst[12] = -(xAxis[0] * eye[0] + xAxis[1] * eye[1] + xAxis[2] * eye[2]);
        newDst[13] = -(yAxis[0] * eye[0] + yAxis[1] * eye[1] + yAxis[2] * eye[2]);
        newDst[14] = -(zAxis[0] * eye[0] + zAxis[1] * eye[1] + zAxis[2] * eye[2]);
        newDst[15] = 1;
        return newDst;
    }
    /**
     * Creates a 4-by-4 matrix which translates by the given vector v.
     * @param v - The vector by
     *     which to translate.
     * @param dst - matrix to hold result. If not passed a new one is created.
     * @returns The translation matrix.
     */
    function translation(v, dst) {
        const newDst = (dst ?? new Ctor(16));
        newDst[0] = 1;
        newDst[1] = 0;
        newDst[2] = 0;
        newDst[3] = 0;
        newDst[4] = 0;
        newDst[5] = 1;
        newDst[6] = 0;
        newDst[7] = 0;
        newDst[8] = 0;
        newDst[9] = 0;
        newDst[10] = 1;
        newDst[11] = 0;
        newDst[12] = v[0];
        newDst[13] = v[1];
        newDst[14] = v[2];
        newDst[15] = 1;
        return newDst;
    }
    /**
     * Translates the given 4-by-4 matrix by the given vector v.
     * @param m - The matrix.
     * @param v - The vector by
     *     which to translate.
     * @param dst - matrix to hold result. If not passed a new one is created.
     * @returns The translated matrix.
     */
    function translate(m, v, dst) {
        const newDst = (dst ?? new Ctor(16));
        const v0 = v[0];
        const v1 = v[1];
        const v2 = v[2];
        const m00 = m[0];
        const m01 = m[1];
        const m02 = m[2];
        const m03 = m[3];
        const m10 = m[1 * 4 + 0];
        const m11 = m[1 * 4 + 1];
        const m12 = m[1 * 4 + 2];
        const m13 = m[1 * 4 + 3];
        const m20 = m[2 * 4 + 0];
        const m21 = m[2 * 4 + 1];
        const m22 = m[2 * 4 + 2];
        const m23 = m[2 * 4 + 3];
        const m30 = m[3 * 4 + 0];
        const m31 = m[3 * 4 + 1];
        const m32 = m[3 * 4 + 2];
        const m33 = m[3 * 4 + 3];
        if (m !== newDst) {
            newDst[0] = m00;
            newDst[1] = m01;
            newDst[2] = m02;
            newDst[3] = m03;
            newDst[4] = m10;
            newDst[5] = m11;
            newDst[6] = m12;
            newDst[7] = m13;
            newDst[8] = m20;
            newDst[9] = m21;
            newDst[10] = m22;
            newDst[11] = m23;
        }
        newDst[12] = m00 * v0 + m10 * v1 + m20 * v2 + m30;
        newDst[13] = m01 * v0 + m11 * v1 + m21 * v2 + m31;
        newDst[14] = m02 * v0 + m12 * v1 + m22 * v2 + m32;
        newDst[15] = m03 * v0 + m13 * v1 + m23 * v2 + m33;
        return newDst;
    }
    /**
     * Creates a 4-by-4 matrix which rotates around the x-axis by the given angle.
     * @param angleInRadians - The angle by which to rotate (in radians).
     * @param dst - matrix to hold result. If not passed a new one is created.
     * @returns The rotation matrix.
     */
    function rotationX(angleInRadians, dst) {
        const newDst = (dst ?? new Ctor(16));
        const c = Math.cos(angleInRadians);
        const s = Math.sin(angleInRadians);
        newDst[0] = 1;
        newDst[1] = 0;
        newDst[2] = 0;
        newDst[3] = 0;
        newDst[4] = 0;
        newDst[5] = c;
        newDst[6] = s;
        newDst[7] = 0;
        newDst[8] = 0;
        newDst[9] = -s;
        newDst[10] = c;
        newDst[11] = 0;
        newDst[12] = 0;
        newDst[13] = 0;
        newDst[14] = 0;
        newDst[15] = 1;
        return newDst;
    }
    /**
     * Rotates the given 4-by-4 matrix around the x-axis by the given
     * angle.
     * @param m - The matrix.
     * @param angleInRadians - The angle by which to rotate (in radians).
     * @param dst - matrix to hold result. If not passed a new one is created.
     * @returns The rotated matrix.
     */
    function rotateX(m, angleInRadians, dst) {
        const newDst = (dst ?? new Ctor(16));
        const m10 = m[4];
        const m11 = m[5];
        const m12 = m[6];
        const m13 = m[7];
        const m20 = m[8];
        const m21 = m[9];
        const m22 = m[10];
        const m23 = m[11];
        const c = Math.cos(angleInRadians);
        const s = Math.sin(angleInRadians);
        newDst[4] = c * m10 + s * m20;
        newDst[5] = c * m11 + s * m21;
        newDst[6] = c * m12 + s * m22;
        newDst[7] = c * m13 + s * m23;
        newDst[8] = c * m20 - s * m10;
        newDst[9] = c * m21 - s * m11;
        newDst[10] = c * m22 - s * m12;
        newDst[11] = c * m23 - s * m13;
        if (m !== newDst) {
            newDst[0] = m[0];
            newDst[1] = m[1];
            newDst[2] = m[2];
            newDst[3] = m[3];
            newDst[12] = m[12];
            newDst[13] = m[13];
            newDst[14] = m[14];
            newDst[15] = m[15];
        }
        return newDst;
    }
    /**
     * Creates a 4-by-4 matrix which rotates around the y-axis by the given angle.
     * @param angleInRadians - The angle by which to rotate (in radians).
     * @param dst - matrix to hold result. If not passed a new one is created.
     * @returns The rotation matrix.
     */
    function rotationY(angleInRadians, dst) {
        const newDst = (dst ?? new Ctor(16));
        const c = Math.cos(angleInRadians);
        const s = Math.sin(angleInRadians);
        newDst[0] = c;
        newDst[1] = 0;
        newDst[2] = -s;
        newDst[3] = 0;
        newDst[4] = 0;
        newDst[5] = 1;
        newDst[6] = 0;
        newDst[7] = 0;
        newDst[8] = s;
        newDst[9] = 0;
        newDst[10] = c;
        newDst[11] = 0;
        newDst[12] = 0;
        newDst[13] = 0;
        newDst[14] = 0;
        newDst[15] = 1;
        return newDst;
    }
    /**
     * Rotates the given 4-by-4 matrix around the y-axis by the given
     * angle.
     * @param m - The matrix.
     * @param angleInRadians - The angle by which to rotate (in radians).
     * @param dst - matrix to hold result. If not passed a new one is created.
     * @returns The rotated matrix.
     */
    function rotateY(m, angleInRadians, dst) {
        const newDst = (dst ?? new Ctor(16));
        const m00 = m[0 * 4 + 0];
        const m01 = m[0 * 4 + 1];
        const m02 = m[0 * 4 + 2];
        const m03 = m[0 * 4 + 3];
        const m20 = m[2 * 4 + 0];
        const m21 = m[2 * 4 + 1];
        const m22 = m[2 * 4 + 2];
        const m23 = m[2 * 4 + 3];
        const c = Math.cos(angleInRadians);
        const s = Math.sin(angleInRadians);
        newDst[0] = c * m00 - s * m20;
        newDst[1] = c * m01 - s * m21;
        newDst[2] = c * m02 - s * m22;
        newDst[3] = c * m03 - s * m23;
        newDst[8] = c * m20 + s * m00;
        newDst[9] = c * m21 + s * m01;
        newDst[10] = c * m22 + s * m02;
        newDst[11] = c * m23 + s * m03;
        if (m !== newDst) {
            newDst[4] = m[4];
            newDst[5] = m[5];
            newDst[6] = m[6];
            newDst[7] = m[7];
            newDst[12] = m[12];
            newDst[13] = m[13];
            newDst[14] = m[14];
            newDst[15] = m[15];
        }
        return newDst;
    }
    /**
     * Creates a 4-by-4 matrix which rotates around the z-axis by the given angle.
     * @param angleInRadians - The angle by which to rotate (in radians).
     * @param dst - matrix to hold result. If not passed a new one is created.
     * @returns The rotation matrix.
     */
    function rotationZ(angleInRadians, dst) {
        const newDst = (dst ?? new Ctor(16));
        const c = Math.cos(angleInRadians);
        const s = Math.sin(angleInRadians);
        newDst[0] = c;
        newDst[1] = s;
        newDst[2] = 0;
        newDst[3] = 0;
        newDst[4] = -s;
        newDst[5] = c;
        newDst[6] = 0;
        newDst[7] = 0;
        newDst[8] = 0;
        newDst[9] = 0;
        newDst[10] = 1;
        newDst[11] = 0;
        newDst[12] = 0;
        newDst[13] = 0;
        newDst[14] = 0;
        newDst[15] = 1;
        return newDst;
    }
    /**
     * Rotates the given 4-by-4 matrix around the z-axis by the given
     * angle.
     * @param m - The matrix.
     * @param angleInRadians - The angle by which to rotate (in radians).
     * @param dst - matrix to hold result. If not passed a new one is created.
     * @returns The rotated matrix.
     */
    function rotateZ(m, angleInRadians, dst) {
        const newDst = (dst ?? new Ctor(16));
        const m00 = m[0 * 4 + 0];
        const m01 = m[0 * 4 + 1];
        const m02 = m[0 * 4 + 2];
        const m03 = m[0 * 4 + 3];
        const m10 = m[1 * 4 + 0];
        const m11 = m[1 * 4 + 1];
        const m12 = m[1 * 4 + 2];
        const m13 = m[1 * 4 + 3];
        const c = Math.cos(angleInRadians);
        const s = Math.sin(angleInRadians);
        newDst[0] = c * m00 + s * m10;
        newDst[1] = c * m01 + s * m11;
        newDst[2] = c * m02 + s * m12;
        newDst[3] = c * m03 + s * m13;
        newDst[4] = c * m10 - s * m00;
        newDst[5] = c * m11 - s * m01;
        newDst[6] = c * m12 - s * m02;
        newDst[7] = c * m13 - s * m03;
        if (m !== newDst) {
            newDst[8] = m[8];
            newDst[9] = m[9];
            newDst[10] = m[10];
            newDst[11] = m[11];
            newDst[12] = m[12];
            newDst[13] = m[13];
            newDst[14] = m[14];
            newDst[15] = m[15];
        }
        return newDst;
    }
    /**
     * Creates a 4-by-4 matrix which rotates around the given axis by the given
     * angle.
     * @param axis - The axis
     *     about which to rotate.
     * @param angleInRadians - The angle by which to rotate (in radians).
     * @param dst - matrix to hold result. If not passed a new one is created.
     * @returns A matrix which rotates angle radians
     *     around the axis.
     */
    function axisRotation(axis, angleInRadians, dst) {
        const newDst = (dst ?? new Ctor(16));
        let x = axis[0];
        let y = axis[1];
        let z = axis[2];
        const n = Math.sqrt(x * x + y * y + z * z);
        x /= n;
        y /= n;
        z /= n;
        const xx = x * x;
        const yy = y * y;
        const zz = z * z;
        const c = Math.cos(angleInRadians);
        const s = Math.sin(angleInRadians);
        const oneMinusCosine = 1 - c;
        newDst[0] = xx + (1 - xx) * c;
        newDst[1] = x * y * oneMinusCosine + z * s;
        newDst[2] = x * z * oneMinusCosine - y * s;
        newDst[3] = 0;
        newDst[4] = x * y * oneMinusCosine - z * s;
        newDst[5] = yy + (1 - yy) * c;
        newDst[6] = y * z * oneMinusCosine + x * s;
        newDst[7] = 0;
        newDst[8] = x * z * oneMinusCosine + y * s;
        newDst[9] = y * z * oneMinusCosine - x * s;
        newDst[10] = zz + (1 - zz) * c;
        newDst[11] = 0;
        newDst[12] = 0;
        newDst[13] = 0;
        newDst[14] = 0;
        newDst[15] = 1;
        return newDst;
    }
    /**
     * Creates a 4-by-4 matrix which rotates around the given axis by the given
     * angle. (same as axisRotation)
     * @param axis - The axis
     *     about which to rotate.
     * @param angleInRadians - The angle by which to rotate (in radians).
     * @param dst - matrix to hold result. If not passed a new one is created.
     * @returns A matrix which rotates angle radians
     *     around the axis.
     */
    const rotation = axisRotation;
    /**
     * Rotates the given 4-by-4 matrix around the given axis by the
     * given angle.
     * @param m - The matrix.
     * @param axis - The axis
     *     about which to rotate.
     * @param angleInRadians - The angle by which to rotate (in radians).
     * @param dst - matrix to hold result. If not passed a new one is created.
     * @returns The rotated matrix.
     */
    function axisRotate(m, axis, angleInRadians, dst) {
        const newDst = (dst ?? new Ctor(16));
        let x = axis[0];
        let y = axis[1];
        let z = axis[2];
        const n = Math.sqrt(x * x + y * y + z * z);
        x /= n;
        y /= n;
        z /= n;
        const xx = x * x;
        const yy = y * y;
        const zz = z * z;
        const c = Math.cos(angleInRadians);
        const s = Math.sin(angleInRadians);
        const oneMinusCosine = 1 - c;
        const r00 = xx + (1 - xx) * c;
        const r01 = x * y * oneMinusCosine + z * s;
        const r02 = x * z * oneMinusCosine - y * s;
        const r10 = x * y * oneMinusCosine - z * s;
        const r11 = yy + (1 - yy) * c;
        const r12 = y * z * oneMinusCosine + x * s;
        const r20 = x * z * oneMinusCosine + y * s;
        const r21 = y * z * oneMinusCosine - x * s;
        const r22 = zz + (1 - zz) * c;
        const m00 = m[0];
        const m01 = m[1];
        const m02 = m[2];
        const m03 = m[3];
        const m10 = m[4];
        const m11 = m[5];
        const m12 = m[6];
        const m13 = m[7];
        const m20 = m[8];
        const m21 = m[9];
        const m22 = m[10];
        const m23 = m[11];
        newDst[0] = r00 * m00 + r01 * m10 + r02 * m20;
        newDst[1] = r00 * m01 + r01 * m11 + r02 * m21;
        newDst[2] = r00 * m02 + r01 * m12 + r02 * m22;
        newDst[3] = r00 * m03 + r01 * m13 + r02 * m23;
        newDst[4] = r10 * m00 + r11 * m10 + r12 * m20;
        newDst[5] = r10 * m01 + r11 * m11 + r12 * m21;
        newDst[6] = r10 * m02 + r11 * m12 + r12 * m22;
        newDst[7] = r10 * m03 + r11 * m13 + r12 * m23;
        newDst[8] = r20 * m00 + r21 * m10 + r22 * m20;
        newDst[9] = r20 * m01 + r21 * m11 + r22 * m21;
        newDst[10] = r20 * m02 + r21 * m12 + r22 * m22;
        newDst[11] = r20 * m03 + r21 * m13 + r22 * m23;
        if (m !== newDst) {
            newDst[12] = m[12];
            newDst[13] = m[13];
            newDst[14] = m[14];
            newDst[15] = m[15];
        }
        return newDst;
    }
    /**
     * Rotates the given 4-by-4 matrix around the given axis by the
     * given angle. (same as rotate)
     * @param m - The matrix.
     * @param axis - The axis
     *     about which to rotate.
     * @param angleInRadians - The angle by which to rotate (in radians).
     * @param dst - matrix to hold result. If not passed a new one is created.
     * @returns The rotated matrix.
     */
    const rotate = axisRotate;
    /**
     * Creates a 4-by-4 matrix which scales in each dimension by an amount given by
     * the corresponding entry in the given vector; assumes the vector has three
     * entries.
     * @param v - A vector of
     *     three entries specifying the factor by which to scale in each dimension.
     * @param dst - matrix to hold result. If not passed a new one is created.
     * @returns The scaling matrix.
     */
    function scaling(v, dst) {
        const newDst = (dst ?? new Ctor(16));
        newDst[0] = v[0];
        newDst[1] = 0;
        newDst[2] = 0;
        newDst[3] = 0;
        newDst[4] = 0;
        newDst[5] = v[1];
        newDst[6] = 0;
        newDst[7] = 0;
        newDst[8] = 0;
        newDst[9] = 0;
        newDst[10] = v[2];
        newDst[11] = 0;
        newDst[12] = 0;
        newDst[13] = 0;
        newDst[14] = 0;
        newDst[15] = 1;
        return newDst;
    }
    /**
     * Scales the given 4-by-4 matrix in each dimension by an amount
     * given by the corresponding entry in the given vector; assumes the vector has
     * three entries.
     * @param m - The matrix to be modified.
     * @param v - A vector of three entries specifying the
     *     factor by which to scale in each dimension.
     * @param dst - matrix to hold result. If not passed a new one is created.
     * @returns The scaled matrix.
     */
    function scale(m, v, dst) {
        const newDst = (dst ?? new Ctor(16));
        const v0 = v[0];
        const v1 = v[1];
        const v2 = v[2];
        newDst[0] = v0 * m[0 * 4 + 0];
        newDst[1] = v0 * m[0 * 4 + 1];
        newDst[2] = v0 * m[0 * 4 + 2];
        newDst[3] = v0 * m[0 * 4 + 3];
        newDst[4] = v1 * m[1 * 4 + 0];
        newDst[5] = v1 * m[1 * 4 + 1];
        newDst[6] = v1 * m[1 * 4 + 2];
        newDst[7] = v1 * m[1 * 4 + 3];
        newDst[8] = v2 * m[2 * 4 + 0];
        newDst[9] = v2 * m[2 * 4 + 1];
        newDst[10] = v2 * m[2 * 4 + 2];
        newDst[11] = v2 * m[2 * 4 + 3];
        if (m !== newDst) {
            newDst[12] = m[12];
            newDst[13] = m[13];
            newDst[14] = m[14];
            newDst[15] = m[15];
        }
        return newDst;
    }
    /**
     * Creates a 4-by-4 matrix which scales a uniform amount in each dimension.
     * @param s - the amount to scale
     * @param dst - matrix to hold result. If not passed a new one is created.
     * @returns The scaling matrix.
     */
    function uniformScaling(s, dst) {
        const newDst = (dst ?? new Ctor(16));
        newDst[0] = s;
        newDst[1] = 0;
        newDst[2] = 0;
        newDst[3] = 0;
        newDst[4] = 0;
        newDst[5] = s;
        newDst[6] = 0;
        newDst[7] = 0;
        newDst[8] = 0;
        newDst[9] = 0;
        newDst[10] = s;
        newDst[11] = 0;
        newDst[12] = 0;
        newDst[13] = 0;
        newDst[14] = 0;
        newDst[15] = 1;
        return newDst;
    }
    /**
     * Scales the given 4-by-4 matrix in each dimension by a uniform scale.
     * @param m - The matrix to be modified.
     * @param s - The amount to scale.
     * @param dst - matrix to hold result. If not passed a new one is created.
     * @returns The scaled matrix.
     */
    function uniformScale(m, s, dst) {
        const newDst = (dst ?? new Ctor(16));
        newDst[0] = s * m[0 * 4 + 0];
        newDst[1] = s * m[0 * 4 + 1];
        newDst[2] = s * m[0 * 4 + 2];
        newDst[3] = s * m[0 * 4 + 3];
        newDst[4] = s * m[1 * 4 + 0];
        newDst[5] = s * m[1 * 4 + 1];
        newDst[6] = s * m[1 * 4 + 2];
        newDst[7] = s * m[1 * 4 + 3];
        newDst[8] = s * m[2 * 4 + 0];
        newDst[9] = s * m[2 * 4 + 1];
        newDst[10] = s * m[2 * 4 + 2];
        newDst[11] = s * m[2 * 4 + 3];
        if (m !== newDst) {
            newDst[12] = m[12];
            newDst[13] = m[13];
            newDst[14] = m[14];
            newDst[15] = m[15];
        }
        return newDst;
    }
    return {
        create,
        set,
        fromMat3,
        fromQuat,
        negate,
        copy,
        clone,
        equalsApproximately,
        equals,
        identity,
        transpose,
        inverse,
        determinant,
        invert,
        multiply,
        mul,
        setTranslation,
        getTranslation,
        getAxis,
        setAxis,
        getScaling,
        perspective,
        perspectiveReverseZ,
        ortho,
        frustum,
        frustumReverseZ,
        aim,
        cameraAim,
        lookAt,
        translation,
        translate,
        rotationX,
        rotateX,
        rotationY,
        rotateY,
        rotationZ,
        rotateZ,
        axisRotation,
        rotation,
        axisRotate,
        rotate,
        scaling,
        scale,
        uniformScaling,
        uniformScale,
    };
}
const cache$2 = new Map();
function getAPI$2(Ctor) {
    let api = cache$2.get(Ctor);
    if (!api) {
        api = getAPIImpl$2(Ctor);
        cache$2.set(Ctor, api);
    }
    return api;
}

/*
 * Copyright 2022 Gregg Tavares
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */
/**
 * Generates am typed API for Qud
 * */
function getAPIImpl$1(Ctor) {
    const vec3 = getAPI$3(Ctor);
    /**
     * Creates a quat4; may be called with x, y, z to set initial values.
     * @param x - Initial x value.
     * @param y - Initial y value.
     * @param z - Initial z value.
     * @param w - Initial w value.
     * @returns the created vector
     */
    function create(x, y, z, w) {
        const newDst = new Ctor(4);
        if (x !== undefined) {
            newDst[0] = x;
            if (y !== undefined) {
                newDst[1] = y;
                if (z !== undefined) {
                    newDst[2] = z;
                    if (w !== undefined) {
                        newDst[3] = w;
                    }
                }
            }
        }
        return newDst;
    }
    /**
     * Creates a Quat; may be called with x, y, z to set initial values. (same as create)
     * @param x - Initial x value.
     * @param y - Initial y value.
     * @param z - Initial z value.
     * @param z - Initial w value.
     * @returns the created vector
     */
    const fromValues = create;
    /**
     * Sets the values of a Quat
     * Also see {@link quat.create} and {@link quat.copy}
     *
     * @param x first value
     * @param y second value
     * @param z third value
     * @param w fourth value
     * @param dst - vector to hold result. If not passed in a new one is created.
     * @returns A vector with its elements set.
     */
    function set(x, y, z, w, dst) {
        const newDst = (dst ?? new Ctor(4));
        newDst[0] = x;
        newDst[1] = y;
        newDst[2] = z;
        newDst[3] = w;
        return newDst;
    }
    /**
     * Sets a quaternion from the given angle and  axis,
     * then returns it.
     *
     * @param axis - the axis to rotate around
     * @param angleInRadians - the angle
     * @param dst - quaternion to hold result. If not passed in a new one is created.
     * @returns The quaternion that represents the given axis and angle
     **/
    function fromAxisAngle(axis, angleInRadians, dst) {
        const newDst = (dst ?? new Ctor(4));
        const halfAngle = angleInRadians * 0.5;
        const s = Math.sin(halfAngle);
        newDst[0] = s * axis[0];
        newDst[1] = s * axis[1];
        newDst[2] = s * axis[2];
        newDst[3] = Math.cos(halfAngle);
        return newDst;
    }
    /**
     * Gets the rotation axis and angle
     * @param q - quaternion to compute from
     * @param dst - Vec3 to hold result. If not passed in a new one is created.
     * @return angle and axis
     */
    function toAxisAngle(q, dst) {
        const newDst = (dst ?? vec3.create(3));
        const angle = Math.acos(q[3]) * 2;
        const s = Math.sin(angle * 0.5);
        if (s > EPSILON) {
            newDst[0] = q[0] / s;
            newDst[1] = q[1] / s;
            newDst[2] = q[2] / s;
        }
        else {
            newDst[0] = 1;
            newDst[1] = 0;
            newDst[2] = 0;
        }
        return { angle, axis: newDst };
    }
    /**
     * Returns the angle in degrees between two rotations a and b.
     * @param a - quaternion a
     * @param b - quaternion b
     * @return angle in radians between the two quaternions
     */
    function angle(a, b) {
        const d = dot(a, b);
        return Math.acos(2 * d * d - 1);
    }
    /**
     * Multiplies two quaternions
     *
     * @param a - the first quaternion
     * @param b - the second quaternion
     * @param dst - quaternion to hold result. If not passed in a new one is created.
     * @returns A quaternion that is the result of a * b
     */
    function multiply(a, b, dst) {
        const newDst = (dst ?? new Ctor(4));
        const ax = a[0];
        const ay = a[1];
        const az = a[2];
        const aw = a[3];
        const bx = b[0];
        const by = b[1];
        const bz = b[2];
        const bw = b[3];
        newDst[0] = ax * bw + aw * bx + ay * bz - az * by;
        newDst[1] = ay * bw + aw * by + az * bx - ax * bz;
        newDst[2] = az * bw + aw * bz + ax * by - ay * bx;
        newDst[3] = aw * bw - ax * bx - ay * by - az * bz;
        return newDst;
    }
    /**
     * Multiplies two quaternions
     *
     * @param a - the first quaternion
     * @param b - the second quaternion
     * @param dst - quaternion to hold result. If not passed in a new one is created.
     * @returns A quaternion that is the result of a * b
     */
    const mul = multiply;
    /**
     * Rotates the given quaternion around the X axis by the given angle.
     * @param q - quaternion to rotate
     * @param angleInRadians - The angle by which to rotate
     * @param dst - quaternion to hold result. If not passed in a new one is created.
     * @returns A quaternion that is the result of a * b
     */
    function rotateX(q, angleInRadians, dst) {
        const newDst = (dst ?? new Ctor(4));
        const halfAngle = angleInRadians * 0.5;
        const qx = q[0];
        const qy = q[1];
        const qz = q[2];
        const qw = q[3];
        const bx = Math.sin(halfAngle);
        const bw = Math.cos(halfAngle);
        newDst[0] = qx * bw + qw * bx;
        newDst[1] = qy * bw + qz * bx;
        newDst[2] = qz * bw - qy * bx;
        newDst[3] = qw * bw - qx * bx;
        return newDst;
    }
    /**
     * Rotates the given quaternion around the Y axis by the given angle.
     * @param q - quaternion to rotate
     * @param angleInRadians - The angle by which to rotate
     * @param dst - quaternion to hold result. If not passed in a new one is created.
     * @returns A quaternion that is the result of a * b
     */
    function rotateY(q, angleInRadians, dst) {
        const newDst = (dst ?? new Ctor(4));
        const halfAngle = angleInRadians * 0.5;
        const qx = q[0];
        const qy = q[1];
        const qz = q[2];
        const qw = q[3];
        const by = Math.sin(halfAngle);
        const bw = Math.cos(halfAngle);
        newDst[0] = qx * bw - qz * by;
        newDst[1] = qy * bw + qw * by;
        newDst[2] = qz * bw + qx * by;
        newDst[3] = qw * bw - qy * by;
        return newDst;
    }
    /**
     * Rotates the given quaternion around the Z axis by the given angle.
     * @param q - quaternion to rotate
     * @param angleInRadians - The angle by which to rotate
     * @param dst - quaternion to hold result. If not passed in a new one is created.
     * @returns A quaternion that is the result of a * b
     */
    function rotateZ(q, angleInRadians, dst) {
        const newDst = (dst ?? new Ctor(4));
        const halfAngle = angleInRadians * 0.5;
        const qx = q[0];
        const qy = q[1];
        const qz = q[2];
        const qw = q[3];
        const bz = Math.sin(halfAngle);
        const bw = Math.cos(halfAngle);
        newDst[0] = qx * bw + qy * bz;
        newDst[1] = qy * bw - qx * bz;
        newDst[2] = qz * bw + qw * bz;
        newDst[3] = qw * bw - qz * bz;
        return newDst;
    }
    /**
     * Spherically linear interpolate between two quaternions
     *
     * @param a - starting value
     * @param b - ending value
     * @param t - value where 0 = a and 1 = b
     * @param dst - quaternion to hold result. If not passed in a new one is created.
     * @returns A quaternion that is the result of a * b
     */
    function slerp(a, b, t, dst) {
        const newDst = (dst ?? new Ctor(4));
        const ax = a[0];
        const ay = a[1];
        const az = a[2];
        const aw = a[3];
        let bx = b[0];
        let by = b[1];
        let bz = b[2];
        let bw = b[3];
        let cosOmega = ax * bx + ay * by + az * bz + aw * bw;
        if (cosOmega < 0) {
            cosOmega = -cosOmega;
            bx = -bx;
            by = -by;
            bz = -bz;
            bw = -bw;
        }
        let scale0;
        let scale1;
        if (1.0 - cosOmega > EPSILON) {
            const omega = Math.acos(cosOmega);
            const sinOmega = Math.sin(omega);
            scale0 = Math.sin((1 - t) * omega) / sinOmega;
            scale1 = Math.sin(t * omega) / sinOmega;
        }
        else {
            scale0 = 1.0 - t;
            scale1 = t;
        }
        newDst[0] = scale0 * ax + scale1 * bx;
        newDst[1] = scale0 * ay + scale1 * by;
        newDst[2] = scale0 * az + scale1 * bz;
        newDst[3] = scale0 * aw + scale1 * bw;
        return newDst;
    }
    /**
     * Compute the inverse of a quaternion
     *
     * @param q - quaternion to compute the inverse of
     * @returns A quaternion that is the result of a * b
     */
    function inverse(q, dst) {
        const newDst = (dst ?? new Ctor(4));
        const a0 = q[0];
        const a1 = q[1];
        const a2 = q[2];
        const a3 = q[3];
        const dot = a0 * a0 + a1 * a1 + a2 * a2 + a3 * a3;
        const invDot = dot ? 1 / dot : 0;
        newDst[0] = -a0 * invDot;
        newDst[1] = -a1 * invDot;
        newDst[2] = -a2 * invDot;
        newDst[3] = a3 * invDot;
        return newDst;
    }
    /**
     * Compute the conjugate of a quaternion
     * For quaternions with a magnitude of 1 (a unit quaternion)
     * this returns the same as the inverse but is faster to calculate.
     *
     * @param q - quaternion to compute the conjugate of.
     * @param dst - quaternion to hold result. If not passed in a new one is created.
     * @returns The conjugate of q
     */
    function conjugate(q, dst) {
        const newDst = (dst ?? new Ctor(4));
        newDst[0] = -q[0];
        newDst[1] = -q[1];
        newDst[2] = -q[2];
        newDst[3] = q[3];
        return newDst;
    }
    /**
     * Creates a quaternion from the given rotation matrix.
     *
     * The created quaternion is not normalized.
     *
     * @param m - rotation matrix
     * @param dst - quaternion to hold result. If not passed in a new one is created.
     * @returns the result
     */
    function fromMat(m, dst) {
        const newDst = (dst ?? new Ctor(4));
        /*
        0 1 2
        3 4 5
        6 7 8
      
        0 1 2
        4 5 6
        8 9 10
         */
        // Algorithm in Ken Shoemake's article in 1987 SIGGRAPH course notes
        // article "Quaternion Calculus and Fast Animation".
        const trace = m[0] + m[5] + m[10];
        if (trace > 0.0) {
            // |w| > 1/2, may as well choose w > 1/2
            const root = Math.sqrt(trace + 1); // 2w
            newDst[3] = 0.5 * root;
            const invRoot = 0.5 / root; // 1/(4w)
            newDst[0] = (m[6] - m[9]) * invRoot;
            newDst[1] = (m[8] - m[2]) * invRoot;
            newDst[2] = (m[1] - m[4]) * invRoot;
        }
        else {
            // |w| <= 1/2
            let i = 0;
            if (m[5] > m[0]) {
                i = 1;
            }
            if (m[10] > m[i * 4 + i]) {
                i = 2;
            }
            const j = (i + 1) % 3;
            const k = (i + 2) % 3;
            const root = Math.sqrt(m[i * 4 + i] - m[j * 4 + j] - m[k * 4 + k] + 1.0);
            newDst[i] = 0.5 * root;
            const invRoot = 0.5 / root;
            newDst[3] = (m[j * 4 + k] - m[k * 4 + j]) * invRoot;
            newDst[j] = (m[j * 4 + i] + m[i * 4 + j]) * invRoot;
            newDst[k] = (m[k * 4 + i] + m[i * 4 + k]) * invRoot;
        }
        return newDst;
    }
    /**
     * Creates a quaternion from the given euler angle x, y, z using the provided intrinsic order for the conversion.
     *
     * @param xAngleInRadians - angle to rotate around X axis in radians.
     * @param yAngleInRadians - angle to rotate around Y axis in radians.
     * @param zAngleInRadians - angle to rotate around Z axis in radians.
     * @param order - order to apply euler angles
     * @param dst - quaternion to hold result. If not passed in a new one is created.
     * @returns A quaternion representing the same rotation as the euler angles applied in the given order
     */
    function fromEuler(xAngleInRadians, yAngleInRadians, zAngleInRadians, order, dst) {
        const newDst = (dst ?? new Ctor(4));
        const xHalfAngle = xAngleInRadians * 0.5;
        const yHalfAngle = yAngleInRadians * 0.5;
        const zHalfAngle = zAngleInRadians * 0.5;
        const sx = Math.sin(xHalfAngle);
        const cx = Math.cos(xHalfAngle);
        const sy = Math.sin(yHalfAngle);
        const cy = Math.cos(yHalfAngle);
        const sz = Math.sin(zHalfAngle);
        const cz = Math.cos(zHalfAngle);
        switch (order) {
            case 'xyz':
                newDst[0] = sx * cy * cz + cx * sy * sz;
                newDst[1] = cx * sy * cz - sx * cy * sz;
                newDst[2] = cx * cy * sz + sx * sy * cz;
                newDst[3] = cx * cy * cz - sx * sy * sz;
                break;
            case 'xzy':
                newDst[0] = sx * cy * cz - cx * sy * sz;
                newDst[1] = cx * sy * cz - sx * cy * sz;
                newDst[2] = cx * cy * sz + sx * sy * cz;
                newDst[3] = cx * cy * cz + sx * sy * sz;
                break;
            case 'yxz':
                newDst[0] = sx * cy * cz + cx * sy * sz;
                newDst[1] = cx * sy * cz - sx * cy * sz;
                newDst[2] = cx * cy * sz - sx * sy * cz;
                newDst[3] = cx * cy * cz + sx * sy * sz;
                break;
            case 'yzx':
                newDst[0] = sx * cy * cz + cx * sy * sz;
                newDst[1] = cx * sy * cz + sx * cy * sz;
                newDst[2] = cx * cy * sz - sx * sy * cz;
                newDst[3] = cx * cy * cz - sx * sy * sz;
                break;
            case 'zxy':
                newDst[0] = sx * cy * cz - cx * sy * sz;
                newDst[1] = cx * sy * cz + sx * cy * sz;
                newDst[2] = cx * cy * sz + sx * sy * cz;
                newDst[3] = cx * cy * cz - sx * sy * sz;
                break;
            case 'zyx':
                newDst[0] = sx * cy * cz - cx * sy * sz;
                newDst[1] = cx * sy * cz + sx * cy * sz;
                newDst[2] = cx * cy * sz - sx * sy * cz;
                newDst[3] = cx * cy * cz + sx * sy * sz;
                break;
            default:
                throw new Error(`Unknown rotation order: ${order}`);
        }
        return newDst;
    }
    /**
     * Copies a quaternion. (same as {@link quat.clone})
     * Also see {@link quat.create} and {@link quat.set}
     * @param q - The quaternion.
     * @param dst - quaternion to hold result. If not passed in a new one is created.
     * @returns A quaternion that is a copy of q
     */
    function copy(q, dst) {
        const newDst = (dst ?? new Ctor(4));
        newDst[0] = q[0];
        newDst[1] = q[1];
        newDst[2] = q[2];
        newDst[3] = q[3];
        return newDst;
    }
    /**
     * Clones a quaternion. (same as {@link quat.copy})
     * Also see {@link quat.create} and {@link quat.set}
     * @param q - The quaternion.
     * @param dst - quaternion to hold result. If not passed in a new one is created.
     * @returns A copy of q.
     */
    const clone = copy;
    /**
     * Adds two quaternions; assumes a and b have the same dimension.
     * @param a - Operand quaternion.
     * @param b - Operand quaternion.
     * @param dst - quaternion to hold result. If not passed in a new one is created.
     * @returns A quaternion that is the sum of a and b.
     */
    function add(a, b, dst) {
        const newDst = (dst ?? new Ctor(4));
        newDst[0] = a[0] + b[0];
        newDst[1] = a[1] + b[1];
        newDst[2] = a[2] + b[2];
        newDst[3] = a[3] + b[3];
        return newDst;
    }
    /**
     * Subtracts two quaternions.
     * @param a - Operand quaternion.
     * @param b - Operand quaternion.
     * @param dst - quaternion to hold result. If not passed in a new one is created.
     * @returns A quaternion that is the difference of a and b.
     */
    function subtract(a, b, dst) {
        const newDst = (dst ?? new Ctor(4));
        newDst[0] = a[0] - b[0];
        newDst[1] = a[1] - b[1];
        newDst[2] = a[2] - b[2];
        newDst[3] = a[3] - b[3];
        return newDst;
    }
    /**
     * Subtracts two quaternions.
     * @param a - Operand quaternion.
     * @param b - Operand quaternion.
     * @param dst - quaternion to hold result. If not passed in a new one is created.
     * @returns A quaternion that is the difference of a and b.
     */
    const sub = subtract;
    /**
     * Multiplies a quaternion by a scalar.
     * @param v - The quaternion.
     * @param k - The scalar.
     * @param dst - quaternion to hold result. If not passed in a new one is created.
     * @returns The scaled quaternion.
     */
    function mulScalar(v, k, dst) {
        const newDst = (dst ?? new Ctor(4));
        newDst[0] = v[0] * k;
        newDst[1] = v[1] * k;
        newDst[2] = v[2] * k;
        newDst[3] = v[3] * k;
        return newDst;
    }
    /**
     * Multiplies a quaternion by a scalar. (same as mulScalar)
     * @param v - The quaternion.
     * @param k - The scalar.
     * @param dst - quaternion to hold result. If not passed in a new one is created.
     * @returns The scaled quaternion.
     */
    const scale = mulScalar;
    /**
     * Divides a vector by a scalar.
     * @param v - The vector.
     * @param k - The scalar.
     * @param dst - quaternion to hold result. If not passed in a new one is created.
     * @returns The scaled quaternion.
     */
    function divScalar(v, k, dst) {
        const newDst = (dst ?? new Ctor(4));
        newDst[0] = v[0] / k;
        newDst[1] = v[1] / k;
        newDst[2] = v[2] / k;
        newDst[3] = v[3] / k;
        return newDst;
    }
    /**
     * Computes the dot product of two quaternions
     * @param a - Operand quaternion.
     * @param b - Operand quaternion.
     * @returns dot product
     */
    function dot(a, b) {
        return (a[0] * b[0]) + (a[1] * b[1]) + (a[2] * b[2]) + (a[3] * b[3]);
    }
    /**
     * Performs linear interpolation on two quaternions.
     * Given quaternions a and b and interpolation coefficient t, returns
     * a + t * (b - a).
     * @param a - Operand quaternion.
     * @param b - Operand quaternion.
     * @param t - Interpolation coefficient.
     * @param dst - quaternion to hold result. If not passed in a new one is created.
     * @returns The linear interpolated result.
     */
    function lerp(a, b, t, dst) {
        const newDst = (dst ?? new Ctor(4));
        newDst[0] = a[0] + t * (b[0] - a[0]);
        newDst[1] = a[1] + t * (b[1] - a[1]);
        newDst[2] = a[2] + t * (b[2] - a[2]);
        newDst[3] = a[3] + t * (b[3] - a[3]);
        return newDst;
    }
    /**
     * Computes the length of quaternion
     * @param v - quaternion.
     * @returns length of quaternion.
     */
    function length(v) {
        const v0 = v[0];
        const v1 = v[1];
        const v2 = v[2];
        const v3 = v[3];
        return Math.sqrt(v0 * v0 + v1 * v1 + v2 * v2 + v3 * v3);
    }
    /**
     * Computes the length of quaternion (same as length)
     * @param v - quaternion.
     * @returns length of quaternion.
     */
    const len = length;
    /**
     * Computes the square of the length of quaternion
     * @param v - quaternion.
     * @returns square of the length of quaternion.
     */
    function lengthSq(v) {
        const v0 = v[0];
        const v1 = v[1];
        const v2 = v[2];
        const v3 = v[3];
        return v0 * v0 + v1 * v1 + v2 * v2 + v3 * v3;
    }
    /**
     * Computes the square of the length of quaternion (same as lengthSq)
     * @param v - quaternion.
     * @returns square of the length of quaternion.
     */
    const lenSq = lengthSq;
    /**
     * Divides a quaternion by its Euclidean length and returns the quotient.
     * @param v - The quaternion.
     * @param dst - quaternion to hold result. If not passed in a new one is created.
     * @returns The normalized quaternion.
     */
    function normalize(v, dst) {
        const newDst = (dst ?? new Ctor(4));
        const v0 = v[0];
        const v1 = v[1];
        const v2 = v[2];
        const v3 = v[3];
        const len = Math.sqrt(v0 * v0 + v1 * v1 + v2 * v2 + v3 * v3);
        if (len > 0.00001) {
            newDst[0] = v0 / len;
            newDst[1] = v1 / len;
            newDst[2] = v2 / len;
            newDst[3] = v3 / len;
        }
        else {
            newDst[0] = 0;
            newDst[1] = 0;
            newDst[2] = 0;
            newDst[3] = 0;
        }
        return newDst;
    }
    /**
     * Check if 2 quaternions are approximately equal
     * @param a - Operand quaternion.
     * @param b - Operand quaternion.
     * @returns true if quaternions are approximately equal
     */
    function equalsApproximately(a, b) {
        return Math.abs(a[0] - b[0]) < EPSILON &&
            Math.abs(a[1] - b[1]) < EPSILON &&
            Math.abs(a[2] - b[2]) < EPSILON &&
            Math.abs(a[3] - b[3]) < EPSILON;
    }
    /**
     * Check if 2 quaternions are exactly equal
     * @param a - Operand quaternion.
     * @param b - Operand quaternion.
     * @returns true if quaternions are exactly equal
     */
    function equals(a, b) {
        return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3];
    }
    /**
     * Creates an identity quaternion
     * @param dst - quaternion to hold result. If not passed in a new one is created.
     * @returns an identity quaternion
     */
    function identity(dst) {
        const newDst = (dst ?? new Ctor(4));
        newDst[0] = 0;
        newDst[1] = 0;
        newDst[2] = 0;
        newDst[3] = 1;
        return newDst;
    }
    const tempVec3 = vec3.create();
    const xUnitVec3 = vec3.create();
    const yUnitVec3 = vec3.create();
    /**
     * Computes a quaternion to represent the shortest rotation from one vector to another.
     *
     * @param aUnit - the start vector
     * @param bUnit - the end vector
     * @param dst - quaternion to hold result. If not passed in a new one is created.
     * @returns the result
     */
    function rotationTo(aUnit, bUnit, dst) {
        const newDst = (dst ?? new Ctor(4));
        const dot = vec3.dot(aUnit, bUnit);
        if (dot < -0.999999) {
            vec3.cross(xUnitVec3, aUnit, tempVec3);
            if (vec3.len(tempVec3) < 0.000001) {
                vec3.cross(yUnitVec3, aUnit, tempVec3);
            }
            vec3.normalize(tempVec3, tempVec3);
            fromAxisAngle(tempVec3, Math.PI, newDst);
            return newDst;
        }
        else if (dot > 0.999999) {
            newDst[0] = 0;
            newDst[1] = 0;
            newDst[2] = 0;
            newDst[3] = 1;
            return newDst;
        }
        else {
            vec3.cross(aUnit, bUnit, tempVec3);
            newDst[0] = tempVec3[0];
            newDst[1] = tempVec3[1];
            newDst[2] = tempVec3[2];
            newDst[3] = 1 + dot;
            return normalize(newDst, newDst);
        }
    }
    const tempQuat1 = new Ctor(4);
    const tempQuat2 = new Ctor(4);
    /**
     * Performs a spherical linear interpolation with two control points
     *
     * @param a - the first quaternion
     * @param b - the second quaternion
     * @param c - the third quaternion
     * @param d - the fourth quaternion
     * @param t - Interpolation coefficient 0 to 1
     * @returns result
     */
    function sqlerp(a, b, c, d, t, dst) {
        const newDst = (dst ?? new Ctor(4));
        slerp(a, d, t, tempQuat1);
        slerp(b, c, t, tempQuat2);
        slerp(tempQuat1, tempQuat2, 2 * t * (1 - t), newDst);
        return newDst;
    }
    return {
        create,
        fromValues,
        set,
        fromAxisAngle,
        toAxisAngle,
        angle,
        multiply,
        mul,
        rotateX,
        rotateY,
        rotateZ,
        slerp,
        inverse,
        conjugate,
        fromMat,
        fromEuler,
        copy,
        clone,
        add,
        subtract,
        sub,
        mulScalar,
        scale,
        divScalar,
        dot,
        lerp,
        length,
        len,
        lengthSq,
        lenSq,
        normalize,
        equalsApproximately,
        equals,
        identity,
        rotationTo,
        sqlerp,
    };
}
const cache$1 = new Map();
/**
 *
 * Quat4 math functions.
 *
 * Almost all functions take an optional `newDst` argument. If it is not passed in the
 * functions will create a new `Quat4`. In other words you can do this
 *
 *     const v = quat4.cross(v1, v2);  // Creates a new Quat4 with the cross product of v1 x v2.
 *
 * or
 *
 *     const v = quat4.create();
 *     quat4.cross(v1, v2, v);  // Puts the cross product of v1 x v2 in v
 *
 * The first style is often easier but depending on where it's used it generates garbage where
 * as there is almost never allocation with the second style.
 *
 * It is always safe to pass any vector as the destination. So for example
 *
 *     quat4.cross(v1, v2, v1);  // Puts the cross product of v1 x v2 in v1
 *
 */
function getAPI$1(Ctor) {
    let api = cache$1.get(Ctor);
    if (!api) {
        api = getAPIImpl$1(Ctor);
        cache$1.set(Ctor, api);
    }
    return api;
}

/*
 * Copyright 2022 Gregg Tavares
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */
/**
 * Generates am typed API for Vec4
 * */
function getAPIImpl(Ctor) {
    /**
     * Creates a vec4; may be called with x, y, z to set initial values.
     * @param x - Initial x value.
     * @param y - Initial y value.
     * @param z - Initial z value.
     * @param w - Initial w value.
     * @returns the created vector
     */
    function create(x, y, z, w) {
        const newDst = new Ctor(4);
        if (x !== undefined) {
            newDst[0] = x;
            if (y !== undefined) {
                newDst[1] = y;
                if (z !== undefined) {
                    newDst[2] = z;
                    if (w !== undefined) {
                        newDst[3] = w;
                    }
                }
            }
        }
        return newDst;
    }
    /**
     * Creates a vec4; may be called with x, y, z to set initial values. (same as create)
     * @param x - Initial x value.
     * @param y - Initial y value.
     * @param z - Initial z value.
     * @param z - Initial w value.
     * @returns the created vector
     */
    const fromValues = create;
    /**
     * Sets the values of a Vec4
     * Also see {@link vec4.create} and {@link vec4.copy}
     *
     * @param x first value
     * @param y second value
     * @param z third value
     * @param w fourth value
     * @param dst - vector to hold result. If not passed in a new one is created.
     * @returns A vector with its elements set.
     */
    function set(x, y, z, w, dst) {
        const newDst = (dst ?? new Ctor(4));
        newDst[0] = x;
        newDst[1] = y;
        newDst[2] = z;
        newDst[3] = w;
        return newDst;
    }
    /**
     * Applies Math.ceil to each element of vector
     * @param v - Operand vector.
     * @param dst - vector to hold result. If not passed in a new one is created.
     * @returns A vector that is the ceil of each element of v.
     */
    function ceil(v, dst) {
        const newDst = (dst ?? new Ctor(4));
        newDst[0] = Math.ceil(v[0]);
        newDst[1] = Math.ceil(v[1]);
        newDst[2] = Math.ceil(v[2]);
        newDst[3] = Math.ceil(v[3]);
        return newDst;
    }
    /**
     * Applies Math.floor to each element of vector
     * @param v - Operand vector.
     * @param dst - vector to hold result. If not passed in a new one is created.
     * @returns A vector that is the floor of each element of v.
     */
    function floor(v, dst) {
        const newDst = (dst ?? new Ctor(4));
        newDst[0] = Math.floor(v[0]);
        newDst[1] = Math.floor(v[1]);
        newDst[2] = Math.floor(v[2]);
        newDst[3] = Math.floor(v[3]);
        return newDst;
    }
    /**
     * Applies Math.round to each element of vector
     * @param v - Operand vector.
     * @param dst - vector to hold result. If not passed in a new one is created.
     * @returns A vector that is the round of each element of v.
     */
    function round(v, dst) {
        const newDst = (dst ?? new Ctor(4));
        newDst[0] = Math.round(v[0]);
        newDst[1] = Math.round(v[1]);
        newDst[2] = Math.round(v[2]);
        newDst[3] = Math.round(v[3]);
        return newDst;
    }
    /**
     * Clamp each element of vector between min and max
     * @param v - Operand vector.
     * @param max - Min value, default 0
     * @param min - Max value, default 1
     * @param dst - vector to hold result. If not passed in a new one is created.
     * @returns A vector that the clamped value of each element of v.
     */
    function clamp(v, min = 0, max = 1, dst) {
        const newDst = (dst ?? new Ctor(4));
        newDst[0] = Math.min(max, Math.max(min, v[0]));
        newDst[1] = Math.min(max, Math.max(min, v[1]));
        newDst[2] = Math.min(max, Math.max(min, v[2]));
        newDst[3] = Math.min(max, Math.max(min, v[3]));
        return newDst;
    }
    /**
     * Adds two vectors; assumes a and b have the same dimension.
     * @param a - Operand vector.
     * @param b - Operand vector.
     * @param dst - vector to hold result. If not passed in a new one is created.
     * @returns A vector that is the sum of a and b.
     */
    function add(a, b, dst) {
        const newDst = (dst ?? new Ctor(4));
        newDst[0] = a[0] + b[0];
        newDst[1] = a[1] + b[1];
        newDst[2] = a[2] + b[2];
        newDst[3] = a[3] + b[3];
        return newDst;
    }
    /**
     * Adds two vectors, scaling the 2nd; assumes a and b have the same dimension.
     * @param a - Operand vector.
     * @param b - Operand vector.
     * @param scale - Amount to scale b
     * @param dst - vector to hold result. If not passed in a new one is created.
     * @returns A vector that is the sum of a + b * scale.
     */
    function addScaled(a, b, scale, dst) {
        const newDst = (dst ?? new Ctor(4));
        newDst[0] = a[0] + b[0] * scale;
        newDst[1] = a[1] + b[1] * scale;
        newDst[2] = a[2] + b[2] * scale;
        newDst[3] = a[3] + b[3] * scale;
        return newDst;
    }
    /**
     * Subtracts two vectors.
     * @param a - Operand vector.
     * @param b - Operand vector.
     * @param dst - vector to hold result. If not passed in a new one is created.
     * @returns A vector that is the difference of a and b.
     */
    function subtract(a, b, dst) {
        const newDst = (dst ?? new Ctor(4));
        newDst[0] = a[0] - b[0];
        newDst[1] = a[1] - b[1];
        newDst[2] = a[2] - b[2];
        newDst[3] = a[3] - b[3];
        return newDst;
    }
    /**
     * Subtracts two vectors.
     * @param a - Operand vector.
     * @param b - Operand vector.
     * @param dst - vector to hold result. If not passed in a new one is created.
     * @returns A vector that is the difference of a and b.
     */
    const sub = subtract;
    /**
     * Check if 2 vectors are approximately equal
     * @param a - Operand vector.
     * @param b - Operand vector.
     * @returns true if vectors are approximately equal
     */
    function equalsApproximately(a, b) {
        return Math.abs(a[0] - b[0]) < EPSILON &&
            Math.abs(a[1] - b[1]) < EPSILON &&
            Math.abs(a[2] - b[2]) < EPSILON &&
            Math.abs(a[3] - b[3]) < EPSILON;
    }
    /**
     * Check if 2 vectors are exactly equal
     * @param a - Operand vector.
     * @param b - Operand vector.
     * @returns true if vectors are exactly equal
     */
    function equals(a, b) {
        return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3];
    }
    /**
     * Performs linear interpolation on two vectors.
     * Given vectors a and b and interpolation coefficient t, returns
     * a + t * (b - a).
     * @param a - Operand vector.
     * @param b - Operand vector.
     * @param t - Interpolation coefficient.
     * @param dst - vector to hold result. If not passed in a new one is created.
     * @returns The linear interpolated result.
     */
    function lerp(a, b, t, dst) {
        const newDst = (dst ?? new Ctor(4));
        newDst[0] = a[0] + t * (b[0] - a[0]);
        newDst[1] = a[1] + t * (b[1] - a[1]);
        newDst[2] = a[2] + t * (b[2] - a[2]);
        newDst[3] = a[3] + t * (b[3] - a[3]);
        return newDst;
    }
    /**
     * Performs linear interpolation on two vectors.
     * Given vectors a and b and interpolation coefficient vector t, returns
     * a + t * (b - a).
     * @param a - Operand vector.
     * @param b - Operand vector.
     * @param t - Interpolation coefficients vector.
     * @param dst - vector to hold result. If not passed in a new one is created.
     * @returns the linear interpolated result.
     */
    function lerpV(a, b, t, dst) {
        const newDst = (dst ?? new Ctor(4));
        newDst[0] = a[0] + t[0] * (b[0] - a[0]);
        newDst[1] = a[1] + t[1] * (b[1] - a[1]);
        newDst[2] = a[2] + t[2] * (b[2] - a[2]);
        newDst[3] = a[3] + t[3] * (b[3] - a[3]);
        return newDst;
    }
    /**
     * Return max values of two vectors.
     * Given vectors a and b returns
     * [max(a[0], b[0]), max(a[1], b[1]), max(a[2], b[2])].
     * @param a - Operand vector.
     * @param b - Operand vector.
     * @param dst - vector to hold result. If not passed in a new one is created.
     * @returns The max components vector.
     */
    function max(a, b, dst) {
        const newDst = (dst ?? new Ctor(4));
        newDst[0] = Math.max(a[0], b[0]);
        newDst[1] = Math.max(a[1], b[1]);
        newDst[2] = Math.max(a[2], b[2]);
        newDst[3] = Math.max(a[3], b[3]);
        return newDst;
    }
    /**
     * Return min values of two vectors.
     * Given vectors a and b returns
     * [min(a[0], b[0]), min(a[1], b[1]), min(a[2], b[2])].
     * @param a - Operand vector.
     * @param b - Operand vector.
     * @param dst - vector to hold result. If not passed in a new one is created.
     * @returns The min components vector.
     */
    function min(a, b, dst) {
        const newDst = (dst ?? new Ctor(4));
        newDst[0] = Math.min(a[0], b[0]);
        newDst[1] = Math.min(a[1], b[1]);
        newDst[2] = Math.min(a[2], b[2]);
        newDst[3] = Math.min(a[3], b[3]);
        return newDst;
    }
    /**
     * Multiplies a vector by a scalar.
     * @param v - The vector.
     * @param k - The scalar.
     * @param dst - vector to hold result. If not passed in a new one is created.
     * @returns The scaled vector.
     */
    function mulScalar(v, k, dst) {
        const newDst = (dst ?? new Ctor(4));
        newDst[0] = v[0] * k;
        newDst[1] = v[1] * k;
        newDst[2] = v[2] * k;
        newDst[3] = v[3] * k;
        return newDst;
    }
    /**
     * Multiplies a vector by a scalar. (same as mulScalar)
     * @param v - The vector.
     * @param k - The scalar.
     * @param dst - vector to hold result. If not passed in a new one is created.
     * @returns The scaled vector.
     */
    const scale = mulScalar;
    /**
     * Divides a vector by a scalar.
     * @param v - The vector.
     * @param k - The scalar.
     * @param dst - vector to hold result. If not passed in a new one is created.
     * @returns The scaled vector.
     */
    function divScalar(v, k, dst) {
        const newDst = (dst ?? new Ctor(4));
        newDst[0] = v[0] / k;
        newDst[1] = v[1] / k;
        newDst[2] = v[2] / k;
        newDst[3] = v[3] / k;
        return newDst;
    }
    /**
     * Inverse a vector.
     * @param v - The vector.
     * @param dst - vector to hold result. If not passed in a new one is created.
     * @returns The inverted vector.
     */
    function inverse(v, dst) {
        const newDst = (dst ?? new Ctor(4));
        newDst[0] = 1 / v[0];
        newDst[1] = 1 / v[1];
        newDst[2] = 1 / v[2];
        newDst[3] = 1 / v[3];
        return newDst;
    }
    /**
     * Invert a vector. (same as inverse)
     * @param v - The vector.
     * @param dst - vector to hold result. If not passed in a new one is created.
     * @returns The inverted vector.
     */
    const invert = inverse;
    /**
     * Computes the dot product of two vectors
     * @param a - Operand vector.
     * @param b - Operand vector.
     * @returns dot product
     */
    function dot(a, b) {
        return (a[0] * b[0]) + (a[1] * b[1]) + (a[2] * b[2]) + (a[3] * b[3]);
    }
    /**
     * Computes the length of vector
     * @param v - vector.
     * @returns length of vector.
     */
    function length(v) {
        const v0 = v[0];
        const v1 = v[1];
        const v2 = v[2];
        const v3 = v[3];
        return Math.sqrt(v0 * v0 + v1 * v1 + v2 * v2 + v3 * v3);
    }
    /**
     * Computes the length of vector (same as length)
     * @param v - vector.
     * @returns length of vector.
     */
    const len = length;
    /**
     * Computes the square of the length of vector
     * @param v - vector.
     * @returns square of the length of vector.
     */
    function lengthSq(v) {
        const v0 = v[0];
        const v1 = v[1];
        const v2 = v[2];
        const v3 = v[3];
        return v0 * v0 + v1 * v1 + v2 * v2 + v3 * v3;
    }
    /**
     * Computes the square of the length of vector (same as lengthSq)
     * @param v - vector.
     * @returns square of the length of vector.
     */
    const lenSq = lengthSq;
    /**
     * Computes the distance between 2 points
     * @param a - vector.
     * @param b - vector.
     * @returns distance between a and b
     */
    function distance(a, b) {
        const dx = a[0] - b[0];
        const dy = a[1] - b[1];
        const dz = a[2] - b[2];
        const dw = a[3] - b[3];
        return Math.sqrt(dx * dx + dy * dy + dz * dz + dw * dw);
    }
    /**
     * Computes the distance between 2 points (same as distance)
     * @param a - vector.
     * @param b - vector.
     * @returns distance between a and b
     */
    const dist = distance;
    /**
     * Computes the square of the distance between 2 points
     * @param a - vector.
     * @param b - vector.
     * @returns square of the distance between a and b
     */
    function distanceSq(a, b) {
        const dx = a[0] - b[0];
        const dy = a[1] - b[1];
        const dz = a[2] - b[2];
        const dw = a[3] - b[3];
        return dx * dx + dy * dy + dz * dz + dw * dw;
    }
    /**
     * Computes the square of the distance between 2 points (same as distanceSq)
     * @param a - vector.
     * @param b - vector.
     * @returns square of the distance between a and b
     */
    const distSq = distanceSq;
    /**
     * Divides a vector by its Euclidean length and returns the quotient.
     * @param v - The vector.
     * @param dst - vector to hold result. If not passed in a new one is created.
     * @returns The normalized vector.
     */
    function normalize(v, dst) {
        const newDst = (dst ?? new Ctor(4));
        const v0 = v[0];
        const v1 = v[1];
        const v2 = v[2];
        const v3 = v[3];
        const len = Math.sqrt(v0 * v0 + v1 * v1 + v2 * v2 + v3 * v3);
        if (len > 0.00001) {
            newDst[0] = v0 / len;
            newDst[1] = v1 / len;
            newDst[2] = v2 / len;
            newDst[3] = v3 / len;
        }
        else {
            newDst[0] = 0;
            newDst[1] = 0;
            newDst[2] = 0;
            newDst[3] = 0;
        }
        return newDst;
    }
    /**
     * Negates a vector.
     * @param v - The vector.
     * @param dst - vector to hold result. If not passed in a new one is created.
     * @returns -v.
     */
    function negate(v, dst) {
        const newDst = (dst ?? new Ctor(4));
        newDst[0] = -v[0];
        newDst[1] = -v[1];
        newDst[2] = -v[2];
        newDst[3] = -v[3];
        return newDst;
    }
    /**
     * Copies a vector. (same as {@link vec4.clone})
     * Also see {@link vec4.create} and {@link vec4.set}
     * @param v - The vector.
     * @param dst - vector to hold result. If not passed in a new one is created.
     * @returns A copy of v.
     */
    function copy(v, dst) {
        const newDst = (dst ?? new Ctor(4));
        newDst[0] = v[0];
        newDst[1] = v[1];
        newDst[2] = v[2];
        newDst[3] = v[3];
        return newDst;
    }
    /**
     * Clones a vector. (same as {@link vec4.copy})
     * Also see {@link vec4.create} and {@link vec4.set}
     * @param v - The vector.
     * @param dst - vector to hold result. If not passed in a new one is created.
     * @returns A copy of v.
     */
    const clone = copy;
    /**
     * Multiplies a vector by another vector (component-wise); assumes a and
     * b have the same length.
     * @param a - Operand vector.
     * @param b - Operand vector.
     * @param dst - vector to hold result. If not passed in a new one is created.
     * @returns The vector of products of entries of a and b.
     */
    function multiply(a, b, dst) {
        const newDst = (dst ?? new Ctor(4));
        newDst[0] = a[0] * b[0];
        newDst[1] = a[1] * b[1];
        newDst[2] = a[2] * b[2];
        newDst[3] = a[3] * b[3];
        return newDst;
    }
    /**
     * Multiplies a vector by another vector (component-wise); assumes a and
     * b have the same length. (same as mul)
     * @param a - Operand vector.
     * @param b - Operand vector.
     * @param dst - vector to hold result. If not passed in a new one is created.
     * @returns The vector of products of entries of a and b.
     */
    const mul = multiply;
    /**
     * Divides a vector by another vector (component-wise); assumes a and
     * b have the same length.
     * @param a - Operand vector.
     * @param b - Operand vector.
     * @param dst - vector to hold result. If not passed in a new one is created.
     * @returns The vector of quotients of entries of a and b.
     */
    function divide(a, b, dst) {
        const newDst = (dst ?? new Ctor(4));
        newDst[0] = a[0] / b[0];
        newDst[1] = a[1] / b[1];
        newDst[2] = a[2] / b[2];
        newDst[3] = a[3] / b[3];
        return newDst;
    }
    /**
     * Divides a vector by another vector (component-wise); assumes a and
     * b have the same length. (same as divide)
     * @param a - Operand vector.
     * @param b - Operand vector.
     * @param dst - vector to hold result. If not passed in a new one is created.
     * @returns The vector of quotients of entries of a and b.
     */
    const div = divide;
    /**
     * Zero's a vector
     * @param dst - vector to hold result. If not passed in a new one is created.
     * @returns The zeroed vector.
     */
    function zero(dst) {
        const newDst = (dst ?? new Ctor(4));
        newDst[0] = 0;
        newDst[1] = 0;
        newDst[2] = 0;
        newDst[3] = 0;
        return newDst;
    }
    /**
     * transform vec4 by 4x4 matrix
     * @param v - the vector
     * @param m - The matrix.
     * @param dst - optional vec4 to store result. If not passed a new one is created.
     * @returns the transformed vector
     */
    function transformMat4(v, m, dst) {
        const newDst = (dst ?? new Ctor(4));
        const x = v[0];
        const y = v[1];
        const z = v[2];
        const w = v[3];
        newDst[0] = m[0] * x + m[4] * y + m[8] * z + m[12] * w;
        newDst[1] = m[1] * x + m[5] * y + m[9] * z + m[13] * w;
        newDst[2] = m[2] * x + m[6] * y + m[10] * z + m[14] * w;
        newDst[3] = m[3] * x + m[7] * y + m[11] * z + m[15] * w;
        return newDst;
    }
    /**
     * Treat a 4D vector as a direction and set it's length
     *
     * @param a The vec4 to lengthen
     * @param len The length of the resulting vector
     * @returns The lengthened vector
     */
    function setLength(a, len, dst) {
        const newDst = (dst ?? new Ctor(4));
        normalize(a, newDst);
        return mulScalar(newDst, len, newDst);
    }
    /**
     * Ensure a vector is not longer than a max length
     *
     * @param a The vec4 to limit
     * @param maxLen The longest length of the resulting vector
     * @returns The vector, shortened to maxLen if it's too long
     */
    function truncate(a, maxLen, dst) {
        const newDst = (dst ?? new Ctor(4));
        if (length(a) > maxLen) {
            return setLength(a, maxLen, newDst);
        }
        return copy(a, newDst);
    }
    /**
     * Return the vector exactly between 2 endpoint vectors
     *
     * @param a Endpoint 1
     * @param b Endpoint 2
     * @returns The vector exactly residing between endpoints 1 and 2
     */
    function midpoint(a, b, dst) {
        const newDst = (dst ?? new Ctor(4));
        return lerp(a, b, 0.5, newDst);
    }
    return {
        create,
        fromValues,
        set,
        ceil,
        floor,
        round,
        clamp,
        add,
        addScaled,
        subtract,
        sub,
        equalsApproximately,
        equals,
        lerp,
        lerpV,
        max,
        min,
        mulScalar,
        scale,
        divScalar,
        inverse,
        invert,
        dot,
        length,
        len,
        lengthSq,
        lenSq,
        distance,
        dist,
        distanceSq,
        distSq,
        normalize,
        negate,
        copy,
        clone,
        multiply,
        mul,
        divide,
        div,
        zero,
        transformMat4,
        setLength,
        truncate,
        midpoint,
    };
}
const cache = new Map();
/**
 *
 * Vec4 math functions.
 *
 * Almost all functions take an optional `newDst` argument. If it is not passed in the
 * functions will create a new `Vec4`. In other words you can do this
 *
 *     const v = vec4.cross(v1, v2);  // Creates a new Vec4 with the cross product of v1 x v2.
 *
 * or
 *
 *     const v = vec4.create();
 *     vec4.cross(v1, v2, v);  // Puts the cross product of v1 x v2 in v
 *
 * The first style is often easier but depending on where it's used it generates garbage where
 * as there is almost never allocation with the second style.
 *
 * It is always safe to pass any vector as the destination. So for example
 *
 *     vec4.cross(v1, v2, v1);  // Puts the cross product of v1 x v2 in v1
 *
 */
function getAPI(Ctor) {
    let api = cache.get(Ctor);
    if (!api) {
        api = getAPIImpl(Ctor);
        cache.set(Ctor, api);
    }
    return api;
}

/**
 * Generate wgpu-matrix API for type
 */
function wgpuMatrixAPI(Mat3Ctor, Mat4Ctor, QuatCtor, Vec2Ctor, Vec3Ctor, Vec4Ctor) {
    return {
        /** @namespace mat4 */
        mat4: getAPI$2(Mat3Ctor),
        /** @namespace mat3 */
        mat3: getAPI$4(Mat4Ctor),
        /** @namespace quat */
        quat: getAPI$1(QuatCtor),
        /** @namespace vec2 */
        vec2: getAPI$5(Vec2Ctor),
        /** @namespace vec3 */
        vec3: getAPI$3(Vec3Ctor),
        /** @namespace vec4 */
        vec4: getAPI(Vec4Ctor),
    };
}
const { 
/** @namespace */
mat4, 
/** @namespace */
mat3, 
/** @namespace */
quat, 
/** @namespace */
vec2, 
/** @namespace */
vec3, 
/** @namespace */
vec4, } = wgpuMatrixAPI(Float32Array, Float32Array, Float32Array, Float32Array, Float32Array, Float32Array);
const { 
/** @namespace */
mat4: mat4d, 
/** @namespace */
mat3: mat3d, 
/** @namespace */
quat: quatd, 
/** @namespace */
vec2: vec2d, 
/** @namespace */
vec3: vec3d, 
/** @namespace */
vec4: vec4d, } = wgpuMatrixAPI(Float64Array, Float64Array, Float64Array, Float64Array, Float64Array, Float64Array);
const { 
/** @namespace */
mat4: mat4n, 
/** @namespace */
mat3: mat3n, 
/** @namespace */
quat: quatn, 
/** @namespace */
vec2: vec2n, 
/** @namespace */
vec3: vec3n, 
/** @namespace */
vec4: vec4n, } = wgpuMatrixAPI(ZeroArray, Array, Array, Array, Array, Array);


//# sourceMappingURL=wgpu-matrix.module.js.map


/***/ })

},
/******/ __webpack_require__ => { // webpackRuntimeModules
/******/ var __webpack_exec__ = (moduleId) => (__webpack_require__(__webpack_require__.s = moduleId))
/******/ var __webpack_exports__ = (__webpack_exec__("./index.ts"));
/******/ }
]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,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bkVBO0FBQzJEO0FBQzNEO0FBQ087QUFDUDtBQUNBLFFBQVEsd0RBQVMsTUFBTSxpREFBTTtBQUM3QixvQkFBb0IsaURBQU07QUFDMUI7QUFDQSxhQUFhLDhEQUFtQjtBQUNoQztBQUNBLDBCQUEwQixrREFBTztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7O0FDakJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDekNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHFCQUFxQixpQkFBaUI7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixtQkFBbUIsS0FBSztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0Q7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdEO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsaUJBQWlCO0FBQ25ELGlCQUFpQixtQkFBbUIsS0FBSztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLGdCQUFnQjtBQUNsRCxpQkFBaUIsbUJBQW1CLEtBQUs7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0RBQStEO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0RBQStEO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0REFBNEQ7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0REFBNEQ7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsbUJBQW1CLEtBQUs7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsaUJBQWlCO0FBQ25ELGlCQUFpQixtQkFBbUIsS0FBSztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsZ0JBQWdCO0FBQ2pELGlCQUFpQixtQkFBbUIsS0FBSztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0Q7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkRBQTZEO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLG1CQUFtQixLQUFLO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtEO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdEO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLGlCQUFpQjtBQUNuRCxpQkFBaUIsbUJBQW1CLEtBQUs7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLGdCQUFnQjtBQUNsRCxpQkFBaUIsbUJBQW1CLEtBQUs7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0RBQStEO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrREFBK0Q7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDREQUE0RDtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNERBQTREO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGNBQWM7QUFDN0IsZUFBZSxjQUFjO0FBQzdCLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGNBQWM7QUFDN0IsZUFBZSxjQUFjO0FBQzdCLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGNBQWM7QUFDN0IsZUFBZSxjQUFjO0FBQzdCLGVBQWUsUUFBUTtBQUN2QjtBQUNBLGlCQUFpQixNQUFNO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQ7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEM7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLG1CQUFtQixLQUFLO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxpQkFBaUI7QUFDbkQsaUJBQWlCLG1CQUFtQixLQUFLO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLGdCQUFnQjtBQUNqRCxpQkFBaUIsbUJBQW1CLEtBQUs7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0Q7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2REFBNkQ7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixtQkFBbUIsS0FBSztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQztBQUMvQztBQUNBLHdDQUF3QztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkRBQTJELE1BQU07QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsaUJBQWlCO0FBQ3ZELGlCQUFpQixtQkFBbUIsS0FBSztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxnQkFBZ0I7QUFDdEQsaUJBQWlCLG1CQUFtQixLQUFLO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUM7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsbUJBQW1CLEtBQUs7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEM7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxpQkFBaUI7QUFDbkQsaUJBQWlCLG1CQUFtQixLQUFLO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLGdCQUFnQjtBQUNsRCxpQkFBaUIsbUJBQW1CLEtBQUs7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0RBQStEO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtEQUErRDtBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNERBQTREO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDREQUE0RDtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTs7QUFFMEg7QUFDekkiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Ad2hlZXp5L2RlbW9zLy4vaW5kZXgudHMiLCJ3ZWJwYWNrOi8vQHdoZWV6eS9kZW1vcy8uL3NyYy9EZW1vMC50cyIsIndlYnBhY2s6Ly9Ad2hlZXp5L2RlbW9zLy4uL2VuZ2luZS9pbmRleC50cyIsIndlYnBhY2s6Ly9Ad2hlZXp5L2RlbW9zLy4uL2VuZ2luZS9zcmMvZW5naW5lL2NvcmUvQnVmZmVyU3RvcmFnZS9CdWZmZXJTdG9yYWdlLnRzIiwid2VicGFjazovL0B3aGVlenkvZGVtb3MvLi4vZW5naW5lL3NyYy9lbmdpbmUvY29yZS9CdWZmZXJTdG9yYWdlL2luZGV4LnRzIiwid2VicGFjazovL0B3aGVlenkvZGVtb3MvLi4vZW5naW5lL3NyYy9lbmdpbmUvY29yZS9Db21wb25lbnQvQ29tcG9uZW50LnRzIiwid2VicGFjazovL0B3aGVlenkvZGVtb3MvLi4vZW5naW5lL3NyYy9lbmdpbmUvY29yZS9Db21wb25lbnQvaW5kZXgudHMiLCJ3ZWJwYWNrOi8vQHdoZWV6eS9kZW1vcy8uLi9lbmdpbmUvc3JjL2VuZ2luZS9jb3JlL0VuZ2luZS9FbmdpbmUudHMiLCJ3ZWJwYWNrOi8vQHdoZWV6eS9kZW1vcy8uLi9lbmdpbmUvc3JjL2VuZ2luZS9jb3JlL0VuZ2luZS9jb25zdGFudHMudHMiLCJ3ZWJwYWNrOi8vQHdoZWV6eS9kZW1vcy8uLi9lbmdpbmUvc3JjL2VuZ2luZS9jb3JlL0VuZ2luZS9pbmRleC50cyIsIndlYnBhY2s6Ly9Ad2hlZXp5L2RlbW9zLy4uL2VuZ2luZS9zcmMvZW5naW5lL2NvcmUvRW50aXR5L0VudGl0eS50cyIsIndlYnBhY2s6Ly9Ad2hlZXp5L2RlbW9zLy4uL2VuZ2luZS9zcmMvZW5naW5lL2NvcmUvRW50aXR5L2luZGV4LnRzIiwid2VicGFjazovL0B3aGVlenkvZGVtb3MvLi4vZW5naW5lL3NyYy9lbmdpbmUvY29yZS9HYW1lT2JqZWN0L0dhbWVPYmplY3QudHMiLCJ3ZWJwYWNrOi8vQHdoZWV6eS9kZW1vcy8uLi9lbmdpbmUvc3JjL2VuZ2luZS9jb3JlL0dhbWVPYmplY3QvaW5kZXgudHMiLCJ3ZWJwYWNrOi8vQHdoZWV6eS9kZW1vcy8uLi9lbmdpbmUvc3JjL2VuZ2luZS9jb3JlL0ltYWdlU3RvcmFnZS9JbWFnZVN0b3JhZ2UudHMiLCJ3ZWJwYWNrOi8vQHdoZWV6eS9kZW1vcy8uLi9lbmdpbmUvc3JjL2VuZ2luZS9jb3JlL0ltYWdlU3RvcmFnZS9pbmRleC50cyIsIndlYnBhY2s6Ly9Ad2hlZXp5L2RlbW9zLy4uL2VuZ2luZS9zcmMvZW5naW5lL2NvcmUvTWF0ZXJpYWxTdG9yYWdlL01hdGVyaWFsU3RvcmFnZS50cyIsIndlYnBhY2s6Ly9Ad2hlZXp5L2RlbW9zLy4uL2VuZ2luZS9zcmMvZW5naW5lL2NvcmUvTWF0ZXJpYWxTdG9yYWdlL2luZGV4LnRzIiwid2VicGFjazovL0B3aGVlenkvZGVtb3MvLi4vZW5naW5lL3NyYy9lbmdpbmUvY29yZS9NZXNoL01lc2gudHMiLCJ3ZWJwYWNrOi8vQHdoZWV6eS9kZW1vcy8uLi9lbmdpbmUvc3JjL2VuZ2luZS9jb3JlL01lc2gvaW5kZXgudHMiLCJ3ZWJwYWNrOi8vQHdoZWV6eS9kZW1vcy8uLi9lbmdpbmUvc3JjL2VuZ2luZS9jb3JlL01vZGVsVXBsb2FkZXIvTW9kZWxVcGxvYWRlci50cyIsIndlYnBhY2s6Ly9Ad2hlZXp5L2RlbW9zLy4uL2VuZ2luZS9zcmMvZW5naW5lL2NvcmUvTW9kZWxVcGxvYWRlci9pbmRleC50cyIsIndlYnBhY2s6Ly9Ad2hlZXp5L2RlbW9zLy4uL2VuZ2luZS9zcmMvZW5naW5lL2NvcmUvT2JqZWN0TWFuYWdlci9PYmplY3RNYW5hZ2VyLnRzIiwid2VicGFjazovL0B3aGVlenkvZGVtb3MvLi4vZW5naW5lL3NyYy9lbmdpbmUvY29yZS9PYmplY3RNYW5hZ2VyL2luZGV4LnRzIiwid2VicGFjazovL0B3aGVlenkvZGVtb3MvLi4vZW5naW5lL3NyYy9lbmdpbmUvY29yZS9TYW1wbGVyU3RvcmFnZS9TYW1wbGVyU3RvcmFnZS50cyIsIndlYnBhY2s6Ly9Ad2hlZXp5L2RlbW9zLy4uL2VuZ2luZS9zcmMvZW5naW5lL2NvcmUvU2FtcGxlclN0b3JhZ2UvaW5kZXgudHMiLCJ3ZWJwYWNrOi8vQHdoZWV6eS9kZW1vcy8uLi9lbmdpbmUvc3JjL2VuZ2luZS9jb3JlL1NjZW5lL1NjZW5lLnRzIiwid2VicGFjazovL0B3aGVlenkvZGVtb3MvLi4vZW5naW5lL3NyYy9lbmdpbmUvY29yZS9TY2VuZS9pbmRleC50cyIsIndlYnBhY2s6Ly9Ad2hlZXp5L2RlbW9zLy4uL2VuZ2luZS9zcmMvZW5naW5lL2NvcmUvU2NlbmVUcmVlL1NjZW5lVHJlZS50cyIsIndlYnBhY2s6Ly9Ad2hlZXp5L2RlbW9zLy4uL2VuZ2luZS9zcmMvZW5naW5lL2NvcmUvU2NlbmVUcmVlL2luZGV4LnRzIiwid2VicGFjazovL0B3aGVlenkvZGVtb3MvLi4vZW5naW5lL3NyYy9lbmdpbmUvY29yZS9UZXh0dXJlU3RvcmFnZS9UZXh0dXJlU3RvcmFnZS50cyIsIndlYnBhY2s6Ly9Ad2hlZXp5L2RlbW9zLy4uL2VuZ2luZS9zcmMvZW5naW5lL2NvcmUvVGV4dHVyZVN0b3JhZ2UvaW5kZXgudHMiLCJ3ZWJwYWNrOi8vQHdoZWV6eS9kZW1vcy8uLi9lbmdpbmUvc3JjL2VuZ2luZS9jb3JlL1RyYW5zZm9ybS9UcmFuc2Zvcm0udHMiLCJ3ZWJwYWNrOi8vQHdoZWV6eS9kZW1vcy8uLi9lbmdpbmUvc3JjL2VuZ2luZS9jb3JlL1RyYW5zZm9ybS9pbmRleC50cyIsIndlYnBhY2s6Ly9Ad2hlZXp5L2RlbW9zLy4uL2VuZ2luZS9zcmMvZW5naW5lL2NvcmUvY2FtZXJhcy9BcmNCYWxsQ2FtZXJhL0FyY0JhbGxDYW1lcmEudHMiLCJ3ZWJwYWNrOi8vQHdoZWV6eS9kZW1vcy8uLi9lbmdpbmUvc3JjL2VuZ2luZS9jb3JlL2NhbWVyYXMvQXJjQmFsbENhbWVyYS9pbmRleC50cyIsIndlYnBhY2s6Ly9Ad2hlZXp5L2RlbW9zLy4uL2VuZ2luZS9zcmMvZW5naW5lL2NvcmUvY2FtZXJhcy9DYW1lcmEvQ2FtZXJhLnRzIiwid2VicGFjazovL0B3aGVlenkvZGVtb3MvLi4vZW5naW5lL3NyYy9lbmdpbmUvY29yZS9jYW1lcmFzL0NhbWVyYS9pbmRleC50cyIsIndlYnBhY2s6Ly9Ad2hlZXp5L2RlbW9zLy4uL2VuZ2luZS9zcmMvZW5naW5lL2NvcmUvY2FtZXJhcy9QZXJzcGVjdGl2ZUNhbWVyYS9QZXJzcGVjdGl2ZUNhbWVyYS50cyIsIndlYnBhY2s6Ly9Ad2hlZXp5L2RlbW9zLy4uL2VuZ2luZS9zcmMvZW5naW5lL2NvcmUvY2FtZXJhcy9QZXJzcGVjdGl2ZUNhbWVyYS9pbmRleC50cyIsIndlYnBhY2s6Ly9Ad2hlZXp5L2RlbW9zLy4uL2VuZ2luZS9zcmMvZW5naW5lL2NvcmUvaW5kZXgudHMiLCJ3ZWJwYWNrOi8vQHdoZWV6eS9kZW1vcy8uLi9lbmdpbmUvc3JjL2VuZ2luZS90eXBlcy9jb3JlL0J1ZmZlclN0b3JhZ2UvaW5kZXgudHMiLCJ3ZWJwYWNrOi8vQHdoZWV6eS9kZW1vcy8uLi9lbmdpbmUvc3JjL2VuZ2luZS90eXBlcy9jb3JlL0NvbXBvbmVudC9pbmRleC50cyIsIndlYnBhY2s6Ly9Ad2hlZXp5L2RlbW9zLy4uL2VuZ2luZS9zcmMvZW5naW5lL3R5cGVzL2NvcmUvRW5naW5lL2luZGV4LnRzIiwid2VicGFjazovL0B3aGVlenkvZGVtb3MvLi4vZW5naW5lL3NyYy9lbmdpbmUvdHlwZXMvY29yZS9FbnRpdHkvaW5kZXgudHMiLCJ3ZWJwYWNrOi8vQHdoZWV6eS9kZW1vcy8uLi9lbmdpbmUvc3JjL2VuZ2luZS90eXBlcy9jb3JlL0dhbWVPYmplY3QvaW5kZXgudHMiLCJ3ZWJwYWNrOi8vQHdoZWV6eS9kZW1vcy8uLi9lbmdpbmUvc3JjL2VuZ2luZS90eXBlcy9jb3JlL0ltYWdlU3RvcmFnZS9pbmRleC50cyIsIndlYnBhY2s6Ly9Ad2hlZXp5L2RlbW9zLy4uL2VuZ2luZS9zcmMvZW5naW5lL3R5cGVzL2NvcmUvTWVzaC9pbmRleC50cyIsIndlYnBhY2s6Ly9Ad2hlZXp5L2RlbW9zLy4uL2VuZ2luZS9zcmMvZW5naW5lL3R5cGVzL2NvcmUvT2JqZWN0TWFuYWdlci9pbmRleC50cyIsIndlYnBhY2s6Ly9Ad2hlZXp5L2RlbW9zLy4uL2VuZ2luZS9zcmMvZW5naW5lL3R5cGVzL2NvcmUvU2FtcGxlclN0b3JhZ2UvaW5kZXgudHMiLCJ3ZWJwYWNrOi8vQHdoZWV6eS9kZW1vcy8uLi9lbmdpbmUvc3JjL2VuZ2luZS90eXBlcy9jb3JlL1NjZW5lL1NjZW5lLnRzIiwid2VicGFjazovL0B3aGVlenkvZGVtb3MvLi4vZW5naW5lL3NyYy9lbmdpbmUvdHlwZXMvY29yZS9TY2VuZS9pbmRleC50cyIsIndlYnBhY2s6Ly9Ad2hlZXp5L2RlbW9zLy4uL2VuZ2luZS9zcmMvZW5naW5lL3R5cGVzL2NvcmUvU2NlbmVUcmVlL2luZGV4LnRzIiwid2VicGFjazovL0B3aGVlenkvZGVtb3MvLi4vZW5naW5lL3NyYy9lbmdpbmUvdHlwZXMvY29yZS9UZXh0dXJlU3RvcmFnZS9pbmRleC50cyIsIndlYnBhY2s6Ly9Ad2hlZXp5L2RlbW9zLy4uL2VuZ2luZS9zcmMvZW5naW5lL3R5cGVzL2NvcmUvVHJhbnNmb3JtL2luZGV4LnRzIiwid2VicGFjazovL0B3aGVlenkvZGVtb3MvLi4vZW5naW5lL3NyYy9lbmdpbmUvdHlwZXMvaW5kZXgudHMiLCJ3ZWJwYWNrOi8vQHdoZWV6eS9kZW1vcy8uLi9lbmdpbmUvc3JjL3BoeXNpY3MvQ29sbGlkZXIvaW5kZXgudHMiLCJ3ZWJwYWNrOi8vQHdoZWV6eS9kZW1vcy8uLi9lbmdpbmUvc3JjL3BoeXNpY3MvUGh5c2ljc09iamVjdC9pbmRleC50cyIsIndlYnBhY2s6Ly9Ad2hlZXp5L2RlbW9zLy4uL2VuZ2luZS9zcmMvcGh5c2ljcy9pbmRleC50cyIsIndlYnBhY2s6Ly9Ad2hlZXp5L2RlbW9zLy4uL2VuZ2luZS9zcmMvdXRpbHMvU3R1ZmYudHMiLCJ3ZWJwYWNrOi8vQHdoZWV6eS9kZW1vcy8uLi9lbmdpbmUvc3JjL3V0aWxzL1doZWV6eUdMQkxvYWRlci9XaGVlenlHTEJMb2FkZXIudHMiLCJ3ZWJwYWNrOi8vQHdoZWV6eS9kZW1vcy8uLi9lbmdpbmUvc3JjL3V0aWxzL1doZWV6eUdMQkxvYWRlci9oZWxwZXJzLnRzIiwid2VicGFjazovL0B3aGVlenkvZGVtb3MvLi4vZW5naW5lL3NyYy91dGlscy9pbmRleC50cyIsIndlYnBhY2s6Ly9Ad2hlZXp5L2RlbW9zLy4uLy4uL25vZGVfbW9kdWxlcy9AbG9hZGVycy5nbC9jb3JlL2Rpc3QvaXRlcmF0b3JzL21ha2UtaXRlcmF0b3IvbWFrZS1hcnJheS1idWZmZXItaXRlcmF0b3IuanMiLCJ3ZWJwYWNrOi8vQHdoZWV6eS9kZW1vcy8uLi8uLi9ub2RlX21vZHVsZXMvQGxvYWRlcnMuZ2wvY29yZS9kaXN0L2l0ZXJhdG9ycy9tYWtlLWl0ZXJhdG9yL21ha2UtYmxvYi1pdGVyYXRvci5qcyIsIndlYnBhY2s6Ly9Ad2hlZXp5L2RlbW9zLy4uLy4uL25vZGVfbW9kdWxlcy9AbG9hZGVycy5nbC9jb3JlL2Rpc3QvaXRlcmF0b3JzL21ha2UtaXRlcmF0b3IvbWFrZS1pdGVyYXRvci5qcyIsIndlYnBhY2s6Ly9Ad2hlZXp5L2RlbW9zLy4uLy4uL25vZGVfbW9kdWxlcy9AbG9hZGVycy5nbC9jb3JlL2Rpc3QvaXRlcmF0b3JzL21ha2UtaXRlcmF0b3IvbWFrZS1zdHJlYW0taXRlcmF0b3IuanMiLCJ3ZWJwYWNrOi8vQHdoZWV6eS9kZW1vcy8uLi8uLi9ub2RlX21vZHVsZXMvQGxvYWRlcnMuZ2wvY29yZS9kaXN0L2l0ZXJhdG9ycy9tYWtlLWl0ZXJhdG9yL21ha2Utc3RyaW5nLWl0ZXJhdG9yLmpzIiwid2VicGFjazovL0B3aGVlenkvZGVtb3MvLi4vLi4vbm9kZV9tb2R1bGVzL0Bsb2FkZXJzLmdsL2NvcmUvZGlzdC9qYXZhc2NyaXB0LXV0aWxzL2lzLXR5cGUuanMiLCJ3ZWJwYWNrOi8vQHdoZWV6eS9kZW1vcy8uLi8uLi9ub2RlX21vZHVsZXMvQGxvYWRlcnMuZ2wvY29yZS9kaXN0L2xpYi9hcGkvbG9hZC5qcyIsIndlYnBhY2s6Ly9Ad2hlZXp5L2RlbW9zLy4uLy4uL25vZGVfbW9kdWxlcy9AbG9hZGVycy5nbC9jb3JlL2Rpc3QvbGliL2FwaS9wYXJzZS5qcyIsIndlYnBhY2s6Ly9Ad2hlZXp5L2RlbW9zLy4uLy4uL25vZGVfbW9kdWxlcy9AbG9hZGVycy5nbC9jb3JlL2Rpc3QvbGliL2FwaS9yZWdpc3Rlci1sb2FkZXJzLmpzIiwid2VicGFjazovL0B3aGVlenkvZGVtb3MvLi4vLi4vbm9kZV9tb2R1bGVzL0Bsb2FkZXJzLmdsL2NvcmUvZGlzdC9saWIvYXBpL3NlbGVjdC1sb2FkZXIuanMiLCJ3ZWJwYWNrOi8vQHdoZWV6eS9kZW1vcy8uLi8uLi9ub2RlX21vZHVsZXMvQGxvYWRlcnMuZ2wvY29yZS9kaXN0L2xpYi9mZXRjaC9mZXRjaC1maWxlLmpzIiwid2VicGFjazovL0B3aGVlenkvZGVtb3MvLi4vLi4vbm9kZV9tb2R1bGVzL0Bsb2FkZXJzLmdsL2NvcmUvZGlzdC9saWIvbG9hZGVyLXV0aWxzL2dldC1kYXRhLmpzIiwid2VicGFjazovL0B3aGVlenkvZGVtb3MvLi4vLi4vbm9kZV9tb2R1bGVzL0Bsb2FkZXJzLmdsL2NvcmUvZGlzdC9saWIvbG9hZGVyLXV0aWxzL2dldC1mZXRjaC1mdW5jdGlvbi5qcyIsIndlYnBhY2s6Ly9Ad2hlZXp5L2RlbW9zLy4uLy4uL25vZGVfbW9kdWxlcy9AbG9hZGVycy5nbC9jb3JlL2Rpc3QvbGliL2xvYWRlci11dGlscy9sb2FkZXItY29udGV4dC5qcyIsIndlYnBhY2s6Ly9Ad2hlZXp5L2RlbW9zLy4uLy4uL25vZGVfbW9kdWxlcy9AbG9hZGVycy5nbC9jb3JlL2Rpc3QvbGliL2xvYWRlci11dGlscy9sb2dnZXJzLmpzIiwid2VicGFjazovL0B3aGVlenkvZGVtb3MvLi4vLi4vbm9kZV9tb2R1bGVzL0Bsb2FkZXJzLmdsL2NvcmUvZGlzdC9saWIvbG9hZGVyLXV0aWxzL25vcm1hbGl6ZS1sb2FkZXIuanMiLCJ3ZWJwYWNrOi8vQHdoZWV6eS9kZW1vcy8uLi8uLi9ub2RlX21vZHVsZXMvQGxvYWRlcnMuZ2wvY29yZS9kaXN0L2xpYi9sb2FkZXItdXRpbHMvb3B0aW9uLWRlZmF1bHRzLmpzIiwid2VicGFjazovL0B3aGVlenkvZGVtb3MvLi4vLi4vbm9kZV9tb2R1bGVzL0Bsb2FkZXJzLmdsL2NvcmUvZGlzdC9saWIvbG9hZGVyLXV0aWxzL29wdGlvbi11dGlscy5qcyIsIndlYnBhY2s6Ly9Ad2hlZXp5L2RlbW9zLy4uLy4uL25vZGVfbW9kdWxlcy9AbG9hZGVycy5nbC9jb3JlL2Rpc3QvbGliL3V0aWxzL2xvZy5qcyIsIndlYnBhY2s6Ly9Ad2hlZXp5L2RlbW9zLy4uLy4uL25vZGVfbW9kdWxlcy9AbG9hZGVycy5nbC9jb3JlL2Rpc3QvbGliL3V0aWxzL21pbWUtdHlwZS11dGlscy5qcyIsIndlYnBhY2s6Ly9Ad2hlZXp5L2RlbW9zLy4uLy4uL25vZGVfbW9kdWxlcy9AbG9hZGVycy5nbC9jb3JlL2Rpc3QvbGliL3V0aWxzL3Jlc291cmNlLXV0aWxzLmpzIiwid2VicGFjazovL0B3aGVlenkvZGVtb3MvLi4vLi4vbm9kZV9tb2R1bGVzL0Bsb2FkZXJzLmdsL2NvcmUvZGlzdC9saWIvdXRpbHMvcmVzcG9uc2UtdXRpbHMuanMiLCJ3ZWJwYWNrOi8vQHdoZWV6eS9kZW1vcy8uLi8uLi9ub2RlX21vZHVsZXMvQGxvYWRlcnMuZ2wvY29yZS9kaXN0L2xpYi91dGlscy91cmwtdXRpbHMuanMiLCJ3ZWJwYWNrOi8vQHdoZWV6eS9kZW1vcy8uLi8uLi9ub2RlX21vZHVsZXMvQGxvYWRlcnMuZ2wvZ2x0Zi9kaXN0L2dsYi1sb2FkZXIuanMiLCJ3ZWJwYWNrOi8vQHdoZWV6eS9kZW1vcy8uLi8uLi9ub2RlX21vZHVsZXMvQGxvYWRlcnMuZ2wvZ2x0Zi9kaXN0L2xpYi9wYXJzZXJzL3BhcnNlLWdsYi5qcyIsIndlYnBhY2s6Ly9Ad2hlZXp5L2RlbW9zLy4uLy4uL25vZGVfbW9kdWxlcy9AbG9hZGVycy5nbC9nbHRmL2Rpc3QvbGliL3V0aWxzL3ZlcnNpb24uanMiLCJ3ZWJwYWNrOi8vQHdoZWV6eS9kZW1vcy8uLi8uLi9ub2RlX21vZHVsZXMvQGxvYWRlcnMuZ2wvbG9hZGVyLXV0aWxzL2Rpc3QvbGliL2JpbmFyeS11dGlscy9hcnJheS1idWZmZXItdXRpbHMuanMiLCJ3ZWJwYWNrOi8vQHdoZWV6eS9kZW1vcy8uLi8uLi9ub2RlX21vZHVsZXMvQGxvYWRlcnMuZ2wvbG9hZGVyLXV0aWxzL2Rpc3QvbGliL2JpbmFyeS11dGlscy9tZW1vcnktY29udmVyc2lvbi11dGlscy5qcyIsIndlYnBhY2s6Ly9Ad2hlZXp5L2RlbW9zLy4uLy4uL25vZGVfbW9kdWxlcy9AbG9hZGVycy5nbC9sb2FkZXItdXRpbHMvZGlzdC9saWIvYmluYXJ5LXV0aWxzL21lbW9yeS1jb3B5LXV0aWxzLmpzIiwid2VicGFjazovL0B3aGVlenkvZGVtb3MvLi4vLi4vbm9kZV9tb2R1bGVzL0Bsb2FkZXJzLmdsL2xvYWRlci11dGlscy9kaXN0L2xpYi9lbnYtdXRpbHMvYXNzZXJ0LmpzIiwid2VicGFjazovL0B3aGVlenkvZGVtb3MvLi4vLi4vbm9kZV9tb2R1bGVzL0Bsb2FkZXJzLmdsL2xvYWRlci11dGlscy9kaXN0L2xpYi9lbnYtdXRpbHMvZ2xvYmFscy5qcyIsIndlYnBhY2s6Ly9Ad2hlZXp5L2RlbW9zLy4uLy4uL25vZGVfbW9kdWxlcy9AbG9hZGVycy5nbC9sb2FkZXItdXRpbHMvZGlzdC9saWIvaXRlcmF0b3JzL2FzeW5jLWl0ZXJhdGlvbi5qcyIsIndlYnBhY2s6Ly9Ad2hlZXp5L2RlbW9zLy4uLy4uL25vZGVfbW9kdWxlcy9AbG9hZGVycy5nbC9sb2FkZXItdXRpbHMvZGlzdC9saWIvbm9kZS9idWZmZXIuYnJvd3Nlci5qcyIsIndlYnBhY2s6Ly9Ad2hlZXp5L2RlbW9zLy4uLy4uL25vZGVfbW9kdWxlcy9AbG9hZGVycy5nbC9sb2FkZXItdXRpbHMvZGlzdC9saWIvb3B0aW9uLXV0aWxzL21lcmdlLWxvYWRlci1vcHRpb25zLmpzIiwid2VicGFjazovL0B3aGVlenkvZGVtb3MvLi4vLi4vbm9kZV9tb2R1bGVzL0Bsb2FkZXJzLmdsL2xvYWRlci11dGlscy9kaXN0L2xpYi9wYXRoLXV0aWxzL2ZpbGUtYWxpYXNlcy5qcyIsIndlYnBhY2s6Ly9Ad2hlZXp5L2RlbW9zLy4uLy4uL25vZGVfbW9kdWxlcy9AbG9hZGVycy5nbC9sb2FkZXItdXRpbHMvZGlzdC9saWIvcGF0aC11dGlscy9nZXQtY3dkLmpzIiwid2VicGFjazovL0B3aGVlenkvZGVtb3MvLi4vLi4vbm9kZV9tb2R1bGVzL0Bsb2FkZXJzLmdsL2xvYWRlci11dGlscy9kaXN0L2xpYi9wYXRoLXV0aWxzL3BhdGguanMiLCJ3ZWJwYWNrOi8vQHdoZWV6eS9kZW1vcy8uLi8uLi9ub2RlX21vZHVsZXMvQGxvYWRlcnMuZ2wvbG9hZGVyLXV0aWxzL2Rpc3QvbGliL3dvcmtlci1sb2FkZXItdXRpbHMvcGFyc2Utd2l0aC13b3JrZXIuanMiLCJ3ZWJwYWNrOi8vQHdoZWV6eS9kZW1vcy8uLi8uLi9ub2RlX21vZHVsZXMvQGxvYWRlcnMuZ2wvd29ya2VyLXV0aWxzL2Rpc3QvbGliL2Vudi11dGlscy9hc3NlcnQuanMiLCJ3ZWJwYWNrOi8vQHdoZWV6eS9kZW1vcy8uLi8uLi9ub2RlX21vZHVsZXMvQGxvYWRlcnMuZ2wvd29ya2VyLXV0aWxzL2Rpc3QvbGliL2Vudi11dGlscy9nbG9iYWxzLmpzIiwid2VicGFjazovL0B3aGVlenkvZGVtb3MvLi4vLi4vbm9kZV9tb2R1bGVzL0Bsb2FkZXJzLmdsL3dvcmtlci11dGlscy9kaXN0L2xpYi9lbnYtdXRpbHMvdmVyc2lvbi5qcyIsIndlYnBhY2s6Ly9Ad2hlZXp5L2RlbW9zLy4uLy4uL25vZGVfbW9kdWxlcy9AbG9hZGVycy5nbC93b3JrZXItdXRpbHMvZGlzdC9saWIvbm9kZS93b3JrZXJfdGhyZWFkcy1icm93c2VyLmpzIiwid2VicGFjazovL0B3aGVlenkvZGVtb3MvLi4vLi4vbm9kZV9tb2R1bGVzL0Bsb2FkZXJzLmdsL3dvcmtlci11dGlscy9kaXN0L2xpYi93b3JrZXItYXBpL2dldC13b3JrZXItdXJsLmpzIiwid2VicGFjazovL0B3aGVlenkvZGVtb3MvLi4vLi4vbm9kZV9tb2R1bGVzL0Bsb2FkZXJzLmdsL3dvcmtlci11dGlscy9kaXN0L2xpYi93b3JrZXItYXBpL3ZhbGlkYXRlLXdvcmtlci12ZXJzaW9uLmpzIiwid2VicGFjazovL0B3aGVlenkvZGVtb3MvLi4vLi4vbm9kZV9tb2R1bGVzL0Bsb2FkZXJzLmdsL3dvcmtlci11dGlscy9kaXN0L2xpYi93b3JrZXItZmFybS93b3JrZXItZmFybS5qcyIsIndlYnBhY2s6Ly9Ad2hlZXp5L2RlbW9zLy4uLy4uL25vZGVfbW9kdWxlcy9AbG9hZGVycy5nbC93b3JrZXItdXRpbHMvZGlzdC9saWIvd29ya2VyLWZhcm0vd29ya2VyLWpvYi5qcyIsIndlYnBhY2s6Ly9Ad2hlZXp5L2RlbW9zLy4uLy4uL25vZGVfbW9kdWxlcy9AbG9hZGVycy5nbC93b3JrZXItdXRpbHMvZGlzdC9saWIvd29ya2VyLWZhcm0vd29ya2VyLXBvb2wuanMiLCJ3ZWJwYWNrOi8vQHdoZWV6eS9kZW1vcy8uLi8uLi9ub2RlX21vZHVsZXMvQGxvYWRlcnMuZ2wvd29ya2VyLXV0aWxzL2Rpc3QvbGliL3dvcmtlci1mYXJtL3dvcmtlci10aHJlYWQuanMiLCJ3ZWJwYWNrOi8vQHdoZWV6eS9kZW1vcy8uLi8uLi9ub2RlX21vZHVsZXMvQGxvYWRlcnMuZ2wvd29ya2VyLXV0aWxzL2Rpc3QvbGliL3dvcmtlci11dGlscy9nZXQtbG9hZGFibGUtd29ya2VyLXVybC5qcyIsIndlYnBhY2s6Ly9Ad2hlZXp5L2RlbW9zLy4uLy4uL25vZGVfbW9kdWxlcy9AbG9hZGVycy5nbC93b3JrZXItdXRpbHMvZGlzdC9saWIvd29ya2VyLXV0aWxzL2dldC10cmFuc2Zlci1saXN0LmpzIiwid2VicGFjazovL0B3aGVlenkvZGVtb3MvLi4vLi4vbm9kZV9tb2R1bGVzL0Bwcm9iZS5nbC9lbnYvZGlzdC9pbmRleC5qcyIsIndlYnBhY2s6Ly9Ad2hlZXp5L2RlbW9zLy4uLy4uL25vZGVfbW9kdWxlcy9AcHJvYmUuZ2wvZW52L2Rpc3QvbGliL2dldC1icm93c2VyLmpzIiwid2VicGFjazovL0B3aGVlenkvZGVtb3MvLi4vLi4vbm9kZV9tb2R1bGVzL0Bwcm9iZS5nbC9lbnYvZGlzdC9saWIvZ2xvYmFscy5qcyIsIndlYnBhY2s6Ly9Ad2hlZXp5L2RlbW9zLy4uLy4uL25vZGVfbW9kdWxlcy9AcHJvYmUuZ2wvZW52L2Rpc3QvbGliL2lzLWJyb3dzZXIuanMiLCJ3ZWJwYWNrOi8vQHdoZWV6eS9kZW1vcy8uLi8uLi9ub2RlX21vZHVsZXMvQHByb2JlLmdsL2Vudi9kaXN0L2xpYi9pcy1lbGVjdHJvbi5qcyIsIndlYnBhY2s6Ly9Ad2hlZXp5L2RlbW9zLy4uLy4uL25vZGVfbW9kdWxlcy9AcHJvYmUuZ2wvZW52L2Rpc3QvdXRpbHMvYXNzZXJ0LmpzIiwid2VicGFjazovL0B3aGVlenkvZGVtb3MvLi4vLi4vbm9kZV9tb2R1bGVzL0Bwcm9iZS5nbC9sb2cvZGlzdC9sb2cuanMiLCJ3ZWJwYWNrOi8vQHdoZWV6eS9kZW1vcy8uLi8uLi9ub2RlX21vZHVsZXMvQHByb2JlLmdsL2xvZy9kaXN0L3V0aWxzL2Fzc2VydC5qcyIsIndlYnBhY2s6Ly9Ad2hlZXp5L2RlbW9zLy4uLy4uL25vZGVfbW9kdWxlcy9AcHJvYmUuZ2wvbG9nL2Rpc3QvdXRpbHMvYXV0b2JpbmQuanMiLCJ3ZWJwYWNrOi8vQHdoZWV6eS9kZW1vcy8uLi8uLi9ub2RlX21vZHVsZXMvQHByb2JlLmdsL2xvZy9kaXN0L3V0aWxzL2NvbG9yLmpzIiwid2VicGFjazovL0B3aGVlenkvZGVtb3MvLi4vLi4vbm9kZV9tb2R1bGVzL0Bwcm9iZS5nbC9sb2cvZGlzdC91dGlscy9mb3JtYXR0ZXJzLmpzIiwid2VicGFjazovL0B3aGVlenkvZGVtb3MvLi4vLi4vbm9kZV9tb2R1bGVzL0Bwcm9iZS5nbC9sb2cvZGlzdC91dGlscy9oaS1yZXMtdGltZXN0YW1wLmpzIiwid2VicGFjazovL0B3aGVlenkvZGVtb3MvLi4vLi4vbm9kZV9tb2R1bGVzL0Bwcm9iZS5nbC9sb2cvZGlzdC91dGlscy9sb2NhbC1zdG9yYWdlLmpzIiwid2VicGFjazovL0B3aGVlenkvZGVtb3MvLi4vLi4vbm9kZV9tb2R1bGVzL3dncHUtbWF0cml4L2Rpc3QvMy54L3dncHUtbWF0cml4Lm1vZHVsZS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBFbmdpbmUgfSBmcm9tICdAd2hlZXp5L2VuZ2luZSdcbmltcG9ydCB7IERlbW8wIH0gZnJvbSAnLi9zcmMvRGVtbzAnXG5cbmNvbnN0IGNhbnZhcyA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCd3ZWJncHUtY2FudmFzJykgYXMgSFRNTENhbnZhc0VsZW1lbnRcblxuY29uc3QgcnVuID0gYXN5bmMgKCkgPT4ge1xuICAgIGNvbnN0IGVuZ2luZSA9IChhd2FpdCBFbmdpbmUuZ2V0T3JJbml0KHsgY2FudmFzIH0pKSBhcyBFbmdpbmVcblxuICAgIGNvbnN0IHNjZW5lID0gbmV3IERlbW8wKClcbiAgICBhd2FpdCBzY2VuZS5pbml0KClcblxuICAgIGVuZ2luZS5zY2VuZSA9IHNjZW5lXG5cbiAgICBlbmdpbmUucmVuZGVyKClcbn1cblxucnVuKClcbiIsImltcG9ydCB7IHZlYzMgfSBmcm9tICd3Z3B1LW1hdHJpeCdcbmltcG9ydCBzaGFkZXJDb2RlIGZyb20gJy4uL3NoYWRlcnMvdGVzdFNoYWRlci53Z3NsJ1xuaW1wb3J0IHtcbiAgICBXaGVlenlHTEJMb2FkZXIsXG4gICAgU2NlbmUsXG4gICAgSUdhbWVPYmplY3QsXG4gICAgR2FtZU9iamVjdCxcbiAgICBUcmFuc2Zvcm0sXG59IGZyb20gJ0B3aGVlenkvZW5naW5lJ1xuaW1wb3J0IHsgQXJjQmFsbENhbWVyYSB9IGZyb20gJ0B3aGVlenkvZW5naW5lL3NyYy9lbmdpbmUvY29yZS9jYW1lcmFzL0FyY0JhbGxDYW1lcmEnXG5cbi8vVGhpcyBpcyBzdXBwb3NlZCB0byBkZW1vbnN0cmF0ZSBiYXNpYyB3b3JrZmxvd1xuZXhwb3J0IGNsYXNzIERlbW8wIGV4dGVuZHMgU2NlbmUge1xuICAgIHByaXZhdGUgX3NoYWRlck1vZHVsZTogR1BVU2hhZGVyTW9kdWxlXG5cbiAgICBwcml2YXRlIHN1biE6IElHYW1lT2JqZWN0XG5cbiAgICBwcml2YXRlIG1lcmN1cnkhOiBJR2FtZU9iamVjdFxuICAgIHByaXZhdGUgbWVyY3VyeUhvb2s6IElHYW1lT2JqZWN0ID0gdGhpcy5fY3JlYXRlVHJhbnNmb3JtT2JqZWN0KClcbiAgICBwcml2YXRlIHZlbnVzITogSUdhbWVPYmplY3RcbiAgICBwcml2YXRlIHZlbnVzSG9vazogSUdhbWVPYmplY3QgPSB0aGlzLl9jcmVhdGVUcmFuc2Zvcm1PYmplY3QoKVxuICAgIHByaXZhdGUgZWFydGghOiBJR2FtZU9iamVjdFxuICAgIHByaXZhdGUgZWFydGhIb29rOiBJR2FtZU9iamVjdCA9IHRoaXMuX2NyZWF0ZVRyYW5zZm9ybU9iamVjdCgpXG4gICAgcHJpdmF0ZSBtYXJzITogSUdhbWVPYmplY3RcbiAgICBwcml2YXRlIG1hcnNIb29rOiBJR2FtZU9iamVjdCA9IHRoaXMuX2NyZWF0ZVRyYW5zZm9ybU9iamVjdCgpXG4gICAgcHJpdmF0ZSBqdXBpdGVyITogSUdhbWVPYmplY3RcbiAgICBwcml2YXRlIGp1cGl0ZXJIb29rOiBJR2FtZU9iamVjdCA9IHRoaXMuX2NyZWF0ZVRyYW5zZm9ybU9iamVjdCgpXG4gICAgcHJpdmF0ZSBzYXR1cm4hOiBJR2FtZU9iamVjdFxuICAgIHByaXZhdGUgc2F0dXJuSG9vazogSUdhbWVPYmplY3QgPSB0aGlzLl9jcmVhdGVUcmFuc2Zvcm1PYmplY3QoKVxuICAgIHByaXZhdGUgdXJhbnVzITogSUdhbWVPYmplY3RcbiAgICBwcml2YXRlIHVyYW51c0hvb2s6IElHYW1lT2JqZWN0ID0gdGhpcy5fY3JlYXRlVHJhbnNmb3JtT2JqZWN0KClcbiAgICBwcml2YXRlIG5lcHR1bmUhOiBJR2FtZU9iamVjdFxuICAgIHByaXZhdGUgbmVwdHVuZUhvb2s6IElHYW1lT2JqZWN0ID0gdGhpcy5fY3JlYXRlVHJhbnNmb3JtT2JqZWN0KClcblxuICAgIHB1YmxpYyB5ZWFyc1Blck1pbnV0ZSA9IDFcblxuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcigpXG4gICAgICAgIHRoaXMuY2FtZXJhID0gbmV3IEFyY0JhbGxDYW1lcmEoe1xuICAgICAgICAgICAgekZhcjogMTAwMCxcbiAgICAgICAgICAgIHpOZWFyOiAwLjEsXG4gICAgICAgICAgICBjYW52YXNXaWR0aDogdGhpcy5fZW5naW5lIS5jb250ZXh0LmNhbnZhcy53aWR0aCxcbiAgICAgICAgICAgIGNhbnZhc0hlaWdodDogdGhpcy5fZW5naW5lIS5jb250ZXh0LmNhbnZhcy5oZWlnaHQsXG4gICAgICAgICAgICBwb3NpdGlvbjogdmVjMy5jcmVhdGUoMCwgNCwgNSksXG4gICAgICAgIH0pXG5cbiAgICAgICAgdGhpcy5fc2hhZGVyTW9kdWxlID0gdGhpcy5lbmdpbmUuZGV2aWNlLmNyZWF0ZVNoYWRlck1vZHVsZSh7XG4gICAgICAgICAgICBjb2RlOiBzaGFkZXJDb2RlLFxuICAgICAgICB9KVxuICAgIH1cblxuICAgIHByaXZhdGUgX2NyZWF0ZVRyYW5zZm9ybU9iamVjdCgpOiBHYW1lT2JqZWN0IHtcbiAgICAgICAgY29uc3QgZ2FtZU9iamVjdCA9IG5ldyBHYW1lT2JqZWN0KClcblxuICAgICAgICB0aGlzLm9iamVjdE1hbmFnZXIuYWRkT2JqZWN0KGdhbWVPYmplY3QsIHRoaXMucm9vdClcblxuICAgICAgICBuZXcgVHJhbnNmb3JtKGdhbWVPYmplY3QpXG5cbiAgICAgICAgcmV0dXJuIGdhbWVPYmplY3RcbiAgICB9XG5cbiAgICBwcml2YXRlIGFzeW5jIF9zZXR1cFN1bigpIHtcbiAgICAgICAgY29uc3QgcGxhbmV0TUQgPSBhd2FpdCBXaGVlenlHTEJMb2FkZXIubG9hZEZyb21VcmwoXG4gICAgICAgICAgICAnc3RhdGljL21vZGVscy9wbGFuZXRzL3N1bi5nbGInXG4gICAgICAgIClcbiAgICAgICAgdGhpcy5zdW4gPSBhd2FpdCB0aGlzLnVwbG9hZE1vZGVsKHtcbiAgICAgICAgICAgIG1vZGVsRGF0YTogcGxhbmV0TUQsXG4gICAgICAgICAgICBzaGFkZXJNb2R1bGU6IHRoaXMuX3NoYWRlck1vZHVsZSxcbiAgICAgICAgfSlcblxuICAgICAgICB0aGlzLnN1bi50cmFuc2Zvcm0uc2NhbGUodmVjMy5jcmVhdGUoMC4xMiwgMC4xMiwgMC4xMikpXG4gICAgfVxuXG4gICAgcHJpdmF0ZSBhc3luYyBfc2V0dXBNZXJjdXJ5KCkge1xuICAgICAgICBjb25zdCBwbGFuZXRNRCA9IGF3YWl0IFdoZWV6eUdMQkxvYWRlci5sb2FkRnJvbVVybChcbiAgICAgICAgICAgICdzdGF0aWMvbW9kZWxzL3BsYW5ldHMvbWVyY3VyeS5nbGInXG4gICAgICAgIClcbiAgICAgICAgdGhpcy5tZXJjdXJ5ID0gYXdhaXQgdGhpcy51cGxvYWRNb2RlbCh7XG4gICAgICAgICAgICBtb2RlbERhdGE6IHBsYW5ldE1ELFxuICAgICAgICAgICAgc2hhZGVyTW9kdWxlOiB0aGlzLl9zaGFkZXJNb2R1bGUsXG4gICAgICAgIH0pXG5cbiAgICAgICAgdGhpcy5vYmplY3RNYW5hZ2VyLnJlcGFyZW50T2JqZWN0KHRoaXMubWVyY3VyeSwgdGhpcy5tZXJjdXJ5SG9vaylcblxuICAgICAgICB0aGlzLm1lcmN1cnlIb29rLnRyYW5zZm9ybS5yb3RhdGVEZWdyZWVzRXVsZXIoeyB5OiA4MCB9KVxuXG4gICAgICAgIHRoaXMubWVyY3VyeS50cmFuc2Zvcm0uc2NhbGUodmVjMy5jcmVhdGUoMC4wOCwgMC4wOCwgMC4wOCkpXG4gICAgICAgIHRoaXMubWVyY3VyeS50cmFuc2Zvcm0udHJhbnNsYXRlKHZlYzMuY3JlYXRlKDEuNCkpXG4gICAgfVxuXG4gICAgcHJpdmF0ZSBhc3luYyBfc2V0dXBWZW51cygpIHtcbiAgICAgICAgY29uc3QgcGxhbmV0TUQgPSBhd2FpdCBXaGVlenlHTEJMb2FkZXIubG9hZEZyb21VcmwoXG4gICAgICAgICAgICAnc3RhdGljL21vZGVscy9wbGFuZXRzL3ZlbnVzLmdsYidcbiAgICAgICAgKVxuICAgICAgICB0aGlzLnZlbnVzID0gYXdhaXQgdGhpcy51cGxvYWRNb2RlbCh7XG4gICAgICAgICAgICBtb2RlbERhdGE6IHBsYW5ldE1ELFxuICAgICAgICAgICAgc2hhZGVyTW9kdWxlOiB0aGlzLl9zaGFkZXJNb2R1bGUsXG4gICAgICAgIH0pXG5cbiAgICAgICAgdGhpcy5vYmplY3RNYW5hZ2VyLnJlcGFyZW50T2JqZWN0KHRoaXMudmVudXMsIHRoaXMudmVudXNIb29rKVxuXG4gICAgICAgIHRoaXMudmVudXNIb29rLnRyYW5zZm9ybS5yb3RhdGVEZWdyZWVzRXVsZXIoeyB5OiAxNjAgfSlcblxuICAgICAgICB0aGlzLnZlbnVzLnRyYW5zZm9ybS5zY2FsZSh2ZWMzLmNyZWF0ZSgwLjEyLCAwLjEyLCAwLjEyKSlcbiAgICAgICAgdGhpcy52ZW51cy50cmFuc2Zvcm0udHJhbnNsYXRlKHZlYzMuY3JlYXRlKDEuNywgMCwgMCkpXG4gICAgfVxuXG4gICAgcHJpdmF0ZSBhc3luYyBfc2V0dXBFYXJ0aCgpIHtcbiAgICAgICAgY29uc3QgcGxhbmV0TUQgPSBhd2FpdCBXaGVlenlHTEJMb2FkZXIubG9hZEZyb21VcmwoXG4gICAgICAgICAgICAnc3RhdGljL21vZGVscy9wbGFuZXRzL2VhcnRoLmdsYidcbiAgICAgICAgKVxuICAgICAgICB0aGlzLmVhcnRoID0gYXdhaXQgdGhpcy51cGxvYWRNb2RlbCh7XG4gICAgICAgICAgICBtb2RlbERhdGE6IHBsYW5ldE1ELFxuICAgICAgICAgICAgc2hhZGVyTW9kdWxlOiB0aGlzLl9zaGFkZXJNb2R1bGUsXG4gICAgICAgIH0pXG5cbiAgICAgICAgdGhpcy5vYmplY3RNYW5hZ2VyLnJlcGFyZW50T2JqZWN0KHRoaXMuZWFydGgsIHRoaXMuZWFydGhIb29rKVxuXG4gICAgICAgIHRoaXMuZWFydGhIb29rLnRyYW5zZm9ybS5yb3RhdGVEZWdyZWVzRXVsZXIoeyB5OiAxMCB9KVxuXG4gICAgICAgIHRoaXMuZWFydGgudHJhbnNmb3JtLnNjYWxlKHZlYzMuY3JlYXRlKDAuMTYsIDAuMTYsIDAuMTYpKVxuICAgICAgICB0aGlzLmVhcnRoLnRyYW5zZm9ybS50cmFuc2xhdGUodmVjMy5jcmVhdGUoMi4yLCAwLCAwKSlcbiAgICB9XG5cbiAgICBwcml2YXRlIGFzeW5jIF9zZXR1cE1hcnMoKSB7XG4gICAgICAgIGNvbnN0IHBsYW5ldE1EID0gYXdhaXQgV2hlZXp5R0xCTG9hZGVyLmxvYWRGcm9tVXJsKFxuICAgICAgICAgICAgJ3N0YXRpYy9tb2RlbHMvcGxhbmV0cy9tYXJzLmdsYidcbiAgICAgICAgKVxuICAgICAgICB0aGlzLm1hcnMgPSBhd2FpdCB0aGlzLnVwbG9hZE1vZGVsKHtcbiAgICAgICAgICAgIG1vZGVsRGF0YTogcGxhbmV0TUQsXG4gICAgICAgICAgICBzaGFkZXJNb2R1bGU6IHRoaXMuX3NoYWRlck1vZHVsZSxcbiAgICAgICAgfSlcblxuICAgICAgICB0aGlzLm9iamVjdE1hbmFnZXIucmVwYXJlbnRPYmplY3QodGhpcy5tYXJzLCB0aGlzLm1hcnNIb29rKVxuXG4gICAgICAgIHRoaXMubWFyc0hvb2sudHJhbnNmb3JtLnJvdGF0ZURlZ3JlZXNFdWxlcih7IHk6IDUwIH0pXG5cbiAgICAgICAgdGhpcy5tYXJzLnRyYW5zZm9ybS5zY2FsZSh2ZWMzLmNyZWF0ZSgwLjE0LCAwLjE0LCAwLjE0KSlcbiAgICAgICAgdGhpcy5tYXJzLnRyYW5zZm9ybS50cmFuc2xhdGUodmVjMy5jcmVhdGUoMi43LCAwLCAwKSlcbiAgICB9XG5cbiAgICBwcml2YXRlIGFzeW5jIF9zZXR1cEp1cGl0ZXIoKSB7XG4gICAgICAgIGNvbnN0IHBsYW5ldE1EID0gYXdhaXQgV2hlZXp5R0xCTG9hZGVyLmxvYWRGcm9tVXJsKFxuICAgICAgICAgICAgJ3N0YXRpYy9tb2RlbHMvcGxhbmV0cy9qdXBpdGVyLmdsYidcbiAgICAgICAgKVxuICAgICAgICB0aGlzLmp1cGl0ZXIgPSBhd2FpdCB0aGlzLnVwbG9hZE1vZGVsKHtcbiAgICAgICAgICAgIG1vZGVsRGF0YTogcGxhbmV0TUQsXG4gICAgICAgICAgICBzaGFkZXJNb2R1bGU6IHRoaXMuX3NoYWRlck1vZHVsZSxcbiAgICAgICAgfSlcblxuICAgICAgICB0aGlzLm9iamVjdE1hbmFnZXIucmVwYXJlbnRPYmplY3QodGhpcy5qdXBpdGVyLCB0aGlzLmp1cGl0ZXJIb29rKVxuXG4gICAgICAgIHRoaXMuanVwaXRlckhvb2sudHJhbnNmb3JtLnJvdGF0ZURlZ3JlZXNFdWxlcih7IHk6IDE1MCB9KVxuXG4gICAgICAgIHRoaXMuanVwaXRlci50cmFuc2Zvcm0uc2NhbGUodmVjMy5jcmVhdGUoMC4xNSwgMC4xNSwgMC4xNSkpXG4gICAgICAgIHRoaXMuanVwaXRlci50cmFuc2Zvcm0ucm90YXRlRGVncmVlc0V1bGVyKHsgeDogOTAgfSlcbiAgICAgICAgdGhpcy5qdXBpdGVyLnRyYW5zZm9ybS50cmFuc2xhdGUodmVjMy5jcmVhdGUoMy40LCAwLCAwKSlcbiAgICB9XG5cbiAgICBwcml2YXRlIGFzeW5jIF9zZXR1cFNhdHVybigpIHtcbiAgICAgICAgY29uc3QgcGxhbmV0TUQgPSBhd2FpdCBXaGVlenlHTEJMb2FkZXIubG9hZEZyb21VcmwoXG4gICAgICAgICAgICAnc3RhdGljL21vZGVscy9wbGFuZXRzL3NhdHVybi5nbGInXG4gICAgICAgIClcbiAgICAgICAgdGhpcy5zYXR1cm4gPSBhd2FpdCB0aGlzLnVwbG9hZE1vZGVsKHtcbiAgICAgICAgICAgIG1vZGVsRGF0YTogcGxhbmV0TUQsXG4gICAgICAgICAgICBzaGFkZXJNb2R1bGU6IHRoaXMuX3NoYWRlck1vZHVsZSxcbiAgICAgICAgfSlcblxuICAgICAgICB0aGlzLm9iamVjdE1hbmFnZXIucmVwYXJlbnRPYmplY3QodGhpcy5zYXR1cm4sIHRoaXMuc2F0dXJuSG9vaylcblxuICAgICAgICB0aGlzLnNhdHVybkhvb2sudHJhbnNmb3JtLnJvdGF0ZURlZ3JlZXNFdWxlcih7IHk6IDIxMCB9KVxuXG4gICAgICAgIHRoaXMuc2F0dXJuLnRyYW5zZm9ybS5zY2FsZSh2ZWMzLmNyZWF0ZSgwLjAwMTIsIDAuMDAxMiwgMC4wMDEyKSlcbiAgICAgICAgdGhpcy5zYXR1cm4udHJhbnNmb3JtLnJvdGF0ZURlZ3JlZXNFdWxlcih7IHg6IDc2IH0pXG4gICAgICAgIHRoaXMuc2F0dXJuLnRyYW5zZm9ybS50cmFuc2xhdGUodmVjMy5jcmVhdGUoNC4zLCAwLCAwKSlcbiAgICB9XG5cbiAgICBwcml2YXRlIGFzeW5jIF9zZXR1cFVyYW51cygpIHtcbiAgICAgICAgY29uc3QgcGxhbmV0TUQgPSBhd2FpdCBXaGVlenlHTEJMb2FkZXIubG9hZEZyb21VcmwoXG4gICAgICAgICAgICAnc3RhdGljL21vZGVscy9wbGFuZXRzL3VyYW51cy5nbGInXG4gICAgICAgIClcbiAgICAgICAgdGhpcy51cmFudXMgPSBhd2FpdCB0aGlzLnVwbG9hZE1vZGVsKHtcbiAgICAgICAgICAgIG1vZGVsRGF0YTogcGxhbmV0TUQsXG4gICAgICAgICAgICBzaGFkZXJNb2R1bGU6IHRoaXMuX3NoYWRlck1vZHVsZSxcbiAgICAgICAgfSlcblxuICAgICAgICB0aGlzLm9iamVjdE1hbmFnZXIucmVwYXJlbnRPYmplY3QodGhpcy51cmFudXMsIHRoaXMudXJhbnVzSG9vaylcblxuICAgICAgICB0aGlzLnVyYW51c0hvb2sudHJhbnNmb3JtLnJvdGF0ZURlZ3JlZXNFdWxlcih7IHk6IDI3MCB9KVxuXG4gICAgICAgIHRoaXMudXJhbnVzLnRyYW5zZm9ybS5zY2FsZSh2ZWMzLmNyZWF0ZSgwLjIsIDAuMiwgMC4yKSlcbiAgICAgICAgdGhpcy51cmFudXMudHJhbnNmb3JtLnJvdGF0ZURlZ3JlZXNFdWxlcih7IHg6IDkwIH0pXG4gICAgICAgIHRoaXMudXJhbnVzLnRyYW5zZm9ybS50cmFuc2xhdGUodmVjMy5jcmVhdGUoNS4yLCAwLCAwKSlcbiAgICB9XG5cbiAgICBwcml2YXRlIGFzeW5jIF9zZXR1cE5lcHR1bmUoKSB7XG4gICAgICAgIGNvbnN0IHBsYW5ldE1EID0gYXdhaXQgV2hlZXp5R0xCTG9hZGVyLmxvYWRGcm9tVXJsKFxuICAgICAgICAgICAgJ3N0YXRpYy9tb2RlbHMvcGxhbmV0cy9uZXB0dW5lLmdsYidcbiAgICAgICAgKVxuICAgICAgICB0aGlzLm5lcHR1bmUgPSBhd2FpdCB0aGlzLnVwbG9hZE1vZGVsKHtcbiAgICAgICAgICAgIG1vZGVsRGF0YTogcGxhbmV0TUQsXG4gICAgICAgICAgICBzaGFkZXJNb2R1bGU6IHRoaXMuX3NoYWRlck1vZHVsZSxcbiAgICAgICAgfSlcblxuICAgICAgICB0aGlzLm9iamVjdE1hbmFnZXIucmVwYXJlbnRPYmplY3QodGhpcy5uZXB0dW5lLCB0aGlzLm5lcHR1bmVIb29rKVxuXG4gICAgICAgIHRoaXMubmVwdHVuZUhvb2sudHJhbnNmb3JtLnJvdGF0ZURlZ3JlZXNFdWxlcih7IHk6IDEwMCB9KVxuXG4gICAgICAgIHRoaXMubmVwdHVuZS50cmFuc2Zvcm0uc2NhbGUodmVjMy5jcmVhdGUoMC4yLCAwLjIsIDAuMikpXG4gICAgICAgIHRoaXMubmVwdHVuZS50cmFuc2Zvcm0ucm90YXRlRGVncmVlc0V1bGVyKHsgeDogOTAgfSlcbiAgICAgICAgdGhpcy5uZXB0dW5lLnRyYW5zZm9ybS50cmFuc2xhdGUodmVjMy5jcmVhdGUoNS44LCAwLCAwKSlcbiAgICB9XG5cbiAgICBwdWJsaWMgYXN5bmMgaW5pdCgpIHtcbiAgICAgICAgYXdhaXQgdGhpcy5fc2V0dXBTdW4oKVxuICAgICAgICBhd2FpdCB0aGlzLl9zZXR1cE1lcmN1cnkoKVxuICAgICAgICBhd2FpdCB0aGlzLl9zZXR1cFZlbnVzKClcbiAgICAgICAgYXdhaXQgdGhpcy5fc2V0dXBFYXJ0aCgpXG4gICAgICAgIGF3YWl0IHRoaXMuX3NldHVwTWFycygpXG4gICAgICAgIGF3YWl0IHRoaXMuX3NldHVwSnVwaXRlcigpXG4gICAgICAgIGF3YWl0IHRoaXMuX3NldHVwU2F0dXJuKClcbiAgICAgICAgYXdhaXQgdGhpcy5fc2V0dXBVcmFudXMoKVxuICAgICAgICBhd2FpdCB0aGlzLl9zZXR1cE5lcHR1bmUoKVxuXG4gICAgICAgIGNvbnN0IHdyYXBwZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKVxuICAgICAgICB3cmFwcGVyLnN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJ1xuICAgICAgICB3cmFwcGVyLnN0eWxlLnRvcCA9ICcwJ1xuICAgICAgICB3cmFwcGVyLnN0eWxlLnpJbmRleCA9ICcxMCdcblxuICAgICAgICBjb25zdCBidXR0b24wID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYnV0dG9uJylcbiAgICAgICAgYnV0dG9uMC50ZXh0Q29udGVudCA9ICcxINCz0L7QtCDQsiDQvNC40L3Rg9GC0YMnXG5cbiAgICAgICAgYnV0dG9uMC5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsICgpID0+IHtcbiAgICAgICAgICAgIHRoaXMueWVhcnNQZXJNaW51dGUgPSAxXG4gICAgICAgIH0pXG5cbiAgICAgICAgY29uc3QgYnV0dG9uMSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2J1dHRvbicpXG4gICAgICAgIGJ1dHRvbjEudGV4dENvbnRlbnQgPSAnMTAwINC70LXRgiDQsiDQvNC40L3Rg9GC0YMnXG5cbiAgICAgICAgYnV0dG9uMS5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsICgpID0+IHtcbiAgICAgICAgICAgIHRoaXMueWVhcnNQZXJNaW51dGUgPSAxMDBcbiAgICAgICAgfSlcblxuICAgICAgICB3cmFwcGVyLmFwcGVuZENoaWxkKGJ1dHRvbjApXG4gICAgICAgIHdyYXBwZXIuYXBwZW5kQ2hpbGQoYnV0dG9uMSlcblxuICAgICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHdyYXBwZXIpXG4gICAgfVxuXG4gICAgcHJpdmF0ZSBnZXRPcmJpdFJvdGF0aW9uUGVyRnJhbWUobmFtZTogc3RyaW5nKSB7XG4gICAgICAgIGNvbnN0IGNvbW1vbkRpdmlkZXIgPSAzNjAwIC8gdGhpcy55ZWFyc1Blck1pbnV0ZVxuXG4gICAgICAgIHN3aXRjaCAobmFtZSkge1xuICAgICAgICAgICAgY2FzZSAnbWVyY3VyeSc6XG4gICAgICAgICAgICAgICAgcmV0dXJuICgzNjAgKiA0LjE3KSAvIGNvbW1vbkRpdmlkZXJcbiAgICAgICAgICAgIGNhc2UgJ3ZlbnVzJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gKDM2MCAqIDEuNjMpIC8gY29tbW9uRGl2aWRlclxuICAgICAgICAgICAgY2FzZSAnZWFydGgnOlxuICAgICAgICAgICAgICAgIHJldHVybiAoMzYwICogMSkgLyBjb21tb25EaXZpZGVyXG4gICAgICAgICAgICBjYXNlICdtYXJzJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gKDM2MCAqIDAuNTMpIC8gY29tbW9uRGl2aWRlclxuICAgICAgICAgICAgY2FzZSAnanVwaXRlcic6XG4gICAgICAgICAgICAgICAgcmV0dXJuICgzNjAgKiAwLjA4NCkgLyBjb21tb25EaXZpZGVyXG4gICAgICAgICAgICBjYXNlICdzYXR1cm4nOlxuICAgICAgICAgICAgICAgIHJldHVybiAoMzYwICogMC4wMzQpIC8gY29tbW9uRGl2aWRlclxuICAgICAgICAgICAgY2FzZSAndXJhbnVzJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gKDM2MCAqIDAuMDEyKSAvIGNvbW1vbkRpdmlkZXJcbiAgICAgICAgICAgIGNhc2UgJ25lcHR1bmUnOlxuICAgICAgICAgICAgICAgIHJldHVybiAoMzYwICogMC4wMDYpIC8gY29tbW9uRGl2aWRlclxuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICByZXR1cm4gMFxuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBnZXRTZWxmUm90YXRpb25QZXJGcmFtZShuYW1lOiBzdHJpbmcpIHtcbiAgICAgICAgY29uc3QgY29tbW9uRGl2aWRlciA9IDM2MDAgLyB0aGlzLnllYXJzUGVyTWludXRlXG5cbiAgICAgICAgc3dpdGNoIChuYW1lKSB7XG4gICAgICAgICAgICBjYXNlICdzdW4nOlxuICAgICAgICAgICAgICAgIHJldHVybiAoMzYwICogMC4wNCAqIDM2NSkgLyBjb21tb25EaXZpZGVyXG4gICAgICAgICAgICBjYXNlICdtZXJjdXJ5JzpcbiAgICAgICAgICAgICAgICByZXR1cm4gKDM2MCAqIDEuNSAqIDM2NSkgLyBjb21tb25EaXZpZGVyXG4gICAgICAgICAgICBjYXNlICd2ZW51cyc6XG4gICAgICAgICAgICAgICAgcmV0dXJuICgzNjAgKiAxLjUwMiAqIDM2NSkgLyBjb21tb25EaXZpZGVyXG4gICAgICAgICAgICBjYXNlICdlYXJ0aCc6XG4gICAgICAgICAgICAgICAgcmV0dXJuICgzNjAgKiAxICogMzY1KSAvIGNvbW1vbkRpdmlkZXJcbiAgICAgICAgICAgIGNhc2UgJ21hcnMnOlxuICAgICAgICAgICAgICAgIHJldHVybiAoMzYwICogMS4wMyAqIDM2NSkgLyBjb21tb25EaXZpZGVyXG4gICAgICAgICAgICBjYXNlICdqdXBpdGVyJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gKDM2MCAqIDAuNDEgKiAzNjUpIC8gY29tbW9uRGl2aWRlclxuICAgICAgICAgICAgY2FzZSAnc2F0dXJuJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gKDM2MCAqIDAuNDUgKiAzNjUpIC8gY29tbW9uRGl2aWRlclxuICAgICAgICAgICAgY2FzZSAndXJhbnVzJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gKDM2MCAqIDAuNjY2ICogMzY1KSAvIGNvbW1vbkRpdmlkZXJcbiAgICAgICAgICAgIGNhc2UgJ25lcHR1bmUnOlxuICAgICAgICAgICAgICAgIHJldHVybiAoMzYwICogMC43MDggKiAzNjUpIC8gY29tbW9uRGl2aWRlclxuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICByZXR1cm4gMFxuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHJvdGVjdGVkIG9uUmVuZGVyKGRlbHRhVGltZTogbnVtYmVyKTogdm9pZCB7XG4gICAgICAgIC8vRllJOiBBbHdheXMgcmVtZW1iZXIgdG8gcmVzZXQgb3JpZW50YXRpb24gaW4gYmxlbmRlciA6L1xuICAgICAgICB0aGlzLnN1bi50cmFuc2Zvcm0ucm90YXRlRGVncmVlc0V1bGVyKHtcbiAgICAgICAgICAgIHk6IHRoaXMuZ2V0U2VsZlJvdGF0aW9uUGVyRnJhbWUoJ3N1bicpLFxuICAgICAgICB9KVxuICAgICAgICB0aGlzLm1lcmN1cnkudHJhbnNmb3JtLnJvdGF0ZURlZ3JlZXNFdWxlcih7XG4gICAgICAgICAgICB5OiB0aGlzLmdldFNlbGZSb3RhdGlvblBlckZyYW1lKCdtZXJjdXJ5JyksXG4gICAgICAgIH0pXG4gICAgICAgIHRoaXMubWVyY3VyeUhvb2sudHJhbnNmb3JtLnJvdGF0ZURlZ3JlZXNFdWxlcih7XG4gICAgICAgICAgICB5OiB0aGlzLmdldE9yYml0Um90YXRpb25QZXJGcmFtZSgnbWVyY3VyeScpLFxuICAgICAgICB9KVxuICAgICAgICB0aGlzLnZlbnVzLnRyYW5zZm9ybS5yb3RhdGVEZWdyZWVzRXVsZXIoe1xuICAgICAgICAgICAgeTogdGhpcy5nZXRTZWxmUm90YXRpb25QZXJGcmFtZSgndmVudXMnKSxcbiAgICAgICAgfSlcbiAgICAgICAgdGhpcy52ZW51c0hvb2sudHJhbnNmb3JtLnJvdGF0ZURlZ3JlZXNFdWxlcih7XG4gICAgICAgICAgICB5OiB0aGlzLmdldE9yYml0Um90YXRpb25QZXJGcmFtZSgndmVudXMnKSxcbiAgICAgICAgfSlcbiAgICAgICAgdGhpcy5lYXJ0aC50cmFuc2Zvcm0ucm90YXRlRGVncmVlc0V1bGVyKHtcbiAgICAgICAgICAgIHk6IHRoaXMuZ2V0U2VsZlJvdGF0aW9uUGVyRnJhbWUoJ2VhcnRoJyksXG4gICAgICAgIH0pXG4gICAgICAgIHRoaXMuZWFydGhIb29rLnRyYW5zZm9ybS5yb3RhdGVEZWdyZWVzRXVsZXIoe1xuICAgICAgICAgICAgeTogdGhpcy5nZXRPcmJpdFJvdGF0aW9uUGVyRnJhbWUoJ2VhcnRoJyksXG4gICAgICAgIH0pXG4gICAgICAgIHRoaXMubWFycy50cmFuc2Zvcm0ucm90YXRlRGVncmVlc0V1bGVyKHtcbiAgICAgICAgICAgIHk6IHRoaXMuZ2V0U2VsZlJvdGF0aW9uUGVyRnJhbWUoJ21hcnMnKSxcbiAgICAgICAgfSlcbiAgICAgICAgdGhpcy5tYXJzSG9vay50cmFuc2Zvcm0ucm90YXRlRGVncmVlc0V1bGVyKHtcbiAgICAgICAgICAgIHk6IHRoaXMuZ2V0T3JiaXRSb3RhdGlvblBlckZyYW1lKCdtYXJzJyksXG4gICAgICAgIH0pXG4gICAgICAgIHRoaXMuanVwaXRlci50cmFuc2Zvcm0ucm90YXRlRGVncmVlc0V1bGVyKHtcbiAgICAgICAgICAgIHo6IC10aGlzLmdldFNlbGZSb3RhdGlvblBlckZyYW1lKCdqdXBpdGVyJyksXG4gICAgICAgIH0pXG4gICAgICAgIHRoaXMuanVwaXRlckhvb2sudHJhbnNmb3JtLnJvdGF0ZURlZ3JlZXNFdWxlcih7XG4gICAgICAgICAgICB5OiB0aGlzLmdldE9yYml0Um90YXRpb25QZXJGcmFtZSgnanVwaXRlcicpLFxuICAgICAgICB9KVxuICAgICAgICB0aGlzLnNhdHVybi50cmFuc2Zvcm0ucm90YXRlRGVncmVlc0V1bGVyKHtcbiAgICAgICAgICAgIHo6IC10aGlzLmdldFNlbGZSb3RhdGlvblBlckZyYW1lKCdzYXR1cm4nKSxcbiAgICAgICAgfSlcbiAgICAgICAgdGhpcy5zYXR1cm5Ib29rLnRyYW5zZm9ybS5yb3RhdGVEZWdyZWVzRXVsZXIoe1xuICAgICAgICAgICAgeTogdGhpcy5nZXRPcmJpdFJvdGF0aW9uUGVyRnJhbWUoJ3NhdHVybicpLFxuICAgICAgICB9KVxuICAgICAgICB0aGlzLnVyYW51cy50cmFuc2Zvcm0ucm90YXRlRGVncmVlc0V1bGVyKHtcbiAgICAgICAgICAgIHo6IC10aGlzLmdldFNlbGZSb3RhdGlvblBlckZyYW1lKCd1cmFudXMnKSxcbiAgICAgICAgfSlcbiAgICAgICAgdGhpcy51cmFudXNIb29rLnRyYW5zZm9ybS5yb3RhdGVEZWdyZWVzRXVsZXIoe1xuICAgICAgICAgICAgeTogdGhpcy5nZXRPcmJpdFJvdGF0aW9uUGVyRnJhbWUoJ3VyYW51cycpLFxuICAgICAgICB9KVxuICAgICAgICB0aGlzLm5lcHR1bmUudHJhbnNmb3JtLnJvdGF0ZURlZ3JlZXNFdWxlcih7XG4gICAgICAgICAgICB6OiAtdGhpcy5nZXRTZWxmUm90YXRpb25QZXJGcmFtZSgnbmVwdHVuZScpLFxuICAgICAgICB9KVxuICAgICAgICB0aGlzLm5lcHR1bmVIb29rLnRyYW5zZm9ybS5yb3RhdGVEZWdyZWVzRXVsZXIoe1xuICAgICAgICAgICAgeTogdGhpcy5nZXRPcmJpdFJvdGF0aW9uUGVyRnJhbWUoJ25lcHR1bmUnKSxcbiAgICAgICAgfSlcbiAgICB9XG59XG4iLCJleHBvcnQgKiBmcm9tICcuL3NyYy9lbmdpbmUvY29yZSdcbmV4cG9ydCAqIGZyb20gJy4vc3JjL2VuZ2luZS90eXBlcydcbmV4cG9ydCAqIGZyb20gJy4vc3JjL3BoeXNpY3MnXG5leHBvcnQgKiBmcm9tICcuL3NyYy91dGlscydcbiIsImltcG9ydCB7IElCdWZmZXJTdG9yYWdlIH0gZnJvbSAnLi4vLi4vdHlwZXMvY29yZS9CdWZmZXJTdG9yYWdlJ1xuXG5leHBvcnQgY2xhc3MgQnVmZmVyU3RvcmFnZSBpbXBsZW1lbnRzIElCdWZmZXJTdG9yYWdlIHtcbiAgICBfYnVmZmVyczogTWFwPHN0cmluZywgQXJyYXlCdWZmZXI+ID0gbmV3IE1hcCgpXG5cbiAgICBnZXQgYnVmZmVycygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2J1ZmZlcnNcbiAgICB9XG59XG4iLCJleHBvcnQgKiBmcm9tICcuL0J1ZmZlclN0b3JhZ2UnXG4iLCJpbXBvcnQgeyBFbnRpdHlUeXBlcywgSUNvbXBvbmVudCB9IGZyb20gJy4uLy4uL3R5cGVzJ1xuaW1wb3J0IHsgRW50aXR5IH0gZnJvbSAnLi4vRW50aXR5J1xuXG5leHBvcnQgY2xhc3MgQ29tcG9uZW50PFQgZXh0ZW5kcyBFbnRpdHlUeXBlcz5cbiAgICBleHRlbmRzIEVudGl0eTxUPlxuICAgIGltcGxlbWVudHMgSUNvbXBvbmVudDxUPlxue1xuICAgIF9wYXJlbnQ6IElDb21wb25lbnQ8VD5bJ3BhcmVudCddXG5cbiAgICBjb25zdHJ1Y3RvcihwYXJlbnQ6IElDb21wb25lbnQ8VD5bJ3BhcmVudCddLCBjb21wb25lbnRUeXBlOiBUKSB7XG4gICAgICAgIHN1cGVyKGNvbXBvbmVudFR5cGUpXG4gICAgICAgIHRoaXMuX3BhcmVudCA9IHBhcmVudFxuICAgICAgICB0aGlzLl9wYXJlbnQuYWRkQ29tcG9uZW50KHRoaXMpXG4gICAgfVxuXG4gICAgZ2V0IHBhcmVudCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3BhcmVudFxuICAgIH1cbn1cbiIsImV4cG9ydCAqIGZyb20gJy4vQ29tcG9uZW50J1xuIiwiaW1wb3J0IHsgSVNjZW5lLCBJRW5naW5lLCBJRW5naW5lUHJvcHMgfSBmcm9tICcuLi8uLi90eXBlcydcbmltcG9ydCB7XG4gICAgREVGQVVMVF9ERVBUSF9GT1JNQVQsXG4gICAgREVGQVVMVF9TV0FQX0NIQUlOX0ZPUk1BVCxcbiAgICBNU0FBX1NBTVBMRV9DT1VOVCxcbiAgICBWSUVXX1BBUkFNU19CVUZGRVJfU0laRSxcbn0gZnJvbSAnLi9jb25zdGFudHMnXG5cbmV4cG9ydCBjbGFzcyBFbmdpbmUgaW1wbGVtZW50cyBJRW5naW5lIHtcbiAgICBwcml2YXRlIF9hZGFwdGVyITogR1BVQWRhcHRlclxuICAgIHByaXZhdGUgX2RldmljZSE6IEdQVURldmljZVxuICAgIHByaXZhdGUgX2NvbnRleHQhOiBHUFVDYW52YXNDb250ZXh0XG5cbiAgICBwcml2YXRlIF9zd2FwQ2hhaW5Gb3JtYXQhOiBHUFVUZXh0dXJlRm9ybWF0XG4gICAgcHJpdmF0ZSBfZGVwdGhUZXh0dXJlRm9ybWF0ITogR1BVVGV4dHVyZUZvcm1hdFxuICAgIHByaXZhdGUgX2RlcHRoVGV4dHVyZSE6IEdQVVRleHR1cmVcblxuICAgIHByaXZhdGUgX3VuaWZvcm1zQkdMYXlvdXQhOiBHUFVCaW5kR3JvdXBMYXlvdXRcbiAgICBwcml2YXRlIF9ub2RlUGFyYW1zQkdMYXlvdXQhOiBHUFVCaW5kR3JvdXBMYXlvdXRcblxuICAgIHByaXZhdGUgX3ZpZXdQYXJhbXNCdWZmZXJTaXplOiBudW1iZXIgPSBWSUVXX1BBUkFNU19CVUZGRVJfU0laRVxuICAgIHByaXZhdGUgX21zYWFTYW1wbGVDb3VudDogbnVtYmVyID0gTVNBQV9TQU1QTEVfQ09VTlRcblxuICAgIHByaXZhdGUgX3ByZXZGcmFtZVRpbWU6IG51bWJlciA9IDBcblxuICAgIHByaXZhdGUgX3NjZW5lPzogSVNjZW5lXG5cbiAgICBwdWJsaWMgc3RhdGljIGFzeW5jIGdldE9ySW5pdCh7XG4gICAgICAgIGNhbnZhcyxcbiAgICAgICAgc3dhcENoYWluRm9ybWF0LFxuICAgICAgICBkZXB0aFRleHR1cmVGb3JtYXQsXG4gICAgfTogSUVuZ2luZVByb3BzKTogUHJvbWlzZTxFbmdpbmUgfCB1bmRlZmluZWQ+IHtcbiAgICAgICAgLy9GSVhNRTogdHlwZXNcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmICgod2luZG93IGFzIGFueSkuV2hlZXp5RW5naW5lKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdFbmdpbmUgaGFzIGFscmVhZHkgYmVlbiBpbnN0YW5jZWQnKVxuICAgICAgICAgICAgICAgIHJldHVybiAod2luZG93IGFzIGFueSkuV2hlZXp5RW5naW5lIGFzIEVuZ2luZVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb25zdCBlbmdpbmVJbnN0YW5jZSA9IG5ldyBFbmdpbmUoKVxuXG4gICAgICAgICAgICBhd2FpdCBlbmdpbmVJbnN0YW5jZS5pbml0aWFsaXplQ29udGV4dChjYW52YXMpXG5cbiAgICAgICAgICAgIGVuZ2luZUluc3RhbmNlLnN3YXBDaGFpbkZvcm1hdCA9XG4gICAgICAgICAgICAgICAgc3dhcENoYWluRm9ybWF0ID8/IERFRkFVTFRfU1dBUF9DSEFJTl9GT1JNQVRcbiAgICAgICAgICAgIGVuZ2luZUluc3RhbmNlLmRlcHRoVGV4dHVyZUZvcm1hdCA9XG4gICAgICAgICAgICAgICAgZGVwdGhUZXh0dXJlRm9ybWF0ID8/IERFRkFVTFRfREVQVEhfRk9STUFUXG5cbiAgICAgICAgICAgIGVuZ2luZUluc3RhbmNlLmluaXRpYWxpemVCaW5kR3JvdXBMYXlvdXRzKClcbiAgICAgICAgICAgIDsod2luZG93IGFzIGFueSkuV2hlZXp5RW5naW5lID0gZW5naW5lSW5zdGFuY2VcblxuICAgICAgICAgICAgcmV0dXJuIGVuZ2luZUluc3RhbmNlXG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgYWxlcnQoZXJyKVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgZ2V0IGFkYXB0ZXIoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hZGFwdGVyXG4gICAgfVxuXG4gICAgZ2V0IGRldmljZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RldmljZVxuICAgIH1cblxuICAgIGdldCBjb250ZXh0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fY29udGV4dFxuICAgIH1cblxuICAgIGdldCBzd2FwQ2hhaW5Gb3JtYXQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zd2FwQ2hhaW5Gb3JtYXRcbiAgICB9XG5cbiAgICBzZXQgc3dhcENoYWluRm9ybWF0KGZvcm1hdDogR1BVVGV4dHVyZUZvcm1hdCkge1xuICAgICAgICB0aGlzLl9zd2FwQ2hhaW5Gb3JtYXQgPSBmb3JtYXRcbiAgICAgICAgdGhpcy5fY29udGV4dC5jb25maWd1cmUoe1xuICAgICAgICAgICAgZGV2aWNlOiB0aGlzLl9kZXZpY2UsXG4gICAgICAgICAgICB1c2FnZTogR1BVVGV4dHVyZVVzYWdlLlJFTkRFUl9BVFRBQ0hNRU5ULFxuICAgICAgICAgICAgZm9ybWF0LFxuICAgICAgICB9KVxuICAgIH1cblxuICAgIGdldCBkZXB0aFRleHR1cmVGb3JtYXQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kZXB0aFRleHR1cmVGb3JtYXRcbiAgICB9XG5cbiAgICBzZXQgZGVwdGhUZXh0dXJlRm9ybWF0KGZvcm1hdDogR1BVVGV4dHVyZUZvcm1hdCkge1xuICAgICAgICB0aGlzLl9kZXB0aFRleHR1cmVGb3JtYXQgPSBmb3JtYXRcbiAgICAgICAgdGhpcy5fZGVwdGhUZXh0dXJlID0gdGhpcy5fZGV2aWNlLmNyZWF0ZVRleHR1cmUoe1xuICAgICAgICAgICAgbGFiZWw6ICdkZXB0aFRleHR1cmUnLFxuICAgICAgICAgICAgc2l6ZToge1xuICAgICAgICAgICAgICAgIHdpZHRoOiB0aGlzLl9jb250ZXh0LmNhbnZhcy53aWR0aCxcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IHRoaXMuX2NvbnRleHQuY2FudmFzLmhlaWdodCxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzYW1wbGVDb3VudDogdGhpcy5fbXNhYVNhbXBsZUNvdW50LFxuICAgICAgICAgICAgZm9ybWF0LFxuICAgICAgICAgICAgdXNhZ2U6IEdQVVRleHR1cmVVc2FnZS5SRU5ERVJfQVRUQUNITUVOVCxcbiAgICAgICAgfSlcbiAgICB9XG5cbiAgICBnZXQgZGVwdGhUZXh0dXJlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGVwdGhUZXh0dXJlXG4gICAgfVxuXG4gICAgZ2V0IHNjZW5lKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fc2NlbmVcbiAgICB9XG5cbiAgICBzZXQgc2NlbmUoc2NlbmU6IElTY2VuZSB8IHVuZGVmaW5lZCkge1xuICAgICAgICB0aGlzLl9zY2VuZSA9IHNjZW5lXG4gICAgfVxuXG4gICAgZ2V0IHVuaWZvcm1zQkdMYXlvdXQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl91bmlmb3Jtc0JHTGF5b3V0XG4gICAgfVxuXG4gICAgZ2V0IG5vZGVQYXJhbXNCR0xheW91dCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX25vZGVQYXJhbXNCR0xheW91dFxuICAgIH1cblxuICAgIGdldCB2aWV3UGFyYW1zQnVmZmVyU2l6ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ZpZXdQYXJhbXNCdWZmZXJTaXplXG4gICAgfVxuXG4gICAgZ2V0IG1zYWFTYW1wbGVDb3VudCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX21zYWFTYW1wbGVDb3VudFxuICAgIH1cblxuICAgIHNldCBtc2FhU2FtcGxlQ291bnQodmFsdWUpIHtcbiAgICAgICAgdGhpcy5fbXNhYVNhbXBsZUNvdW50ID0gdmFsdWVcbiAgICB9XG5cbiAgICBwdWJsaWMgYXN5bmMgaW5pdGlhbGl6ZUNvbnRleHQoY2FudmFzOiBIVE1MQ2FudmFzRWxlbWVudCkge1xuICAgICAgICBjb25zdCBhZGFwdGVyID0gYXdhaXQgbmF2aWdhdG9yLmdwdS5yZXF1ZXN0QWRhcHRlcigpXG5cbiAgICAgICAgaWYgKCFhZGFwdGVyKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0dQVSBBZGFwdGVyIFVuYXZhaWxhYmxlJylcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGRldmljZSA9IGF3YWl0IGFkYXB0ZXIucmVxdWVzdERldmljZSgpXG5cbiAgICAgICAgdGhpcy5fZGV2aWNlID0gZGV2aWNlXG4gICAgICAgIHRoaXMuX2FkYXB0ZXIgPSBhZGFwdGVyXG5cbiAgICAgICAgY2FudmFzLndpZHRoID0gZG9jdW1lbnQuYm9keS5jbGllbnRXaWR0aCAqIHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvXG4gICAgICAgIGNhbnZhcy5oZWlnaHQgPSBkb2N1bWVudC5ib2R5LmNsaWVudEhlaWdodCAqIHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvXG5cbiAgICAgICAgdGhpcy5fY29udGV4dCA9IGNhbnZhcy5nZXRDb250ZXh0KCd3ZWJncHUnKSBhcyBHUFVDYW52YXNDb250ZXh0XG5cbiAgICAgICAgaWYgKCF0aGlzLl9jb250ZXh0KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZhaWxlZCB0byBhY3F1aXJlIEdwdUNhbnZhc0NvbnRleHQnKVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHVibGljIGluaXRpYWxpemVCaW5kR3JvdXBMYXlvdXRzKCkge1xuICAgICAgICB0aGlzLl91bmlmb3Jtc0JHTGF5b3V0ID0gdGhpcy5kZXZpY2UuY3JlYXRlQmluZEdyb3VwTGF5b3V0KHtcbiAgICAgICAgICAgIGVudHJpZXM6IFtcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGJpbmRpbmc6IDAsXG4gICAgICAgICAgICAgICAgICAgIHZpc2liaWxpdHk6IEdQVVNoYWRlclN0YWdlLlZFUlRFWCxcbiAgICAgICAgICAgICAgICAgICAgYnVmZmVyOiB7IHR5cGU6ICd1bmlmb3JtJyB9LFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBdLFxuICAgICAgICB9KVxuXG4gICAgICAgIHRoaXMuX25vZGVQYXJhbXNCR0xheW91dCA9IHRoaXMuZGV2aWNlLmNyZWF0ZUJpbmRHcm91cExheW91dCh7XG4gICAgICAgICAgICBlbnRyaWVzOiBbXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBiaW5kaW5nOiAwLFxuICAgICAgICAgICAgICAgICAgICB2aXNpYmlsaXR5OiBHUFVTaGFkZXJTdGFnZS5WRVJURVgsXG4gICAgICAgICAgICAgICAgICAgIGJ1ZmZlcjogeyB0eXBlOiAndW5pZm9ybScgfSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgXSxcbiAgICAgICAgfSlcbiAgICB9XG5cbiAgICBwdWJsaWMgcmVuZGVyKHRpbWU6IG51bWJlciA9IDApIHtcbiAgICAgICAgaWYgKCF0aGlzLnNjZW5lKSByZXR1cm5cblxuICAgICAgICBjb25zdCBkdCA9ICh0aW1lIC0gdGhpcy5fcHJldkZyYW1lVGltZSkgLyAxMDBcbiAgICAgICAgdGhpcy5fcHJldkZyYW1lVGltZSA9IHRpbWVcblxuICAgICAgICB0aGlzLnNjZW5lLnJlbmRlcihkdClcbiAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCh0aW1lOiBudW1iZXIpID0+IHRoaXMucmVuZGVyKHRpbWUpKVxuICAgIH1cbn1cbiIsImV4cG9ydCBjb25zdCBERUZBVUxUX1NXQVBfQ0hBSU5fRk9STUFUOiBHUFVUZXh0dXJlRm9ybWF0ID0gJ2JncmE4dW5vcm0nXG5leHBvcnQgY29uc3QgREVGQVVMVF9ERVBUSF9GT1JNQVQ6IEdQVVRleHR1cmVGb3JtYXQgPSAnZGVwdGgyNHBsdXMtc3RlbmNpbDgnXG5leHBvcnQgY29uc3QgVklFV19QQVJBTVNfQlVGRkVSX1NJWkU6IG51bWJlciA9IDE2ICogNVxuZXhwb3J0IGNvbnN0IE1TQUFfU0FNUExFX0NPVU5UOiBudW1iZXIgPSA0XG4iLCJleHBvcnQgKiBmcm9tICcuL0VuZ2luZSdcbmV4cG9ydCAqIGZyb20gJy4vY29uc3RhbnRzJ1xuIiwiaW1wb3J0IHsgRW50aXR5VHlwZXMsIElFbnRpdHkgfSBmcm9tICcuLi8uLi90eXBlcydcblxuZXhwb3J0IGNsYXNzIEVudGl0eTxUIGV4dGVuZHMgRW50aXR5VHlwZXM+IGltcGxlbWVudHMgSUVudGl0eTxUPiB7XG4gICAgcHJpdmF0ZSBfaWQ6IHN0cmluZ1xuICAgIHByaXZhdGUgX3R5cGU6IFRcblxuICAgIGNvbnN0cnVjdG9yKHR5cGU6IFQpIHtcbiAgICAgICAgdGhpcy5faWQgPSB0aGlzLl9nZW5lcmF0ZUlkKClcbiAgICAgICAgdGhpcy5fdHlwZSA9IHR5cGVcbiAgICB9XG5cbiAgICBwcml2YXRlIF9nZW5lcmF0ZUlkKCkge1xuICAgICAgICByZXR1cm4gU3RyaW5nKE1hdGgucmFuZG9tKCkpXG4gICAgfVxuXG4gICAgZ2V0IGlkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faWRcbiAgICB9XG5cbiAgICBnZXQgdHlwZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3R5cGVcbiAgICB9XG59XG4iLCJleHBvcnQgKiBmcm9tICcuL0VudGl0eSdcbiIsImltcG9ydCB7XG4gICAgRW50aXR5SUQsXG4gICAgRW50aXR5VHlwZXMsXG4gICAgSUNvbXBvbmVudCxcbiAgICBJR2FtZU9iamVjdCxcbiAgICBJVHJhbnNmb3JtLFxufSBmcm9tICcuLi8uLi90eXBlcydcbmltcG9ydCB7IEVudGl0eSB9IGZyb20gJy4uL0VudGl0eSdcblxuZXhwb3J0IGNsYXNzIEdhbWVPYmplY3RcbiAgICBleHRlbmRzIEVudGl0eTxFbnRpdHlUeXBlcy5nYW1lT2JqZWN0PlxuICAgIGltcGxlbWVudHMgSUdhbWVPYmplY3RcbntcbiAgICBfbmFtZTogc3RyaW5nXG4gICAgX2NvbXBvbmVudHMgPSBuZXcgTWFwKCkgYXMgTWFwPEVudGl0eUlELCBJQ29tcG9uZW50PEVudGl0eVR5cGVzPj5cbiAgICBfdHJhbnNmb3JtPzogSVRyYW5zZm9ybVxuXG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKEVudGl0eVR5cGVzLmdhbWVPYmplY3QpXG4gICAgICAgIHRoaXMuX25hbWUgPSBgR2FtZU9iamVjdCAke3N1cGVyLmlkfWBcbiAgICB9XG5cbiAgICBnZXQgbmFtZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX25hbWVcbiAgICB9XG5cbiAgICBzZXQgbmFtZSh2YWx1ZTogc3RyaW5nKSB7XG4gICAgICAgIHRoaXMuX25hbWUgPSB2YWx1ZVxuICAgIH1cblxuICAgIGdldCBjb21wb25lbnRzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fY29tcG9uZW50c1xuICAgIH1cblxuICAgIGdldCB0cmFuc2Zvcm0oKSB7XG4gICAgICAgIC8vRklYTUU6IGZpbmQgYSBsZXNzIGR1bWIgd2F5IHRvIGRvIGl0XG4gICAgICAgIGlmICh0aGlzLl90cmFuc2Zvcm0pIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl90cmFuc2Zvcm1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBbLi4udGhpcy5jb21wb25lbnRzLnZhbHVlcygpXS5maW5kKFxuICAgICAgICAgICAgKGNvbXBvbmVudCkgPT4gY29tcG9uZW50LnR5cGUgPT09IEVudGl0eVR5cGVzLnRyYW5zZm9ybVxuICAgICAgICApIGFzIElUcmFuc2Zvcm1cbiAgICB9XG5cbiAgICBwdWJsaWMgYWRkQ29tcG9uZW50KGNvbXBvbmVudDogSUNvbXBvbmVudDxFbnRpdHlUeXBlcz4pIHtcbiAgICAgICAgdGhpcy5fY29tcG9uZW50cy5zZXQoY29tcG9uZW50LmlkLCBjb21wb25lbnQpXG4gICAgfVxuXG4gICAgcHVibGljIHJlbW92ZUNvbXBvbmVudChpZDogRW50aXR5SUQpIHtcbiAgICAgICAgdGhpcy5fY29tcG9uZW50cy5kZWxldGUoaWQpXG4gICAgfVxufVxuIiwiZXhwb3J0ICogZnJvbSAnLi9HYW1lT2JqZWN0J1xuIiwiaW1wb3J0IHsgSUltYWdlU3RvcmFnZSB9IGZyb20gJy4uLy4uL3R5cGVzL2NvcmUvSW1hZ2VTdG9yYWdlJ1xuXG5leHBvcnQgY2xhc3MgSW1hZ2VTdG9yYWdlIGltcGxlbWVudHMgSUltYWdlU3RvcmFnZSB7XG4gICAgcHJpdmF0ZSBfaW1hZ2VzOiBNYXA8c3RyaW5nLCBJbWFnZUJpdG1hcD4gPSBuZXcgTWFwKClcblxuICAgIGdldCBpbWFnZXMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pbWFnZXNcbiAgICB9XG59XG4iLCJleHBvcnQgKiBmcm9tICcuL0ltYWdlU3RvcmFnZSdcbiIsImltcG9ydCB7IElNYXRlcmlhbCB9IGZyb20gJy4uLy4uL3R5cGVzJ1xuaW1wb3J0IHsgSU1hdGVyaWFsU3RvcmFnZSB9IGZyb20gJy4uLy4uL3R5cGVzL2NvcmUvTWF0ZXJpYWxTdG9yYWdlJ1xuXG5leHBvcnQgY2xhc3MgTWF0ZXJpYWxTdG9yYWdlIGltcGxlbWVudHMgSU1hdGVyaWFsU3RvcmFnZSB7XG4gICAgX21hdGVyaWFsczogTWFwPHN0cmluZywgSU1hdGVyaWFsPiA9IG5ldyBNYXAoKVxuXG4gICAgZ2V0IG1hdGVyaWFscygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX21hdGVyaWFsc1xuICAgIH1cbn1cbiIsImV4cG9ydCAqIGZyb20gJy4vTWF0ZXJpYWxTdG9yYWdlJ1xuIiwiaW1wb3J0IHtcbiAgICBFbnRpdHlUeXBlcyxcbiAgICBHTFRGQWNjZXNzb3IsXG4gICAgSUdhbWVPYmplY3QsXG4gICAgSU1hdGVyaWFsLFxuICAgIElNZXNoLFxufSBmcm9tICcuLi8uLi90eXBlcydcbmltcG9ydCB7IElCdWZmZXJTdG9yYWdlIH0gZnJvbSAnLi4vLi4vdHlwZXMvY29yZS9CdWZmZXJTdG9yYWdlJ1xuaW1wb3J0IHsgQ29tcG9uZW50IH0gZnJvbSAnLi4vQ29tcG9uZW50J1xuXG5leHBvcnQgY29uc3QgYWxpZ25UbyA9ICh2YWw6IG51bWJlciwgYWxpZ246IG51bWJlcikgPT4ge1xuICAgIHJldHVybiBNYXRoLmZsb29yKCh2YWwgKyBhbGlnbiAtIDEpIC8gYWxpZ24pICogYWxpZ25cbn1cblxuZXhwb3J0IGNsYXNzIE1lc2ggZXh0ZW5kcyBDb21wb25lbnQ8RW50aXR5VHlwZXMubWVzaD4gaW1wbGVtZW50cyBJTWVzaCB7XG4gICAgbW9kZSA9IDQgLy8gR1BVIHRvcG9sb2d5IG1vZGVcbiAgICBwb3NpdGlvbnM6IEdMVEZBY2Nlc3NvclxuICAgIGluZGljZXM/OiBHTFRGQWNjZXNzb3JcbiAgICB0ZXh0dXJlQ29vcmRpbmF0ZXM/OiBHTFRGQWNjZXNzb3JcbiAgICBub3JtYWxzPzogR0xURkFjY2Vzc29yXG4gICAgcmVuZGVyUGlwZWxpbmU/OiBHUFVSZW5kZXJQaXBlbGluZVxuICAgIG5vZGVQYXJhbXNCaW5kR3JvdXA/OiBHUFVCaW5kR3JvdXBcbiAgICBtYXRlcmlhbD86IElNYXRlcmlhbFxuICAgIHByaXZhdGUgcG9zaXRpb25zQnVmZmVyPzogR1BVQnVmZmVyXG4gICAgcHJpdmF0ZSBpbmRpY2VzQnVmZmVyPzogR1BVQnVmZmVyXG4gICAgcHJpdmF0ZSB0ZXh0dXJlQ29vcmRpbmF0ZXNCdWZmZXI/OiBHUFVCdWZmZXJcbiAgICBwcml2YXRlIG5vcm1hbHNCdWZmZXI/OiBHUFVCdWZmZXJcbiAgICBwcml2YXRlIG1hdGVyaWFsUGFyYW1zQnVmZmVyPzogR1BVQnVmZmVyXG4gICAgcHJpdmF0ZSBtYXRlcmlhbEJpbmRHcm91cD86IEdQVUJpbmRHcm91cFxuICAgIHByaXZhdGUgc2FtcGxlckJpbmRHcm91cD86IEdQVUJpbmRHcm91cFxuXG4gICAgY29uc3RydWN0b3IoXG4gICAgICAgIHBhcmVudDogSUdhbWVPYmplY3QsXG4gICAgICAgIHBvc2l0aW9uczogR0xURkFjY2Vzc29yLFxuICAgICAgICBpbmRpY2VzPzogR0xURkFjY2Vzc29yLFxuICAgICAgICBub3JtYWxzPzogR0xURkFjY2Vzc29yLFxuICAgICAgICB0ZXh0dXJlQ29vcmRpbmF0ZXM/OiBHTFRGQWNjZXNzb3IsXG4gICAgICAgIG1hdGVyaWFsPzogSU1hdGVyaWFsXG4gICAgKSB7XG4gICAgICAgIHN1cGVyKHBhcmVudCwgRW50aXR5VHlwZXMubWVzaClcblxuICAgICAgICB0aGlzLnBvc2l0aW9ucyA9IHBvc2l0aW9uc1xuICAgICAgICB0aGlzLmluZGljZXMgPSBpbmRpY2VzXG4gICAgICAgIHRoaXMudGV4dHVyZUNvb3JkaW5hdGVzID0gdGV4dHVyZUNvb3JkaW5hdGVzXG4gICAgICAgIHRoaXMubWF0ZXJpYWwgPSBtYXRlcmlhbFxuICAgICAgICB0aGlzLm5vcm1hbHMgPSBub3JtYWxzXG4gICAgfVxuXG4gICAgcHVibGljIGJ1aWxkUmVuZGVyUGlwZWxpbmUoXG4gICAgICAgIGRldmljZTogR1BVRGV2aWNlLFxuICAgICAgICBzaGFkZXJNb2R1bGU6IEdQVVNoYWRlck1vZHVsZSxcbiAgICAgICAgY29sb3JGb3JtYXQ6IEdQVVRleHR1cmVGb3JtYXQsXG4gICAgICAgIGRlcHRoRm9ybWF0OiBHUFVUZXh0dXJlRm9ybWF0LFxuICAgICAgICBtc2FhU2FtcGxlQ291bnQ6IG51bWJlciB8IHVuZGVmaW5lZCxcbiAgICAgICAgdW5pZm9ybXNCR0xheW91dDogR1BVQmluZEdyb3VwTGF5b3V0LFxuICAgICAgICBub2RlUGFyYW1zQkdMYXlvdXQ6IEdQVUJpbmRHcm91cExheW91dCxcbiAgICAgICAgYnVmZmVyU3RvcmFnZTogSUJ1ZmZlclN0b3JhZ2VcbiAgICApIHtcbiAgICAgICAgLy9GSVhNRTogUkVGQUNUT1IgVEhJUyBTSElUXG4gICAgICAgIHRoaXMubWF0ZXJpYWxQYXJhbXNCdWZmZXIgPSBkZXZpY2UuY3JlYXRlQnVmZmVyKHtcbiAgICAgICAgICAgIHNpemU6IDggKiA0LFxuICAgICAgICAgICAgdXNhZ2U6IEdQVUJ1ZmZlclVzYWdlLkNPUFlfRFNUIHwgR1BVQnVmZmVyVXNhZ2UuVU5JRk9STSxcbiAgICAgICAgICAgIG1hcHBlZEF0Q3JlYXRpb246IHRydWUsXG4gICAgICAgIH0pXG5cbiAgICAgICAgaWYgKHRoaXMubWF0ZXJpYWwpIHtcbiAgICAgICAgICAgIGNvbnN0IHBhcmFtcyA9IG5ldyBGbG9hdDMyQXJyYXkoXG4gICAgICAgICAgICAgICAgdGhpcy5tYXRlcmlhbFBhcmFtc0J1ZmZlci5nZXRNYXBwZWRSYW5nZSgpXG4gICAgICAgICAgICApXG4gICAgICAgICAgICBwYXJhbXMuc2V0KHRoaXMubWF0ZXJpYWwuYmFzZUNvbG9yRmFjdG9yLCAwKVxuICAgICAgICAgICAgcGFyYW1zLnNldChcbiAgICAgICAgICAgICAgICBbdGhpcy5tYXRlcmlhbC5tZXRhbGxpY0ZhY3RvciwgdGhpcy5tYXRlcmlhbC5yb3VnaG5lc3NGYWN0b3JdLFxuICAgICAgICAgICAgICAgIDRcbiAgICAgICAgICAgIClcblxuICAgICAgICAgICAgdGhpcy5tYXRlcmlhbFBhcmFtc0J1ZmZlci51bm1hcCgpXG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBzYW1wbGVUeXBlID0gJ2Zsb2F0J1xuXG4gICAgICAgIGxldCBtYXRlcmlhbEJpbmRHcm91cExheW91dEVudHJpZXM6IEdQVUJpbmRHcm91cExheW91dEVudHJ5W10gPSBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgYmluZGluZzogMCxcbiAgICAgICAgICAgICAgICB2aXNpYmlsaXR5OiBHUFVTaGFkZXJTdGFnZS5GUkFHTUVOVCxcbiAgICAgICAgICAgICAgICBidWZmZXI6IHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogJ3VuaWZvcm0nLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9LFxuICAgICAgICBdXG5cbiAgICAgICAgbGV0IHNhbXBsZXJCaW5kR3JvdXBMYXlvdXRFbnRyaWVzOiBHUFVCaW5kR3JvdXBMYXlvdXRFbnRyeVtdID0gW11cblxuICAgICAgICBsZXQgc2FtcGxlckJpbmRHcm91cEVudHJpZXM6IEdQVUJpbmRHcm91cEVudHJ5W10gPSBbXVxuXG4gICAgICAgIGxldCBtYXRlcmlhbEJpbmRHcm91cEVudHJpZXM6IEdQVUJpbmRHcm91cEVudHJ5W10gPSBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgYmluZGluZzogMCxcbiAgICAgICAgICAgICAgICByZXNvdXJjZToge1xuICAgICAgICAgICAgICAgICAgICBidWZmZXI6IHRoaXMubWF0ZXJpYWxQYXJhbXNCdWZmZXIsXG4gICAgICAgICAgICAgICAgICAgIHNpemU6IDggKiA0LFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9LFxuICAgICAgICBdXG5cbiAgICAgICAgLy8gSWYgd2UgaGF2ZSBhIGJhc2UgY29sb3IgdGV4dHVyZSwgYWRkIHRoZSBzYW1wbGVyIGFuZCB0ZXh0dXJlIGJpbmRpbmdzXG4gICAgICAgIGlmICh0aGlzLm1hdGVyaWFsPy5iYXNlQ29sb3JUZXh0dXJlKSB7XG4gICAgICAgICAgICBzYW1wbGVyQmluZEdyb3VwTGF5b3V0RW50cmllcy5wdXNoKHtcbiAgICAgICAgICAgICAgICBiaW5kaW5nOiAxLFxuICAgICAgICAgICAgICAgIHZpc2liaWxpdHk6IEdQVVNoYWRlclN0YWdlLkZSQUdNRU5ULFxuICAgICAgICAgICAgICAgIHNhbXBsZXI6IHt9LFxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIG1hdGVyaWFsQmluZEdyb3VwTGF5b3V0RW50cmllcy5wdXNoKHtcbiAgICAgICAgICAgICAgICBiaW5kaW5nOiAxLFxuICAgICAgICAgICAgICAgIHZpc2liaWxpdHk6IEdQVVNoYWRlclN0YWdlLkZSQUdNRU5ULFxuICAgICAgICAgICAgICAgIHRleHR1cmU6IHtcbiAgICAgICAgICAgICAgICAgICAgc2FtcGxlVHlwZSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSlcblxuICAgICAgICAgICAgc2FtcGxlckJpbmRHcm91cEVudHJpZXMucHVzaCh7XG4gICAgICAgICAgICAgICAgYmluZGluZzogMSxcbiAgICAgICAgICAgICAgICByZXNvdXJjZTogdGhpcy5tYXRlcmlhbC5iYXNlQ29sb3JUZXh0dXJlLnNhbXBsZXIsXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgbWF0ZXJpYWxCaW5kR3JvdXBFbnRyaWVzLnB1c2goe1xuICAgICAgICAgICAgICAgIGJpbmRpbmc6IDEsXG4gICAgICAgICAgICAgICAgcmVzb3VyY2U6IHRoaXMubWF0ZXJpYWwuYmFzZUNvbG9yVGV4dHVyZS52aWV3LFxuICAgICAgICAgICAgfSlcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLm1hdGVyaWFsPy5tZXRhbGxpY1JvdWdobmVzc1RleHR1cmUpIHtcbiAgICAgICAgICAgIHNhbXBsZXJCaW5kR3JvdXBMYXlvdXRFbnRyaWVzLnB1c2goe1xuICAgICAgICAgICAgICAgIGJpbmRpbmc6IDIsXG4gICAgICAgICAgICAgICAgdmlzaWJpbGl0eTogR1BVU2hhZGVyU3RhZ2UuRlJBR01FTlQsXG4gICAgICAgICAgICAgICAgc2FtcGxlcjoge30sXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgbWF0ZXJpYWxCaW5kR3JvdXBMYXlvdXRFbnRyaWVzLnB1c2goe1xuICAgICAgICAgICAgICAgIGJpbmRpbmc6IDIsXG4gICAgICAgICAgICAgICAgdmlzaWJpbGl0eTogR1BVU2hhZGVyU3RhZ2UuRlJBR01FTlQsXG4gICAgICAgICAgICAgICAgdGV4dHVyZToge1xuICAgICAgICAgICAgICAgICAgICBzYW1wbGVUeXBlLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9KVxuXG4gICAgICAgICAgICBzYW1wbGVyQmluZEdyb3VwRW50cmllcy5wdXNoKHtcbiAgICAgICAgICAgICAgICBiaW5kaW5nOiAyLFxuICAgICAgICAgICAgICAgIHJlc291cmNlOiB0aGlzLm1hdGVyaWFsPy5tZXRhbGxpY1JvdWdobmVzc1RleHR1cmUuc2FtcGxlcixcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICBtYXRlcmlhbEJpbmRHcm91cEVudHJpZXMucHVzaCh7XG4gICAgICAgICAgICAgICAgYmluZGluZzogMixcbiAgICAgICAgICAgICAgICByZXNvdXJjZTogdGhpcy5tYXRlcmlhbD8ubWV0YWxsaWNSb3VnaG5lc3NUZXh0dXJlLnZpZXcsXG4gICAgICAgICAgICB9KVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMubWF0ZXJpYWw/Lm5vcm1hbFRleHR1cmUpIHtcbiAgICAgICAgICAgIHNhbXBsZXJCaW5kR3JvdXBMYXlvdXRFbnRyaWVzLnB1c2goe1xuICAgICAgICAgICAgICAgIGJpbmRpbmc6IDMsXG4gICAgICAgICAgICAgICAgdmlzaWJpbGl0eTogR1BVU2hhZGVyU3RhZ2UuRlJBR01FTlQsXG4gICAgICAgICAgICAgICAgc2FtcGxlcjoge30sXG4gICAgICAgICAgICB9KVxuXG4gICAgICAgICAgICBtYXRlcmlhbEJpbmRHcm91cExheW91dEVudHJpZXMucHVzaCh7XG4gICAgICAgICAgICAgICAgYmluZGluZzogMyxcbiAgICAgICAgICAgICAgICB2aXNpYmlsaXR5OiBHUFVTaGFkZXJTdGFnZS5GUkFHTUVOVCxcbiAgICAgICAgICAgICAgICB0ZXh0dXJlOiB7XG4gICAgICAgICAgICAgICAgICAgIHNhbXBsZVR5cGUsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0pXG5cbiAgICAgICAgICAgIHNhbXBsZXJCaW5kR3JvdXBFbnRyaWVzLnB1c2goe1xuICAgICAgICAgICAgICAgIGJpbmRpbmc6IDMsXG4gICAgICAgICAgICAgICAgcmVzb3VyY2U6IHRoaXMubWF0ZXJpYWw/Lm5vcm1hbFRleHR1cmUuc2FtcGxlcixcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICBtYXRlcmlhbEJpbmRHcm91cEVudHJpZXMucHVzaCh7XG4gICAgICAgICAgICAgICAgYmluZGluZzogMyxcbiAgICAgICAgICAgICAgICByZXNvdXJjZTogdGhpcy5tYXRlcmlhbD8ubm9ybWFsVGV4dHVyZS52aWV3LFxuICAgICAgICAgICAgfSlcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHZlcnRleFN0YXRlOiBHUFVWZXJ0ZXhTdGF0ZSA9IHtcbiAgICAgICAgICAgIG1vZHVsZTogc2hhZGVyTW9kdWxlLFxuICAgICAgICAgICAgZW50cnlQb2ludDogJ3ZlcnRleF9tYWluJyxcbiAgICAgICAgICAgIGJ1ZmZlcnM6IFtcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGFycmF5U3RyaWRlOiB0aGlzLnBvc2l0aW9ucy5ieXRlU3RyaWRlLFxuICAgICAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9ybWF0OiB0aGlzLnBvc2l0aW9ucy5lbGVtZW50VHlwZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvZmZzZXQ6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2hhZGVyTG9jYXRpb246IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBdLFxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMudGV4dHVyZUNvb3JkaW5hdGVzKSB7XG4gICAgICAgICAgICA7KHZlcnRleFN0YXRlLmJ1ZmZlcnMgYXMgR1BVVmVydGV4QnVmZmVyTGF5b3V0W10pLnB1c2goe1xuICAgICAgICAgICAgICAgIGFycmF5U3RyaWRlOiB0aGlzLnRleHR1cmVDb29yZGluYXRlcy5ieXRlU3RyaWRlLFxuICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXM6IFtcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9ybWF0OiB0aGlzLnRleHR1cmVDb29yZGluYXRlcy5lbGVtZW50VHlwZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG9mZnNldDogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNoYWRlckxvY2F0aW9uOiAxLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICB9KVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMubm9ybWFscykge1xuICAgICAgICAgICAgOyh2ZXJ0ZXhTdGF0ZS5idWZmZXJzIGFzIEdQVVZlcnRleEJ1ZmZlckxheW91dFtdKS5wdXNoKHtcbiAgICAgICAgICAgICAgICBhcnJheVN0cmlkZTogdGhpcy5ub3JtYWxzLmJ5dGVTdHJpZGUsXG4gICAgICAgICAgICAgICAgYXR0cmlidXRlczogW1xuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3JtYXQ6IHRoaXMubm9ybWFscy5lbGVtZW50VHlwZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG9mZnNldDogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNoYWRlckxvY2F0aW9uOiAyLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICB9KVxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgZnJhZ21lbnRTdGF0ZTogR1BVRnJhZ21lbnRTdGF0ZSA9IHtcbiAgICAgICAgICAgIG1vZHVsZTogc2hhZGVyTW9kdWxlLFxuICAgICAgICAgICAgZW50cnlQb2ludDogJ2ZyYWdtZW50X21haW4nLFxuICAgICAgICAgICAgdGFyZ2V0czogW3sgZm9ybWF0OiBjb2xvckZvcm1hdCB9XSxcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHByaW1pdGl2ZTogR1BVUHJpbWl0aXZlU3RhdGUgPSB7XG4gICAgICAgICAgICB0b3BvbG9neTogJ3RyaWFuZ2xlLWxpc3QnLFxuICAgICAgICAgICAgc3RyaXBJbmRleEZvcm1hdDogdW5kZWZpbmVkLFxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMubW9kZSA9PT0gNSkge1xuICAgICAgICAgICAgcHJpbWl0aXZlLnRvcG9sb2d5ID0gJ3RyaWFuZ2xlLXN0cmlwJ1xuICAgICAgICAgICAgcHJpbWl0aXZlLnN0cmlwSW5kZXhGb3JtYXQgPSB0aGlzPy5pbmRpY2VzXG4gICAgICAgICAgICAgICAgPy5lbGVtZW50VHlwZSBhcyBHUFVJbmRleEZvcm1hdFxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3Qgc2FtcGxlckJpbmRHcm91cExheW91dCA9IGRldmljZS5jcmVhdGVCaW5kR3JvdXBMYXlvdXQoe1xuICAgICAgICAgICAgZW50cmllczogc2FtcGxlckJpbmRHcm91cExheW91dEVudHJpZXMsXG4gICAgICAgICAgICBsYWJlbDogJ3NhbXBsZXJCaW5kR3JvdXBMYXlvdXQnLFxuICAgICAgICB9KVxuXG4gICAgICAgIGNvbnN0IG1hdGVyaWFsQmluZEdyb3VwTGF5b3V0ID0gZGV2aWNlLmNyZWF0ZUJpbmRHcm91cExheW91dCh7XG4gICAgICAgICAgICBlbnRyaWVzOiBtYXRlcmlhbEJpbmRHcm91cExheW91dEVudHJpZXMsXG4gICAgICAgICAgICBsYWJlbDogJ21hdGVyaWFsQmluZEdyb3VwTGF5b3V0JyxcbiAgICAgICAgfSlcblxuICAgICAgICB0aGlzLnNhbXBsZXJCaW5kR3JvdXAgPSBkZXZpY2UuY3JlYXRlQmluZEdyb3VwKHtcbiAgICAgICAgICAgIGxheW91dDogc2FtcGxlckJpbmRHcm91cExheW91dCxcbiAgICAgICAgICAgIGVudHJpZXM6IHNhbXBsZXJCaW5kR3JvdXBFbnRyaWVzLFxuICAgICAgICB9KVxuXG4gICAgICAgIHRoaXMubWF0ZXJpYWxCaW5kR3JvdXAgPSBkZXZpY2UuY3JlYXRlQmluZEdyb3VwKHtcbiAgICAgICAgICAgIGxheW91dDogbWF0ZXJpYWxCaW5kR3JvdXBMYXlvdXQsXG4gICAgICAgICAgICBlbnRyaWVzOiBtYXRlcmlhbEJpbmRHcm91cEVudHJpZXMsXG4gICAgICAgIH0pXG5cbiAgICAgICAgY29uc3QgbGF5b3V0ID0gZGV2aWNlLmNyZWF0ZVBpcGVsaW5lTGF5b3V0KHtcbiAgICAgICAgICAgIGJpbmRHcm91cExheW91dHM6IFtcbiAgICAgICAgICAgICAgICB1bmlmb3Jtc0JHTGF5b3V0LFxuICAgICAgICAgICAgICAgIG5vZGVQYXJhbXNCR0xheW91dCxcbiAgICAgICAgICAgICAgICBtYXRlcmlhbEJpbmRHcm91cExheW91dCxcbiAgICAgICAgICAgICAgICBzYW1wbGVyQmluZEdyb3VwTGF5b3V0LFxuICAgICAgICAgICAgXSxcbiAgICAgICAgfSlcblxuICAgICAgICB0aGlzLnJlbmRlclBpcGVsaW5lID0gZGV2aWNlLmNyZWF0ZVJlbmRlclBpcGVsaW5lKHtcbiAgICAgICAgICAgIGxheW91dDogbGF5b3V0LFxuICAgICAgICAgICAgdmVydGV4OiB2ZXJ0ZXhTdGF0ZSxcbiAgICAgICAgICAgIGZyYWdtZW50OiBmcmFnbWVudFN0YXRlLFxuICAgICAgICAgICAgcHJpbWl0aXZlOiBwcmltaXRpdmUsXG4gICAgICAgICAgICBkZXB0aFN0ZW5jaWw6IHtcbiAgICAgICAgICAgICAgICBmb3JtYXQ6IGRlcHRoRm9ybWF0LFxuICAgICAgICAgICAgICAgIGRlcHRoV3JpdGVFbmFibGVkOiB0cnVlLFxuICAgICAgICAgICAgICAgIGRlcHRoQ29tcGFyZTogJ2xlc3MnLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG11bHRpc2FtcGxlOiB7XG4gICAgICAgICAgICAgICAgY291bnQ6IG1zYWFTYW1wbGVDb3VudCxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pXG5cbiAgICAgICAgY29uc3QgcG9zaXRpb25zVmlldyA9IG5ldyBVaW50OEFycmF5KFxuICAgICAgICAgICAgYnVmZmVyU3RvcmFnZS5idWZmZXJzLmdldCh0aGlzLnBvc2l0aW9ucy5idWZmZXJJZCkgYXMgQXJyYXlCdWZmZXIsXG4gICAgICAgICAgICB0aGlzLnBvc2l0aW9ucy5ieXRlT2Zmc2V0LFxuICAgICAgICAgICAgdGhpcy5wb3NpdGlvbnMuYnl0ZUxlbmd0aFxuICAgICAgICApXG5cbiAgICAgICAgdGhpcy5wb3NpdGlvbnNCdWZmZXIgPSBkZXZpY2UuY3JlYXRlQnVmZmVyKHtcbiAgICAgICAgICAgIHNpemU6IGFsaWduVG8odGhpcy5wb3NpdGlvbnMuYnl0ZUxlbmd0aCwgNCksXG4gICAgICAgICAgICB1c2FnZTogdGhpcy5wb3NpdGlvbnMudXNhZ2UsXG4gICAgICAgICAgICBtYXBwZWRBdENyZWF0aW9uOiB0cnVlLFxuICAgICAgICB9KVxuXG4gICAgICAgIG5ldyBVaW50OEFycmF5KHRoaXMucG9zaXRpb25zQnVmZmVyLmdldE1hcHBlZFJhbmdlKCkpLnNldChwb3NpdGlvbnNWaWV3KVxuICAgICAgICB0aGlzLnBvc2l0aW9uc0J1ZmZlci51bm1hcCgpXG5cbiAgICAgICAgaWYgKHRoaXMudGV4dHVyZUNvb3JkaW5hdGVzKSB7XG4gICAgICAgICAgICBjb25zdCB0ZXh0dXJlQ29vcmRpbmF0ZXNCdWZmZXIgPSBidWZmZXJTdG9yYWdlLmJ1ZmZlcnMuZ2V0KFxuICAgICAgICAgICAgICAgIHRoaXM/LnRleHR1cmVDb29yZGluYXRlcy5idWZmZXJJZFxuICAgICAgICAgICAgKVxuXG4gICAgICAgICAgICBjb25zdCB0ZXh0dXJlQ29vcmRpbmF0ZXNWaWV3ID0gbmV3IFVpbnQ4QXJyYXkoXG4gICAgICAgICAgICAgICAgdGV4dHVyZUNvb3JkaW5hdGVzQnVmZmVyIGFzIEFycmF5QnVmZmVyLFxuICAgICAgICAgICAgICAgIHRoaXMudGV4dHVyZUNvb3JkaW5hdGVzLmJ5dGVPZmZzZXQsXG4gICAgICAgICAgICAgICAgdGhpcy50ZXh0dXJlQ29vcmRpbmF0ZXMuYnl0ZUxlbmd0aFxuICAgICAgICAgICAgKVxuXG4gICAgICAgICAgICB0aGlzLnRleHR1cmVDb29yZGluYXRlc0J1ZmZlciA9IGRldmljZS5jcmVhdGVCdWZmZXIoe1xuICAgICAgICAgICAgICAgIHNpemU6IGFsaWduVG8odGhpcy50ZXh0dXJlQ29vcmRpbmF0ZXMuYnl0ZUxlbmd0aCwgNCksXG4gICAgICAgICAgICAgICAgdXNhZ2U6IHRoaXMudGV4dHVyZUNvb3JkaW5hdGVzLnVzYWdlLFxuICAgICAgICAgICAgICAgIG1hcHBlZEF0Q3JlYXRpb246IHRydWUsXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgbmV3IFVpbnQ4QXJyYXkodGhpcy50ZXh0dXJlQ29vcmRpbmF0ZXNCdWZmZXIuZ2V0TWFwcGVkUmFuZ2UoKSkuc2V0KFxuICAgICAgICAgICAgICAgIHRleHR1cmVDb29yZGluYXRlc1ZpZXdcbiAgICAgICAgICAgIClcbiAgICAgICAgICAgIHRoaXMudGV4dHVyZUNvb3JkaW5hdGVzQnVmZmVyLnVubWFwKClcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLm5vcm1hbHMpIHtcbiAgICAgICAgICAgIGNvbnN0IG5vcm1hbHNCdWZmZXIgPSBidWZmZXJTdG9yYWdlLmJ1ZmZlcnMuZ2V0KFxuICAgICAgICAgICAgICAgIHRoaXM/Lm5vcm1hbHMuYnVmZmVySWRcbiAgICAgICAgICAgIClcblxuICAgICAgICAgICAgY29uc3Qgbm9ybWFsc1ZpZXcgPSBuZXcgVWludDhBcnJheShcbiAgICAgICAgICAgICAgICBub3JtYWxzQnVmZmVyIGFzIEFycmF5QnVmZmVyLFxuICAgICAgICAgICAgICAgIHRoaXMubm9ybWFscy5ieXRlT2Zmc2V0LFxuICAgICAgICAgICAgICAgIHRoaXMubm9ybWFscy5ieXRlTGVuZ3RoXG4gICAgICAgICAgICApXG5cbiAgICAgICAgICAgIHRoaXMubm9ybWFsc0J1ZmZlciA9IGRldmljZS5jcmVhdGVCdWZmZXIoe1xuICAgICAgICAgICAgICAgIHNpemU6IGFsaWduVG8odGhpcy5ub3JtYWxzLmJ5dGVMZW5ndGgsIDQpLFxuICAgICAgICAgICAgICAgIHVzYWdlOiB0aGlzLm5vcm1hbHMudXNhZ2UsXG4gICAgICAgICAgICAgICAgbWFwcGVkQXRDcmVhdGlvbjogdHJ1ZSxcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICBuZXcgVWludDhBcnJheSh0aGlzLm5vcm1hbHNCdWZmZXIuZ2V0TWFwcGVkUmFuZ2UoKSkuc2V0KG5vcm1hbHNWaWV3KVxuICAgICAgICAgICAgdGhpcy5ub3JtYWxzQnVmZmVyLnVubWFwKClcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLmluZGljZXMpIHtcbiAgICAgICAgICAgIGNvbnN0IGluZGljZXNCdWZmZXIgPSBidWZmZXJTdG9yYWdlLmJ1ZmZlcnMuZ2V0KFxuICAgICAgICAgICAgICAgIHRoaXM/LmluZGljZXMuYnVmZmVySWRcbiAgICAgICAgICAgIClcblxuICAgICAgICAgICAgY29uc3QgaW5kaWNlc1ZpZXcgPSBuZXcgVWludDhBcnJheShcbiAgICAgICAgICAgICAgICBpbmRpY2VzQnVmZmVyIGFzIEFycmF5QnVmZmVyLFxuICAgICAgICAgICAgICAgIHRoaXMuaW5kaWNlcy5ieXRlT2Zmc2V0LFxuICAgICAgICAgICAgICAgIHRoaXMuaW5kaWNlcy5ieXRlTGVuZ3RoXG4gICAgICAgICAgICApXG4gICAgICAgICAgICB0aGlzLmluZGljZXNCdWZmZXIgPSBkZXZpY2UuY3JlYXRlQnVmZmVyKHtcbiAgICAgICAgICAgICAgICBzaXplOiBhbGlnblRvKHRoaXMuaW5kaWNlcy5ieXRlTGVuZ3RoLCA0KSxcbiAgICAgICAgICAgICAgICB1c2FnZTogdGhpcy5pbmRpY2VzLnVzYWdlLFxuICAgICAgICAgICAgICAgIG1hcHBlZEF0Q3JlYXRpb246IHRydWUsXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgbmV3IFVpbnQ4QXJyYXkodGhpcy5pbmRpY2VzQnVmZmVyLmdldE1hcHBlZFJhbmdlKCkpLnNldChpbmRpY2VzVmlldylcbiAgICAgICAgICAgIHRoaXMuaW5kaWNlc0J1ZmZlci51bm1hcCgpXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZW5kZXIocmVuZGVyUGFzc0VuY29kZXI6IEdQVVJlbmRlclBhc3NFbmNvZGVyKSB7XG4gICAgICAgIHJlbmRlclBhc3NFbmNvZGVyLnNldFBpcGVsaW5lKHRoaXMucmVuZGVyUGlwZWxpbmUgYXMgR1BVUmVuZGVyUGlwZWxpbmUpXG5cbiAgICAgICAgaWYgKHRoaXMubWF0ZXJpYWxCaW5kR3JvdXApIHtcbiAgICAgICAgICAgIHJlbmRlclBhc3NFbmNvZGVyLnNldEJpbmRHcm91cCgyLCB0aGlzLm1hdGVyaWFsQmluZEdyb3VwKVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuc2FtcGxlckJpbmRHcm91cCkge1xuICAgICAgICAgICAgcmVuZGVyUGFzc0VuY29kZXIuc2V0QmluZEdyb3VwKDMsIHRoaXMuc2FtcGxlckJpbmRHcm91cClcbiAgICAgICAgfVxuXG4gICAgICAgIHJlbmRlclBhc3NFbmNvZGVyLnNldFZlcnRleEJ1ZmZlcihcbiAgICAgICAgICAgIDAsXG4gICAgICAgICAgICB0aGlzLnBvc2l0aW9uc0J1ZmZlciBhcyBHUFVCdWZmZXIsXG4gICAgICAgICAgICAwLFxuICAgICAgICAgICAgdGhpcy5wb3NpdGlvbnMuYnl0ZUxlbmd0aFxuICAgICAgICApXG5cbiAgICAgICAgaWYgKHRoaXMudGV4dHVyZUNvb3JkaW5hdGVzKSB7XG4gICAgICAgICAgICByZW5kZXJQYXNzRW5jb2Rlci5zZXRWZXJ0ZXhCdWZmZXIoXG4gICAgICAgICAgICAgICAgMSxcbiAgICAgICAgICAgICAgICB0aGlzLnRleHR1cmVDb29yZGluYXRlc0J1ZmZlciBhcyBHUFVCdWZmZXIsXG4gICAgICAgICAgICAgICAgMCxcbiAgICAgICAgICAgICAgICB0aGlzLnRleHR1cmVDb29yZGluYXRlcy5ieXRlTGVuZ3RoXG4gICAgICAgICAgICApXG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5ub3JtYWxzKSB7XG4gICAgICAgICAgICByZW5kZXJQYXNzRW5jb2Rlci5zZXRWZXJ0ZXhCdWZmZXIoXG4gICAgICAgICAgICAgICAgMixcbiAgICAgICAgICAgICAgICB0aGlzLm5vcm1hbHNCdWZmZXIgYXMgR1BVQnVmZmVyLFxuICAgICAgICAgICAgICAgIDAsXG4gICAgICAgICAgICAgICAgdGhpcy5ub3JtYWxzLmJ5dGVMZW5ndGhcbiAgICAgICAgICAgIClcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLmluZGljZXMpIHtcbiAgICAgICAgICAgIHJlbmRlclBhc3NFbmNvZGVyLnNldEluZGV4QnVmZmVyKFxuICAgICAgICAgICAgICAgIHRoaXMuaW5kaWNlc0J1ZmZlciBhcyBHUFVCdWZmZXIsXG4gICAgICAgICAgICAgICAgdGhpcy5pbmRpY2VzLmVsZW1lbnRUeXBlIGFzIEdQVUluZGV4Rm9ybWF0LFxuICAgICAgICAgICAgICAgIDAsXG4gICAgICAgICAgICAgICAgdGhpcy5pbmRpY2VzLmJ5dGVMZW5ndGhcbiAgICAgICAgICAgIClcbiAgICAgICAgICAgIHJlbmRlclBhc3NFbmNvZGVyLmRyYXdJbmRleGVkKHRoaXMuaW5kaWNlcy5jb3VudClcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlbmRlclBhc3NFbmNvZGVyLmRyYXcodGhpcy5wb3NpdGlvbnMuY291bnQpXG4gICAgICAgIH1cbiAgICB9XG59XG4iLCJleHBvcnQgKiBmcm9tICcuL01lc2gnXG4iLCJpbXBvcnQgeyB2ZWMzLCB2ZWM0IH0gZnJvbSAnd2dwdS1tYXRyaXgnXG5pbXBvcnQge1xuICAgIEdMVEZBY2Nlc3NvcixcbiAgICBHTFRGVGV4dHVyZUZpbHRlcixcbiAgICBHTFRGVGV4dHVyZVdyYXAsXG4gICAgSUJ1ZmZlclN0b3JhZ2UsXG4gICAgSUdhbWVPYmplY3QsXG4gICAgSUltYWdlU3RvcmFnZSxcbiAgICBJTWF0ZXJpYWwsXG4gICAgSU1vZGVsUHJlbG9hZERhdGEsXG4gICAgSU9iamVjdE1hbmFnZXIsXG4gICAgSVByZWxvYWRFbnRpdHksXG4gICAgSVNhbXBsZXJTdG9yYWdlLFxuICAgIElUZXh0dXJlLFxuICAgIElUZXh0dXJlU3RvcmFnZSxcbn0gZnJvbSAnLi4vLi4vdHlwZXMnXG5pbXBvcnQgeyBJTWF0ZXJpYWxTdG9yYWdlIH0gZnJvbSAnLi4vLi4vdHlwZXMvY29yZS9NYXRlcmlhbFN0b3JhZ2UnXG5pbXBvcnQgeyBHYW1lT2JqZWN0IH0gZnJvbSAnLi4vR2FtZU9iamVjdCdcbmltcG9ydCB7IE1lc2ggfSBmcm9tICcuLi9NZXNoJ1xuaW1wb3J0IHsgVHJhbnNmb3JtIH0gZnJvbSAnLi4vVHJhbnNmb3JtJ1xuXG5leHBvcnQgY2xhc3MgTW9kZWxVcGxvYWRlciB7XG4gICAgcHJpdmF0ZSBzdGF0aWMgZ2V0VGV4dHVyZUZpbHRlck1vZGUoZmlsdGVyPzogR0xURlRleHR1cmVGaWx0ZXIpIHtcbiAgICAgICAgc3dpdGNoIChmaWx0ZXIpIHtcbiAgICAgICAgICAgIGNhc2UgR0xURlRleHR1cmVGaWx0ZXIuTkVBUkVTVF9NSVBNQVBfTkVBUkVTVDpcbiAgICAgICAgICAgIGNhc2UgR0xURlRleHR1cmVGaWx0ZXIuTkVBUkVTVF9NSVBNQVBfTElORUFSOlxuICAgICAgICAgICAgY2FzZSBHTFRGVGV4dHVyZUZpbHRlci5ORUFSRVNUOlxuICAgICAgICAgICAgICAgIHJldHVybiAnbmVhcmVzdCcgYXMgR1BVRmlsdGVyTW9kZVxuICAgICAgICAgICAgY2FzZSBHTFRGVGV4dHVyZUZpbHRlci5MSU5FQVJfTUlQTUFQX05FQVJFU1Q6XG4gICAgICAgICAgICBjYXNlIEdMVEZUZXh0dXJlRmlsdGVyLkxJTkVBUl9NSVBNQVBfTElORUFSOlxuICAgICAgICAgICAgY2FzZSBHTFRGVGV4dHVyZUZpbHRlci5MSU5FQVI6XG4gICAgICAgICAgICAgICAgcmV0dXJuICdsaW5lYXInIGFzIEdQVUZpbHRlck1vZGVcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuICdsaW5lYXInXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwcml2YXRlIHN0YXRpYyBnZXRUZXh0dXJlTWlwTWFwTW9kZShmaWx0ZXI6IEdMVEZUZXh0dXJlRmlsdGVyKSB7XG4gICAgICAgIHN3aXRjaCAoZmlsdGVyKSB7XG4gICAgICAgICAgICBjYXNlIEdMVEZUZXh0dXJlRmlsdGVyLk5FQVJFU1RfTUlQTUFQX05FQVJFU1Q6XG4gICAgICAgICAgICBjYXNlIEdMVEZUZXh0dXJlRmlsdGVyLkxJTkVBUl9NSVBNQVBfTkVBUkVTVDpcbiAgICAgICAgICAgIGNhc2UgR0xURlRleHR1cmVGaWx0ZXIuTkVBUkVTVDpcbiAgICAgICAgICAgICAgICByZXR1cm4gJ25lYXJlc3QnIGFzIEdQVU1pcG1hcEZpbHRlck1vZGVcbiAgICAgICAgICAgIGNhc2UgR0xURlRleHR1cmVGaWx0ZXIuTElORUFSX01JUE1BUF9MSU5FQVI6XG4gICAgICAgICAgICBjYXNlIEdMVEZUZXh0dXJlRmlsdGVyLk5FQVJFU1RfTUlQTUFQX0xJTkVBUjpcbiAgICAgICAgICAgIGNhc2UgR0xURlRleHR1cmVGaWx0ZXIuTElORUFSOlxuICAgICAgICAgICAgICAgIHJldHVybiAnbGluZWFyJyBhcyBHUFVNaXBtYXBGaWx0ZXJNb2RlXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwcml2YXRlIHN0YXRpYyBnZXRUZXh0dXJlQWRkcmVzc01vZGUobW9kZT86IEdMVEZUZXh0dXJlV3JhcCkge1xuICAgICAgICBzd2l0Y2ggKG1vZGUpIHtcbiAgICAgICAgICAgIGNhc2UgR0xURlRleHR1cmVXcmFwLlJFUEVBVDpcbiAgICAgICAgICAgICAgICByZXR1cm4gJ3JlcGVhdCcgYXMgR1BVQWRkcmVzc01vZGVcbiAgICAgICAgICAgIGNhc2UgR0xURlRleHR1cmVXcmFwLkNMQU1QX1RPX0VER0U6XG4gICAgICAgICAgICAgICAgcmV0dXJuICdjbGFtcC10by1lZGdlJyBhcyBHUFVBZGRyZXNzTW9kZVxuICAgICAgICAgICAgY2FzZSBHTFRGVGV4dHVyZVdyYXAuTUlSUk9SRURfUkVQRUFUOlxuICAgICAgICAgICAgICAgIHJldHVybiAnbWlycm9yLXJlcGVhdCcgYXMgR1BVQWRkcmVzc01vZGVcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuICdyZXBlYXQnXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwcml2YXRlIHN0YXRpYyBhc3luYyB1cGxvYWRJbWFnZXMoXG4gICAgICAgIG1vZGVsRGF0YTogSU1vZGVsUHJlbG9hZERhdGEsXG4gICAgICAgIGJ1ZmZlclN0b3JhZ2U6IElCdWZmZXJTdG9yYWdlLFxuICAgICAgICBpbWFnZVN0b3JhZ2U6IElJbWFnZVN0b3JhZ2VcbiAgICApIHtcbiAgICAgICAgZm9yIChsZXQgW2tleSwgdmFsdWVdIG9mIG1vZGVsRGF0YS5pbWFnZXMuZW50cmllcygpKSB7XG4gICAgICAgICAgICBjb25zdCB7XG4gICAgICAgICAgICAgICAgYnVmZmVyVmlldzogeyBidWZmZXIsIGJ5dGVMZW5ndGgsIGJ5dGVPZmZzZXQgfSxcbiAgICAgICAgICAgICAgICBtaW1lVHlwZSxcbiAgICAgICAgICAgIH0gPSB2YWx1ZVxuXG4gICAgICAgICAgICBjb25zdCBpbWFnZVZpZXcgPSBuZXcgVWludDhBcnJheShcbiAgICAgICAgICAgICAgICBidWZmZXJTdG9yYWdlLmJ1ZmZlcnMuZ2V0KGJ1ZmZlcikgYXMgQXJyYXlCdWZmZXIsXG4gICAgICAgICAgICAgICAgYnl0ZU9mZnNldCxcbiAgICAgICAgICAgICAgICBieXRlTGVuZ3RoXG4gICAgICAgICAgICApXG5cbiAgICAgICAgICAgIGNvbnN0IGJsb2IgPSBuZXcgQmxvYihbaW1hZ2VWaWV3XSwgeyB0eXBlOiBtaW1lVHlwZSB9KVxuICAgICAgICAgICAgY29uc3QgYml0bWFwID0gYXdhaXQgY3JlYXRlSW1hZ2VCaXRtYXAoYmxvYilcbiAgICAgICAgICAgIGltYWdlU3RvcmFnZS5pbWFnZXMuc2V0KGtleSwgYml0bWFwKVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBzdGF0aWMgdXBsb2FkQnVmZmVycyhcbiAgICAgICAgbW9kZWxEYXRhOiBJTW9kZWxQcmVsb2FkRGF0YSxcbiAgICAgICAgYnVmZmVyU3RvcmFnZTogSUJ1ZmZlclN0b3JhZ2VcbiAgICApIHtcbiAgICAgICAgbW9kZWxEYXRhLmJ1ZmZlcnMuZm9yRWFjaCgodmFsdWUsIGtleSkgPT4ge1xuICAgICAgICAgICAgYnVmZmVyU3RvcmFnZS5idWZmZXJzLnNldChrZXksIHZhbHVlKVxuICAgICAgICB9KVxuICAgIH1cblxuICAgIHByaXZhdGUgc3RhdGljIHVwbG9hZFNhbXBsZXJzKFxuICAgICAgICBtb2RlbERhdGE6IElNb2RlbFByZWxvYWREYXRhLFxuICAgICAgICBzYW1wbGVyU3RvcmFnZTogSVNhbXBsZXJTdG9yYWdlLFxuICAgICAgICBkZXZpY2U6IEdQVURldmljZVxuICAgICkge1xuICAgICAgICBtb2RlbERhdGEuc2FtcGxlcnMuZm9yRWFjaCgodmFsdWUsIGtleSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgZ3B1U2FtcGxlciA9IGRldmljZS5jcmVhdGVTYW1wbGVyKHtcbiAgICAgICAgICAgICAgICBtYWdGaWx0ZXI6IHRoaXMuZ2V0VGV4dHVyZUZpbHRlck1vZGUodmFsdWU/Lm1hZ0ZpbHRlciksXG4gICAgICAgICAgICAgICAgbWluRmlsdGVyOiB0aGlzLmdldFRleHR1cmVGaWx0ZXJNb2RlKHZhbHVlPy5taW5GaWx0ZXIpLFxuICAgICAgICAgICAgICAgIGFkZHJlc3NNb2RlVTogdGhpcy5nZXRUZXh0dXJlQWRkcmVzc01vZGUodmFsdWU/LndyYXBTKSxcbiAgICAgICAgICAgICAgICBhZGRyZXNzTW9kZVY6IHRoaXMuZ2V0VGV4dHVyZUFkZHJlc3NNb2RlKHZhbHVlPy53cmFwVCksXG4gICAgICAgICAgICAgICAgLy9GSVhNRTogdXNlIG1pcG1hcCBmaWx0cmF0aW9uXG4gICAgICAgICAgICAgICAgbWlwbWFwRmlsdGVyOiAnbmVhcmVzdCcsXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgc2FtcGxlclN0b3JhZ2Uuc2FtcGxlcnMuc2V0KGtleSwgZ3B1U2FtcGxlcilcbiAgICAgICAgfSlcbiAgICB9XG5cbiAgICBwcml2YXRlIHN0YXRpYyB1cGxvYWRUZXh0dXJlcyhcbiAgICAgICAgbW9kZWxEYXRhOiBJTW9kZWxQcmVsb2FkRGF0YSxcbiAgICAgICAgdGV4dHVyZVN0b3JhZ2U6IElUZXh0dXJlU3RvcmFnZVxuICAgICkge1xuICAgICAgICBtb2RlbERhdGEudGV4dHVyZXMuZm9yRWFjaCgodmFsdWUsIGtleSkgPT4ge1xuICAgICAgICAgICAgdGV4dHVyZVN0b3JhZ2UudGV4dHVyZXMuc2V0KGtleSwgdmFsdWUpXG4gICAgICAgIH0pXG4gICAgfVxuXG4gICAgcHJpdmF0ZSBzdGF0aWMgY3JlYXRlR1BVVGV4dHVyZShcbiAgICAgICAgZGV2aWNlOiBHUFVEZXZpY2UsXG4gICAgICAgIGZvcm1hdDogR1BVVGV4dHVyZUZvcm1hdCxcbiAgICAgICAgc2FtcGxlclN0b3JhZ2U6IElTYW1wbGVyU3RvcmFnZSxcbiAgICAgICAgaW1hZ2VTdG9yYWdlOiBJSW1hZ2VTdG9yYWdlLFxuICAgICAgICB0ZXh0dXJlUHJlbG9hZERhdGE/OiBJVGV4dHVyZVxuICAgICkge1xuICAgICAgICBsZXQgdGV4dHVyZVZpZXc6IEdQVVRleHR1cmVWaWV3IHwgdW5kZWZpbmVkXG4gICAgICAgIGxldCB0ZXh0dXJlU2FtcGxlcjogR1BVU2FtcGxlciB8IHVuZGVmaW5lZFxuXG4gICAgICAgIGlmICghdGV4dHVyZVByZWxvYWREYXRhKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oJ05vIHRleHR1cmUgZGF0YScpXG5cbiAgICAgICAgICAgIHJldHVyblxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCF0ZXh0dXJlUHJlbG9hZERhdGEuaW1hZ2VJZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyBpbWFnZSB2aWV3IGZvciB0aGlzIHRleHR1cmUnKVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCF0ZXh0dXJlUHJlbG9hZERhdGEuc2FtcGxlcklkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIHNhbXBsZXIgZm9yIHRoaXMgdGV4dHVyZScpXG4gICAgICAgIH1cblxuICAgICAgICB0ZXh0dXJlU2FtcGxlciA9IHNhbXBsZXJTdG9yYWdlLnNhbXBsZXJzLmdldChcbiAgICAgICAgICAgIHRleHR1cmVQcmVsb2FkRGF0YS5zYW1wbGVySWRcbiAgICAgICAgKSBhcyBHUFVTYW1wbGVyXG5cbiAgICAgICAgY29uc3QgaW1hZ2VCaXRtYXAgPSBpbWFnZVN0b3JhZ2UuaW1hZ2VzLmdldChcbiAgICAgICAgICAgIHRleHR1cmVQcmVsb2FkRGF0YS5pbWFnZUlkXG4gICAgICAgICkgYXMgSW1hZ2VCaXRtYXBcblxuICAgICAgICBjb25zdCBpbWFnZVNpemUgPSBbaW1hZ2VCaXRtYXAud2lkdGgsIGltYWdlQml0bWFwLmhlaWdodCwgMV1cblxuICAgICAgICBjb25zdCBpbWFnZVRleHR1cmUgPSBkZXZpY2UuY3JlYXRlVGV4dHVyZSh7XG4gICAgICAgICAgICBzaXplOiBpbWFnZVNpemUsXG4gICAgICAgICAgICBmb3JtYXQ6IGZvcm1hdCxcbiAgICAgICAgICAgIHVzYWdlOlxuICAgICAgICAgICAgICAgIEdQVVRleHR1cmVVc2FnZS5URVhUVVJFX0JJTkRJTkcgfFxuICAgICAgICAgICAgICAgIEdQVVRleHR1cmVVc2FnZS5DT1BZX0RTVCB8XG4gICAgICAgICAgICAgICAgR1BVVGV4dHVyZVVzYWdlLlJFTkRFUl9BVFRBQ0hNRU5ULFxuICAgICAgICB9KVxuXG4gICAgICAgIGRldmljZS5xdWV1ZS5jb3B5RXh0ZXJuYWxJbWFnZVRvVGV4dHVyZShcbiAgICAgICAgICAgIHsgc291cmNlOiBpbWFnZUJpdG1hcCB9LFxuICAgICAgICAgICAgeyB0ZXh0dXJlOiBpbWFnZVRleHR1cmUgfSxcbiAgICAgICAgICAgIGltYWdlU2l6ZVxuICAgICAgICApXG5cbiAgICAgICAgdGV4dHVyZVZpZXcgPSBpbWFnZVRleHR1cmUuY3JlYXRlVmlldygpXG5cbiAgICAgICAgcmV0dXJuIHsgdmlldzogdGV4dHVyZVZpZXcsIHNhbXBsZXI6IHRleHR1cmVTYW1wbGVyIH1cbiAgICB9XG5cbiAgICBwcml2YXRlIHN0YXRpYyB1cGxvYWRNYXRlcmlhbHMoXG4gICAgICAgIG1vZGVsRGF0YTogSU1vZGVsUHJlbG9hZERhdGEsXG4gICAgICAgIHRleHR1cmVTdG9yYWdlOiBJVGV4dHVyZVN0b3JhZ2UsXG4gICAgICAgIHNhbXBsZXJTdG9yYWdlOiBJU2FtcGxlclN0b3JhZ2UsXG4gICAgICAgIGltYWdlU3RvcmFnZTogSUltYWdlU3RvcmFnZSxcbiAgICAgICAgbWF0ZXJpYWxTdG9yYWdlOiBJTWF0ZXJpYWxTdG9yYWdlLFxuICAgICAgICBkZXZpY2U6IEdQVURldmljZVxuICAgICkge1xuICAgICAgICBtb2RlbERhdGEubWF0ZXJpYWxzLmZvckVhY2goKHZhbHVlLCBrZXkpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IG1hdGVyaWFsOiBJTWF0ZXJpYWwgPSB7XG4gICAgICAgICAgICAgICAgbmFtZTogdmFsdWUubmFtZSxcbiAgICAgICAgICAgICAgICBlbWlzc2l2ZUZhY3RvcjogdmFsdWU/LmVtaXNzaXZlRmFjdG9yID8/IHZlYzMuY3JlYXRlKDEsIDEsIDEpLFxuICAgICAgICAgICAgICAgIG1ldGFsbGljRmFjdG9yOiB2YWx1ZT8ubWV0YWxsaWNGYWN0b3IgPz8gMSxcbiAgICAgICAgICAgICAgICByb3VnaG5lc3NGYWN0b3I6IHZhbHVlLnJvdWdobmVzc0ZhY3RvciA/PyAxLFxuICAgICAgICAgICAgICAgIGJhc2VDb2xvckZhY3RvcjpcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU/LmJhc2VDb2xvckZhY3RvciA/PyB2ZWM0LmNyZWF0ZSgxLCAxLCAxLCAxKSxcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHZhbHVlLmJhc2VDb2xvclRleHR1cmVJZCkge1xuICAgICAgICAgICAgICAgIG1hdGVyaWFsLmJhc2VDb2xvclRleHR1cmUgPSB0aGlzLmNyZWF0ZUdQVVRleHR1cmUoXG4gICAgICAgICAgICAgICAgICAgIGRldmljZSxcbiAgICAgICAgICAgICAgICAgICAgJ3JnYmE4dW5vcm0tc3JnYicsXG4gICAgICAgICAgICAgICAgICAgIHNhbXBsZXJTdG9yYWdlLFxuICAgICAgICAgICAgICAgICAgICBpbWFnZVN0b3JhZ2UsXG4gICAgICAgICAgICAgICAgICAgIHRleHR1cmVTdG9yYWdlLnRleHR1cmVzLmdldCh2YWx1ZS5iYXNlQ29sb3JUZXh0dXJlSWQpXG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodmFsdWUubWV0YWxsaWNSb3VnaG5lc3NUZXh0dXJlSWQpIHtcbiAgICAgICAgICAgICAgICBtYXRlcmlhbC5tZXRhbGxpY1JvdWdobmVzc1RleHR1cmUgPSB0aGlzLmNyZWF0ZUdQVVRleHR1cmUoXG4gICAgICAgICAgICAgICAgICAgIGRldmljZSxcbiAgICAgICAgICAgICAgICAgICAgJ3JnYmE4dW5vcm0nLFxuICAgICAgICAgICAgICAgICAgICBzYW1wbGVyU3RvcmFnZSxcbiAgICAgICAgICAgICAgICAgICAgaW1hZ2VTdG9yYWdlLFxuICAgICAgICAgICAgICAgICAgICB0ZXh0dXJlU3RvcmFnZS50ZXh0dXJlcy5nZXQoXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZS5tZXRhbGxpY1JvdWdobmVzc1RleHR1cmVJZFxuICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodmFsdWUubm9ybWFsVGV4dHVyZUlkKSB7XG4gICAgICAgICAgICAgICAgbWF0ZXJpYWwubm9ybWFsVGV4dHVyZSA9IHRoaXMuY3JlYXRlR1BVVGV4dHVyZShcbiAgICAgICAgICAgICAgICAgICAgZGV2aWNlLFxuICAgICAgICAgICAgICAgICAgICAncmdiYTh1bm9ybS1zcmdiJyxcbiAgICAgICAgICAgICAgICAgICAgc2FtcGxlclN0b3JhZ2UsXG4gICAgICAgICAgICAgICAgICAgIGltYWdlU3RvcmFnZSxcbiAgICAgICAgICAgICAgICAgICAgdGV4dHVyZVN0b3JhZ2UudGV4dHVyZXMuZ2V0KHZhbHVlLm5vcm1hbFRleHR1cmVJZClcbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIG1hdGVyaWFsU3RvcmFnZS5tYXRlcmlhbHMuc2V0KGtleSwgbWF0ZXJpYWwpXG4gICAgICAgIH0pXG4gICAgfVxuXG4gICAgcHJpdmF0ZSBzdGF0aWMgdHJhdmVyc2VQcmVsb2FkTm9kZShcbiAgICAgICAgbm9kZTogSVByZWxvYWRFbnRpdHksXG4gICAgICAgIHBhcmVudEdhbWVPYmplY3Q6IElHYW1lT2JqZWN0LFxuICAgICAgICBvYmplY3RNYW5hZ2VyOiBJT2JqZWN0TWFuYWdlcixcbiAgICAgICAgcGlwZWxpbmVQYXJhbXM6IHtcbiAgICAgICAgICAgIGRldmljZTogR1BVRGV2aWNlXG4gICAgICAgICAgICBzaGFkZXJNb2R1bGU6IEdQVVNoYWRlck1vZHVsZVxuICAgICAgICAgICAgY29sb3JGb3JtYXQ6IEdQVVRleHR1cmVGb3JtYXRcbiAgICAgICAgICAgIGRlcHRoRm9ybWF0OiBHUFVUZXh0dXJlRm9ybWF0XG4gICAgICAgICAgICBtc2FhU2FtcGxlQ291bnQ6IG51bWJlciB8IHVuZGVmaW5lZFxuICAgICAgICAgICAgdW5pZm9ybXNCR0xheW91dDogR1BVQmluZEdyb3VwTGF5b3V0XG4gICAgICAgICAgICBub2RlUGFyYW1zQkdMYXlvdXQ6IEdQVUJpbmRHcm91cExheW91dFxuICAgICAgICB9LFxuICAgICAgICBidWZmZXJTdG9yYWdlOiBJQnVmZmVyU3RvcmFnZSxcbiAgICAgICAgbWF0ZXJpYWxTdG9yYWdlOiBJTWF0ZXJpYWxTdG9yYWdlXG4gICAgKSB7XG4gICAgICAgIGNvbnN0IHsgdHJzTWF0cml4LCBtZXNoZXMsIGNoaWxkcmVuIH0gPSBub2RlXG5cbiAgICAgICAgY29uc3QgZ2FtZU9iamVjdCA9IG5ldyBHYW1lT2JqZWN0KClcblxuICAgICAgICBvYmplY3RNYW5hZ2VyLmFkZE9iamVjdChnYW1lT2JqZWN0LCBwYXJlbnRHYW1lT2JqZWN0KVxuXG4gICAgICAgIG5ldyBUcmFuc2Zvcm0oZ2FtZU9iamVjdCwgdHJzTWF0cml4KVxuXG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICAgIGRldmljZSxcbiAgICAgICAgICAgIHNoYWRlck1vZHVsZSxcbiAgICAgICAgICAgIGNvbG9yRm9ybWF0OiBzd2FwQ2hhaW5Gb3JtYXQsXG4gICAgICAgICAgICBkZXB0aEZvcm1hdCxcbiAgICAgICAgICAgIG1zYWFTYW1wbGVDb3VudCxcbiAgICAgICAgICAgIHVuaWZvcm1zQkdMYXlvdXQ6IHZpZXdQYXJhbXNCaW5kR3JvdXBMYXlvdXQsXG4gICAgICAgICAgICBub2RlUGFyYW1zQkdMYXlvdXQ6IG5vZGVQYXJhbXNCaW5kR3JvdXBMYXlvdXQsXG4gICAgICAgIH0gPSBwaXBlbGluZVBhcmFtc1xuXG4gICAgICAgIG1lc2hlcy5mb3JFYWNoKChtZXNoRGF0YSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgbWVzaCA9IG5ldyBNZXNoKFxuICAgICAgICAgICAgICAgIGdhbWVPYmplY3QsXG4gICAgICAgICAgICAgICAgbWVzaERhdGEucG9zaXRpb25zIGFzIEdMVEZBY2Nlc3NvcixcbiAgICAgICAgICAgICAgICBtZXNoRGF0YS5pbmRpY2VzLFxuICAgICAgICAgICAgICAgIG1lc2hEYXRhLm5vcm1hbHMsXG4gICAgICAgICAgICAgICAgbWVzaERhdGEudGV4dHVyZUNvb3JkaW5hdGVzLFxuICAgICAgICAgICAgICAgIG1lc2hEYXRhLm1hdGVyaWFsSWRcbiAgICAgICAgICAgICAgICAgICAgPyBtYXRlcmlhbFN0b3JhZ2UubWF0ZXJpYWxzLmdldChtZXNoRGF0YS5tYXRlcmlhbElkKVxuICAgICAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZFxuICAgICAgICAgICAgKVxuXG4gICAgICAgICAgICBtZXNoLmJ1aWxkUmVuZGVyUGlwZWxpbmUoXG4gICAgICAgICAgICAgICAgZGV2aWNlLFxuICAgICAgICAgICAgICAgIHNoYWRlck1vZHVsZSxcbiAgICAgICAgICAgICAgICBzd2FwQ2hhaW5Gb3JtYXQsXG4gICAgICAgICAgICAgICAgZGVwdGhGb3JtYXQsXG4gICAgICAgICAgICAgICAgbXNhYVNhbXBsZUNvdW50LFxuICAgICAgICAgICAgICAgIHZpZXdQYXJhbXNCaW5kR3JvdXBMYXlvdXQsXG4gICAgICAgICAgICAgICAgbm9kZVBhcmFtc0JpbmRHcm91cExheW91dCxcbiAgICAgICAgICAgICAgICBidWZmZXJTdG9yYWdlXG4gICAgICAgICAgICApXG4gICAgICAgIH0pXG5cbiAgICAgICAgY2hpbGRyZW4uZm9yRWFjaCgoY2hpbGQpID0+IHtcbiAgICAgICAgICAgIHRoaXMudHJhdmVyc2VQcmVsb2FkTm9kZShcbiAgICAgICAgICAgICAgICBjaGlsZCxcbiAgICAgICAgICAgICAgICBnYW1lT2JqZWN0LFxuICAgICAgICAgICAgICAgIG9iamVjdE1hbmFnZXIsXG4gICAgICAgICAgICAgICAgcGlwZWxpbmVQYXJhbXMsXG4gICAgICAgICAgICAgICAgYnVmZmVyU3RvcmFnZSxcbiAgICAgICAgICAgICAgICBtYXRlcmlhbFN0b3JhZ2VcbiAgICAgICAgICAgIClcbiAgICAgICAgfSlcbiAgICB9XG5cbiAgICBwdWJsaWMgc3RhdGljIGFzeW5jIHVwbG9hZE1vZGVsKFxuICAgICAgICBtb2RlbERhdGE6IElNb2RlbFByZWxvYWREYXRhLFxuICAgICAgICBvYmplY3RNYW5hZ2VyOiBJT2JqZWN0TWFuYWdlcixcbiAgICAgICAgcGlwZWxpbmVQYXJhbXM6IHtcbiAgICAgICAgICAgIGRldmljZTogR1BVRGV2aWNlXG4gICAgICAgICAgICBzaGFkZXJNb2R1bGU6IEdQVVNoYWRlck1vZHVsZVxuICAgICAgICAgICAgY29sb3JGb3JtYXQ6IEdQVVRleHR1cmVGb3JtYXRcbiAgICAgICAgICAgIGRlcHRoRm9ybWF0OiBHUFVUZXh0dXJlRm9ybWF0XG4gICAgICAgICAgICB1bmlmb3Jtc0JHTGF5b3V0OiBHUFVCaW5kR3JvdXBMYXlvdXRcbiAgICAgICAgICAgIG5vZGVQYXJhbXNCR0xheW91dDogR1BVQmluZEdyb3VwTGF5b3V0XG4gICAgICAgICAgICBtc2FhU2FtcGxlQ291bnQ6IG51bWJlciB8IHVuZGVmaW5lZFxuICAgICAgICB9LFxuICAgICAgICBidWZmZXJTdG9yYWdlOiBJQnVmZmVyU3RvcmFnZSxcbiAgICAgICAgaW1hZ2VTdG9yYWdlOiBJSW1hZ2VTdG9yYWdlLFxuICAgICAgICBzYW1wbGVyU3RvcmFnZTogSVNhbXBsZXJTdG9yYWdlLFxuICAgICAgICBtYXRlcmlhbFN0b3JhZ2U6IElNYXRlcmlhbFN0b3JhZ2UsXG4gICAgICAgIHRleHR1cmVTdG9yYWdlOiBJVGV4dHVyZVN0b3JhZ2UsXG4gICAgICAgIHNjZW5lT2JqZWN0OiBJR2FtZU9iamVjdFxuICAgICkge1xuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgICBkZXZpY2UsXG4gICAgICAgICAgICBzaGFkZXJNb2R1bGUsXG4gICAgICAgICAgICBjb2xvckZvcm1hdDogc3dhcENoYWluRm9ybWF0LFxuICAgICAgICAgICAgZGVwdGhGb3JtYXQsXG4gICAgICAgICAgICB1bmlmb3Jtc0JHTGF5b3V0OiB2aWV3UGFyYW1zQmluZEdyb3VwTGF5b3V0LFxuICAgICAgICAgICAgbm9kZVBhcmFtc0JHTGF5b3V0OiBub2RlUGFyYW1zQmluZEdyb3VwTGF5b3V0LFxuICAgICAgICAgICAgbXNhYVNhbXBsZUNvdW50LFxuICAgICAgICB9ID0gcGlwZWxpbmVQYXJhbXNcblxuICAgICAgICB0aGlzLnVwbG9hZEJ1ZmZlcnMobW9kZWxEYXRhLCBidWZmZXJTdG9yYWdlKVxuICAgICAgICBhd2FpdCB0aGlzLnVwbG9hZEltYWdlcyhtb2RlbERhdGEsIGJ1ZmZlclN0b3JhZ2UsIGltYWdlU3RvcmFnZSlcbiAgICAgICAgdGhpcy51cGxvYWRTYW1wbGVycyhtb2RlbERhdGEsIHNhbXBsZXJTdG9yYWdlLCBwaXBlbGluZVBhcmFtcy5kZXZpY2UpXG4gICAgICAgIHRoaXMudXBsb2FkVGV4dHVyZXMobW9kZWxEYXRhLCB0ZXh0dXJlU3RvcmFnZSlcbiAgICAgICAgdGhpcy51cGxvYWRNYXRlcmlhbHMoXG4gICAgICAgICAgICBtb2RlbERhdGEsXG4gICAgICAgICAgICB0ZXh0dXJlU3RvcmFnZSxcbiAgICAgICAgICAgIHNhbXBsZXJTdG9yYWdlLFxuICAgICAgICAgICAgaW1hZ2VTdG9yYWdlLFxuICAgICAgICAgICAgbWF0ZXJpYWxTdG9yYWdlLFxuICAgICAgICAgICAgcGlwZWxpbmVQYXJhbXMuZGV2aWNlXG4gICAgICAgIClcblxuICAgICAgICBjb25zdCB7IHRyc01hdHJpeCwgbWVzaGVzLCBjaGlsZHJlbiB9ID0gbW9kZWxEYXRhLm1vZGVsXG5cbiAgICAgICAgY29uc3QgbWVzaE9iamVjdCA9IG5ldyBHYW1lT2JqZWN0KClcblxuICAgICAgICBvYmplY3RNYW5hZ2VyLmFkZE9iamVjdChtZXNoT2JqZWN0LCBzY2VuZU9iamVjdClcblxuICAgICAgICBuZXcgVHJhbnNmb3JtKG1lc2hPYmplY3QsIHRyc01hdHJpeClcblxuICAgICAgICBtZXNoZXMuZm9yRWFjaCgobWVzaERhdGEpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IG1lc2ggPSBuZXcgTWVzaChcbiAgICAgICAgICAgICAgICBtZXNoT2JqZWN0LFxuICAgICAgICAgICAgICAgIG1lc2hEYXRhLnBvc2l0aW9ucyBhcyBHTFRGQWNjZXNzb3IsXG4gICAgICAgICAgICAgICAgbWVzaERhdGEuaW5kaWNlcyxcbiAgICAgICAgICAgICAgICBtZXNoRGF0YS5ub3JtYWxzLFxuICAgICAgICAgICAgICAgIG1lc2hEYXRhLnRleHR1cmVDb29yZGluYXRlcyxcbiAgICAgICAgICAgICAgICBtZXNoRGF0YS5tYXRlcmlhbElkXG4gICAgICAgICAgICAgICAgICAgID8gbWF0ZXJpYWxTdG9yYWdlLm1hdGVyaWFscy5nZXQobWVzaERhdGEubWF0ZXJpYWxJZClcbiAgICAgICAgICAgICAgICAgICAgOiB1bmRlZmluZWRcbiAgICAgICAgICAgIClcblxuICAgICAgICAgICAgbWVzaC5idWlsZFJlbmRlclBpcGVsaW5lKFxuICAgICAgICAgICAgICAgIGRldmljZSxcbiAgICAgICAgICAgICAgICBzaGFkZXJNb2R1bGUsXG4gICAgICAgICAgICAgICAgc3dhcENoYWluRm9ybWF0LFxuICAgICAgICAgICAgICAgIGRlcHRoRm9ybWF0LFxuICAgICAgICAgICAgICAgIG1zYWFTYW1wbGVDb3VudCxcbiAgICAgICAgICAgICAgICB2aWV3UGFyYW1zQmluZEdyb3VwTGF5b3V0LFxuICAgICAgICAgICAgICAgIG5vZGVQYXJhbXNCaW5kR3JvdXBMYXlvdXQsXG4gICAgICAgICAgICAgICAgYnVmZmVyU3RvcmFnZVxuICAgICAgICAgICAgKVxuICAgICAgICB9KVxuXG4gICAgICAgIGNoaWxkcmVuLmZvckVhY2goKGNoaWxkKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnRyYXZlcnNlUHJlbG9hZE5vZGUoXG4gICAgICAgICAgICAgICAgY2hpbGQsXG4gICAgICAgICAgICAgICAgbWVzaE9iamVjdCxcbiAgICAgICAgICAgICAgICBvYmplY3RNYW5hZ2VyLFxuICAgICAgICAgICAgICAgIHBpcGVsaW5lUGFyYW1zLFxuICAgICAgICAgICAgICAgIGJ1ZmZlclN0b3JhZ2UsXG4gICAgICAgICAgICAgICAgbWF0ZXJpYWxTdG9yYWdlXG4gICAgICAgICAgICApXG4gICAgICAgIH0pXG5cbiAgICAgICAgcmV0dXJuIG1lc2hPYmplY3RcbiAgICB9XG59XG4iLCJleHBvcnQgKiBmcm9tICcuL01vZGVsVXBsb2FkZXInXG4iLCJpbXBvcnQge1xuICAgIEVudGl0eUlELFxuICAgIElHYW1lT2JqZWN0LFxuICAgIElPYmplY3RNYW5hZ2VyLFxuICAgIElTY2VuZVRyZWUsXG4gICAgU2NlbmVUcmVlUG9zaXRpb24sXG59IGZyb20gJy4uLy4uL3R5cGVzJ1xuaW1wb3J0IHsgU2NlbmVUcmVlIH0gZnJvbSAnLi4vU2NlbmVUcmVlJ1xuXG50eXBlIE9iamVjdFBvc2l0aW9ucyA9IE1hcDxFbnRpdHlJRCwgU2NlbmVUcmVlUG9zaXRpb24gfCBudWxsPlxuXG5leHBvcnQgY2xhc3MgT2JqZWN0TWFuYWdlciBpbXBsZW1lbnRzIElPYmplY3RNYW5hZ2VyIHtcbiAgICBwcml2YXRlIF9vYmplY3RQb3NpdGlvbnM6IE9iamVjdFBvc2l0aW9ucyA9IG5ldyBNYXAoKVxuICAgIHByaXZhdGUgX3NjZW5lVHJlZTogSVNjZW5lVHJlZSA9IG5ldyBTY2VuZVRyZWUoKVxuXG4gICAgcHVibGljIGdldCBzY2VuZVRyZWUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zY2VuZVRyZWVcbiAgICB9XG5cbiAgICBwcml2YXRlIGdldE9iamVjdFBvc2l0aW9uKGdhbWVPYmplY3Q/OiBJR2FtZU9iamVjdCB8IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIGdhbWVPYmplY3RcbiAgICAgICAgICAgID8gdGhpcy5fb2JqZWN0UG9zaXRpb25zLmdldChnYW1lT2JqZWN0LmlkKSA/PyBudWxsXG4gICAgICAgICAgICA6IG51bGxcbiAgICB9XG5cbiAgICBwdWJsaWMgYWRkT2JqZWN0KGNoaWxkOiBJR2FtZU9iamVjdCwgdGFyZ2V0PzogSUdhbWVPYmplY3QpIHtcbiAgICAgICAgY29uc3QgcG9zaXRpb24gPSB0aGlzLl9zY2VuZVRyZWUuYWRkTm9kZUF0KFxuICAgICAgICAgICAgdGhpcy5nZXRPYmplY3RQb3NpdGlvbih0YXJnZXQpLFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGdhbWVPYmplY3Q6IGNoaWxkLFxuICAgICAgICAgICAgICAgIGNoaWxkcmVuOiBuZXcgTWFwKCksXG4gICAgICAgICAgICB9XG4gICAgICAgIClcblxuICAgICAgICB0aGlzLl9vYmplY3RQb3NpdGlvbnMuc2V0KGNoaWxkLmlkLCBwb3NpdGlvbilcbiAgICB9XG5cbiAgICBwdWJsaWMgcmVwYXJlbnRPYmplY3QoY2hpbGQ6IElHYW1lT2JqZWN0LCB0YXJnZXQ/OiBJR2FtZU9iamVjdCkge1xuICAgICAgICBjb25zdCBjaGlsZFBvc2l0aW9uID0gdGhpcy5fb2JqZWN0UG9zaXRpb25zLmdldChjaGlsZC5pZClcblxuICAgICAgICBpZiAoIWNoaWxkUG9zaXRpb24pIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgUG9zaXRpb24gcmVjb3JkIG5vdCBmb3VuZCBmb3IgJHtjaGlsZC5pZH1gKVxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgbmV3UG9zaXRpb24gPSB0aGlzLl9zY2VuZVRyZWUucmVwYXJlbnROb2RlKFxuICAgICAgICAgICAgdGhpcy5nZXRPYmplY3RQb3NpdGlvbih0YXJnZXQpLFxuICAgICAgICAgICAgY2hpbGRQb3NpdGlvblxuICAgICAgICApXG5cbiAgICAgICAgdGhpcy5fb2JqZWN0UG9zaXRpb25zLnNldChjaGlsZC5pZCwgbmV3UG9zaXRpb24pXG4gICAgfVxuXG4gICAgcHVibGljIGRlc3Ryb3lPYmplY3QoZ2FtZU9iamVjdDogSUdhbWVPYmplY3QpIHtcbiAgICAgICAgY29uc3QgY2hpbGRQb3NpdGlvbiA9IHRoaXMuX29iamVjdFBvc2l0aW9ucy5nZXQoZ2FtZU9iamVjdC5pZClcblxuICAgICAgICBpZiAoIWNoaWxkUG9zaXRpb24pIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgUG9zaXRpb24gcmVjb3JkIG5vdCBmb3VuZCBmb3IgJHtnYW1lT2JqZWN0LmlkfWApXG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBpZHNUb1JlbW92ZSA9IHRoaXMuX3NjZW5lVHJlZS5yZW1vdmVOb2RlKGNoaWxkUG9zaXRpb24pXG5cbiAgICAgICAgaWRzVG9SZW1vdmUuZm9yRWFjaCgoaWQpID0+IHtcbiAgICAgICAgICAgIHRoaXMuX29iamVjdFBvc2l0aW9ucy5kZWxldGUoaWQpXG4gICAgICAgIH0pXG4gICAgfVxufVxuIiwiZXhwb3J0ICogZnJvbSAnLi9PYmplY3RNYW5hZ2VyJ1xuIiwiaW1wb3J0IHsgSVNhbXBsZXJTdG9yYWdlIH0gZnJvbSAnLi4vLi4vdHlwZXMnXG5cbmV4cG9ydCBjbGFzcyBTYW1wbGVyU3RvcmFnZSBpbXBsZW1lbnRzIElTYW1wbGVyU3RvcmFnZSB7XG4gICAgX3NhbXBsZXJzOiBNYXA8c3RyaW5nLCBHUFVTYW1wbGVyPiA9IG5ldyBNYXAoKVxuXG4gICAgZ2V0IHNhbXBsZXJzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fc2FtcGxlcnNcbiAgICB9XG59XG4iLCJleHBvcnQgKiBmcm9tICcuL1NhbXBsZXJTdG9yYWdlJ1xuIiwiaW1wb3J0IHsgbWF0NCwgTWF0NCwgdmVjMyB9IGZyb20gJ3dncHUtbWF0cml4J1xuaW1wb3J0IHtcbiAgICBFbnRpdHlUeXBlcyxcbiAgICBJQnVmZmVyU3RvcmFnZSxcbiAgICBJRW5naW5lLFxuICAgIElHYW1lT2JqZWN0LFxuICAgIElJbWFnZVN0b3JhZ2UsXG4gICAgSU9iamVjdE1hbmFnZXIsXG4gICAgSVNhbXBsZXJTdG9yYWdlLFxuICAgIElTY2VuZSxcbiAgICBJU2NlbmVQcm9wcyxcbiAgICBJU2NlbmVVcGxvYWRNb2RlbFByb3BzLFxuICAgIElUcmFuc2Zvcm0sXG4gICAgU2NlbmVOb2RlQ29udGVudCxcbn0gZnJvbSAnLi4vLi4vdHlwZXMnXG5pbXBvcnQgeyBJQ2FtZXJhIH0gZnJvbSAnLi4vLi4vdHlwZXMvY29yZS9DYW1lcmEnXG5pbXBvcnQgeyBCdWZmZXJTdG9yYWdlIH0gZnJvbSAnLi4vQnVmZmVyU3RvcmFnZSdcbmltcG9ydCB7IEFyY0JhbGxDYW1lcmEgfSBmcm9tICcuLi9jYW1lcmFzL0FyY0JhbGxDYW1lcmEnXG5pbXBvcnQgeyBJbWFnZVN0b3JhZ2UgfSBmcm9tICcuLi9JbWFnZVN0b3JhZ2UnXG5pbXBvcnQgeyBNYXRlcmlhbFN0b3JhZ2UgfSBmcm9tICcuLi9NYXRlcmlhbFN0b3JhZ2UnXG5pbXBvcnQgeyBNb2RlbFVwbG9hZGVyIH0gZnJvbSAnLi4vTW9kZWxVcGxvYWRlcidcbmltcG9ydCB7IE9iamVjdE1hbmFnZXIgfSBmcm9tICcuLi9PYmplY3RNYW5hZ2VyJ1xuaW1wb3J0IHsgU2FtcGxlclN0b3JhZ2UgfSBmcm9tICcuLi9TYW1wbGVyU3RvcmFnZSdcbmltcG9ydCB7IFRleHR1cmVTdG9yYWdlIH0gZnJvbSAnLi4vVGV4dHVyZVN0b3JhZ2UnXG5pbXBvcnQgeyBTdHVmZiB9IGZyb20gJy4uLy4uLy4uL3V0aWxzL1N0dWZmJ1xuaW1wb3J0IHsgTWVzaCB9IGZyb20gJy4uL01lc2gnXG5pbXBvcnQgeyBHYW1lT2JqZWN0IH0gZnJvbSAnLi4vR2FtZU9iamVjdCdcblxuZXhwb3J0IGNsYXNzIFNjZW5lIGltcGxlbWVudHMgSVNjZW5lIHtcbiAgICBwcml2YXRlIF9vYmplY3RNYW5hZ2VyOiBJT2JqZWN0TWFuYWdlciA9IG5ldyBPYmplY3RNYW5hZ2VyKClcbiAgICBwcml2YXRlIF9idWZmZXJTdG9yYWdlOiBJQnVmZmVyU3RvcmFnZSA9IG5ldyBCdWZmZXJTdG9yYWdlKClcbiAgICBwcml2YXRlIF9pbWFnZVN0b3JhZ2U6IElJbWFnZVN0b3JhZ2UgPSBuZXcgSW1hZ2VTdG9yYWdlKClcbiAgICBwcml2YXRlIF9zYW1wbGVyU3RvcmFnZTogSVNhbXBsZXJTdG9yYWdlID0gbmV3IFNhbXBsZXJTdG9yYWdlKClcbiAgICBwcml2YXRlIF90ZXh0dXJlU3RvcmFnZSA9IG5ldyBUZXh0dXJlU3RvcmFnZSgpXG4gICAgcHJpdmF0ZSBfbWF0ZXJpYWxTdG9yYWdlID0gbmV3IE1hdGVyaWFsU3RvcmFnZSgpXG5cbiAgICBwcml2YXRlIF9jYW1lcmEhOiBJQ2FtZXJhXG5cbiAgICBwcm90ZWN0ZWQgX2VuZ2luZT86IElFbmdpbmVcblxuICAgIHByaXZhdGUgX3JlbmRlclBhc3NEZXNjcmlwdG9yOiBHUFVSZW5kZXJQYXNzRGVzY3JpcHRvclxuXG4gICAgcHJpdmF0ZSBfdmlld1BhcmFtc0J1ZmZlciE6IEdQVUJ1ZmZlclxuICAgIHByaXZhdGUgX3ZpZXdQYXJhbXNCaW5kR3JvdXAhOiBHUFVCaW5kR3JvdXBcblxuICAgIHByaXZhdGUgX211bHRpc2FtcGxlVGV4dHVyZVZpZXc/OiBHUFVUZXh0dXJlVmlld1xuXG4gICAgcHJpdmF0ZSBfcm9vdDogSUdhbWVPYmplY3RcblxuICAgIGNvbnN0cnVjdG9yKHByb3BzPzogSVNjZW5lUHJvcHMpIHtcbiAgICAgICAgY29uc3QgeyBjYW1lcmEgfSA9IHByb3BzID8/IHt9XG4gICAgICAgIC8vRklYTUU6IHR5cGVzXG4gICAgICAgIHRoaXMuX2VuZ2luZSA9ICh3aW5kb3cgYXMgYW55KS5XaGVlenlFbmdpbmUgYXMgSUVuZ2luZSB8IHVuZGVmaW5lZFxuXG4gICAgICAgIGlmICghdGhpcy5fZW5naW5lKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICAgICAgJ0ZhaWxlZCB0byBpbml0aWFsaXplIHNjZW5lIGFzIG5vIGluc3RhbmNlIG9mIFdoZWV6eSBFbmdpbmUgaXMgZm91bmQnXG4gICAgICAgICAgICApXG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9yb290ID0gbmV3IEdhbWVPYmplY3QoKVxuXG4gICAgICAgIHRoaXMuX29iamVjdE1hbmFnZXIuYWRkT2JqZWN0KHRoaXMuX3Jvb3QpXG5cbiAgICAgICAgdGhpcy5faW5pdGlhbGl6ZVZpZXdQYXJhbXMoKVxuXG4gICAgICAgIGlmICh0aGlzLl9lbmdpbmUubXNhYVNhbXBsZUNvdW50ICE9PSAxKSB7XG4gICAgICAgICAgICB0aGlzLl9tdWx0aXNhbXBsZVRleHR1cmVWaWV3ID0gdGhpcy5fZW5naW5lLmRldmljZVxuICAgICAgICAgICAgICAgIC5jcmVhdGVUZXh0dXJlKHtcbiAgICAgICAgICAgICAgICAgICAgc2l6ZTogW1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fZW5naW5lLmNvbnRleHQuY2FudmFzLndpZHRoLFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fZW5naW5lLmNvbnRleHQuY2FudmFzLmhlaWdodCxcbiAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICAgICAgc2FtcGxlQ291bnQ6IHRoaXMuX2VuZ2luZS5tc2FhU2FtcGxlQ291bnQsXG4gICAgICAgICAgICAgICAgICAgIGZvcm1hdDogdGhpcy5fZW5naW5lLnN3YXBDaGFpbkZvcm1hdCxcbiAgICAgICAgICAgICAgICAgICAgdXNhZ2U6IEdQVVRleHR1cmVVc2FnZS5SRU5ERVJfQVRUQUNITUVOVCxcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC5jcmVhdGVWaWV3KClcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX211bHRpc2FtcGxlVGV4dHVyZVZpZXcgPSB1bmRlZmluZWRcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX3JlbmRlclBhc3NEZXNjcmlwdG9yID0ge1xuICAgICAgICAgICAgY29sb3JBdHRhY2htZW50czogW1xuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgdmlldzogbnVsbCBhcyB1bmtub3duIGFzIEdQVVRleHR1cmVWaWV3LFxuICAgICAgICAgICAgICAgICAgICByZXNvbHZlVGFyZ2V0OiAodGhpcy5fZW5naW5lLm1zYWFTYW1wbGVDb3VudCA9PT0gMVxuICAgICAgICAgICAgICAgICAgICAgICAgPyB1bmRlZmluZWRcbiAgICAgICAgICAgICAgICAgICAgICAgIDogbnVsbCkgYXMgdW5rbm93biBhcyBHUFVUZXh0dXJlVmlldyxcbiAgICAgICAgICAgICAgICAgICAgbG9hZE9wOiAnY2xlYXInIGFzIEdQVUxvYWRPcCxcbiAgICAgICAgICAgICAgICAgICAgY2xlYXJWYWx1ZTogWzAuMCwgMC4wLCAwLjAsIDFdLFxuICAgICAgICAgICAgICAgICAgICBzdG9yZU9wOlxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fZW5naW5lLm1zYWFTYW1wbGVDb3VudCA9PT0gMVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gJ3N0b3JlJ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogKCdkaXNjYXJkJyBhcyBHUFVTdG9yZU9wKSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIGRlcHRoU3RlbmNpbEF0dGFjaG1lbnQ6IHtcbiAgICAgICAgICAgICAgICB2aWV3OiB0aGlzLl9lbmdpbmUuZGVwdGhUZXh0dXJlLmNyZWF0ZVZpZXcoKSxcbiAgICAgICAgICAgICAgICBkZXB0aExvYWRPcDogJ2NsZWFyJyBhcyBHUFVMb2FkT3AsXG4gICAgICAgICAgICAgICAgZGVwdGhDbGVhclZhbHVlOiAxLjAsXG4gICAgICAgICAgICAgICAgZGVwdGhTdG9yZU9wOiAnc3RvcmUnIGFzIEdQVVN0b3JlT3AsXG4gICAgICAgICAgICAgICAgc3RlbmNpbExvYWRPcDogJ2NsZWFyJyBhcyBHUFVMb2FkT3AsXG4gICAgICAgICAgICAgICAgc3RlbmNpbENsZWFyVmFsdWU6IDAsXG4gICAgICAgICAgICAgICAgc3RlbmNpbFN0b3JlT3A6ICdzdG9yZScgYXMgR1BVU3RvcmVPcCxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmNhbWVyYSA9XG4gICAgICAgICAgICBjYW1lcmEgPz9cbiAgICAgICAgICAgIG5ldyBBcmNCYWxsQ2FtZXJhKHtcbiAgICAgICAgICAgICAgICB6RmFyOiAxMDAwLFxuICAgICAgICAgICAgICAgIHpOZWFyOiAwLjEsXG4gICAgICAgICAgICAgICAgY2FudmFzV2lkdGg6IHRoaXMuX2VuZ2luZS5jb250ZXh0LmNhbnZhcy53aWR0aCxcbiAgICAgICAgICAgICAgICBjYW52YXNIZWlnaHQ6IHRoaXMuX2VuZ2luZS5jb250ZXh0LmNhbnZhcy5oZWlnaHQsXG4gICAgICAgICAgICAgICAgcG9zaXRpb246IHZlYzMuY3JlYXRlKDAsIDAsIDUpLFxuICAgICAgICAgICAgfSlcbiAgICB9XG5cbiAgICBnZXQgb2JqZWN0TWFuYWdlcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX29iamVjdE1hbmFnZXJcbiAgICB9XG5cbiAgICBnZXQgcm9vdCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3Jvb3RcbiAgICB9XG5cbiAgICBnZXQgdGV4dHVyZVN0b3JhZ2UoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl90ZXh0dXJlU3RvcmFnZVxuICAgIH1cblxuICAgIGdldCBtYXRlcmlhbFN0b3JhZ2UoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9tYXRlcmlhbFN0b3JhZ2VcbiAgICB9XG5cbiAgICBnZXQgYnVmZmVyU3RvcmFnZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2J1ZmZlclN0b3JhZ2VcbiAgICB9XG5cbiAgICBnZXQgaW1hZ2VTdG9yYWdlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faW1hZ2VTdG9yYWdlXG4gICAgfVxuXG4gICAgZ2V0IHNhbXBsZXJTdG9yYWdlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fc2FtcGxlclN0b3JhZ2VcbiAgICB9XG5cbiAgICBnZXQgcmVuZGVyUGFzc0Rlc2NyaXB0b3IoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9yZW5kZXJQYXNzRGVzY3JpcHRvclxuICAgIH1cblxuICAgIGdldCBjYW1lcmEoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jYW1lcmFcbiAgICB9XG5cbiAgICBzZXQgY2FtZXJhKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuX2NhbWVyYSA9IHZhbHVlXG4gICAgfVxuXG4gICAgZ2V0IHZpZXdQYXJhbXNCdWZmZXIoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl92aWV3UGFyYW1zQnVmZmVyXG4gICAgfVxuXG4gICAgZ2V0IG11bHRpc2FtcGxlVGV4dHVyZVZpZXcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9tdWx0aXNhbXBsZVRleHR1cmVWaWV3XG4gICAgfVxuXG4gICAgZ2V0IHZpZXdQYXJhbXNCaW5kR3JvdXAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl92aWV3UGFyYW1zQmluZEdyb3VwXG4gICAgfVxuXG4gICAgZ2V0IGVuZ2luZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2VuZ2luZSBhcyBJRW5naW5lXG4gICAgfVxuXG4gICAgcHJpdmF0ZSBfaW5pdGlhbGl6ZVZpZXdQYXJhbXMoKSB7XG4gICAgICAgIGlmICghdGhpcy5fZW5naW5lKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICAgICAgJ0ZhaWxlZCB0byBpbml0aWFsaXplIGJ1ZmZlcnMgYXMgbm8gaW5zdGFuY2Ugb2YgV2hlZXp5IEVuZ2luZSBpcyBmb3VuZCdcbiAgICAgICAgICAgIClcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX3ZpZXdQYXJhbXNCdWZmZXIgPSB0aGlzLl9lbmdpbmUuZGV2aWNlLmNyZWF0ZUJ1ZmZlcih7XG4gICAgICAgICAgICBzaXplOiB0aGlzLl9lbmdpbmUudmlld1BhcmFtc0J1ZmZlclNpemUsXG4gICAgICAgICAgICB1c2FnZTogR1BVQnVmZmVyVXNhZ2UuVU5JRk9STSB8IEdQVUJ1ZmZlclVzYWdlLkNPUFlfRFNULFxuICAgICAgICB9KVxuXG4gICAgICAgIHRoaXMuX3ZpZXdQYXJhbXNCaW5kR3JvdXAgPSB0aGlzLl9lbmdpbmUuZGV2aWNlLmNyZWF0ZUJpbmRHcm91cCh7XG4gICAgICAgICAgICBsYXlvdXQ6IHRoaXMuX2VuZ2luZS51bmlmb3Jtc0JHTGF5b3V0LFxuICAgICAgICAgICAgZW50cmllczogW1xuICAgICAgICAgICAgICAgIHsgYmluZGluZzogMCwgcmVzb3VyY2U6IHsgYnVmZmVyOiB0aGlzLl92aWV3UGFyYW1zQnVmZmVyIH0gfSxcbiAgICAgICAgICAgIF0sXG4gICAgICAgIH0pXG4gICAgfVxuXG4gICAgcHVibGljIHVwbG9hZE1vZGVsKHByb3BzOiBJU2NlbmVVcGxvYWRNb2RlbFByb3BzKTogUHJvbWlzZTxJR2FtZU9iamVjdD4ge1xuICAgICAgICBpZiAoIXRoaXMuX2VuZ2luZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgICAgICdGYWlsZWQgdG8gdXBsb2FkIG1vZGVsIGFzIG5vIGluc3RhbmNlIG9mIFdoZWV6eSBFbmdpbmUgaXMgZm91bmQnXG4gICAgICAgICAgICApXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gTW9kZWxVcGxvYWRlci51cGxvYWRNb2RlbChcbiAgICAgICAgICAgIHByb3BzLm1vZGVsRGF0YSxcbiAgICAgICAgICAgIHRoaXMuX29iamVjdE1hbmFnZXIsXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgZGV2aWNlOiB0aGlzLl9lbmdpbmUuZGV2aWNlLFxuICAgICAgICAgICAgICAgIHNoYWRlck1vZHVsZTogcHJvcHMuc2hhZGVyTW9kdWxlLFxuICAgICAgICAgICAgICAgIGNvbG9yRm9ybWF0OiB0aGlzLl9lbmdpbmUuc3dhcENoYWluRm9ybWF0LFxuICAgICAgICAgICAgICAgIGRlcHRoRm9ybWF0OiB0aGlzLl9lbmdpbmUuZGVwdGhUZXh0dXJlRm9ybWF0LFxuICAgICAgICAgICAgICAgIHVuaWZvcm1zQkdMYXlvdXQ6IHRoaXMuX2VuZ2luZS51bmlmb3Jtc0JHTGF5b3V0LFxuICAgICAgICAgICAgICAgIG5vZGVQYXJhbXNCR0xheW91dDogdGhpcy5fZW5naW5lLm5vZGVQYXJhbXNCR0xheW91dCxcbiAgICAgICAgICAgICAgICBtc2FhU2FtcGxlQ291bnQ6IHRoaXMuX2VuZ2luZS5tc2FhU2FtcGxlQ291bnQsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdGhpcy5fYnVmZmVyU3RvcmFnZSxcbiAgICAgICAgICAgIHRoaXMuX2ltYWdlU3RvcmFnZSxcbiAgICAgICAgICAgIHRoaXMuX3NhbXBsZXJTdG9yYWdlLFxuICAgICAgICAgICAgdGhpcy5fbWF0ZXJpYWxTdG9yYWdlLFxuICAgICAgICAgICAgdGhpcy5fdGV4dHVyZVN0b3JhZ2UsXG4gICAgICAgICAgICB0aGlzLl9yb290XG4gICAgICAgIClcbiAgICB9XG5cbiAgICBwcm90ZWN0ZWQgb25SZW5kZXIoZGVsdGFUaW1lOiBudW1iZXIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgJ29uUmVuZGVyIG1ldGhvZCBzaG91bGQgYmUgcmVkZWZpbmVkIGluIGV4dGVuZGluZyBjbGFzcydcbiAgICAgICAgKVxuICAgIH1cblxuICAgIHB1YmxpYyByZW5kZXIoZGVsdGFUaW1lOiBudW1iZXIpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9lbmdpbmUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgICAgICAnRmFpbGVkIHRvIHJlbmRlciBzY2VuZSBhcyBubyBpbnN0YW5jZSBvZiBXaGVlenkgRW5naW5lIGlzIGZvdW5kJ1xuICAgICAgICAgICAgKVxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5vblJlbmRlcihkZWx0YVRpbWUpXG5cbiAgICAgICAgY29uc3QgbWVzaGVzVG9SZW5kZXI6IE1lc2hbXSA9IFtdXG5cbiAgICAgICAgY29uc3Qgdmlld1BhcmFtc1VwbG9hZEJ1ZmZlciA9IHRoaXMuX2VuZ2luZS5kZXZpY2UuY3JlYXRlQnVmZmVyKHtcbiAgICAgICAgICAgIHNpemU6IHRoaXMuX2VuZ2luZS52aWV3UGFyYW1zQnVmZmVyU2l6ZSxcbiAgICAgICAgICAgIHVzYWdlOiBHUFVCdWZmZXJVc2FnZS5DT1BZX1NSQyxcbiAgICAgICAgICAgIG1hcHBlZEF0Q3JlYXRpb246IHRydWUsXG4gICAgICAgIH0pXG5cbiAgICAgICAgY29uc3Qgdmlld01hcCA9IG5ldyBGbG9hdDMyQXJyYXkoXG4gICAgICAgICAgICB2aWV3UGFyYW1zVXBsb2FkQnVmZmVyLmdldE1hcHBlZFJhbmdlKClcbiAgICAgICAgKVxuICAgICAgICB2aWV3TWFwLnNldCh0aGlzLmNhbWVyYS5wcm9qZWN0aW9uTWF0cml4KVxuICAgICAgICB2aWV3TWFwLnNldCh0aGlzLmNhbWVyYS5wb3NpdGlvbiwgMTYpXG5cbiAgICAgICAgdmlld1BhcmFtc1VwbG9hZEJ1ZmZlci51bm1hcCgpXG5cbiAgICAgICAgY29uc3QgaXRlcmF0ZU5vZGUgPSAobm9kZTogU2NlbmVOb2RlQ29udGVudCwgd29ybGRNYXRyaXg6IE1hdDQpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IG5vZGVUcmFuc2Zvcm0gPSBub2RlLmdhbWVPYmplY3QudHJhbnNmb3JtXG5cbiAgICAgICAgICAgIGNvbnN0IG1lc2hNYXRyaXggPSBub2RlVHJhbnNmb3JtXG4gICAgICAgICAgICAgICAgPyBtYXQ0Lm11bCh3b3JsZE1hdHJpeCwgbm9kZVRyYW5zZm9ybS5tYXRyaXgpXG4gICAgICAgICAgICAgICAgOiB3b3JsZE1hdHJpeFxuXG4gICAgICAgICAgICBub2RlPy5nYW1lT2JqZWN0Py5jb21wb25lbnRzPy5mb3JFYWNoKChjb21wb25lbnQ6IGFueSkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5fZW5naW5lKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgICAgICAgICAgICAgICdGYWlsZWQgdG8gaXRlcmF0ZSBub2RlcyBhcyBubyBpbnN0YW5jZSBvZiBXaGVlenkgRW5naW5lIGlzIGZvdW5kJ1xuICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChjb21wb25lbnQudHlwZSA9PT0gRW50aXR5VHlwZXMubWVzaCkge1xuICAgICAgICAgICAgICAgICAgICAvL0ZJWE1FOiB0aGlzIGNhbiBiZSBkb25lIG9uY2UgcGVyIG5vZGUsIGFuZCBvbmx5IGlmIG5vZGUgY29udGFpbnMgbWVzaGVzXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHZpZXdNYXRyaXggPSBtYXQ0LmNvcHkodGhpcy5jYW1lcmEudmlldylcblxuICAgICAgICAgICAgICAgICAgICBtYXQ0LnRyYW5zbGF0ZShcbiAgICAgICAgICAgICAgICAgICAgICAgIHZpZXdNYXRyaXgsXG4gICAgICAgICAgICAgICAgICAgICAgICBtYXQ0LmdldFRyYW5zbGF0aW9uKG1lc2hNYXRyaXgpLFxuICAgICAgICAgICAgICAgICAgICAgICAgdmlld01hdHJpeFxuICAgICAgICAgICAgICAgICAgICApXG5cbiAgICAgICAgICAgICAgICAgICAgbWF0NC5zY2FsZShcbiAgICAgICAgICAgICAgICAgICAgICAgIHZpZXdNYXRyaXgsXG4gICAgICAgICAgICAgICAgICAgICAgICBtYXQ0LmdldFNjYWxpbmcobWVzaE1hdHJpeCksXG4gICAgICAgICAgICAgICAgICAgICAgICB2aWV3TWF0cml4XG4gICAgICAgICAgICAgICAgICAgIClcblxuICAgICAgICAgICAgICAgICAgICAvL0ZJWE1FOiBEbyB0aGlzIG9uY2Ugb24gbG9hZFxuICAgICAgICAgICAgICAgICAgICBjb25zdCBtZXNoUm90YXRpb24gPSBTdHVmZi5leHRyYWN0RXVsZXJSb3RhdGlvbihtZXNoTWF0cml4KVxuXG4gICAgICAgICAgICAgICAgICAgIG1hdDQucm90YXRlWCh2aWV3TWF0cml4LCBtZXNoUm90YXRpb25bMF0sIHZpZXdNYXRyaXgpXG4gICAgICAgICAgICAgICAgICAgIG1hdDQucm90YXRlWSh2aWV3TWF0cml4LCBtZXNoUm90YXRpb25bMV0sIHZpZXdNYXRyaXgpXG4gICAgICAgICAgICAgICAgICAgIG1hdDQucm90YXRlWih2aWV3TWF0cml4LCBtZXNoUm90YXRpb25bMl0sIHZpZXdNYXRyaXgpXG5cbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgbm9kZVBhcmFtc1VwbG9hZEJ1ZmZlciA9XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9lbmdpbmUuZGV2aWNlLmNyZWF0ZUJ1ZmZlcih7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2l6ZTogMTYgKiA0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVzYWdlOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBHUFVCdWZmZXJVc2FnZS5VTklGT1JNIHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgR1BVQnVmZmVyVXNhZ2UuQ09QWV9EU1QsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWFwcGVkQXRDcmVhdGlvbjogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG5vZGVQYXJhbXNNYXAgPSBuZXcgRmxvYXQzMkFycmF5KFxuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZVBhcmFtc1VwbG9hZEJ1ZmZlci5nZXRNYXBwZWRSYW5nZSgpXG4gICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgICAgbm9kZVBhcmFtc01hcC5zZXQodmlld01hdHJpeClcbiAgICAgICAgICAgICAgICAgICAgbm9kZVBhcmFtc1VwbG9hZEJ1ZmZlci51bm1hcCgpXG5cbiAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50Lm5vZGVQYXJhbXNCaW5kR3JvdXAgPVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fZW5naW5lLmRldmljZS5jcmVhdGVCaW5kR3JvdXAoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxheW91dDogdGhpcy5fZW5naW5lLm5vZGVQYXJhbXNCR0xheW91dCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbnRyaWVzOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJpbmRpbmc6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNvdXJjZToge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJ1ZmZlcjogbm9kZVBhcmFtc1VwbG9hZEJ1ZmZlcixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pXG5cbiAgICAgICAgICAgICAgICAgICAgbWVzaGVzVG9SZW5kZXIucHVzaChjb21wb25lbnQpXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSlcblxuICAgICAgICAgICAgbm9kZT8uY2hpbGRyZW4/LmZvckVhY2goKGNoaWxkOiBhbnkpID0+IHtcbiAgICAgICAgICAgICAgICBpdGVyYXRlTm9kZShjaGlsZCwgbWVzaE1hdHJpeClcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLm9iamVjdE1hbmFnZXIuc2NlbmVUcmVlLm5vZGVzLmZvckVhY2goKG5vZGUpID0+IHtcbiAgICAgICAgICAgIGl0ZXJhdGVOb2RlKG5vZGUsIG1hdDQuaWRlbnRpdHkoKSlcbiAgICAgICAgfSlcblxuICAgICAgICBjb25zdCBjb21tYW5kRW5jb2RlciA9IHRoaXMuX2VuZ2luZS5kZXZpY2UuY3JlYXRlQ29tbWFuZEVuY29kZXIoKVxuXG4gICAgICAgIGNvbW1hbmRFbmNvZGVyLmNvcHlCdWZmZXJUb0J1ZmZlcihcbiAgICAgICAgICAgIHZpZXdQYXJhbXNVcGxvYWRCdWZmZXIsXG4gICAgICAgICAgICAwLFxuICAgICAgICAgICAgdGhpcy52aWV3UGFyYW1zQnVmZmVyLFxuICAgICAgICAgICAgMCxcbiAgICAgICAgICAgIHRoaXMuX2VuZ2luZS52aWV3UGFyYW1zQnVmZmVyU2l6ZVxuICAgICAgICApXG4gICAgICAgIDsodGhpcy5yZW5kZXJQYXNzRGVzY3JpcHRvciBhcyBhbnkpLmNvbG9yQXR0YWNobWVudHNbMF0udmlldyA9XG4gICAgICAgICAgICB0aGlzLl9lbmdpbmUuY29udGV4dC5nZXRDdXJyZW50VGV4dHVyZSgpLmNyZWF0ZVZpZXcoKVxuICAgICAgICBpZiAodGhpcy5fZW5naW5lLm1zYWFTYW1wbGVDb3VudCAhPT0gMSkge1xuICAgICAgICAgICAgOyh0aGlzLnJlbmRlclBhc3NEZXNjcmlwdG9yIGFzIGFueSkuY29sb3JBdHRhY2htZW50c1swXS52aWV3ID1cbiAgICAgICAgICAgICAgICB0aGlzLl9tdWx0aXNhbXBsZVRleHR1cmVWaWV3XG4gICAgICAgICAgICA7KFxuICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyUGFzc0Rlc2NyaXB0b3IgYXMgYW55XG4gICAgICAgICAgICApLmNvbG9yQXR0YWNobWVudHNbMF0ucmVzb2x2ZVRhcmdldCA9IHRoaXMuX2VuZ2luZS5jb250ZXh0XG4gICAgICAgICAgICAgICAgLmdldEN1cnJlbnRUZXh0dXJlKClcbiAgICAgICAgICAgICAgICAuY3JlYXRlVmlldygpXG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCByZW5kZXJQYXNzID0gY29tbWFuZEVuY29kZXIuYmVnaW5SZW5kZXJQYXNzKFxuICAgICAgICAgICAgdGhpcy5yZW5kZXJQYXNzRGVzY3JpcHRvclxuICAgICAgICApXG5cbiAgICAgICAgcmVuZGVyUGFzcy5zZXRCaW5kR3JvdXAoMCwgdGhpcy52aWV3UGFyYW1zQmluZEdyb3VwKVxuXG4gICAgICAgIG1lc2hlc1RvUmVuZGVyLmZvckVhY2goKG1lc2gpID0+IHtcbiAgICAgICAgICAgIHJlbmRlclBhc3Muc2V0QmluZEdyb3VwKDEsIG1lc2gubm9kZVBhcmFtc0JpbmRHcm91cCBhcyBHUFVCaW5kR3JvdXApXG4gICAgICAgICAgICBtZXNoLnJlbmRlcihyZW5kZXJQYXNzKVxuICAgICAgICB9KVxuXG4gICAgICAgIHJlbmRlclBhc3MuZW5kKClcbiAgICAgICAgdGhpcy5fZW5naW5lLmRldmljZS5xdWV1ZS5zdWJtaXQoW2NvbW1hbmRFbmNvZGVyLmZpbmlzaCgpXSlcbiAgICAgICAgdmlld1BhcmFtc1VwbG9hZEJ1ZmZlci5kZXN0cm95KClcbiAgICB9XG59XG4iLCJleHBvcnQgKiBmcm9tICcuL1NjZW5lJ1xuIiwiaW1wb3J0IHtcbiAgICBFbnRpdHlJRCxcbiAgICBJU2NlbmVUcmVlLFxuICAgIFNjZW5lTm9kZSxcbiAgICBTY2VuZU5vZGVDb250ZW50LFxuICAgIFNjZW5lVHJlZVBvc2l0aW9uLFxufSBmcm9tICcuLi8uLi90eXBlcydcblxuZXhwb3J0IGNsYXNzIFNjZW5lVHJlZSBpbXBsZW1lbnRzIElTY2VuZVRyZWUge1xuICAgIF9ub2RlczogU2NlbmVOb2RlID0gbmV3IE1hcCgpXG5cbiAgICBwdWJsaWMgZ2V0Tm9kZUNvbnRlbnRBdChwb3NpdGlvbjogU2NlbmVUcmVlUG9zaXRpb24pIHtcbiAgICAgICAgbGV0IGN1cnJlbnRUcmVlTm9kZSA9IHRoaXMuX25vZGVzLmdldChwb3NpdGlvblswXSlcblxuICAgICAgICBmb3IgKGxldCBpID0gMTsgaSA8IHBvc2l0aW9uLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjdXJyZW50VHJlZU5vZGUgPSBjdXJyZW50VHJlZU5vZGU/LmNoaWxkcmVuPy5nZXQocG9zaXRpb25baV0pXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gY3VycmVudFRyZWVOb2RlID8/IG51bGxcbiAgICB9XG5cbiAgICBwdWJsaWMgYWRkTm9kZUF0KFxuICAgICAgICBwb3NpdGlvbjogU2NlbmVUcmVlUG9zaXRpb24gfCBudWxsLFxuICAgICAgICBub2RlQ29udGVudDogU2NlbmVOb2RlQ29udGVudFxuICAgICk6IFNjZW5lVHJlZVBvc2l0aW9uIHtcbiAgICAgICAgaWYgKCFwb3NpdGlvbikge1xuICAgICAgICAgICAgdGhpcy5fbm9kZXMuc2V0KG5vZGVDb250ZW50LmdhbWVPYmplY3QuaWQsIG5vZGVDb250ZW50KVxuXG4gICAgICAgICAgICByZXR1cm4gW25vZGVDb250ZW50LmdhbWVPYmplY3QuaWRdXG4gICAgICAgIH1cblxuICAgICAgICBsZXQgY3VycmVudFRyZWVOb2RlID0gdGhpcy5nZXROb2RlQ29udGVudEF0KHBvc2l0aW9uKVxuXG4gICAgICAgIGN1cnJlbnRUcmVlTm9kZT8uY2hpbGRyZW4/LnNldChub2RlQ29udGVudC5nYW1lT2JqZWN0LmlkLCBub2RlQ29udGVudClcblxuICAgICAgICByZXR1cm4gWy4uLnBvc2l0aW9uLCBub2RlQ29udGVudC5nYW1lT2JqZWN0LmlkXVxuICAgIH1cblxuICAgIHB1YmxpYyByZXBhcmVudE5vZGUoXG4gICAgICAgIHRhcmdldDogU2NlbmVUcmVlUG9zaXRpb24gfCBudWxsLFxuICAgICAgICBjaGlsZDogU2NlbmVUcmVlUG9zaXRpb25cbiAgICApOiBTY2VuZVRyZWVQb3NpdGlvbiB7XG4gICAgICAgIGNvbnN0IG5vZGVDb250ZW50ID0gdGhpcy5nZXROb2RlQ29udGVudEF0KGNoaWxkKVxuXG4gICAgICAgIGlmICghbm9kZUNvbnRlbnQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgTm8gbm9kZSBmb3VuZCBhdCBwb3NpdGlvbiAke2NoaWxkLmpvaW4oKX1gKVxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgbmV3UG9zaXRpb24gPSB0aGlzLmFkZE5vZGVBdCh0YXJnZXQsIG5vZGVDb250ZW50KVxuICAgICAgICB0aGlzLnJlbW92ZU5vZGUoY2hpbGQpXG5cbiAgICAgICAgcmV0dXJuIG5ld1Bvc2l0aW9uXG4gICAgfVxuXG4gICAgcHVibGljIHJlbW92ZU5vZGUodGFyZ2V0UG9zaXRpb246IFNjZW5lVHJlZVBvc2l0aW9uKTogRW50aXR5SURbXSB7XG4gICAgICAgIGNvbnN0IHBhcmVudFBvc2l0aW9uID0gdGFyZ2V0UG9zaXRpb24uc2xpY2UoXG4gICAgICAgICAgICAwLFxuICAgICAgICAgICAgdGFyZ2V0UG9zaXRpb24ubGVuZ3RoIC0gMVxuICAgICAgICApXG5cbiAgICAgICAgY29uc3QgcGFyZW50Tm9kZSA9IHRoaXMuZ2V0Tm9kZUNvbnRlbnRBdChwYXJlbnRQb3NpdGlvbilcblxuICAgICAgICBjb25zdCBjaGlsZHJlbklkczogRW50aXR5SURbXSA9IFtdXG4gICAgICAgIHRoaXMudHJhdmVyc2VOb2RlKHBhcmVudE5vZGU/LmNoaWxkcmVuLCAobm9kZUlkKSA9PiB7XG4gICAgICAgICAgICBjaGlsZHJlbklkcy5wdXNoKG5vZGVJZClcbiAgICAgICAgfSlcblxuICAgICAgICBwYXJlbnROb2RlPy5jaGlsZHJlbj8uZGVsZXRlKHRhcmdldFBvc2l0aW9uW3RhcmdldFBvc2l0aW9uLmxlbmd0aCAtIDFdKVxuXG4gICAgICAgIHJldHVybiBjaGlsZHJlbklkc1xuICAgIH1cblxuICAgIHByaXZhdGUgdHJhdmVyc2VOb2RlKFxuICAgICAgICBub2RlOiBTY2VuZU5vZGUgfCBudWxsIHwgdW5kZWZpbmVkLFxuICAgICAgICBjYWxsYmFjazogKG5vZGVJZDogRW50aXR5SUQsIG5vZGVDb250ZW50OiBTY2VuZU5vZGVDb250ZW50KSA9PiB2b2lkXG4gICAgKSB7XG4gICAgICAgIGNvbnN0IGl0ZXJhdGUgPSAoc2NlbmVOb2RlPzogU2NlbmVOb2RlIHwgbnVsbCkgPT4ge1xuICAgICAgICAgICAgaWYgKCFzY2VuZU5vZGUpIHJldHVyblxuXG4gICAgICAgICAgICBzY2VuZU5vZGUuZm9yRWFjaCgodmFsdWUsIGtleSkgPT4ge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKGtleSwgdmFsdWUpXG4gICAgICAgICAgICAgICAgaXRlcmF0ZSh2YWx1ZS5jaGlsZHJlbilcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH1cblxuICAgICAgICBpdGVyYXRlKG5vZGUpXG4gICAgfVxuXG4gICAgZ2V0IG5vZGVzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbm9kZXNcbiAgICB9XG59XG4iLCJleHBvcnQgKiBmcm9tICcuL1NjZW5lVHJlZSdcbiIsImltcG9ydCB7IElUZXh0dXJlLCBJVGV4dHVyZVN0b3JhZ2UgfSBmcm9tICcuLi8uLi90eXBlcy9jb3JlL1RleHR1cmVTdG9yYWdlJ1xuXG5leHBvcnQgY2xhc3MgVGV4dHVyZVN0b3JhZ2UgaW1wbGVtZW50cyBJVGV4dHVyZVN0b3JhZ2Uge1xuICAgIF90ZXh0dXJlczogTWFwPHN0cmluZywgSVRleHR1cmU+ID0gbmV3IE1hcCgpXG5cbiAgICBnZXQgdGV4dHVyZXMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl90ZXh0dXJlc1xuICAgIH1cbn1cbiIsImV4cG9ydCAqIGZyb20gJy4vVGV4dHVyZVN0b3JhZ2UnXG4iLCJpbXBvcnQgeyBtYXQ0LCB2ZWMzLCBWZWMzIH0gZnJvbSAnd2dwdS1tYXRyaXgnXG5pbXBvcnQge1xuICAgIEVudGl0eVR5cGVzLFxuICAgIElHYW1lT2JqZWN0LFxuICAgIElSb3RhdGVSYWRpYW5zUHJvcHMsXG4gICAgVHJhbnNmb3JtYXRpb25NYXRyaXgsXG59IGZyb20gJy4uLy4uL3R5cGVzJ1xuaW1wb3J0IHsgSVRyYW5zZm9ybSB9IGZyb20gJy4uLy4uL3R5cGVzJ1xuaW1wb3J0IHsgQ29tcG9uZW50IH0gZnJvbSAnLi4vQ29tcG9uZW50J1xuXG5leHBvcnQgY2xhc3MgVHJhbnNmb3JtXG4gICAgZXh0ZW5kcyBDb21wb25lbnQ8RW50aXR5VHlwZXMudHJhbnNmb3JtPlxuICAgIGltcGxlbWVudHMgSVRyYW5zZm9ybVxue1xuICAgIG1hdHJpeDogVHJhbnNmb3JtYXRpb25NYXRyaXhcblxuICAgIHByaXZhdGUgX3Bvc2l0aW9uOiBGbG9hdDMyQXJyYXlcblxuICAgIGNvbnN0cnVjdG9yKHBhcmVudDogSUdhbWVPYmplY3QsIG1hdHJpeD86IFRyYW5zZm9ybWF0aW9uTWF0cml4KSB7XG4gICAgICAgIHN1cGVyKHBhcmVudCwgRW50aXR5VHlwZXMudHJhbnNmb3JtKVxuICAgICAgICB0aGlzLm1hdHJpeCA9IG1hdHJpeCA/IG1hdDQuY29weShtYXRyaXgpIDogbWF0NC5pZGVudGl0eSgpXG4gICAgICAgIHRoaXMuX3Bvc2l0aW9uID0gbmV3IEZsb2F0MzJBcnJheSh0aGlzLm1hdHJpeC5idWZmZXIsIDQgKiAxMiwgNClcbiAgICB9XG5cbiAgICBzY2FsZSh2YWx1ZTogVmVjMykge1xuICAgICAgICBtYXQ0LnNjYWxlKHRoaXMubWF0cml4LCB2YWx1ZSwgdGhpcy5tYXRyaXgpXG4gICAgfVxuXG4gICAgdHJhbnNsYXRlKHZhbHVlOiBWZWMzKSB7XG4gICAgICAgIHRoaXMuX3Bvc2l0aW9uID0gdmVjMy5jb3B5KHZhbHVlLCB0aGlzLl9wb3NpdGlvbilcbiAgICB9XG5cbiAgICByb3RhdGVSYWRpYW5zKHsgeCwgeSwgeiB9OiBJUm90YXRlUmFkaWFuc1Byb3BzKSB7XG4gICAgICAgIGNvbnN0IG5ld01hdHJpeCA9IG1hdDQuY29weSh0aGlzLm1hdHJpeClcblxuICAgICAgICB4ICYmIG1hdDQucm90YXRlWChuZXdNYXRyaXgsIHgsIG5ld01hdHJpeClcbiAgICAgICAgeSAmJiBtYXQ0LnJvdGF0ZVkobmV3TWF0cml4LCB5LCBuZXdNYXRyaXgpXG4gICAgICAgIHogJiYgbWF0NC5yb3RhdGVaKG5ld01hdHJpeCwgeiwgbmV3TWF0cml4KVxuXG4gICAgICAgIG1hdDQuY29weShuZXdNYXRyaXgsIHRoaXMubWF0cml4KVxuICAgIH1cblxuICAgIHJvdGF0ZURlZ3JlZXNFdWxlcih7IHgsIHksIHogfTogSVJvdGF0ZVJhZGlhbnNQcm9wcykge1xuICAgICAgICBjb25zdCBkZWdyZWVUb1JhZCA9IDAuMDE3NDUzMjkyNTJcbiAgICAgICAgdGhpcy5yb3RhdGVSYWRpYW5zKHtcbiAgICAgICAgICAgIHg6ICh4ID8/IDApICogZGVncmVlVG9SYWQsXG4gICAgICAgICAgICB5OiAoeSA/PyAwKSAqIGRlZ3JlZVRvUmFkLFxuICAgICAgICAgICAgejogKHogPz8gMCkgKiBkZWdyZWVUb1JhZCxcbiAgICAgICAgfSlcbiAgICB9XG59XG4iLCJleHBvcnQgKiBmcm9tICcuL1RyYW5zZm9ybSdcbiIsImltcG9ydCB7IG1hdDQsIE1hdDQsIFZlYzMsIHZlYzMgfSBmcm9tICd3Z3B1LW1hdHJpeCdcbmltcG9ydCB7IElBcmNCYWxsQ2FtZXJhIH0gZnJvbSAnLi4vLi4vLi4vdHlwZXMvY29yZS9DYW1lcmEnXG5pbXBvcnQgeyBDYW1lcmEsIElDYW1lcmFQcm9wcyB9IGZyb20gJy4uL0NhbWVyYSdcblxuZXhwb3J0IGludGVyZmFjZSBBcmNCYWxsQ2FtZXJhUHJvcHMgZXh0ZW5kcyBJQ2FtZXJhUHJvcHMge31cblxuZXhwb3J0IGNsYXNzIEFyY0JhbGxDYW1lcmEgZXh0ZW5kcyBDYW1lcmEgaW1wbGVtZW50cyBJQXJjQmFsbENhbWVyYSB7XG4gICAgcHJpdmF0ZSBfZGlzdGFuY2UgPSAwXG4gICAgcHJpdmF0ZSBfYXhpcyA9IHZlYzMuY3JlYXRlKClcblxuICAgIGNvbnN0cnVjdG9yKHByb3BzOiBBcmNCYWxsQ2FtZXJhUHJvcHMpIHtcbiAgICAgICAgc3VwZXIocHJvcHMpXG5cbiAgICAgICAgY29uc3QgcG9zaXRpb25WZWMgPSBwcm9wcz8ucG9zaXRpb24gPz8gdmVjMy5jcmVhdGUoMCwgMCwgMClcbiAgICAgICAgc3VwZXIucG9zaXRpb24gPSBwb3NpdGlvblZlY1xuICAgICAgICB0aGlzLl9kaXN0YW5jZSA9IHZlYzMubGVuKHN1cGVyLnBvc2l0aW9uKVxuICAgICAgICBzdXBlci5iYWNrID0gdmVjMy5ub3JtYWxpemUoc3VwZXIucG9zaXRpb24pXG4gICAgICAgIHRoaXMucmVjYWxjdWxhdGVSaWdodCgpXG4gICAgICAgIHRoaXMucmVjYWxjdWxhdGVVcCgpXG4gICAgICAgIHN1cGVyLnZpZXcgPSBtYXQ0LmludmVydChzdXBlci5tYXRyaXgpXG4gICAgfVxuXG4gICAgZ2V0IGF4aXMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9heGlzXG4gICAgfVxuXG4gICAgc2V0IGF4aXModmVjOiBWZWMzKSB7XG4gICAgICAgIHZlYzMuY29weSh2ZWMsIHRoaXMuX2F4aXMpXG4gICAgfVxuXG4gICAgZ2V0IGRpc3RhbmNlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGlzdGFuY2VcbiAgICB9XG5cbiAgICBzZXQgZGlzdGFuY2UodmFsdWUpIHtcbiAgICAgICAgdGhpcy5fZGlzdGFuY2UgPSB2YWx1ZVxuICAgIH1cblxuICAgIGdldCBtYXRyaXgoKSB7XG4gICAgICAgIHJldHVybiBzdXBlci5tYXRyaXhcbiAgICB9XG5cbiAgICBzZXQgbWF0cml4KG1hdDogTWF0NCkge1xuICAgICAgICBzdXBlci5tYXRyaXggPSBtYXRcbiAgICAgICAgdGhpcy5fZGlzdGFuY2UgPSB2ZWMzLmxlbihzdXBlci5wb3NpdGlvbilcbiAgICB9XG5cbiAgICByZWNhbGN1bGF0ZVJpZ2h0KCkge1xuICAgICAgICBzdXBlci5yaWdodCA9IHZlYzMubm9ybWFsaXplKHZlYzMuY3Jvc3Moc3VwZXIudXAsIHN1cGVyLmJhY2spKVxuICAgIH1cblxuICAgIHJlY2FsY3VsYXRlVXAoKSB7XG4gICAgICAgIHN1cGVyLnVwID0gdmVjMy5ub3JtYWxpemUodmVjMy5jcm9zcyhzdXBlci5iYWNrLCBzdXBlci5yaWdodCkpXG4gICAgfVxufVxuIiwiZXhwb3J0ICogZnJvbSAnLi9BcmNCYWxsQ2FtZXJhJ1xuIiwiaW1wb3J0IHsgTWF0NCwgbWF0NCwgdmVjMywgVmVjMyB9IGZyb20gJ3dncHUtbWF0cml4J1xuaW1wb3J0IHsgRW50aXR5VHlwZXMgfSBmcm9tICcuLi8uLi8uLi90eXBlcydcbmltcG9ydCB7IEVudGl0eSB9IGZyb20gJy4uLy4uL0VudGl0eSdcbmltcG9ydCB7IElDYW1lcmEgfSBmcm9tICcuLi8uLi8uLi90eXBlcy9jb3JlL0NhbWVyYSdcblxuZXhwb3J0IGludGVyZmFjZSBJQ2FtZXJhUHJvcHMge1xuICAgIHpGYXI/OiBudW1iZXJcbiAgICB6TmVhcj86IG51bWJlclxuICAgIHBvc2l0aW9uPzogVmVjM1xuICAgIHRhcmdldD86IFZlYzNcbiAgICBjYW52YXNXaWR0aDogbnVtYmVyXG4gICAgY2FudmFzSGVpZ2h0OiBudW1iZXJcbn1cblxuZXhwb3J0IGNsYXNzIENhbWVyYSBleHRlbmRzIEVudGl0eTxFbnRpdHlUeXBlcy5jYW1lcmE+IGltcGxlbWVudHMgSUNhbWVyYSB7XG4gICAgcHJpdmF0ZSByZWFkb25seSBfdmlldyA9IG1hdDQuY3JlYXRlKClcblxuICAgIHByaXZhdGUgX21hdHJpeCA9IG5ldyBGbG9hdDMyQXJyYXkoW1xuICAgICAgICAxLCAwLCAwLCAwLCAwLCAxLCAwLCAwLCAwLCAwLCAxLCAwLCAwLCAwLCAwLCAxLFxuICAgIF0pXG4gICAgcHJpdmF0ZSBfcmlnaHQgPSBuZXcgRmxvYXQzMkFycmF5KHRoaXMuX21hdHJpeC5idWZmZXIsIDQgKiAwLCA0KVxuICAgIHByaXZhdGUgX3VwID0gbmV3IEZsb2F0MzJBcnJheSh0aGlzLl9tYXRyaXguYnVmZmVyLCA0ICogNCwgNClcbiAgICBwcml2YXRlIF9iYWNrID0gbmV3IEZsb2F0MzJBcnJheSh0aGlzLl9tYXRyaXguYnVmZmVyLCA0ICogOCwgNClcbiAgICBwcml2YXRlIF9wb3NpdGlvbiA9IG5ldyBGbG9hdDMyQXJyYXkodGhpcy5fbWF0cml4LmJ1ZmZlciwgNCAqIDEyLCA0KVxuXG4gICAgcHJpdmF0ZSBfekZhcjogbnVtYmVyXG4gICAgcHJpdmF0ZSBfek5lYXI6IG51bWJlclxuICAgIHByaXZhdGUgX2FzcGVjdFJhdGlvOiBudW1iZXJcbiAgICBwcml2YXRlIF9wcm9qZWN0aW9uTWF0cml4XG5cbiAgICBjb25zdHJ1Y3Rvcihwcm9wczogSUNhbWVyYVByb3BzKSB7XG4gICAgICAgIHN1cGVyKEVudGl0eVR5cGVzLmNhbWVyYSlcblxuICAgICAgICB0aGlzLl96RmFyID0gcHJvcHM/LnpGYXIgPz8gMTAwMFxuICAgICAgICB0aGlzLl96TmVhciA9IHByb3BzPy56TmVhciA/PyAwLjFcbiAgICAgICAgdGhpcy5fYXNwZWN0UmF0aW8gPSBwcm9wcy5jYW52YXNXaWR0aCAvIHByb3BzLmNhbnZhc0hlaWdodFxuICAgICAgICB0aGlzLl9wcm9qZWN0aW9uTWF0cml4ID0gbWF0NC5wZXJzcGVjdGl2ZShcbiAgICAgICAgICAgICgyICogTWF0aC5QSSkgLyA1LFxuICAgICAgICAgICAgdGhpcy5fYXNwZWN0UmF0aW8sXG4gICAgICAgICAgICB0aGlzLl96TmVhcixcbiAgICAgICAgICAgIHRoaXMuX3pGYXJcbiAgICAgICAgKVxuICAgIH1cblxuICAgIGdldCBhc3BlY3RSYXRpbygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FzcGVjdFJhdGlvXG4gICAgfVxuXG4gICAgZ2V0IHpGYXIoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl96RmFyXG4gICAgfVxuXG4gICAgZ2V0IHpOZWFyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fek5lYXJcbiAgICB9XG5cbiAgICBnZXQgcHJvamVjdGlvbk1hdHJpeCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3Byb2plY3Rpb25NYXRyaXhcbiAgICB9XG5cbiAgICBnZXQgdmlldygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ZpZXdcbiAgICB9XG5cbiAgICBzZXQgdmlldyhtYXQ6IE1hdDQpIHtcbiAgICAgICAgbWF0NC5jb3B5KG1hdCwgdGhpcy5fdmlldylcbiAgICB9XG5cbiAgICBnZXQgcmlnaHQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9yaWdodFxuICAgIH1cblxuICAgIHNldCByaWdodCh2ZWM6IFZlYzMpIHtcbiAgICAgICAgdmVjMy5jb3B5KHZlYywgdGhpcy5fcmlnaHQpXG4gICAgfVxuXG4gICAgZ2V0IHVwKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fdXBcbiAgICB9XG5cbiAgICBzZXQgdXAodmVjOiBWZWMzKSB7XG4gICAgICAgIHZlYzMuY29weSh2ZWMsIHRoaXMuX3VwKVxuICAgIH1cblxuICAgIGdldCBiYWNrKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYmFja1xuICAgIH1cblxuICAgIHNldCBiYWNrKHZlYzogVmVjMykge1xuICAgICAgICB2ZWMzLmNvcHkodmVjLCB0aGlzLl9iYWNrKVxuICAgIH1cblxuICAgIGdldCBtYXRyaXgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9tYXRyaXhcbiAgICB9XG5cbiAgICBzZXQgbWF0cml4KHZhbHVlOiBNYXQ0KSB7XG4gICAgICAgIHRoaXMuX21hdHJpeCA9IG1hdDQuY29weSh2YWx1ZSwgdGhpcy5fbWF0cml4KVxuICAgIH1cblxuICAgIGdldCBwb3NpdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3Bvc2l0aW9uXG4gICAgfVxuXG4gICAgc2V0IHBvc2l0aW9uKHZhbHVlOiBWZWMzKSB7XG4gICAgICAgIHZlYzMuY29weSh2YWx1ZSwgdGhpcy5fcG9zaXRpb24pXG4gICAgfVxufVxuIiwiZXhwb3J0ICogZnJvbSAnLi9DYW1lcmEnXG4iLCJpbXBvcnQgeyBNYXQ0LCBtYXQ0LCB2ZWMzLCBWZWMzLCB2ZWM0IH0gZnJvbSAnd2dwdS1tYXRyaXgnXG5pbXBvcnQgeyBTdHVmZiB9IGZyb20gJy4uLy4uLy4uLy4uL3V0aWxzL1N0dWZmJ1xuaW1wb3J0IHsgQ2FtZXJhLCBJQ2FtZXJhUHJvcHMgfSBmcm9tICcuLi9DYW1lcmEvQ2FtZXJhJ1xuaW1wb3J0IHsgSVBlcnNwZWN0aXZlQ2FtZXJhIH0gZnJvbSAnLi4vLi4vLi4vdHlwZXMvY29yZS9DYW1lcmEnXG5cbmV4cG9ydCBpbnRlcmZhY2UgUGVyc3BlY3RpdmVDYW1lcmFQcm9wcyBleHRlbmRzIElDYW1lcmFQcm9wcyB7fVxuXG5leHBvcnQgY2xhc3MgUGVyc3BlY3RpdmVDYW1lcmEgZXh0ZW5kcyBDYW1lcmEgaW1wbGVtZW50cyBJUGVyc3BlY3RpdmVDYW1lcmEge1xuICAgIHB1YmxpYyBwaXRjaCA9IDBcbiAgICBwdWJsaWMgeWF3ID0gMFxuXG4gICAgY29uc3RydWN0b3IocHJvcHM6IFBlcnNwZWN0aXZlQ2FtZXJhUHJvcHMpIHtcbiAgICAgICAgc3VwZXIocHJvcHMpXG5cbiAgICAgICAgY29uc3QgcG9zaXRpb25WZWMgPSBwcm9wcz8ucG9zaXRpb24gPz8gdmVjMy5jcmVhdGUoMCwgMCwgMClcbiAgICAgICAgY29uc3QgdGFyZ2V0VmVjID0gcHJvcHM/LnRhcmdldCA/PyB2ZWMzLmNvcHkocG9zaXRpb25WZWMpXG4gICAgICAgIGNvbnN0IGJhY2sgPSB2ZWMzLm5vcm1hbGl6ZSh2ZWMzLnN1Yihwb3NpdGlvblZlYywgdGFyZ2V0VmVjKSlcbiAgICAgICAgdGhpcy5fcmVjYWxjdWxhdGVBbmdsZXMoYmFjaylcbiAgICAgICAgc3VwZXIucG9zaXRpb24gPSBwb3NpdGlvblZlY1xuICAgIH1cblxuICAgIHByaXZhdGUgX3JlY2FsY3VsYXRlQW5nbGVzKGRpcmVjdGlvbjogVmVjMykge1xuICAgICAgICB0aGlzLnlhdyA9IE1hdGguYXRhbjIoZGlyZWN0aW9uWzBdLCBkaXJlY3Rpb25bMl0pXG4gICAgICAgIHRoaXMucGl0Y2ggPSAtTWF0aC5hc2luKGRpcmVjdGlvblsxXSlcbiAgICB9XG5cbiAgICB1cGRhdGUoKTogTWF0NCB7XG4gICAgICAgIHRoaXMueWF3ID0gU3R1ZmYubW9kKHRoaXMueWF3LCBNYXRoLlBJICogMilcbiAgICAgICAgdGhpcy5waXRjaCA9IFN0dWZmLmNsYW1wKHRoaXMucGl0Y2gsIC1NYXRoLlBJIC8gMiwgTWF0aC5QSSAvIDIpXG5cbiAgICAgICAgY29uc3QgcG9zaXRpb24gPSB2ZWMzLmNvcHkoc3VwZXIucG9zaXRpb24pXG4gICAgICAgIHN1cGVyLm1hdHJpeCA9IG1hdDQucm90YXRlWChtYXQ0LnJvdGF0aW9uWSh0aGlzLnlhdyksIHRoaXMucGl0Y2gpXG4gICAgICAgIHN1cGVyLnBvc2l0aW9uID0gcG9zaXRpb25cblxuICAgICAgICBzdXBlci52aWV3ID0gbWF0NC5pbnZlcnQoc3VwZXIubWF0cml4KVxuXG4gICAgICAgIHJldHVybiBzdXBlci52aWV3XG4gICAgfVxufVxuIiwiZXhwb3J0ICogZnJvbSAnLi9QZXJzcGVjdGl2ZUNhbWVyYSdcbiIsImV4cG9ydCAqIGZyb20gJy4vQ29tcG9uZW50J1xuZXhwb3J0ICogZnJvbSAnLi9FbnRpdHknXG5leHBvcnQgKiBmcm9tICcuL0dhbWVPYmplY3QnXG5leHBvcnQgKiBmcm9tICcuL09iamVjdE1hbmFnZXInXG5leHBvcnQgKiBmcm9tICcuL1NjZW5lVHJlZSdcbmV4cG9ydCAqIGZyb20gJy4vVHJhbnNmb3JtJ1xuZXhwb3J0ICogZnJvbSAnLi9NZXNoJ1xuZXhwb3J0ICogZnJvbSAnLi9CdWZmZXJTdG9yYWdlJ1xuZXhwb3J0ICogZnJvbSAnLi9JbWFnZVN0b3JhZ2UnXG5leHBvcnQgKiBmcm9tICcuL1NhbXBsZXJTdG9yYWdlJ1xuZXhwb3J0ICogZnJvbSAnLi9UZXh0dXJlU3RvcmFnZSdcbmV4cG9ydCAqIGZyb20gJy4vTWF0ZXJpYWxTdG9yYWdlJ1xuZXhwb3J0ICogZnJvbSAnLi9jYW1lcmFzL0NhbWVyYSdcbmV4cG9ydCAqIGZyb20gJy4vY2FtZXJhcy9QZXJzcGVjdGl2ZUNhbWVyYSdcbmV4cG9ydCAqIGZyb20gJy4vRW5naW5lJ1xuZXhwb3J0ICogZnJvbSAnLi9TY2VuZSdcbiIsImV4cG9ydCBpbnRlcmZhY2UgSUJ1ZmZlclN0b3JhZ2Uge1xuICAgIGJ1ZmZlcnM6IE1hcDxzdHJpbmcsIEFycmF5QnVmZmVyPlxufVxuIiwiaW1wb3J0IHsgRW50aXR5VHlwZSwgSUVudGl0eSB9IGZyb20gJy4uL0VudGl0eSdcbmltcG9ydCB7IElHYW1lT2JqZWN0IH0gZnJvbSAnLi4vR2FtZU9iamVjdCdcblxuZXhwb3J0IGludGVyZmFjZSBJQ29tcG9uZW50PFQgZXh0ZW5kcyBFbnRpdHlUeXBlPiBleHRlbmRzIElFbnRpdHk8VD4ge1xuICAgIHBhcmVudDogSUdhbWVPYmplY3Rcbn1cbiIsImltcG9ydCB7IElTY2VuZSB9IGZyb20gJy4uL1NjZW5lJ1xuXG5leHBvcnQgaW50ZXJmYWNlIElFbmdpbmUge1xuICAgIGFkYXB0ZXI6IEdQVUFkYXB0ZXJcbiAgICBkZXZpY2U6IEdQVURldmljZVxuICAgIGNvbnRleHQ6IEdQVUNhbnZhc0NvbnRleHRcbiAgICBzd2FwQ2hhaW5Gb3JtYXQ6IEdQVVRleHR1cmVGb3JtYXRcbiAgICBkZXB0aFRleHR1cmVGb3JtYXQ6IEdQVVRleHR1cmVGb3JtYXRcbiAgICBkZXB0aFRleHR1cmU6IEdQVVRleHR1cmVcbiAgICBzY2VuZT86IElTY2VuZVxuICAgIHVuaWZvcm1zQkdMYXlvdXQ6IEdQVUJpbmRHcm91cExheW91dFxuICAgIG5vZGVQYXJhbXNCR0xheW91dDogR1BVQmluZEdyb3VwTGF5b3V0XG4gICAgdmlld1BhcmFtc0J1ZmZlclNpemU6IG51bWJlclxuICAgIG1zYWFTYW1wbGVDb3VudD86IG51bWJlclxuXG4gICAgcmVuZGVyOiAodGltZTogbnVtYmVyKSA9PiB2b2lkXG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgSUVuZ2luZVByb3BzIHtcbiAgICBjYW52YXM6IEhUTUxDYW52YXNFbGVtZW50XG4gICAgc3dhcENoYWluRm9ybWF0PzogR1BVVGV4dHVyZUZvcm1hdFxuICAgIGRlcHRoVGV4dHVyZUZvcm1hdD86IEdQVVRleHR1cmVGb3JtYXRcbn1cbiIsImV4cG9ydCBlbnVtIEVudGl0eVR5cGVzIHtcbiAgICBnYW1lT2JqZWN0ID0gJ2dhbWVPYmplY3QnLFxuICAgIG1lc2ggPSAnbWVzaCcsXG4gICAgbWF0ZXJpYWwgPSAnbWF0ZXJpYWwnLFxuICAgIHRyYW5zZm9ybSA9ICd0cmFuc2Zvcm0nLFxuICAgIGNhbWVyYSA9ICdjYW1lcmEnLFxuICAgIGNvbGxpZGVyID0gJ2NvbGxpZGVyJyxcbiAgICBwaHlzaWNzT2JqZWN0ID0gJ3BoeXNpY3NPYmplY3QnLFxufVxuXG5leHBvcnQgdHlwZSBFbnRpdHlUeXBlID0ga2V5b2YgdHlwZW9mIEVudGl0eVR5cGVzXG5cbmV4cG9ydCB0eXBlIEVudGl0eUlEID0gc3RyaW5nXG5cbmV4cG9ydCBpbnRlcmZhY2UgSUVudGl0eTxUIGV4dGVuZHMgUGFydGlhbDxFbnRpdHlUeXBlPj4ge1xuICAgIGlkOiBFbnRpdHlJRFxuICAgIHR5cGU6IFRcbn1cbiIsImltcG9ydCB7IElDb21wb25lbnQgfSBmcm9tICcuLi9Db21wb25lbnQnXG5pbXBvcnQgeyBFbnRpdHlJRCwgRW50aXR5VHlwZXMsIElFbnRpdHkgfSBmcm9tICcuLi9FbnRpdHknXG5pbXBvcnQgeyBJVHJhbnNmb3JtIH0gZnJvbSAnLi4vVHJhbnNmb3JtJ1xuXG5leHBvcnQgaW50ZXJmYWNlIElHYW1lT2JqZWN0IGV4dGVuZHMgSUVudGl0eTxFbnRpdHlUeXBlcy5nYW1lT2JqZWN0PiB7XG4gICAgbmFtZTogc3RyaW5nXG4gICAgdHJhbnNmb3JtOiBJVHJhbnNmb3JtXG4gICAgb25VcGRhdGU/OiAoZHQ6IG51bWJlcikgPT4gdm9pZFxuICAgIC8vRklYTUU6IHR5cGUgaW5jbHVkZXMgZ2FtZU9iamVjdFxuICAgIGNvbXBvbmVudHM6IE1hcDxFbnRpdHlJRCwgSUNvbXBvbmVudDxFbnRpdHlUeXBlcz4+XG4gICAgYWRkQ29tcG9uZW50OiAoY29tcG9uZW50OiBJQ29tcG9uZW50PEVudGl0eVR5cGVzPikgPT4gdm9pZFxuICAgIHJlbW92ZUNvbXBvbmVudDogKGlkOiBFbnRpdHlJRCkgPT4gdm9pZFxufVxuIiwiZXhwb3J0IGludGVyZmFjZSBJSW1hZ2VTdG9yYWdlIHtcbiAgICBpbWFnZXM6IE1hcDxzdHJpbmcsIEltYWdlQml0bWFwPlxufVxuIiwiaW1wb3J0IHsgSUNvbXBvbmVudCB9IGZyb20gJy4uL0NvbXBvbmVudCdcbmltcG9ydCB7IEVudGl0eVR5cGVzIH0gZnJvbSAnLi4vRW50aXR5J1xuaW1wb3J0IHsgVmVjMywgVmVjNCB9IGZyb20gJ3dncHUtbWF0cml4J1xuXG5leHBvcnQgaW50ZXJmYWNlIEdMVEZCdWZmZXJEYXRhIHtcbiAgICBpZDogc3RyaW5nXG4gICAgYnVmZmVyOiBHUFVCdWZmZXJcbn1cblxuZXhwb3J0IGludGVyZmFjZSBJTWF0ZXJpYWxUZXh0dXJlIHtcbiAgICB2aWV3OiBHUFVUZXh0dXJlVmlld1xuICAgIHNhbXBsZXI6IEdQVVNhbXBsZXJcbn1cblxuZXhwb3J0IGludGVyZmFjZSBJTWF0ZXJpYWwge1xuICAgIG5hbWU/OiBzdHJpbmdcblxuICAgIGJhc2VDb2xvclRleHR1cmU/OiBJTWF0ZXJpYWxUZXh0dXJlXG4gICAgbWV0YWxsaWNSb3VnaG5lc3NUZXh0dXJlPzogSU1hdGVyaWFsVGV4dHVyZVxuICAgIG5vcm1hbFRleHR1cmU/OiBJTWF0ZXJpYWxUZXh0dXJlXG4gICAgZW1pc3NpdmVUZXh0dXJlPzogSU1hdGVyaWFsVGV4dHVyZVxuICAgIG9jY2x1c2lvblRleHR1cmU/OiBJTWF0ZXJpYWxUZXh0dXJlXG5cbiAgICBtZXRhbGxpY0ZhY3RvcjogbnVtYmVyXG4gICAgcm91Z2huZXNzRmFjdG9yOiBudW1iZXJcblxuICAgIGVtaXNzaXZlRmFjdG9yPzogVmVjM1xuICAgIGJhc2VDb2xvckZhY3RvcjogVmVjNFxufVxuXG5leHBvcnQgaW50ZXJmYWNlIEdMVEZBY2Nlc3NvciB7XG4gICAgYnl0ZVN0cmlkZTogbnVtYmVyXG4gICAgY291bnQ6IG51bWJlclxuICAgIGNvbXBvbmVudFR5cGU6IG51bWJlclxuICAgIGVsZW1lbnRUeXBlOiBHUFVWZXJ0ZXhGb3JtYXQgLy9GSVhNRTogY291bGQgYmUgR1BVSW5kZXhGb3JtYXRcbiAgICBieXRlT2Zmc2V0OiBudW1iZXJcbiAgICBieXRlTGVuZ3RoOiBudW1iZXJcbiAgICBidWZmZXJJZDogR0xURkJ1ZmZlckRhdGFbJ2lkJ11cbiAgICBtaW4/OiBudW1iZXJbXVxuICAgIG1heD86IG51bWJlcltdXG4gICAgdXNhZ2U6IEdQVUJ1ZmZlclVzYWdlRmxhZ3Ncbn1cblxuZXhwb3J0IGludGVyZmFjZSBJTWVzaCBleHRlbmRzIElDb21wb25lbnQ8RW50aXR5VHlwZXMubWVzaD4ge1xuICAgIC8vaHR0cHM6Ly9yZWdpc3RyeS5raHJvbm9zLm9yZy9nbFRGL3NwZWNzLzIuMC9nbFRGLTIuMC5odG1sI3JlZmVyZW5jZS1tZXNoLXByaW1pdGl2ZVxuICAgIG5vcm1hbHM/OiBHTFRGQWNjZXNzb3JcbiAgICB0YW5nZW50PzogR0xURkFjY2Vzc29yXG4gICAgaW5kaWNlcz86IEdMVEZBY2Nlc3NvclxuICAgIC8vRklYTUU6IGltcGxlbWVudCBkZWZhdWx0IG1hdGVyaWFsIGFjY29yZGluZyB0byBkZWZhdWx0cyBodHRwczovL3JlZ2lzdHJ5Lmtocm9ub3Mub3JnL2dsVEYvc3BlY3MvMi4wL2dsVEYtMi4wLmh0bWwjcmVmZXJlbmNlLW1hdGVyaWFsXG4gICAgbWF0ZXJpYWw/OiBJTWF0ZXJpYWwgLy9pZiBub3QgcHJlc2VudCBpbiB0aGUgZmlsZSwgYSBkZWZhdWx0IG1hdGVyaWFsIHNob3VsZCBiZSB1c2VkXG4gICAgcG9zaXRpb25zOiBHTFRGQWNjZXNzb3JcbiAgICBtb2RlOiBudW1iZXIgLy9ncHUgdG9wb2xvZ3kgLSBkZWZhdWx0IGlzIDQgKHRyaWFuZ2xlcylcbn1cbiIsImltcG9ydCB7IElHYW1lT2JqZWN0IH0gZnJvbSAnLi4vR2FtZU9iamVjdCdcbmltcG9ydCB7IElTY2VuZVRyZWUgfSBmcm9tICcuLi9TY2VuZVRyZWUnXG5cbmV4cG9ydCBpbnRlcmZhY2UgSU9iamVjdE1hbmFnZXIge1xuICAgIGFkZE9iamVjdDogKGNoaWxkOiBJR2FtZU9iamVjdCwgdGFyZ2V0PzogSUdhbWVPYmplY3QpID0+IHZvaWRcbiAgICByZXBhcmVudE9iamVjdDogKGNoaWxkOiBJR2FtZU9iamVjdCwgdGFyZ2V0PzogSUdhbWVPYmplY3QpID0+IHZvaWRcbiAgICBkZXN0cm95T2JqZWN0OiAoZ2FtZU9iamVjdDogSUdhbWVPYmplY3QpID0+IHZvaWRcbiAgICBzY2VuZVRyZWU6IElTY2VuZVRyZWVcbn1cbiIsImV4cG9ydCBpbnRlcmZhY2UgSVNhbXBsZXJTdG9yYWdlIHtcbiAgICBzYW1wbGVyczogTWFwPHN0cmluZywgR1BVU2FtcGxlcj5cbn1cbiIsImltcG9ydCB7IElFbmdpbmUsIElNb2RlbFByZWxvYWREYXRhIH0gZnJvbSAnLi4vLi4nXG5pbXBvcnQgeyBJQnVmZmVyU3RvcmFnZSB9IGZyb20gJy4uL0J1ZmZlclN0b3JhZ2UnXG5pbXBvcnQgeyBJQ2FtZXJhIH0gZnJvbSAnLi4vQ2FtZXJhJ1xuaW1wb3J0IHsgSUdhbWVPYmplY3QgfSBmcm9tICcuLi9HYW1lT2JqZWN0J1xuaW1wb3J0IHsgSUltYWdlU3RvcmFnZSB9IGZyb20gJy4uL0ltYWdlU3RvcmFnZSdcbmltcG9ydCB7IElNYXRlcmlhbFN0b3JhZ2UgfSBmcm9tICcuLi9NYXRlcmlhbFN0b3JhZ2UnXG5pbXBvcnQgeyBJT2JqZWN0TWFuYWdlciB9IGZyb20gJy4uL09iamVjdE1hbmFnZXInXG5pbXBvcnQgeyBJU2FtcGxlclN0b3JhZ2UgfSBmcm9tICcuLi9TYW1wbGVyU3RvcmFnZSdcbmltcG9ydCB7IElUZXh0dXJlU3RvcmFnZSB9IGZyb20gJy4uL1RleHR1cmVTdG9yYWdlJ1xuXG5leHBvcnQgaW50ZXJmYWNlIElTY2VuZVVwbG9hZE1vZGVsUHJvcHMge1xuICAgIG1vZGVsRGF0YTogSU1vZGVsUHJlbG9hZERhdGFcbiAgICBzaGFkZXJNb2R1bGU6IEdQVVNoYWRlck1vZHVsZVxufVxuXG5leHBvcnQgaW50ZXJmYWNlIElTY2VuZSB7XG4gICAgY2FtZXJhOiBJQ2FtZXJhXG4gICAgb2JqZWN0TWFuYWdlcjogSU9iamVjdE1hbmFnZXJcbiAgICBidWZmZXJTdG9yYWdlOiBJQnVmZmVyU3RvcmFnZVxuICAgIGltYWdlU3RvcmFnZTogSUltYWdlU3RvcmFnZVxuICAgIHNhbXBsZXJTdG9yYWdlOiBJU2FtcGxlclN0b3JhZ2VcbiAgICB0ZXh0dXJlU3RvcmFnZTogSVRleHR1cmVTdG9yYWdlXG4gICAgbWF0ZXJpYWxTdG9yYWdlOiBJTWF0ZXJpYWxTdG9yYWdlXG4gICAgcmVuZGVyUGFzc0Rlc2NyaXB0b3I6IEdQVVJlbmRlclBhc3NEZXNjcmlwdG9yXG4gICAgdmlld1BhcmFtc0J1ZmZlcjogR1BVQnVmZmVyXG4gICAgdmlld1BhcmFtc0JpbmRHcm91cDogR1BVQmluZEdyb3VwXG4gICAgbXVsdGlzYW1wbGVUZXh0dXJlVmlldz86IEdQVVRleHR1cmVWaWV3XG4gICAgZW5naW5lOiBJRW5naW5lXG4gICAgcm9vdDogSUdhbWVPYmplY3RcblxuICAgIHVwbG9hZE1vZGVsOiAocHJvcHM6IElTY2VuZVVwbG9hZE1vZGVsUHJvcHMpID0+IFByb21pc2U8SUdhbWVPYmplY3Q+XG4gICAgcmVuZGVyOiAoZGVsdGFUaW1lOiBudW1iZXIpID0+IHZvaWRcbn1cblxuZXhwb3J0IGludGVyZmFjZSBJU2NlbmVQcm9wcyB7XG4gICAgY2FtZXJhPzogSUNhbWVyYVxufVxuIiwiZXhwb3J0ICogZnJvbSAnLi9TY2VuZSdcbiIsImltcG9ydCB7IEVudGl0eUlEIH0gZnJvbSAnLi4vRW50aXR5J1xuaW1wb3J0IHsgSUdhbWVPYmplY3QgfSBmcm9tICcuLi9HYW1lT2JqZWN0J1xuXG5leHBvcnQgdHlwZSBTY2VuZU5vZGUgPSBNYXA8RW50aXR5SUQsIFNjZW5lTm9kZUNvbnRlbnQ+XG5cbmV4cG9ydCB0eXBlIFNjZW5lTm9kZUNvbnRlbnQgPSB7XG4gICAgZ2FtZU9iamVjdDogSUdhbWVPYmplY3RcbiAgICBjaGlsZHJlbjogU2NlbmVOb2RlIHwgbnVsbFxufVxuXG5leHBvcnQgdHlwZSBTY2VuZVRyZWVQb3NpdGlvbiA9IEVudGl0eUlEW11cblxuZXhwb3J0IGludGVyZmFjZSBJU2NlbmVUcmVlIHtcbiAgICBub2RlczogU2NlbmVOb2RlXG4gICAgYWRkTm9kZUF0OiAoXG4gICAgICAgIHBvc2l0aW9uOiBTY2VuZVRyZWVQb3NpdGlvbiB8IG51bGwsXG4gICAgICAgIG5vZGU6IFNjZW5lTm9kZUNvbnRlbnRcbiAgICApID0+IFNjZW5lVHJlZVBvc2l0aW9uXG4gICAgcmVwYXJlbnROb2RlOiAoXG4gICAgICAgIHRhcmdldDogU2NlbmVUcmVlUG9zaXRpb24gfCBudWxsLFxuICAgICAgICBjaGlsZDogU2NlbmVUcmVlUG9zaXRpb25cbiAgICApID0+IFNjZW5lVHJlZVBvc2l0aW9uXG4gICAgLy9yZXR1cm5zIGFuIGFycmF5IG9mIGdhbWVPYmplY3QgaWRzIHRvIGJlIGNsZWFyZWQgZnJvbSBPYmplY3RNYW5hZ2VyXG4gICAgcmVtb3ZlTm9kZTogKHRhcmdldFBvc2l0aW9uOiBTY2VuZVRyZWVQb3NpdGlvbikgPT4gRW50aXR5SURbXVxuICAgIGdldE5vZGVDb250ZW50QXQ6IChwb3NpdGlvbjogU2NlbmVUcmVlUG9zaXRpb24pID0+IFNjZW5lTm9kZUNvbnRlbnQgfCBudWxsXG59XG4iLCJleHBvcnQgaW50ZXJmYWNlIElUZXh0dXJlU3RvcmFnZSB7XG4gICAgdGV4dHVyZXM6IE1hcDxzdHJpbmcsIElUZXh0dXJlPlxufVxuXG5leHBvcnQgaW50ZXJmYWNlIElUZXh0dXJlIHtcbiAgICBzYW1wbGVySWQ6IHN0cmluZ1xuICAgIGltYWdlSWQ6IHN0cmluZ1xufVxuIiwiaW1wb3J0IHsgVmVjMyB9IGZyb20gJ3dncHUtbWF0cml4J1xuaW1wb3J0IHsgSUNvbXBvbmVudCB9IGZyb20gJy4uL0NvbXBvbmVudCdcbmltcG9ydCB7IEVudGl0eVR5cGVzIH0gZnJvbSAnLi4vRW50aXR5J1xuXG5leHBvcnQgdHlwZSBUcmFuc2Zvcm1hdGlvbk1hdHJpeCA9IEZsb2F0MzJBcnJheVxuXG5leHBvcnQgaW50ZXJmYWNlIElSb3RhdGVSYWRpYW5zUHJvcHMge1xuICAgIHg/OiBudW1iZXJcbiAgICB5PzogbnVtYmVyXG4gICAgej86IG51bWJlclxufVxuXG5leHBvcnQgaW50ZXJmYWNlIElUcmFuc2Zvcm0gZXh0ZW5kcyBJQ29tcG9uZW50PEVudGl0eVR5cGVzLnRyYW5zZm9ybT4ge1xuICAgIG1hdHJpeDogVHJhbnNmb3JtYXRpb25NYXRyaXhcbiAgICByb3RhdGVSYWRpYW5zOiAocHJvcHM6IElSb3RhdGVSYWRpYW5zUHJvcHMpID0+IHZvaWRcbiAgICByb3RhdGVEZWdyZWVzRXVsZXI6IChwcm9wczogSVJvdGF0ZVJhZGlhbnNQcm9wcykgPT4gdm9pZFxuICAgIHRyYW5zbGF0ZTogKHZlYzogVmVjMykgPT4gdm9pZFxuICAgIHNjYWxlOiAodmVjOiBWZWMzKSA9PiB2b2lkXG59XG4iLCJpbXBvcnQgeyBNYXQ0LCBWZWMzLCBWZWM0IH0gZnJvbSAnd2dwdS1tYXRyaXgnXG5pbXBvcnQgeyBHTFRGQWNjZXNzb3IgfSBmcm9tICcuL2NvcmUvTWVzaCdcblxuZXhwb3J0ICogZnJvbSAnLi9jb3JlL0VudGl0eSdcbmV4cG9ydCAqIGZyb20gJy4vY29yZS9HYW1lT2JqZWN0J1xuZXhwb3J0ICogZnJvbSAnLi9jb3JlL0NvbXBvbmVudCdcbmV4cG9ydCAqIGZyb20gJy4vY29yZS9TY2VuZVRyZWUnXG5leHBvcnQgKiBmcm9tICcuL2NvcmUvT2JqZWN0TWFuYWdlcidcbmV4cG9ydCAqIGZyb20gJy4vY29yZS9NZXNoJ1xuZXhwb3J0ICogZnJvbSAnLi9jb3JlL1RyYW5zZm9ybSdcbmV4cG9ydCAqIGZyb20gJy4vY29yZS9CdWZmZXJTdG9yYWdlJ1xuZXhwb3J0ICogZnJvbSAnLi9jb3JlL0ltYWdlU3RvcmFnZSdcbmV4cG9ydCAqIGZyb20gJy4vY29yZS9TYW1wbGVyU3RvcmFnZSdcbmV4cG9ydCAqIGZyb20gJy4vY29yZS9UZXh0dXJlU3RvcmFnZSdcbmV4cG9ydCAqIGZyb20gJy4vY29yZS9TY2VuZSdcbmV4cG9ydCAqIGZyb20gJy4vY29yZS9FbmdpbmUnXG5cbi8vRklYTUU6IG1vdmUgdGhpcyBzb21ld2hlcmUgZWxzZVxuZXhwb3J0IGludGVyZmFjZSBJUHJlbG9hZE1lc2gge1xuICAgIHBvc2l0aW9ucz86IEdMVEZBY2Nlc3NvclxuICAgIGluZGljZXM/OiBHTFRGQWNjZXNzb3JcbiAgICBub3JtYWxzPzogR0xURkFjY2Vzc29yXG4gICAgdGV4dHVyZUNvb3JkaW5hdGVzPzogR0xURkFjY2Vzc29yXG4gICAgbWF0ZXJpYWxJZD86IHN0cmluZ1xuICAgIG1vZGU6IG51bWJlclxufVxuXG5leHBvcnQgaW50ZXJmYWNlIElQcmVsb2FkRW50aXR5IHtcbiAgICB0cnNNYXRyaXg6IE1hdDRcbiAgICBtZXNoZXM6IElQcmVsb2FkTWVzaFtdXG4gICAgbmFtZT86IHN0cmluZ1xuICAgIGNoaWxkcmVuOiBJUHJlbG9hZEVudGl0eVtdXG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgSU1vZGVsUHJlbG9hZERhdGEge1xuICAgIGJ1ZmZlcnM6IEJ1ZmZlck1hcFxuICAgIGltYWdlczogSW1hZ2VNYXBcbiAgICBzYW1wbGVyczogU2FtcGxlck1hcFxuICAgIHRleHR1cmVzOiBUZXh0dXJlTWFwXG4gICAgbWF0ZXJpYWxzOiBNYXRlcmlhbE1hcFxuICAgIG1vZGVsOiBJUHJlbG9hZEVudGl0eVxufVxuXG5leHBvcnQgaW50ZXJmYWNlIElNYXRlcmlhbFByZWxvYWREYXRhIHtcbiAgICBuYW1lPzogc3RyaW5nXG4gICAgYmFzZUNvbG9yRmFjdG9yPzogVmVjNCAvL1sxLCAxLCAxLCAxXVxuICAgIGVtaXNzaXZlRmFjdG9yPzogVmVjM1xuICAgIG1ldGFsbGljRmFjdG9yPzogbnVtYmVyIC8vIDFcbiAgICByb3VnaG5lc3NGYWN0b3I/OiBudW1iZXIgLy8gMVxuICAgIGJhc2VDb2xvclRleHR1cmVJZD86IHN0cmluZ1xuICAgIG1ldGFsbGljUm91Z2huZXNzVGV4dHVyZUlkPzogc3RyaW5nXG4gICAgbm9ybWFsVGV4dHVyZUlkPzogc3RyaW5nXG4gICAgb2NjbHVzaW9uVGV4dHVyZUlkPzogc3RyaW5nXG4gICAgZW1pc3NpdmVUZXh0dXJlSWQ/OiBzdHJpbmdcbn1cblxuZXhwb3J0IGludGVyZmFjZSBJVGV4dHVyZVByZWxvYWREYXRhIHtcbiAgICBzYW1wbGVySWQ6IHN0cmluZ1xuICAgIGltYWdlSWQ6IHN0cmluZ1xuICAgIC8vIHVzYWdlOiBHUFVUZXh0dXJlVXNhZ2VGbGFnc1xufVxuXG5leHBvcnQgZW51bSBHTFRGVGV4dHVyZUZpbHRlciB7XG4gICAgTkVBUkVTVCA9IDk3MjgsXG4gICAgTElORUFSID0gOTcyOSxcbiAgICBORUFSRVNUX01JUE1BUF9ORUFSRVNUID0gOTk4NCxcbiAgICBMSU5FQVJfTUlQTUFQX05FQVJFU1QgPSA5OTg1LFxuICAgIE5FQVJFU1RfTUlQTUFQX0xJTkVBUiA9IDk5ODYsXG4gICAgTElORUFSX01JUE1BUF9MSU5FQVIgPSA5OTg3LFxufVxuXG5leHBvcnQgZW51bSBHTFRGVGV4dHVyZVdyYXAge1xuICAgIFJFUEVBVCA9IDEwNDk3LFxuICAgIENMQU1QX1RPX0VER0UgPSAzMzA3MSxcbiAgICBNSVJST1JFRF9SRVBFQVQgPSAzMzY0OCxcbn1cblxuZXhwb3J0IGludGVyZmFjZSBJU2FtcGxlclByZWxvYWREYXRhIHtcbiAgICBtYWdGaWx0ZXI/OiBHTFRGVGV4dHVyZUZpbHRlclxuICAgIG1pbkZpbHRlcj86IEdMVEZUZXh0dXJlRmlsdGVyXG4gICAgd3JhcFM/OiBHTFRGVGV4dHVyZVdyYXBcbiAgICB3cmFwVD86IEdMVEZUZXh0dXJlV3JhcFxufVxuXG5leHBvcnQgaW50ZXJmYWNlIElJbWFnZVByZWxvYWREYXRhIHtcbiAgICBidWZmZXJWaWV3OiB7XG4gICAgICAgIGJ1ZmZlcjogc3RyaW5nXG4gICAgICAgIGJ5dGVMZW5ndGg6IG51bWJlclxuICAgICAgICBieXRlT2Zmc2V0OiBudW1iZXJcbiAgICAgICAgYnl0ZVN0cmlkZTogbnVtYmVyXG4gICAgICAgIHRhcmdldDogbnVtYmVyXG4gICAgfVxuICAgIG1pbWVUeXBlOiBzdHJpbmdcbn1cblxuZXhwb3J0IHR5cGUgQnVmZmVyTWFwID0gTWFwPHN0cmluZywgQXJyYXlCdWZmZXI+XG5leHBvcnQgdHlwZSBJbWFnZU1hcCA9IE1hcDxzdHJpbmcsIElJbWFnZVByZWxvYWREYXRhPlxuZXhwb3J0IHR5cGUgU2FtcGxlck1hcCA9IE1hcDxzdHJpbmcsIElTYW1wbGVyUHJlbG9hZERhdGE+XG5leHBvcnQgdHlwZSBUZXh0dXJlTWFwID0gTWFwPHN0cmluZywgSVRleHR1cmVQcmVsb2FkRGF0YT5cbmV4cG9ydCB0eXBlIE1hdGVyaWFsTWFwID0gTWFwPHN0cmluZywgSU1hdGVyaWFsUHJlbG9hZERhdGE+XG4iLCJpbXBvcnQgeyBDb21wb25lbnQgfSBmcm9tICcuLi8uLi9lbmdpbmUvY29yZSdcbmltcG9ydCB7IEVudGl0eVR5cGVzLCBJR2FtZU9iamVjdCB9IGZyb20gJy4uLy4uL2VuZ2luZS90eXBlcydcblxuZXhwb3J0IGNsYXNzIENvbGxpZGVyIGV4dGVuZHMgQ29tcG9uZW50PEVudGl0eVR5cGVzLmNvbGxpZGVyPiB7XG4gICAgY29uc3RydWN0b3IocGFyZW50OiBJR2FtZU9iamVjdCkge1xuICAgICAgICBzdXBlcihwYXJlbnQsIEVudGl0eVR5cGVzLmNvbGxpZGVyKVxuICAgIH1cbn1cbiIsImltcG9ydCB7IHZlYzMsIFZlYzMgfSBmcm9tICd3Z3B1LW1hdHJpeCdcbmltcG9ydCB7IENvbXBvbmVudCB9IGZyb20gJy4uLy4uL2VuZ2luZS9jb3JlJ1xuaW1wb3J0IHsgRW50aXR5VHlwZXMsIElHYW1lT2JqZWN0IH0gZnJvbSAnLi4vLi4vZW5naW5lL3R5cGVzJ1xuaW1wb3J0IHsgSVBoeXNpY3NPYmplY3QgfSBmcm9tICcuLi8uLi9lbmdpbmUvdHlwZXMvcGh5c2ljcy9QaHlzaWNzT2JqZWN0J1xuXG5leHBvcnQgY2xhc3MgUGh5c2ljc09iamVjdFxuICAgIGV4dGVuZHMgQ29tcG9uZW50PEVudGl0eVR5cGVzLnBoeXNpY3NPYmplY3Q+XG4gICAgaW1wbGVtZW50cyBJUGh5c2ljc09iamVjdFxue1xuICAgIHZlbG9jaXR5OiBWZWMzID0gdmVjMy5jcmVhdGUoMClcblxuICAgIGNvbnN0cnVjdG9yKHBhcmVudDogSUdhbWVPYmplY3QpIHtcbiAgICAgICAgc3VwZXIocGFyZW50LCBFbnRpdHlUeXBlcy5waHlzaWNzT2JqZWN0KVxuICAgIH1cbn1cbiIsImV4cG9ydCAqIGZyb20gJy4vQ29sbGlkZXInXG5leHBvcnQgKiBmcm9tICcuL1BoeXNpY3NPYmplY3QnXG4iLCJpbXBvcnQgeyBtYXQ0LCBNYXQ0LCB2ZWMzLCBWZWMzIH0gZnJvbSAnd2dwdS1tYXRyaXgnXG5cbmV4cG9ydCBjbGFzcyBTdHVmZiB7XG4gICAgc3RhdGljIGNsYW1wKHg6IG51bWJlciwgbWluOiBudW1iZXIsIG1heDogbnVtYmVyKTogbnVtYmVyIHtcbiAgICAgICAgcmV0dXJuIE1hdGgubWluKE1hdGgubWF4KHgsIG1pbiksIG1heClcbiAgICB9XG5cbiAgICBzdGF0aWMgbW9kKHg6IG51bWJlciwgZGl2OiBudW1iZXIpOiBudW1iZXIge1xuICAgICAgICByZXR1cm4geCAtIE1hdGguZmxvb3IoTWF0aC5hYnMoeCkgLyBkaXYpICogZGl2ICogTWF0aC5zaWduKHgpXG4gICAgfVxuXG4gICAgc3RhdGljIGxlcnAoYTogVmVjMywgYjogVmVjMywgczogbnVtYmVyKTogVmVjMyB7XG4gICAgICAgIHJldHVybiB2ZWMzLmFkZFNjYWxlZChhLCB2ZWMzLnN1YihiLCBhKSwgcylcbiAgICB9XG5cbiAgICBzdGF0aWMgcm90YXRlKHZlYzogVmVjMywgYXhpczogVmVjMywgYW5nbGU6IG51bWJlcik6IFZlYzMge1xuICAgICAgICByZXR1cm4gdmVjMy50cmFuc2Zvcm1NYXQ0VXBwZXIzeDModmVjLCBtYXQ0LnJvdGF0aW9uKGF4aXMsIGFuZ2xlKSlcbiAgICB9XG5cbiAgICBzdGF0aWMgZXh0cmFjdEV1bGVyUm90YXRpb24obWF0OiBNYXQ0KTogVmVjMyB7XG4gICAgICAgIC8vIFtcbiAgICAgICAgLy8gICAgIHgxLCB4MiwgeDMsIHg0LCAgLy8gPC0gY29sdW1uIDBcbiAgICAgICAgLy8gICAgIHkxLCB5MiwgeTMsIHk0LCAgLy8gPC0gY29sdW1uIDFcbiAgICAgICAgLy8gICAgIHoxLCB6MiwgejMsIHo0LCAgLy8gPC0gY29sdW1uIDJcbiAgICAgICAgLy8gICAgIHcxLCB3MiwgdzMsIHc0LCAgLy8gPC0gY29sdW1uIDNcbiAgICAgICAgLy8gICBdXG4gICAgICAgIGNvbnN0IHJvdFhhbmdsZSA9IE1hdGguYXRhbjIoLW1hdFs5XSwgbWF0WzEwXSlcbiAgICAgICAgY29uc3QgY29zWWFuZ2xlID0gTWF0aC5zcXJ0KE1hdGgucG93KG1hdFswXSwgMikgKyBNYXRoLnBvdyhtYXRbNF0sIDIpKVxuICAgICAgICBjb25zdCByb3RZYW5nbGUgPSBNYXRoLmF0YW4yKG1hdFs4XSwgY29zWWFuZ2xlKVxuICAgICAgICBjb25zdCBzaW5YYW5nbGUgPSBNYXRoLnNpbihyb3RYYW5nbGUpXG4gICAgICAgIGNvbnN0IGNvc1hhbmdsZSA9IE1hdGguY29zKHJvdFhhbmdsZSlcbiAgICAgICAgY29uc3Qgcm90WmFuZ2xlID0gTWF0aC5hdGFuMihcbiAgICAgICAgICAgIGNvc1hhbmdsZSAqIG1hdFsxXSArIHNpblhhbmdsZSAqIG1hdFsyXSxcbiAgICAgICAgICAgIGNvc1hhbmdsZSAqIG1hdFs1XSArIHNpblhhbmdsZSAqIG1hdFs2XVxuICAgICAgICApXG5cbiAgICAgICAgcmV0dXJuIHZlYzMuY3JlYXRlKHJvdFhhbmdsZSwgcm90WWFuZ2xlLCByb3RaYW5nbGUpXG4gICAgfVxufVxuIiwiaW1wb3J0IHsgbG9hZCB9IGZyb20gJ0Bsb2FkZXJzLmdsL2NvcmUnXG5pbXBvcnQgeyBHTEIsIEdMQkxvYWRlciB9IGZyb20gJ0Bsb2FkZXJzLmdsL2dsdGYnXG5pbXBvcnQge1xuICAgIEJ1ZmZlck1hcCxcbiAgICBHTFRGQWNjZXNzb3IsXG4gICAgSW1hZ2VNYXAsXG4gICAgSU1hdGVyaWFsUHJlbG9hZERhdGEsXG4gICAgSU1vZGVsUHJlbG9hZERhdGEsXG4gICAgSVByZWxvYWRFbnRpdHksXG4gICAgSVNhbXBsZXJQcmVsb2FkRGF0YSxcbiAgICBJVGV4dHVyZVByZWxvYWREYXRhLFxuICAgIE1hdGVyaWFsTWFwLFxuICAgIFNhbXBsZXJNYXAsXG4gICAgVGV4dHVyZU1hcCxcbn0gZnJvbSAnLi4vLi4vZW5naW5lL3R5cGVzJ1xuaW1wb3J0IHsgZ2V0VHlwZVNpemUsIGdldFZlcnRleFR5cGUgfSBmcm9tICcuL2hlbHBlcnMnXG5pbXBvcnQgeyBtYXQ0LCBWZWMzLCBWZWM0IH0gZnJvbSAnd2dwdS1tYXRyaXgnXG5cbnR5cGUgSW5kZXhNYXAgPSBNYXA8bnVtYmVyLCBzdHJpbmc+XG5cbmNvbnN0IGdlbmVyYXRlSWQgPSAoKSA9PiB7XG4gICAgcmV0dXJuIFN0cmluZyhNYXRoLnJhbmRvbSgpKVxufVxuXG5leHBvcnQgY2xhc3MgV2hlZXp5R0xCTG9hZGVyIHtcbiAgICBwcml2YXRlIHN0YXRpYyBsb2FkSW1hZ2VzKFxuICAgICAgICBtb2RlbERhdGE6IEdMQixcbiAgICAgICAgYnVmZmVySW5kZXhNYXA6IEluZGV4TWFwXG4gICAgKToge1xuICAgICAgICBpbWFnZXNJbmRleE1hcDogSW5kZXhNYXBcbiAgICAgICAgaW1hZ2VzTWFwOiBJbWFnZU1hcFxuICAgIH0ge1xuICAgICAgICBjb25zdCBpbWFnZXNJbmRleE1hcDogSW5kZXhNYXAgPSBuZXcgTWFwKClcbiAgICAgICAgY29uc3QgaW1hZ2VzTWFwOiBJbWFnZU1hcCA9IG5ldyBNYXAoKVxuXG4gICAgICAgIG1vZGVsRGF0YS5qc29uPy5pbWFnZXM/LmZvckVhY2goXG4gICAgICAgICAgICAoXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBidWZmZXJWaWV3LFxuICAgICAgICAgICAgICAgICAgICBtaW1lVHlwZSxcbiAgICAgICAgICAgICAgICB9OiB7XG4gICAgICAgICAgICAgICAgICAgIGJ1ZmZlclZpZXc6IG51bWJlclxuICAgICAgICAgICAgICAgICAgICBtaW1lVHlwZTogc3RyaW5nXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBpbmRleDogbnVtYmVyXG4gICAgICAgICAgICApID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBidWZmZXJWaWV3RGF0YSA9IG1vZGVsRGF0YS5qc29uLmJ1ZmZlclZpZXdzW2J1ZmZlclZpZXddXG4gICAgICAgICAgICAgICAgY29uc3QgYnVmZmVySWQgPSBidWZmZXJJbmRleE1hcC5nZXQoYnVmZmVyVmlld0RhdGEuYnVmZmVyKVxuXG4gICAgICAgICAgICAgICAgY29uc3QgYnVmZmVyT2Zmc2V0ID1cbiAgICAgICAgICAgICAgICAgICAgbW9kZWxEYXRhLmJpbkNodW5rc1tidWZmZXJWaWV3RGF0YS5idWZmZXJdLmJ5dGVPZmZzZXQgPz8gMFxuICAgICAgICAgICAgICAgIGJ1ZmZlclZpZXdEYXRhLmJ1ZmZlciA9IGJ1ZmZlcklkXG4gICAgICAgICAgICAgICAgYnVmZmVyVmlld0RhdGEuYnl0ZU9mZnNldCArPSBidWZmZXJPZmZzZXRcblxuICAgICAgICAgICAgICAgIGNvbnN0IGlkID0gZ2VuZXJhdGVJZCgpXG4gICAgICAgICAgICAgICAgaW1hZ2VzSW5kZXhNYXAuc2V0KGluZGV4LCBpZClcbiAgICAgICAgICAgICAgICBpbWFnZXNNYXAuc2V0KGlkLCB7IGJ1ZmZlclZpZXc6IGJ1ZmZlclZpZXdEYXRhLCBtaW1lVHlwZSB9KVxuICAgICAgICAgICAgfVxuICAgICAgICApXG5cbiAgICAgICAgcmV0dXJuIHsgaW1hZ2VzSW5kZXhNYXAsIGltYWdlc01hcCB9XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBzdGF0aWMgbG9hZFNhbXBsZXJzID0gKFxuICAgICAgICBtb2RlbERhdGE6IEdMQlxuICAgICk6IHtcbiAgICAgICAgc2FtcGxlcnNJbmRleE1hcDogSW5kZXhNYXBcbiAgICAgICAgc2FtcGxlcnNNYXA6IFNhbXBsZXJNYXBcbiAgICB9ID0+IHtcbiAgICAgICAgY29uc3Qgc2FtcGxlcnNJbmRleE1hcDogSW5kZXhNYXAgPSBuZXcgTWFwKClcbiAgICAgICAgY29uc3Qgc2FtcGxlcnNNYXA6IFNhbXBsZXJNYXAgPSBuZXcgTWFwKClcblxuICAgICAgICBtb2RlbERhdGEuanNvbj8uc2FtcGxlcnM/LmZvckVhY2goXG4gICAgICAgICAgICAoc2FtcGxlcjogSVNhbXBsZXJQcmVsb2FkRGF0YSwgaW5kZXg6IG51bWJlcikgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGlkID0gZ2VuZXJhdGVJZCgpXG4gICAgICAgICAgICAgICAgc2FtcGxlcnNJbmRleE1hcC5zZXQoaW5kZXgsIGlkKVxuICAgICAgICAgICAgICAgIHNhbXBsZXJzTWFwLnNldChpZCwgc2FtcGxlcilcbiAgICAgICAgICAgIH1cbiAgICAgICAgKVxuXG4gICAgICAgIHJldHVybiB7IHNhbXBsZXJzSW5kZXhNYXAsIHNhbXBsZXJzTWFwIH1cbiAgICB9XG5cbiAgICBwcml2YXRlIHN0YXRpYyBsb2FkVGV4dHVyZXMgPSAoXG4gICAgICAgIG1vZGVsRGF0YTogR0xCLFxuICAgICAgICBzYW1wbGVyc0luZGV4TWFwOiBJbmRleE1hcCxcbiAgICAgICAgaW1hZ2VzSW5kZXhNYXA6IEluZGV4TWFwXG4gICAgKToge1xuICAgICAgICB0ZXh0dXJlc0luZGV4TWFwOiBJbmRleE1hcFxuICAgICAgICB0ZXh0dXJlc01hcDogVGV4dHVyZU1hcFxuICAgIH0gPT4ge1xuICAgICAgICBjb25zdCB0ZXh0dXJlc0luZGV4TWFwOiBJbmRleE1hcCA9IG5ldyBNYXAoKVxuICAgICAgICBjb25zdCB0ZXh0dXJlc01hcDogVGV4dHVyZU1hcCA9IG5ldyBNYXAoKVxuXG4gICAgICAgIG1vZGVsRGF0YS5qc29uPy50ZXh0dXJlcz8uZm9yRWFjaChcbiAgICAgICAgICAgIChcbiAgICAgICAgICAgICAgICB0ZXh0dXJlRGF0YTogeyBzb3VyY2U6IG51bWJlcjsgc2FtcGxlcjogbnVtYmVyIH0sXG4gICAgICAgICAgICAgICAgaW5kZXg6IG51bWJlclxuICAgICAgICAgICAgKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgaWQgPSBnZW5lcmF0ZUlkKClcbiAgICAgICAgICAgICAgICBjb25zdCB0ZXh0dXJlOiBJVGV4dHVyZVByZWxvYWREYXRhID0ge1xuICAgICAgICAgICAgICAgICAgICBzYW1wbGVySWQ6IHNhbXBsZXJzSW5kZXhNYXAuZ2V0KFxuICAgICAgICAgICAgICAgICAgICAgICAgdGV4dHVyZURhdGEuc2FtcGxlclxuICAgICAgICAgICAgICAgICAgICApIGFzIHN0cmluZyxcbiAgICAgICAgICAgICAgICAgICAgaW1hZ2VJZDogaW1hZ2VzSW5kZXhNYXAuZ2V0KHRleHR1cmVEYXRhLnNvdXJjZSkgYXMgc3RyaW5nLFxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHRleHR1cmVzSW5kZXhNYXAuc2V0KGluZGV4LCBpZClcbiAgICAgICAgICAgICAgICB0ZXh0dXJlc01hcC5zZXQoaWQsIHRleHR1cmUpXG4gICAgICAgICAgICB9XG4gICAgICAgIClcblxuICAgICAgICByZXR1cm4geyB0ZXh0dXJlc0luZGV4TWFwLCB0ZXh0dXJlc01hcCB9XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBzdGF0aWMgbG9hZE1hdGVyaWFscyA9IChcbiAgICAgICAgbW9kZWxEYXRhOiBHTEIsXG4gICAgICAgIHRleHR1cmVzSW5kZXhNYXA6IEluZGV4TWFwXG4gICAgKToge1xuICAgICAgICBtYXRlcmlhbHNJbmRleE1hcDogSW5kZXhNYXBcbiAgICAgICAgbWF0ZXJpYWxzTWFwOiBNYXRlcmlhbE1hcFxuICAgIH0gPT4ge1xuICAgICAgICBjb25zdCBtYXRlcmlhbHNJbmRleE1hcDogSW5kZXhNYXAgPSBuZXcgTWFwKClcbiAgICAgICAgY29uc3QgbWF0ZXJpYWxzTWFwOiBNYXRlcmlhbE1hcCA9IG5ldyBNYXAoKVxuXG4gICAgICAgIG1vZGVsRGF0YS5qc29uPy5tYXRlcmlhbHM/LmZvckVhY2goXG4gICAgICAgICAgICAoXG4gICAgICAgICAgICAgICAgLy9GSVhNRTogY2hlY2sgdHlwZXNcbiAgICAgICAgICAgICAgICBtYXRlcmlhbERhdGE6IHtcbiAgICAgICAgICAgICAgICAgICAgcGJyTWV0YWxsaWNSb3VnaG5lc3M/OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBiYXNlQ29sb3JUZXh0dXJlPzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4OiBudW1iZXJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIG1ldGFsbGljUm91Z2huZXNzVGV4dHVyZT86IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbmRleDogbnVtYmVyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBiYXNlQ29sb3JGYWN0b3I/OiBWZWM0XG4gICAgICAgICAgICAgICAgICAgICAgICBtZXRhbGxpY0ZhY3Rvcj86IG51bWJlclxuICAgICAgICAgICAgICAgICAgICAgICAgcm91Z2huZXNzRmFjdG9yPzogbnVtYmVyXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgbm9ybWFsVGV4dHVyZT86IHsgaW5kZXg6IG51bWJlciB9XG4gICAgICAgICAgICAgICAgICAgIGVtaXNzaXZlVGV4dHVyZT86IHsgaW5kZXg6IG51bWJlciB9XG4gICAgICAgICAgICAgICAgICAgIG9jY2x1c2lvblRleHR1cmU/OiB7IGluZGV4OiBudW1iZXIgfVxuICAgICAgICAgICAgICAgICAgICBlbWlzc2l2ZUZhY3Rvcj86IFZlYzNcbiAgICAgICAgICAgICAgICAgICAgbmFtZT86IHN0cmluZ1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgaW5kZXg6IG51bWJlclxuICAgICAgICAgICAgKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgbWF0ZXJpYWw6IElNYXRlcmlhbFByZWxvYWREYXRhID0ge1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiBtYXRlcmlhbERhdGEubmFtZSxcbiAgICAgICAgICAgICAgICAgICAgYmFzZUNvbG9yRmFjdG9yOlxuICAgICAgICAgICAgICAgICAgICAgICAgbWF0ZXJpYWxEYXRhPy5wYnJNZXRhbGxpY1JvdWdobmVzcz8uYmFzZUNvbG9yRmFjdG9yLFxuICAgICAgICAgICAgICAgICAgICBlbWlzc2l2ZUZhY3RvcjogbWF0ZXJpYWxEYXRhLmVtaXNzaXZlRmFjdG9yLFxuICAgICAgICAgICAgICAgICAgICBtZXRhbGxpY0ZhY3RvcjpcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hdGVyaWFsRGF0YT8ucGJyTWV0YWxsaWNSb3VnaG5lc3M/Lm1ldGFsbGljRmFjdG9yLFxuICAgICAgICAgICAgICAgICAgICByb3VnaG5lc3NGYWN0b3I6XG4gICAgICAgICAgICAgICAgICAgICAgICBtYXRlcmlhbERhdGE/LnBick1ldGFsbGljUm91Z2huZXNzPy5yb3VnaG5lc3NGYWN0b3IsXG4gICAgICAgICAgICAgICAgICAgIGJhc2VDb2xvclRleHR1cmVJZDpcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hdGVyaWFsRGF0YT8ucGJyTWV0YWxsaWNSb3VnaG5lc3M/LmJhc2VDb2xvclRleHR1cmVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA/LmluZGV4ICE9PSB1bmRlZmluZWRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IHRleHR1cmVzSW5kZXhNYXAuZ2V0KFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hdGVyaWFsRGF0YT8ucGJyTWV0YWxsaWNSb3VnaG5lc3NcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPy5iYXNlQ29sb3JUZXh0dXJlPy5pbmRleFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgICAgICBtZXRhbGxpY1JvdWdobmVzc1RleHR1cmVJZDpcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hdGVyaWFsRGF0YT8ucGJyTWV0YWxsaWNSb3VnaG5lc3NcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA/Lm1ldGFsbGljUm91Z2huZXNzVGV4dHVyZT8uaW5kZXggIT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gdGV4dHVyZXNJbmRleE1hcC5nZXQoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF0ZXJpYWxEYXRhPy5wYnJNZXRhbGxpY1JvdWdobmVzc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA/Lm1ldGFsbGljUm91Z2huZXNzVGV4dHVyZT8uaW5kZXhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICAgICAgbm9ybWFsVGV4dHVyZUlkOlxuICAgICAgICAgICAgICAgICAgICAgICAgbWF0ZXJpYWxEYXRhPy5ub3JtYWxUZXh0dXJlPy5pbmRleCAhPT0gdW5kZWZpbmVkXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPyB0ZXh0dXJlc0luZGV4TWFwLmdldChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXRlcmlhbERhdGE/Lm5vcm1hbFRleHR1cmU/LmluZGV4XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgICAgIG9jY2x1c2lvblRleHR1cmVJZDpcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hdGVyaWFsRGF0YT8ub2NjbHVzaW9uVGV4dHVyZT8uaW5kZXggIT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gdGV4dHVyZXNJbmRleE1hcC5nZXQoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF0ZXJpYWxEYXRhPy5vY2NsdXNpb25UZXh0dXJlPy5pbmRleFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgICAgICBlbWlzc2l2ZVRleHR1cmVJZDpcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hdGVyaWFsRGF0YT8uZW1pc3NpdmVUZXh0dXJlPy5pbmRleCAhPT0gdW5kZWZpbmVkXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPyB0ZXh0dXJlc0luZGV4TWFwLmdldChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXRlcmlhbERhdGE/LmVtaXNzaXZlVGV4dHVyZT8uaW5kZXhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBjb25zdCBpZCA9IGdlbmVyYXRlSWQoKVxuICAgICAgICAgICAgICAgIG1hdGVyaWFsc0luZGV4TWFwLnNldChpbmRleCwgaWQpXG4gICAgICAgICAgICAgICAgbWF0ZXJpYWxzTWFwLnNldChpZCwgbWF0ZXJpYWwpXG4gICAgICAgICAgICB9XG4gICAgICAgIClcblxuICAgICAgICByZXR1cm4geyBtYXRlcmlhbHNJbmRleE1hcCwgbWF0ZXJpYWxzTWFwIH1cbiAgICB9XG5cbiAgICBwcml2YXRlIHN0YXRpYyBsb2FkQnVmZmVycyA9IChtb2RlbERhdGE6IEdMQikgPT4ge1xuICAgICAgICBjb25zdCBidWZmZXJJbmRleE1hcDogSW5kZXhNYXAgPSBuZXcgTWFwKClcbiAgICAgICAgY29uc3QgYnVmZmVyTWFwOiBCdWZmZXJNYXAgPSBuZXcgTWFwKClcblxuICAgICAgICBtb2RlbERhdGEuYmluQ2h1bmtzLmZvckVhY2goKGNodW5rLCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgaWYgKGNodW5rLmFycmF5QnVmZmVyKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgaWQgPSBnZW5lcmF0ZUlkKClcbiAgICAgICAgICAgICAgICBidWZmZXJJbmRleE1hcC5zZXQoaW5kZXgsIGlkKVxuICAgICAgICAgICAgICAgIGJ1ZmZlck1hcC5zZXQoaWQsIGNodW5rLmFycmF5QnVmZmVyKVxuICAgICAgICAgICAgfVxuICAgICAgICB9KVxuXG4gICAgICAgIHJldHVybiB7IGJ1ZmZlckluZGV4TWFwLCBidWZmZXJNYXAgfVxuICAgIH1cblxuICAgIHB1YmxpYyBzdGF0aWMgYXN5bmMgbG9hZEZyb21VcmwodXJsOiBzdHJpbmcpOiBQcm9taXNlPElNb2RlbFByZWxvYWREYXRhPiB7XG4gICAgICAgIGNvbnN0IG1vZGVsRGF0YSA9IGF3YWl0IGxvYWQodXJsLCBHTEJMb2FkZXIpXG5cbiAgICAgICAgY29uc29sZS5sb2cobW9kZWxEYXRhKVxuXG4gICAgICAgIGNvbnN0IHsgYnVmZmVySW5kZXhNYXAsIGJ1ZmZlck1hcCB9ID0gdGhpcy5sb2FkQnVmZmVycyhtb2RlbERhdGEpXG5cbiAgICAgICAgY29uc3QgeyBpbWFnZXNJbmRleE1hcCwgaW1hZ2VzTWFwIH0gPSB0aGlzLmxvYWRJbWFnZXMoXG4gICAgICAgICAgICBtb2RlbERhdGEsXG4gICAgICAgICAgICBidWZmZXJJbmRleE1hcFxuICAgICAgICApXG5cbiAgICAgICAgY29uc3QgeyBzYW1wbGVyc0luZGV4TWFwLCBzYW1wbGVyc01hcCB9ID0gdGhpcy5sb2FkU2FtcGxlcnMobW9kZWxEYXRhKVxuXG4gICAgICAgIGNvbnN0IHsgdGV4dHVyZXNJbmRleE1hcCwgdGV4dHVyZXNNYXAgfSA9IHRoaXMubG9hZFRleHR1cmVzKFxuICAgICAgICAgICAgbW9kZWxEYXRhLFxuICAgICAgICAgICAgc2FtcGxlcnNJbmRleE1hcCxcbiAgICAgICAgICAgIGltYWdlc0luZGV4TWFwXG4gICAgICAgIClcblxuICAgICAgICBjb25zdCB7IG1hdGVyaWFsc0luZGV4TWFwLCBtYXRlcmlhbHNNYXAgfSA9IHRoaXMubG9hZE1hdGVyaWFscyhcbiAgICAgICAgICAgIG1vZGVsRGF0YSxcbiAgICAgICAgICAgIHRleHR1cmVzSW5kZXhNYXBcbiAgICAgICAgKVxuXG4gICAgICAgIGNvbnN0IG1vZGVsUHJlbG9hZDogSVByZWxvYWRFbnRpdHkgPSB7XG4gICAgICAgICAgICB0cnNNYXRyaXg6IG1hdDQuaWRlbnRpdHkoKSxcbiAgICAgICAgICAgIG1lc2hlczogW10sXG4gICAgICAgICAgICBjaGlsZHJlbjogW10sXG4gICAgICAgIH1cblxuICAgICAgICBtb2RlbERhdGE/Lmpzb24/LnNjZW5lcz8uZm9yRWFjaCgoc2NlbmU6IHsgbm9kZXM/OiBudW1iZXJbXSB9KSA9PiB7XG4gICAgICAgICAgICBzY2VuZT8ubm9kZXM/LmZvckVhY2goKG5vZGVJbmRleCkgPT4ge1xuICAgICAgICAgICAgICAgIG1vZGVsUHJlbG9hZC5jaGlsZHJlbi5wdXNoKFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmxvYWROb2RlKFxuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZUluZGV4LFxuICAgICAgICAgICAgICAgICAgICAgICAgbW9kZWxEYXRhLFxuICAgICAgICAgICAgICAgICAgICAgICAgYnVmZmVySW5kZXhNYXAsXG4gICAgICAgICAgICAgICAgICAgICAgICBtYXRlcmlhbHNJbmRleE1hcFxuICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgfSlcbiAgICAgICAgfSlcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbW9kZWw6IG1vZGVsUHJlbG9hZCxcbiAgICAgICAgICAgIGJ1ZmZlcnM6IGJ1ZmZlck1hcCxcbiAgICAgICAgICAgIGltYWdlczogaW1hZ2VzTWFwLFxuICAgICAgICAgICAgc2FtcGxlcnM6IHNhbXBsZXJzTWFwLFxuICAgICAgICAgICAgdGV4dHVyZXM6IHRleHR1cmVzTWFwLFxuICAgICAgICAgICAgbWF0ZXJpYWxzOiBtYXRlcmlhbHNNYXAsXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwcml2YXRlIHN0YXRpYyBwYXJzZUFjY2Vzc29yID0gKFxuICAgICAgICBtb2RlbERhdGE6IFJlY29yZDxzdHJpbmcsIGFueT4sXG4gICAgICAgIGFjY2Vzc29ySWQ6IG51bWJlcixcbiAgICAgICAgdXNhZ2U6IEdQVUJ1ZmZlclVzYWdlRmxhZ3MsXG4gICAgICAgIGJ1ZmZlckluZGV4TWFwOiBJbmRleE1hcFxuICAgICk6IEdMVEZBY2Nlc3NvciB8IHVuZGVmaW5lZCA9PiB7XG4gICAgICAgIGlmIChhY2Nlc3NvcklkICE9PSAwICYmICFhY2Nlc3NvcklkKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkXG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCByYXdBY2Nlc3NvciA9IG1vZGVsRGF0YS5qc29uLmFjY2Vzc29yc1thY2Nlc3NvcklkXVxuICAgICAgICBjb25zdCByYXdCdWZmZXJWaWV3ID0gbW9kZWxEYXRhLmpzb24uYnVmZmVyVmlld3NbcmF3QWNjZXNzb3IuYnVmZmVyVmlld11cbiAgICAgICAgY29uc3QgYnVmZmVyID0gbW9kZWxEYXRhLmJpbkNodW5rc1tyYXdCdWZmZXJWaWV3LmJ1ZmZlcl1cblxuICAgICAgICBjb25zdCBlbGVtZW50U2l6ZSA9IGdldFR5cGVTaXplKFxuICAgICAgICAgICAgcmF3QWNjZXNzb3IuY29tcG9uZW50VHlwZSxcbiAgICAgICAgICAgIHJhd0FjY2Vzc29yLnR5cGVcbiAgICAgICAgKVxuICAgICAgICBjb25zdCBieXRlU3RyaWRlID0gTWF0aC5tYXgoZWxlbWVudFNpemUsIHJhd0J1ZmZlclZpZXcuYnl0ZVN0cmlkZSA/PyAwKVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBidWZmZXJJZDogYnVmZmVySW5kZXhNYXAuZ2V0KHJhd0J1ZmZlclZpZXcuYnVmZmVyKSBhcyBzdHJpbmcsXG4gICAgICAgICAgICBieXRlU3RyaWRlOiBieXRlU3RyaWRlLFxuICAgICAgICAgICAgYnl0ZUxlbmd0aDogcmF3QWNjZXNzb3IuY291bnQgKiAoYnl0ZVN0cmlkZSA/PyAxKSxcbiAgICAgICAgICAgIGJ5dGVPZmZzZXQ6XG4gICAgICAgICAgICAgICAgKHJhd0FjY2Vzc29yPy5ieXRlT2Zmc2V0ID8/IDApICtcbiAgICAgICAgICAgICAgICAocmF3QnVmZmVyVmlldz8uYnl0ZU9mZnNldCA/PyAwKSArXG4gICAgICAgICAgICAgICAgKGJ1ZmZlcj8uYnl0ZU9mZnNldCA/PyAwKSxcbiAgICAgICAgICAgIGNvdW50OiByYXdBY2Nlc3Nvci5jb3VudCxcbiAgICAgICAgICAgIGNvbXBvbmVudFR5cGU6IHJhd0FjY2Vzc29yLmNvbXBvbmVudFR5cGUsXG4gICAgICAgICAgICBlbGVtZW50VHlwZTogZ2V0VmVydGV4VHlwZShcbiAgICAgICAgICAgICAgICByYXdBY2Nlc3Nvci5jb21wb25lbnRUeXBlLFxuICAgICAgICAgICAgICAgIHJhd0FjY2Vzc29yLnR5cGVcbiAgICAgICAgICAgICksXG4gICAgICAgICAgICBtaW46IHJhd0FjY2Vzc29yLm1pbixcbiAgICAgICAgICAgIG1heDogcmF3QWNjZXNzb3IubWF4LFxuICAgICAgICAgICAgdXNhZ2U6IHVzYWdlLFxuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBzdGF0aWMgbG9hZE5vZGUoXG4gICAgICAgIG5vZGVJbmRleDogbnVtYmVyLFxuICAgICAgICBtb2RlbERhdGE6IFJlY29yZDxzdHJpbmcsIGFueT4sXG4gICAgICAgIGJ1ZmZlckluZGV4TWFwOiBJbmRleE1hcCxcbiAgICAgICAgbWF0ZXJpYWxzSW5kZXhNYXA6IEluZGV4TWFwXG4gICAgKSB7XG4gICAgICAgIGNvbnN0IG5vZGVKc29uRGF0YSA9IG1vZGVsRGF0YT8uanNvbj8ubm9kZXNbbm9kZUluZGV4XVxuICAgICAgICBjb25zdCBkYXRhU3RydWN0RW50cnk6IElQcmVsb2FkRW50aXR5ID0ge1xuICAgICAgICAgICAgdHJzTWF0cml4OiBub2RlSnNvbkRhdGEubWF0cml4ID8/IG1hdDQuaWRlbnRpdHkoKSxcbiAgICAgICAgICAgIG1lc2hlczogW10sXG4gICAgICAgICAgICBjaGlsZHJlbjogW10sXG4gICAgICAgIH1cblxuICAgICAgICBpZiAobm9kZUpzb25EYXRhLm1lc2ggIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY29uc3QgbWVzaEpzb25EYXRhID0gbW9kZWxEYXRhLmpzb24ubWVzaGVzW25vZGVKc29uRGF0YS5tZXNoXVxuXG4gICAgICAgICAgICBtZXNoSnNvbkRhdGEucHJpbWl0aXZlcy5mb3JFYWNoKFxuICAgICAgICAgICAgICAgIChwcmltaXRpdmU6IHtcbiAgICAgICAgICAgICAgICAgICAgYXR0cmlidXRlczoge1xuICAgICAgICAgICAgICAgICAgICAgICAgTk9STUFMOiBudW1iZXJcbiAgICAgICAgICAgICAgICAgICAgICAgIFBPU0lUSU9OOiBudW1iZXJcbiAgICAgICAgICAgICAgICAgICAgICAgIFRFWENPT1JEXzA6IG51bWJlclxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGluZGljZXM6IG51bWJlclxuICAgICAgICAgICAgICAgICAgICBtb2RlOiBudW1iZXJcbiAgICAgICAgICAgICAgICAgICAgbWF0ZXJpYWw/OiBudW1iZXJcbiAgICAgICAgICAgICAgICB9KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGRhdGFTdHJ1Y3RFbnRyeS5tZXNoZXMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbnM6IFdoZWV6eUdMQkxvYWRlci5wYXJzZUFjY2Vzc29yKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1vZGVsRGF0YSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcmltaXRpdmUuYXR0cmlidXRlcy5QT1NJVElPTixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBHUFVCdWZmZXJVc2FnZS5WRVJURVgsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnVmZmVySW5kZXhNYXBcbiAgICAgICAgICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgICAgICAgICBpbmRpY2VzOiBXaGVlenlHTEJMb2FkZXIucGFyc2VBY2Nlc3NvcihcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtb2RlbERhdGEsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJpbWl0aXZlLmluZGljZXMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgR1BVQnVmZmVyVXNhZ2UuSU5ERVgsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnVmZmVySW5kZXhNYXBcbiAgICAgICAgICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgICAgICAgICBub3JtYWxzOiBXaGVlenlHTEJMb2FkZXIucGFyc2VBY2Nlc3NvcihcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtb2RlbERhdGEsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJpbWl0aXZlLmF0dHJpYnV0ZXMuTk9STUFMLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIEdQVUJ1ZmZlclVzYWdlLlZFUlRFWCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBidWZmZXJJbmRleE1hcFxuICAgICAgICAgICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRleHR1cmVDb29yZGluYXRlczogV2hlZXp5R0xCTG9hZGVyLnBhcnNlQWNjZXNzb3IoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbW9kZWxEYXRhLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByaW1pdGl2ZS5hdHRyaWJ1dGVzLlRFWENPT1JEXzAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgR1BVQnVmZmVyVXNhZ2UuVkVSVEVYLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJ1ZmZlckluZGV4TWFwXG4gICAgICAgICAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWF0ZXJpYWxJZDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcmltaXRpdmUubWF0ZXJpYWwgIT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IG1hdGVyaWFsc0luZGV4TWFwLmdldChwcmltaXRpdmUubWF0ZXJpYWwpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgICAgICAgICAgbW9kZTogcHJpbWl0aXZlLm1vZGUgPz8gNCxcbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICApXG4gICAgICAgIH1cblxuICAgICAgICBub2RlSnNvbkRhdGE/LmNoaWxkcmVuPy5mb3JFYWNoKChjaGlsZEluZGV4OiBudW1iZXIpID0+IHtcbiAgICAgICAgICAgIGRhdGFTdHJ1Y3RFbnRyeS5jaGlsZHJlbi5wdXNoKFxuICAgICAgICAgICAgICAgIHRoaXMubG9hZE5vZGUoXG4gICAgICAgICAgICAgICAgICAgIGNoaWxkSW5kZXgsXG4gICAgICAgICAgICAgICAgICAgIG1vZGVsRGF0YSxcbiAgICAgICAgICAgICAgICAgICAgYnVmZmVySW5kZXhNYXAsXG4gICAgICAgICAgICAgICAgICAgIG1hdGVyaWFsc0luZGV4TWFwXG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgKVxuICAgICAgICB9KVxuXG4gICAgICAgIHJldHVybiBkYXRhU3RydWN0RW50cnlcbiAgICB9XG59XG4iLCJleHBvcnQgZW51bSBHTFRGQ29tcG9uZW50VHlwZSB7XG4gICAgQllURSA9IDUxMjAsXG4gICAgVU5TSUdORURfQllURSA9IDUxMjEsXG4gICAgU0hPUlQgPSA1MTIyLFxuICAgIFVOU0lHTkVEX1NIT1JUID0gNTEyMyxcbiAgICBJTlQgPSA1MTI0LFxuICAgIFVOU0lHTkVEX0lOVCA9IDUxMjUsXG4gICAgRkxPQVQgPSA1MTI2LFxuICAgIERPVUJMRSA9IDUxMzAsXG59XG5cbmV4cG9ydCBjb25zdCBnZXRUeXBlQ29tcG9uZW50c0Ftb3VudCA9ICh0eXBlOiBzdHJpbmcpID0+IHtcbiAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgY2FzZSAnU0NBTEFSJzpcbiAgICAgICAgICAgIHJldHVybiAxXG4gICAgICAgIGNhc2UgJ1ZFQzInOlxuICAgICAgICAgICAgcmV0dXJuIDJcbiAgICAgICAgY2FzZSAnVkVDMyc6XG4gICAgICAgICAgICByZXR1cm4gM1xuICAgICAgICBjYXNlICdWRUM0JzpcbiAgICAgICAgICAgIHJldHVybiA0XG4gICAgICAgIGNhc2UgJ01BVDInOlxuICAgICAgICAgICAgcmV0dXJuIDRcbiAgICAgICAgY2FzZSAnTUFUMyc6XG4gICAgICAgICAgICByZXR1cm4gOVxuICAgICAgICBjYXNlICdNQVQ0JzpcbiAgICAgICAgICAgIHJldHVybiAxNlxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdGhyb3cgRXJyb3IoYEludmFsaWQgZ2x0ZiB0eXBlICR7dHlwZX1gKVxuICAgIH1cbn1cblxuZXhwb3J0IGNvbnN0IGdldFZlcnRleFR5cGUgPSAoXG4gICAgY29tcG9uZW50VHlwZTogbnVtYmVyLFxuICAgIHR5cGU6IHN0cmluZ1xuKTogR1BVVmVydGV4Rm9ybWF0ID0+IHtcbiAgICBsZXQgdHlwZVN0cjogc3RyaW5nIHwgbnVsbCA9IG51bGxcbiAgICBzd2l0Y2ggKGNvbXBvbmVudFR5cGUpIHtcbiAgICAgICAgY2FzZSBHTFRGQ29tcG9uZW50VHlwZS5CWVRFOlxuICAgICAgICAgICAgdHlwZVN0ciA9ICdzaW50OCdcbiAgICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgR0xURkNvbXBvbmVudFR5cGUuVU5TSUdORURfQllURTpcbiAgICAgICAgICAgIHR5cGVTdHIgPSAndWludDgnXG4gICAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlIEdMVEZDb21wb25lbnRUeXBlLlNIT1JUOlxuICAgICAgICAgICAgdHlwZVN0ciA9ICdzaW50MTYnXG4gICAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlIEdMVEZDb21wb25lbnRUeXBlLlVOU0lHTkVEX1NIT1JUOlxuICAgICAgICAgICAgdHlwZVN0ciA9ICd1aW50MTYnXG4gICAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlIEdMVEZDb21wb25lbnRUeXBlLklOVDpcbiAgICAgICAgICAgIHR5cGVTdHIgPSAnaW50MzInXG4gICAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlIEdMVEZDb21wb25lbnRUeXBlLlVOU0lHTkVEX0lOVDpcbiAgICAgICAgICAgIHR5cGVTdHIgPSAndWludDMyJ1xuICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSBHTFRGQ29tcG9uZW50VHlwZS5GTE9BVDpcbiAgICAgICAgICAgIHR5cGVTdHIgPSAnZmxvYXQzMidcbiAgICAgICAgICAgIGJyZWFrXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgICAgICAgICBgVW5yZWNvZ25pemVkIG9yIHVuc3VwcG9ydGVkIGdsdGYgdHlwZSAke2NvbXBvbmVudFR5cGV9YFxuICAgICAgICAgICAgKVxuICAgIH1cblxuICAgIHN3aXRjaCAoZ2V0VHlwZUNvbXBvbmVudHNBbW91bnQodHlwZSkpIHtcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgdHlwZVN0ciArPSAneDInXG4gICAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICB0eXBlU3RyICs9ICd4MydcbiAgICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgIHR5cGVTdHIgKz0gJ3g0J1xuICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHRocm93IEVycm9yKGBJbnZhbGlkIG51bWJlciBvZiBjb21wb25lbnRzIGZvciBnbHRmIHR5cGU6ICR7dHlwZX1gKVxuICAgIH1cblxuICAgIHJldHVybiB0eXBlU3RyIGFzIEdQVVZlcnRleEZvcm1hdFxufVxuXG5leHBvcnQgY29uc3QgZ2V0VHlwZVNpemUgPSAoY29tcG9uZW50VHlwZTogR0xURkNvbXBvbmVudFR5cGUsIHR5cGU6IHN0cmluZykgPT4ge1xuICAgIGxldCBjb21wb25lbnRTaXplID0gMFxuICAgIHN3aXRjaCAoY29tcG9uZW50VHlwZSkge1xuICAgICAgICBjYXNlIEdMVEZDb21wb25lbnRUeXBlLkJZVEU6XG4gICAgICAgICAgICBjb21wb25lbnRTaXplID0gMVxuICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSBHTFRGQ29tcG9uZW50VHlwZS5VTlNJR05FRF9CWVRFOlxuICAgICAgICAgICAgY29tcG9uZW50U2l6ZSA9IDFcbiAgICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgR0xURkNvbXBvbmVudFR5cGUuU0hPUlQ6XG4gICAgICAgICAgICBjb21wb25lbnRTaXplID0gMlxuICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSBHTFRGQ29tcG9uZW50VHlwZS5VTlNJR05FRF9TSE9SVDpcbiAgICAgICAgICAgIGNvbXBvbmVudFNpemUgPSAyXG4gICAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlIEdMVEZDb21wb25lbnRUeXBlLklOVDpcbiAgICAgICAgICAgIGNvbXBvbmVudFNpemUgPSA0XG4gICAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlIEdMVEZDb21wb25lbnRUeXBlLlVOU0lHTkVEX0lOVDpcbiAgICAgICAgICAgIGNvbXBvbmVudFNpemUgPSA0XG4gICAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlIEdMVEZDb21wb25lbnRUeXBlLkZMT0FUOlxuICAgICAgICAgICAgY29tcG9uZW50U2l6ZSA9IDRcbiAgICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgR0xURkNvbXBvbmVudFR5cGUuRE9VQkxFOlxuICAgICAgICAgICAgY29tcG9uZW50U2l6ZSA9IDhcbiAgICAgICAgICAgIGJyZWFrXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB0aHJvdyBFcnJvcignVW5yZWNvZ25pemVkIEdMVEYgQ29tcG9uZW50IFR5cGU/JylcbiAgICB9XG4gICAgcmV0dXJuIGdldFR5cGVDb21wb25lbnRzQW1vdW50KHR5cGUpICogY29tcG9uZW50U2l6ZVxufVxuXG5leHBvcnQgZW51bSBJbWFnZVVzYWdlIHtcbiAgICBCQVNFX0NPTE9SLFxuICAgIE1FVEFMTElDX1JPVUdITkVTUyxcbiAgICBOT1JNQUwsXG4gICAgT0NDTFVTSU9OLFxuICAgIEVNSVNTSU9OLFxufVxuIiwiZXhwb3J0ICogZnJvbSAnLi9XaGVlenlHTEJMb2FkZXIvV2hlZXp5R0xCTG9hZGVyJ1xuIiwiY29uc3QgREVGQVVMVF9DSFVOS19TSVpFID0gMjU2ICogMTAyNDtcbmV4cG9ydCBmdW5jdGlvbiBtYWtlQXJyYXlCdWZmZXJJdGVyYXRvcihhcnJheUJ1ZmZlcikge1xuICBsZXQgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gIHJldHVybiBmdW5jdGlvbiogKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIGNodW5rU2l6ZSA9IERFRkFVTFRfQ0hVTktfU0laRVxuICAgIH0gPSBvcHRpb25zO1xuICAgIGxldCBieXRlT2Zmc2V0ID0gMDtcbiAgICB3aGlsZSAoYnl0ZU9mZnNldCA8IGFycmF5QnVmZmVyLmJ5dGVMZW5ndGgpIHtcbiAgICAgIGNvbnN0IGNodW5rQnl0ZUxlbmd0aCA9IE1hdGgubWluKGFycmF5QnVmZmVyLmJ5dGVMZW5ndGggLSBieXRlT2Zmc2V0LCBjaHVua1NpemUpO1xuICAgICAgY29uc3QgY2h1bmsgPSBuZXcgQXJyYXlCdWZmZXIoY2h1bmtCeXRlTGVuZ3RoKTtcbiAgICAgIGNvbnN0IHNvdXJjZUFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXlCdWZmZXIsIGJ5dGVPZmZzZXQsIGNodW5rQnl0ZUxlbmd0aCk7XG4gICAgICBjb25zdCBjaHVua0FycmF5ID0gbmV3IFVpbnQ4QXJyYXkoY2h1bmspO1xuICAgICAgY2h1bmtBcnJheS5zZXQoc291cmNlQXJyYXkpO1xuICAgICAgYnl0ZU9mZnNldCArPSBjaHVua0J5dGVMZW5ndGg7XG4gICAgICB5aWVsZCBjaHVuaztcbiAgICB9XG4gIH0oKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1ha2UtYXJyYXktYnVmZmVyLWl0ZXJhdG9yLmpzLm1hcCIsImNvbnN0IERFRkFVTFRfQ0hVTktfU0laRSA9IDEwMjQgKiAxMDI0O1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uKiBtYWtlQmxvYkl0ZXJhdG9yKGJsb2IsIG9wdGlvbnMpIHtcbiAgY29uc3QgY2h1bmtTaXplID0gKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5jaHVua1NpemUpIHx8IERFRkFVTFRfQ0hVTktfU0laRTtcbiAgbGV0IG9mZnNldCA9IDA7XG4gIHdoaWxlIChvZmZzZXQgPCBibG9iLnNpemUpIHtcbiAgICBjb25zdCBlbmQgPSBvZmZzZXQgKyBjaHVua1NpemU7XG4gICAgY29uc3QgY2h1bmsgPSBhd2FpdCBibG9iLnNsaWNlKG9mZnNldCwgZW5kKS5hcnJheUJ1ZmZlcigpO1xuICAgIG9mZnNldCA9IGVuZDtcbiAgICB5aWVsZCBjaHVuaztcbiAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bWFrZS1ibG9iLWl0ZXJhdG9yLmpzLm1hcCIsImltcG9ydCB7IG1ha2VTdHJpbmdJdGVyYXRvciB9IGZyb20gXCIuL21ha2Utc3RyaW5nLWl0ZXJhdG9yLmpzXCI7XG5pbXBvcnQgeyBtYWtlQXJyYXlCdWZmZXJJdGVyYXRvciB9IGZyb20gXCIuL21ha2UtYXJyYXktYnVmZmVyLWl0ZXJhdG9yLmpzXCI7XG5pbXBvcnQgeyBtYWtlQmxvYkl0ZXJhdG9yIH0gZnJvbSBcIi4vbWFrZS1ibG9iLWl0ZXJhdG9yLmpzXCI7XG5pbXBvcnQgeyBtYWtlU3RyZWFtSXRlcmF0b3IgfSBmcm9tIFwiLi9tYWtlLXN0cmVhbS1pdGVyYXRvci5qc1wiO1xuaW1wb3J0IHsgaXNCbG9iLCBpc1JlYWRhYmxlU3RyZWFtLCBpc1Jlc3BvbnNlIH0gZnJvbSBcIi4uLy4uL2phdmFzY3JpcHQtdXRpbHMvaXMtdHlwZS5qc1wiO1xuZXhwb3J0IGZ1bmN0aW9uIG1ha2VJdGVyYXRvcihkYXRhLCBvcHRpb25zKSB7XG4gIGlmICh0eXBlb2YgZGF0YSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gbWFrZVN0cmluZ0l0ZXJhdG9yKGRhdGEsIG9wdGlvbnMpO1xuICB9XG4gIGlmIChkYXRhIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHtcbiAgICByZXR1cm4gbWFrZUFycmF5QnVmZmVySXRlcmF0b3IoZGF0YSwgb3B0aW9ucyk7XG4gIH1cbiAgaWYgKGlzQmxvYihkYXRhKSkge1xuICAgIHJldHVybiBtYWtlQmxvYkl0ZXJhdG9yKGRhdGEsIG9wdGlvbnMpO1xuICB9XG4gIGlmIChpc1JlYWRhYmxlU3RyZWFtKGRhdGEpKSB7XG4gICAgcmV0dXJuIG1ha2VTdHJlYW1JdGVyYXRvcihkYXRhLCBvcHRpb25zKTtcbiAgfVxuICBpZiAoaXNSZXNwb25zZShkYXRhKSkge1xuICAgIGNvbnN0IHJlc3BvbnNlID0gZGF0YTtcbiAgICByZXR1cm4gbWFrZVN0cmVhbUl0ZXJhdG9yKHJlc3BvbnNlLmJvZHksIG9wdGlvbnMpO1xuICB9XG4gIHRocm93IG5ldyBFcnJvcignbWFrZUl0ZXJhdG9yJyk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tYWtlLWl0ZXJhdG9yLmpzLm1hcCIsImltcG9ydCB7IGlzQnJvd3NlciwgdG9BcnJheUJ1ZmZlciB9IGZyb20gJ0Bsb2FkZXJzLmdsL2xvYWRlci11dGlscyc7XG5leHBvcnQgZnVuY3Rpb24gbWFrZVN0cmVhbUl0ZXJhdG9yKHN0cmVhbSwgb3B0aW9ucykge1xuICByZXR1cm4gaXNCcm93c2VyID8gbWFrZUJyb3dzZXJTdHJlYW1JdGVyYXRvcihzdHJlYW0sIG9wdGlvbnMpIDogbWFrZU5vZGVTdHJlYW1JdGVyYXRvcihzdHJlYW0sIG9wdGlvbnMpO1xufVxuYXN5bmMgZnVuY3Rpb24qIG1ha2VCcm93c2VyU3RyZWFtSXRlcmF0b3Ioc3RyZWFtLCBvcHRpb25zKSB7XG4gIGNvbnN0IHJlYWRlciA9IHN0cmVhbS5nZXRSZWFkZXIoKTtcbiAgbGV0IG5leHRCYXRjaFByb21pc2U7XG4gIHRyeSB7XG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgIGNvbnN0IGN1cnJlbnRCYXRjaFByb21pc2UgPSBuZXh0QmF0Y2hQcm9taXNlIHx8IHJlYWRlci5yZWFkKCk7XG4gICAgICBpZiAob3B0aW9ucyAhPT0gbnVsbCAmJiBvcHRpb25zICE9PSB2b2lkIDAgJiYgb3B0aW9ucy5fc3RyZWFtUmVhZEFoZWFkKSB7XG4gICAgICAgIG5leHRCYXRjaFByb21pc2UgPSByZWFkZXIucmVhZCgpO1xuICAgICAgfVxuICAgICAgY29uc3Qge1xuICAgICAgICBkb25lLFxuICAgICAgICB2YWx1ZVxuICAgICAgfSA9IGF3YWl0IGN1cnJlbnRCYXRjaFByb21pc2U7XG4gICAgICBpZiAoZG9uZSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB5aWVsZCB0b0FycmF5QnVmZmVyKHZhbHVlKTtcbiAgICB9XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgcmVhZGVyLnJlbGVhc2VMb2NrKCk7XG4gIH1cbn1cbmFzeW5jIGZ1bmN0aW9uKiBtYWtlTm9kZVN0cmVhbUl0ZXJhdG9yKHN0cmVhbSwgb3B0aW9ucykge1xuICBmb3IgYXdhaXQgKGNvbnN0IGNodW5rIG9mIHN0cmVhbSkge1xuICAgIHlpZWxkIHRvQXJyYXlCdWZmZXIoY2h1bmspO1xuICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tYWtlLXN0cmVhbS1pdGVyYXRvci5qcy5tYXAiLCJjb25zdCBERUZBVUxUX0NIVU5LX1NJWkUgPSAyNTYgKiAxMDI0O1xuZXhwb3J0IGZ1bmN0aW9uKiBtYWtlU3RyaW5nSXRlcmF0b3Ioc3RyaW5nLCBvcHRpb25zKSB7XG4gIGNvbnN0IGNodW5rU2l6ZSA9IChvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuY2h1bmtTaXplKSB8fCBERUZBVUxUX0NIVU5LX1NJWkU7XG4gIGxldCBvZmZzZXQgPSAwO1xuICBjb25zdCB0ZXh0RW5jb2RlciA9IG5ldyBUZXh0RW5jb2RlcigpO1xuICB3aGlsZSAob2Zmc2V0IDwgc3RyaW5nLmxlbmd0aCkge1xuICAgIGNvbnN0IGNodW5rTGVuZ3RoID0gTWF0aC5taW4oc3RyaW5nLmxlbmd0aCAtIG9mZnNldCwgY2h1bmtTaXplKTtcbiAgICBjb25zdCBjaHVuayA9IHN0cmluZy5zbGljZShvZmZzZXQsIG9mZnNldCArIGNodW5rTGVuZ3RoKTtcbiAgICBvZmZzZXQgKz0gY2h1bmtMZW5ndGg7XG4gICAgeWllbGQgdGV4dEVuY29kZXIuZW5jb2RlKGNodW5rKTtcbiAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bWFrZS1zdHJpbmctaXRlcmF0b3IuanMubWFwIiwiY29uc3QgaXNCb29sZWFuID0geCA9PiB0eXBlb2YgeCA9PT0gJ2Jvb2xlYW4nO1xuY29uc3QgaXNGdW5jdGlvbiA9IHggPT4gdHlwZW9mIHggPT09ICdmdW5jdGlvbic7XG5leHBvcnQgY29uc3QgaXNPYmplY3QgPSB4ID0+IHggIT09IG51bGwgJiYgdHlwZW9mIHggPT09ICdvYmplY3QnO1xuZXhwb3J0IGNvbnN0IGlzUHVyZU9iamVjdCA9IHggPT4gaXNPYmplY3QoeCkgJiYgeC5jb25zdHJ1Y3RvciA9PT0ge30uY29uc3RydWN0b3I7XG5leHBvcnQgY29uc3QgaXNQcm9taXNlID0geCA9PiBpc09iamVjdCh4KSAmJiBpc0Z1bmN0aW9uKHgudGhlbik7XG5leHBvcnQgY29uc3QgaXNJdGVyYWJsZSA9IHggPT4gQm9vbGVhbih4KSAmJiB0eXBlb2YgeFtTeW1ib2wuaXRlcmF0b3JdID09PSAnZnVuY3Rpb24nO1xuZXhwb3J0IGNvbnN0IGlzQXN5bmNJdGVyYWJsZSA9IHggPT4geCAmJiB0eXBlb2YgeFtTeW1ib2wuYXN5bmNJdGVyYXRvcl0gPT09ICdmdW5jdGlvbic7XG5leHBvcnQgY29uc3QgaXNJdGVyYXRvciA9IHggPT4geCAmJiBpc0Z1bmN0aW9uKHgubmV4dCk7XG5leHBvcnQgY29uc3QgaXNSZXNwb25zZSA9IHggPT4gdHlwZW9mIFJlc3BvbnNlICE9PSAndW5kZWZpbmVkJyAmJiB4IGluc3RhbmNlb2YgUmVzcG9uc2UgfHwgeCAmJiB4LmFycmF5QnVmZmVyICYmIHgudGV4dCAmJiB4Lmpzb247XG5leHBvcnQgY29uc3QgaXNGaWxlID0geCA9PiB0eXBlb2YgRmlsZSAhPT0gJ3VuZGVmaW5lZCcgJiYgeCBpbnN0YW5jZW9mIEZpbGU7XG5leHBvcnQgY29uc3QgaXNCbG9iID0geCA9PiB0eXBlb2YgQmxvYiAhPT0gJ3VuZGVmaW5lZCcgJiYgeCBpbnN0YW5jZW9mIEJsb2I7XG5leHBvcnQgY29uc3QgaXNCdWZmZXIgPSB4ID0+IHggJiYgdHlwZW9mIHggPT09ICdvYmplY3QnICYmIHguaXNCdWZmZXI7XG5leHBvcnQgY29uc3QgaXNXcml0YWJsZURPTVN0cmVhbSA9IHggPT4gaXNPYmplY3QoeCkgJiYgaXNGdW5jdGlvbih4LmFib3J0KSAmJiBpc0Z1bmN0aW9uKHguZ2V0V3JpdGVyKTtcbmV4cG9ydCBjb25zdCBpc1JlYWRhYmxlRE9NU3RyZWFtID0geCA9PiB0eXBlb2YgUmVhZGFibGVTdHJlYW0gIT09ICd1bmRlZmluZWQnICYmIHggaW5zdGFuY2VvZiBSZWFkYWJsZVN0cmVhbSB8fCBpc09iamVjdCh4KSAmJiBpc0Z1bmN0aW9uKHgudGVlKSAmJiBpc0Z1bmN0aW9uKHguY2FuY2VsKSAmJiBpc0Z1bmN0aW9uKHguZ2V0UmVhZGVyKTtcbmV4cG9ydCBjb25zdCBpc1dyaXRhYmxlTm9kZVN0cmVhbSA9IHggPT4gaXNPYmplY3QoeCkgJiYgaXNGdW5jdGlvbih4LmVuZCkgJiYgaXNGdW5jdGlvbih4LndyaXRlKSAmJiBpc0Jvb2xlYW4oeC53cml0YWJsZSk7XG5leHBvcnQgY29uc3QgaXNSZWFkYWJsZU5vZGVTdHJlYW0gPSB4ID0+IGlzT2JqZWN0KHgpICYmIGlzRnVuY3Rpb24oeC5yZWFkKSAmJiBpc0Z1bmN0aW9uKHgucGlwZSkgJiYgaXNCb29sZWFuKHgucmVhZGFibGUpO1xuZXhwb3J0IGNvbnN0IGlzUmVhZGFibGVTdHJlYW0gPSB4ID0+IGlzUmVhZGFibGVET01TdHJlYW0oeCkgfHwgaXNSZWFkYWJsZU5vZGVTdHJlYW0oeCk7XG5leHBvcnQgY29uc3QgaXNXcml0YWJsZVN0cmVhbSA9IHggPT4gaXNXcml0YWJsZURPTVN0cmVhbSh4KSB8fCBpc1dyaXRhYmxlTm9kZVN0cmVhbSh4KTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWlzLXR5cGUuanMubWFwIiwiaW1wb3J0IHsgaXNCbG9iIH0gZnJvbSBcIi4uLy4uL2phdmFzY3JpcHQtdXRpbHMvaXMtdHlwZS5qc1wiO1xuaW1wb3J0IHsgaXNMb2FkZXJPYmplY3QgfSBmcm9tIFwiLi4vbG9hZGVyLXV0aWxzL25vcm1hbGl6ZS1sb2FkZXIuanNcIjtcbmltcG9ydCB7IGdldEZldGNoRnVuY3Rpb24gfSBmcm9tIFwiLi4vbG9hZGVyLXV0aWxzL2dldC1mZXRjaC1mdW5jdGlvbi5qc1wiO1xuaW1wb3J0IHsgcGFyc2UgfSBmcm9tIFwiLi9wYXJzZS5qc1wiO1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGxvYWQodXJsLCBsb2FkZXJzLCBvcHRpb25zLCBjb250ZXh0KSB7XG4gIGxldCByZXNvbHZlZExvYWRlcnM7XG4gIGxldCByZXNvbHZlZE9wdGlvbnM7XG4gIGlmICghQXJyYXkuaXNBcnJheShsb2FkZXJzKSAmJiAhaXNMb2FkZXJPYmplY3QobG9hZGVycykpIHtcbiAgICByZXNvbHZlZExvYWRlcnMgPSBbXTtcbiAgICByZXNvbHZlZE9wdGlvbnMgPSBsb2FkZXJzO1xuICAgIGNvbnRleHQgPSB1bmRlZmluZWQ7XG4gIH0gZWxzZSB7XG4gICAgcmVzb2x2ZWRMb2FkZXJzID0gbG9hZGVycztcbiAgICByZXNvbHZlZE9wdGlvbnMgPSBvcHRpb25zO1xuICB9XG4gIGNvbnN0IGZldGNoID0gZ2V0RmV0Y2hGdW5jdGlvbihyZXNvbHZlZE9wdGlvbnMpO1xuICBsZXQgZGF0YSA9IHVybDtcbiAgaWYgKHR5cGVvZiB1cmwgPT09ICdzdHJpbmcnKSB7XG4gICAgZGF0YSA9IGF3YWl0IGZldGNoKHVybCk7XG4gIH1cbiAgaWYgKGlzQmxvYih1cmwpKSB7XG4gICAgZGF0YSA9IGF3YWl0IGZldGNoKHVybCk7XG4gIH1cbiAgcmV0dXJuIEFycmF5LmlzQXJyYXkocmVzb2x2ZWRMb2FkZXJzKSA/IGF3YWl0IHBhcnNlKGRhdGEsIHJlc29sdmVkTG9hZGVycywgcmVzb2x2ZWRPcHRpb25zKSA6IGF3YWl0IHBhcnNlKGRhdGEsIHJlc29sdmVkTG9hZGVycywgcmVzb2x2ZWRPcHRpb25zKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWxvYWQuanMubWFwIiwiaW1wb3J0IHsgcGFyc2VXaXRoV29ya2VyLCBjYW5QYXJzZVdpdGhXb3JrZXIgfSBmcm9tICdAbG9hZGVycy5nbC9sb2FkZXItdXRpbHMnO1xuaW1wb3J0IHsgYXNzZXJ0LCB2YWxpZGF0ZVdvcmtlclZlcnNpb24gfSBmcm9tICdAbG9hZGVycy5nbC93b3JrZXItdXRpbHMnO1xuaW1wb3J0IHsgaXNMb2FkZXJPYmplY3QgfSBmcm9tIFwiLi4vbG9hZGVyLXV0aWxzL25vcm1hbGl6ZS1sb2FkZXIuanNcIjtcbmltcG9ydCB7IGlzUmVzcG9uc2UgfSBmcm9tIFwiLi4vLi4vamF2YXNjcmlwdC11dGlscy9pcy10eXBlLmpzXCI7XG5pbXBvcnQgeyBub3JtYWxpemVPcHRpb25zIH0gZnJvbSBcIi4uL2xvYWRlci11dGlscy9vcHRpb24tdXRpbHMuanNcIjtcbmltcG9ydCB7IG1lcmdlTG9hZGVyT3B0aW9ucyB9IGZyb20gJ0Bsb2FkZXJzLmdsL2xvYWRlci11dGlscyc7XG5pbXBvcnQgeyBnZXRBcnJheUJ1ZmZlck9yU3RyaW5nRnJvbURhdGEgfSBmcm9tIFwiLi4vbG9hZGVyLXV0aWxzL2dldC1kYXRhLmpzXCI7XG5pbXBvcnQgeyBnZXRMb2FkZXJDb250ZXh0LCBnZXRMb2FkZXJzRnJvbUNvbnRleHQgfSBmcm9tIFwiLi4vbG9hZGVyLXV0aWxzL2xvYWRlci1jb250ZXh0LmpzXCI7XG5pbXBvcnQgeyBnZXRSZXNvdXJjZVVybCB9IGZyb20gXCIuLi91dGlscy9yZXNvdXJjZS11dGlscy5qc1wiO1xuaW1wb3J0IHsgc2VsZWN0TG9hZGVyIH0gZnJvbSBcIi4vc2VsZWN0LWxvYWRlci5qc1wiO1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHBhcnNlKGRhdGEsIGxvYWRlcnMsIG9wdGlvbnMsIGNvbnRleHQpIHtcbiAgaWYgKGxvYWRlcnMgJiYgIUFycmF5LmlzQXJyYXkobG9hZGVycykgJiYgIWlzTG9hZGVyT2JqZWN0KGxvYWRlcnMpKSB7XG4gICAgY29udGV4dCA9IHVuZGVmaW5lZDtcbiAgICBvcHRpb25zID0gbG9hZGVycztcbiAgICBsb2FkZXJzID0gdW5kZWZpbmVkO1xuICB9XG4gIGRhdGEgPSBhd2FpdCBkYXRhO1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgY29uc3QgdXJsID0gZ2V0UmVzb3VyY2VVcmwoZGF0YSk7XG4gIGNvbnN0IHR5cGVkTG9hZGVycyA9IGxvYWRlcnM7XG4gIGNvbnN0IGNhbmRpZGF0ZUxvYWRlcnMgPSBnZXRMb2FkZXJzRnJvbUNvbnRleHQodHlwZWRMb2FkZXJzLCBjb250ZXh0KTtcbiAgY29uc3QgbG9hZGVyID0gYXdhaXQgc2VsZWN0TG9hZGVyKGRhdGEsIGNhbmRpZGF0ZUxvYWRlcnMsIG9wdGlvbnMpO1xuICBpZiAoIWxvYWRlcikge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIG9wdGlvbnMgPSBub3JtYWxpemVPcHRpb25zKG9wdGlvbnMsIGxvYWRlciwgY2FuZGlkYXRlTG9hZGVycywgdXJsKTtcbiAgY29udGV4dCA9IGdldExvYWRlckNvbnRleHQoe1xuICAgIHVybCxcbiAgICBfcGFyc2U6IHBhcnNlLFxuICAgIGxvYWRlcnM6IGNhbmRpZGF0ZUxvYWRlcnNcbiAgfSwgb3B0aW9ucywgY29udGV4dCB8fCBudWxsKTtcbiAgcmV0dXJuIGF3YWl0IHBhcnNlV2l0aExvYWRlcihsb2FkZXIsIGRhdGEsIG9wdGlvbnMsIGNvbnRleHQpO1xufVxuYXN5bmMgZnVuY3Rpb24gcGFyc2VXaXRoTG9hZGVyKGxvYWRlciwgZGF0YSwgb3B0aW9ucywgY29udGV4dCkge1xuICB2YWxpZGF0ZVdvcmtlclZlcnNpb24obG9hZGVyKTtcbiAgb3B0aW9ucyA9IG1lcmdlTG9hZGVyT3B0aW9ucyhsb2FkZXIub3B0aW9ucywgb3B0aW9ucyk7XG4gIGlmIChpc1Jlc3BvbnNlKGRhdGEpKSB7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBkYXRhO1xuICAgIGNvbnN0IHtcbiAgICAgIG9rLFxuICAgICAgcmVkaXJlY3RlZCxcbiAgICAgIHN0YXR1cyxcbiAgICAgIHN0YXR1c1RleHQsXG4gICAgICB0eXBlLFxuICAgICAgdXJsXG4gICAgfSA9IHJlc3BvbnNlO1xuICAgIGNvbnN0IGhlYWRlcnMgPSBPYmplY3QuZnJvbUVudHJpZXMocmVzcG9uc2UuaGVhZGVycy5lbnRyaWVzKCkpO1xuICAgIGNvbnRleHQucmVzcG9uc2UgPSB7XG4gICAgICBoZWFkZXJzLFxuICAgICAgb2ssXG4gICAgICByZWRpcmVjdGVkLFxuICAgICAgc3RhdHVzLFxuICAgICAgc3RhdHVzVGV4dCxcbiAgICAgIHR5cGUsXG4gICAgICB1cmxcbiAgICB9O1xuICB9XG4gIGRhdGEgPSBhd2FpdCBnZXRBcnJheUJ1ZmZlck9yU3RyaW5nRnJvbURhdGEoZGF0YSwgbG9hZGVyLCBvcHRpb25zKTtcbiAgY29uc3QgbG9hZGVyV2l0aFBhcnNlciA9IGxvYWRlcjtcbiAgaWYgKGxvYWRlcldpdGhQYXJzZXIucGFyc2VUZXh0U3luYyAmJiB0eXBlb2YgZGF0YSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gbG9hZGVyV2l0aFBhcnNlci5wYXJzZVRleHRTeW5jKGRhdGEsIG9wdGlvbnMsIGNvbnRleHQpO1xuICB9XG4gIGlmIChjYW5QYXJzZVdpdGhXb3JrZXIobG9hZGVyLCBvcHRpb25zKSkge1xuICAgIHJldHVybiBhd2FpdCBwYXJzZVdpdGhXb3JrZXIobG9hZGVyLCBkYXRhLCBvcHRpb25zLCBjb250ZXh0LCBwYXJzZSk7XG4gIH1cbiAgaWYgKGxvYWRlcldpdGhQYXJzZXIucGFyc2VUZXh0ICYmIHR5cGVvZiBkYXRhID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBhd2FpdCBsb2FkZXJXaXRoUGFyc2VyLnBhcnNlVGV4dChkYXRhLCBvcHRpb25zLCBjb250ZXh0KTtcbiAgfVxuICBpZiAobG9hZGVyV2l0aFBhcnNlci5wYXJzZSkge1xuICAgIHJldHVybiBhd2FpdCBsb2FkZXJXaXRoUGFyc2VyLnBhcnNlKGRhdGEsIG9wdGlvbnMsIGNvbnRleHQpO1xuICB9XG4gIGFzc2VydCghbG9hZGVyV2l0aFBhcnNlci5wYXJzZVN5bmMpO1xuICB0aHJvdyBuZXcgRXJyb3IoYCR7bG9hZGVyLmlkfSBsb2FkZXIgLSBubyBwYXJzZXIgZm91bmQgYW5kIHdvcmtlciBpcyBkaXNhYmxlZGApO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cGFyc2UuanMubWFwIiwiaW1wb3J0IHsgbm9ybWFsaXplTG9hZGVyIH0gZnJvbSBcIi4uL2xvYWRlci11dGlscy9ub3JtYWxpemUtbG9hZGVyLmpzXCI7XG5pbXBvcnQgeyBnZXRHbG9iYWxMb2FkZXJTdGF0ZSB9IGZyb20gXCIuLi9sb2FkZXItdXRpbHMvb3B0aW9uLXV0aWxzLmpzXCI7XG5jb25zdCBnZXRHbG9iYWxMb2FkZXJSZWdpc3RyeSA9ICgpID0+IHtcbiAgY29uc3Qgc3RhdGUgPSBnZXRHbG9iYWxMb2FkZXJTdGF0ZSgpO1xuICBzdGF0ZS5sb2FkZXJSZWdpc3RyeSA9IHN0YXRlLmxvYWRlclJlZ2lzdHJ5IHx8IFtdO1xuICByZXR1cm4gc3RhdGUubG9hZGVyUmVnaXN0cnk7XG59O1xuZXhwb3J0IGZ1bmN0aW9uIHJlZ2lzdGVyTG9hZGVycyhsb2FkZXJzKSB7XG4gIGNvbnN0IGxvYWRlclJlZ2lzdHJ5ID0gZ2V0R2xvYmFsTG9hZGVyUmVnaXN0cnkoKTtcbiAgbG9hZGVycyA9IEFycmF5LmlzQXJyYXkobG9hZGVycykgPyBsb2FkZXJzIDogW2xvYWRlcnNdO1xuICBmb3IgKGNvbnN0IGxvYWRlciBvZiBsb2FkZXJzKSB7XG4gICAgY29uc3Qgbm9ybWFsaXplZExvYWRlciA9IG5vcm1hbGl6ZUxvYWRlcihsb2FkZXIpO1xuICAgIGlmICghbG9hZGVyUmVnaXN0cnkuZmluZChyZWdpc3RlcmVkTG9hZGVyID0+IG5vcm1hbGl6ZWRMb2FkZXIgPT09IHJlZ2lzdGVyZWRMb2FkZXIpKSB7XG4gICAgICBsb2FkZXJSZWdpc3RyeS51bnNoaWZ0KG5vcm1hbGl6ZWRMb2FkZXIpO1xuICAgIH1cbiAgfVxufVxuZXhwb3J0IGZ1bmN0aW9uIGdldFJlZ2lzdGVyZWRMb2FkZXJzKCkge1xuICByZXR1cm4gZ2V0R2xvYmFsTG9hZGVyUmVnaXN0cnkoKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBfdW5yZWdpc3RlckxvYWRlcnMoKSB7XG4gIGNvbnN0IHN0YXRlID0gZ2V0R2xvYmFsTG9hZGVyU3RhdGUoKTtcbiAgc3RhdGUubG9hZGVyUmVnaXN0cnkgPSBbXTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJlZ2lzdGVyLWxvYWRlcnMuanMubWFwIiwiaW1wb3J0IHsgY29tcGFyZUFycmF5QnVmZmVycywgcGF0aCB9IGZyb20gJ0Bsb2FkZXJzLmdsL2xvYWRlci11dGlscyc7XG5pbXBvcnQgeyBub3JtYWxpemVMb2FkZXIgfSBmcm9tIFwiLi4vbG9hZGVyLXV0aWxzL25vcm1hbGl6ZS1sb2FkZXIuanNcIjtcbmltcG9ydCB7IGxvZyB9IGZyb20gXCIuLi91dGlscy9sb2cuanNcIjtcbmltcG9ydCB7IGdldFJlc291cmNlVXJsLCBnZXRSZXNvdXJjZU1JTUVUeXBlIH0gZnJvbSBcIi4uL3V0aWxzL3Jlc291cmNlLXV0aWxzLmpzXCI7XG5pbXBvcnQgeyBnZXRSZWdpc3RlcmVkTG9hZGVycyB9IGZyb20gXCIuL3JlZ2lzdGVyLWxvYWRlcnMuanNcIjtcbmltcG9ydCB7IGlzQmxvYiB9IGZyb20gXCIuLi8uLi9qYXZhc2NyaXB0LXV0aWxzL2lzLXR5cGUuanNcIjtcbmltcG9ydCB7IHN0cmlwUXVlcnlTdHJpbmcgfSBmcm9tIFwiLi4vdXRpbHMvdXJsLXV0aWxzLmpzXCI7XG5jb25zdCBFWFRfUEFUVEVSTiA9IC9cXC4oW14uXSspJC87XG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gc2VsZWN0TG9hZGVyKGRhdGEpIHtcbiAgbGV0IGxvYWRlcnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IFtdO1xuICBsZXQgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyID8gYXJndW1lbnRzWzJdIDogdW5kZWZpbmVkO1xuICBsZXQgY29udGV4dCA9IGFyZ3VtZW50cy5sZW5ndGggPiAzID8gYXJndW1lbnRzWzNdIDogdW5kZWZpbmVkO1xuICBpZiAoIXZhbGlkSFRUUFJlc3BvbnNlKGRhdGEpKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgbGV0IGxvYWRlciA9IHNlbGVjdExvYWRlclN5bmMoZGF0YSwgbG9hZGVycywge1xuICAgIC4uLm9wdGlvbnMsXG4gICAgbm90aHJvdzogdHJ1ZVxuICB9LCBjb250ZXh0KTtcbiAgaWYgKGxvYWRlcikge1xuICAgIHJldHVybiBsb2FkZXI7XG4gIH1cbiAgaWYgKGlzQmxvYihkYXRhKSkge1xuICAgIGRhdGEgPSBhd2FpdCBkYXRhLnNsaWNlKDAsIDEwKS5hcnJheUJ1ZmZlcigpO1xuICAgIGxvYWRlciA9IHNlbGVjdExvYWRlclN5bmMoZGF0YSwgbG9hZGVycywgb3B0aW9ucywgY29udGV4dCk7XG4gIH1cbiAgaWYgKCFsb2FkZXIgJiYgIShvcHRpb25zICE9PSBudWxsICYmIG9wdGlvbnMgIT09IHZvaWQgMCAmJiBvcHRpb25zLm5vdGhyb3cpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGdldE5vVmFsaWRMb2FkZXJNZXNzYWdlKGRhdGEpKTtcbiAgfVxuICByZXR1cm4gbG9hZGVyO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHNlbGVjdExvYWRlclN5bmMoZGF0YSkge1xuICBsZXQgbG9hZGVycyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogW107XG4gIGxldCBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgPyBhcmd1bWVudHNbMl0gOiB1bmRlZmluZWQ7XG4gIGxldCBjb250ZXh0ID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgPyBhcmd1bWVudHNbM10gOiB1bmRlZmluZWQ7XG4gIGlmICghdmFsaWRIVFRQUmVzcG9uc2UoZGF0YSkpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBpZiAobG9hZGVycyAmJiAhQXJyYXkuaXNBcnJheShsb2FkZXJzKSkge1xuICAgIHJldHVybiBub3JtYWxpemVMb2FkZXIobG9hZGVycyk7XG4gIH1cbiAgbGV0IGNhbmRpZGF0ZUxvYWRlcnMgPSBbXTtcbiAgaWYgKGxvYWRlcnMpIHtcbiAgICBjYW5kaWRhdGVMb2FkZXJzID0gY2FuZGlkYXRlTG9hZGVycy5jb25jYXQobG9hZGVycyk7XG4gIH1cbiAgaWYgKCEob3B0aW9ucyAhPT0gbnVsbCAmJiBvcHRpb25zICE9PSB2b2lkIDAgJiYgb3B0aW9ucy5pZ25vcmVSZWdpc3RlcmVkTG9hZGVycykpIHtcbiAgICBjYW5kaWRhdGVMb2FkZXJzLnB1c2goLi4uZ2V0UmVnaXN0ZXJlZExvYWRlcnMoKSk7XG4gIH1cbiAgbm9ybWFsaXplTG9hZGVycyhjYW5kaWRhdGVMb2FkZXJzKTtcbiAgY29uc3QgbG9hZGVyID0gc2VsZWN0TG9hZGVySW50ZXJuYWwoZGF0YSwgY2FuZGlkYXRlTG9hZGVycywgb3B0aW9ucywgY29udGV4dCk7XG4gIGlmICghbG9hZGVyICYmICEob3B0aW9ucyAhPT0gbnVsbCAmJiBvcHRpb25zICE9PSB2b2lkIDAgJiYgb3B0aW9ucy5ub3Rocm93KSkge1xuICAgIHRocm93IG5ldyBFcnJvcihnZXROb1ZhbGlkTG9hZGVyTWVzc2FnZShkYXRhKSk7XG4gIH1cbiAgcmV0dXJuIGxvYWRlcjtcbn1cbmZ1bmN0aW9uIHNlbGVjdExvYWRlckludGVybmFsKGRhdGEsIGxvYWRlcnMsIG9wdGlvbnMsIGNvbnRleHQpIHtcbiAgY29uc3QgdXJsID0gZ2V0UmVzb3VyY2VVcmwoZGF0YSk7XG4gIGNvbnN0IHR5cGUgPSBnZXRSZXNvdXJjZU1JTUVUeXBlKGRhdGEpO1xuICBjb25zdCB0ZXN0VXJsID0gc3RyaXBRdWVyeVN0cmluZyh1cmwpIHx8IChjb250ZXh0ID09PSBudWxsIHx8IGNvbnRleHQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNvbnRleHQudXJsKTtcbiAgbGV0IGxvYWRlciA9IG51bGw7XG4gIGxldCByZWFzb24gPSAnJztcbiAgaWYgKG9wdGlvbnMgIT09IG51bGwgJiYgb3B0aW9ucyAhPT0gdm9pZCAwICYmIG9wdGlvbnMubWltZVR5cGUpIHtcbiAgICBsb2FkZXIgPSBmaW5kTG9hZGVyQnlNSU1FVHlwZShsb2FkZXJzLCBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMubWltZVR5cGUpO1xuICAgIHJlYXNvbiA9IGBtYXRjaCBmb3JjZWQgYnkgc3VwcGxpZWQgTUlNRSB0eXBlICR7b3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLm1pbWVUeXBlfWA7XG4gIH1cbiAgbG9hZGVyID0gbG9hZGVyIHx8IGZpbmRMb2FkZXJCeVVybChsb2FkZXJzLCB0ZXN0VXJsKTtcbiAgcmVhc29uID0gcmVhc29uIHx8IChsb2FkZXIgPyBgbWF0Y2hlZCB1cmwgJHt0ZXN0VXJsfWAgOiAnJyk7XG4gIGxvYWRlciA9IGxvYWRlciB8fCBmaW5kTG9hZGVyQnlNSU1FVHlwZShsb2FkZXJzLCB0eXBlKTtcbiAgcmVhc29uID0gcmVhc29uIHx8IChsb2FkZXIgPyBgbWF0Y2hlZCBNSU1FIHR5cGUgJHt0eXBlfWAgOiAnJyk7XG4gIGxvYWRlciA9IGxvYWRlciB8fCBmaW5kTG9hZGVyQnlJbml0aWFsQnl0ZXMobG9hZGVycywgZGF0YSk7XG4gIHJlYXNvbiA9IHJlYXNvbiB8fCAobG9hZGVyID8gYG1hdGNoZWQgaW5pdGlhbCBkYXRhICR7Z2V0Rmlyc3RDaGFyYWN0ZXJzKGRhdGEpfWAgOiAnJyk7XG4gIGlmIChvcHRpb25zICE9PSBudWxsICYmIG9wdGlvbnMgIT09IHZvaWQgMCAmJiBvcHRpb25zLmZhbGxiYWNrTWltZVR5cGUpIHtcbiAgICBsb2FkZXIgPSBsb2FkZXIgfHwgZmluZExvYWRlckJ5TUlNRVR5cGUobG9hZGVycywgb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmZhbGxiYWNrTWltZVR5cGUpO1xuICAgIHJlYXNvbiA9IHJlYXNvbiB8fCAobG9hZGVyID8gYG1hdGNoZWQgZmFsbGJhY2sgTUlNRSB0eXBlICR7dHlwZX1gIDogJycpO1xuICB9XG4gIGlmIChyZWFzb24pIHtcbiAgICB2YXIgX2xvYWRlcjtcbiAgICBsb2cubG9nKDEsIGBzZWxlY3RMb2FkZXIgc2VsZWN0ZWQgJHsoX2xvYWRlciA9IGxvYWRlcikgPT09IG51bGwgfHwgX2xvYWRlciA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2xvYWRlci5uYW1lfTogJHtyZWFzb259LmApO1xuICB9XG4gIHJldHVybiBsb2FkZXI7XG59XG5mdW5jdGlvbiB2YWxpZEhUVFBSZXNwb25zZShkYXRhKSB7XG4gIGlmIChkYXRhIGluc3RhbmNlb2YgUmVzcG9uc2UpIHtcbiAgICBpZiAoZGF0YS5zdGF0dXMgPT09IDIwNCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cbmZ1bmN0aW9uIGdldE5vVmFsaWRMb2FkZXJNZXNzYWdlKGRhdGEpIHtcbiAgY29uc3QgdXJsID0gZ2V0UmVzb3VyY2VVcmwoZGF0YSk7XG4gIGNvbnN0IHR5cGUgPSBnZXRSZXNvdXJjZU1JTUVUeXBlKGRhdGEpO1xuICBsZXQgbWVzc2FnZSA9ICdObyB2YWxpZCBsb2FkZXIgZm91bmQgKCc7XG4gIG1lc3NhZ2UgKz0gdXJsID8gYCR7cGF0aC5maWxlbmFtZSh1cmwpfSwgYCA6ICdubyB1cmwgcHJvdmlkZWQsICc7XG4gIG1lc3NhZ2UgKz0gYE1JTUUgdHlwZTogJHt0eXBlID8gYFwiJHt0eXBlfVwiYCA6ICdub3QgcHJvdmlkZWQnfSwgYDtcbiAgY29uc3QgZmlyc3RDaGFyYWN0ZXJzID0gZGF0YSA/IGdldEZpcnN0Q2hhcmFjdGVycyhkYXRhKSA6ICcnO1xuICBtZXNzYWdlICs9IGZpcnN0Q2hhcmFjdGVycyA/IGAgZmlyc3QgYnl0ZXM6IFwiJHtmaXJzdENoYXJhY3RlcnN9XCJgIDogJ2ZpcnN0IGJ5dGVzOiBub3QgYXZhaWxhYmxlJztcbiAgbWVzc2FnZSArPSAnKSc7XG4gIHJldHVybiBtZXNzYWdlO1xufVxuZnVuY3Rpb24gbm9ybWFsaXplTG9hZGVycyhsb2FkZXJzKSB7XG4gIGZvciAoY29uc3QgbG9hZGVyIG9mIGxvYWRlcnMpIHtcbiAgICBub3JtYWxpemVMb2FkZXIobG9hZGVyKTtcbiAgfVxufVxuZnVuY3Rpb24gZmluZExvYWRlckJ5VXJsKGxvYWRlcnMsIHVybCkge1xuICBjb25zdCBtYXRjaCA9IHVybCAmJiBFWFRfUEFUVEVSTi5leGVjKHVybCk7XG4gIGNvbnN0IGV4dGVuc2lvbiA9IG1hdGNoICYmIG1hdGNoWzFdO1xuICByZXR1cm4gZXh0ZW5zaW9uID8gZmluZExvYWRlckJ5RXh0ZW5zaW9uKGxvYWRlcnMsIGV4dGVuc2lvbikgOiBudWxsO1xufVxuZnVuY3Rpb24gZmluZExvYWRlckJ5RXh0ZW5zaW9uKGxvYWRlcnMsIGV4dGVuc2lvbikge1xuICBleHRlbnNpb24gPSBleHRlbnNpb24udG9Mb3dlckNhc2UoKTtcbiAgZm9yIChjb25zdCBsb2FkZXIgb2YgbG9hZGVycykge1xuICAgIGZvciAoY29uc3QgbG9hZGVyRXh0ZW5zaW9uIG9mIGxvYWRlci5leHRlbnNpb25zKSB7XG4gICAgICBpZiAobG9hZGVyRXh0ZW5zaW9uLnRvTG93ZXJDYXNlKCkgPT09IGV4dGVuc2lvbikge1xuICAgICAgICByZXR1cm4gbG9hZGVyO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIGZpbmRMb2FkZXJCeU1JTUVUeXBlKGxvYWRlcnMsIG1pbWVUeXBlKSB7XG4gIGZvciAoY29uc3QgbG9hZGVyIG9mIGxvYWRlcnMpIHtcbiAgICBpZiAobG9hZGVyLm1pbWVUeXBlcyAmJiBsb2FkZXIubWltZVR5cGVzLmluY2x1ZGVzKG1pbWVUeXBlKSkge1xuICAgICAgcmV0dXJuIGxvYWRlcjtcbiAgICB9XG4gICAgaWYgKG1pbWVUeXBlID09PSBgYXBwbGljYXRpb24veC4ke2xvYWRlci5pZH1gKSB7XG4gICAgICByZXR1cm4gbG9hZGVyO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIGZpbmRMb2FkZXJCeUluaXRpYWxCeXRlcyhsb2FkZXJzLCBkYXRhKSB7XG4gIGlmICghZGF0YSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGZvciAoY29uc3QgbG9hZGVyIG9mIGxvYWRlcnMpIHtcbiAgICBpZiAodHlwZW9mIGRhdGEgPT09ICdzdHJpbmcnKSB7XG4gICAgICBpZiAodGVzdERhdGFBZ2FpbnN0VGV4dChkYXRhLCBsb2FkZXIpKSB7XG4gICAgICAgIHJldHVybiBsb2FkZXI7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChBcnJheUJ1ZmZlci5pc1ZpZXcoZGF0YSkpIHtcbiAgICAgIGlmICh0ZXN0RGF0YUFnYWluc3RCaW5hcnkoZGF0YS5idWZmZXIsIGRhdGEuYnl0ZU9mZnNldCwgbG9hZGVyKSkge1xuICAgICAgICByZXR1cm4gbG9hZGVyO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoZGF0YSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB7XG4gICAgICBjb25zdCBieXRlT2Zmc2V0ID0gMDtcbiAgICAgIGlmICh0ZXN0RGF0YUFnYWluc3RCaW5hcnkoZGF0YSwgYnl0ZU9mZnNldCwgbG9hZGVyKSkge1xuICAgICAgICByZXR1cm4gbG9hZGVyO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIHRlc3REYXRhQWdhaW5zdFRleHQoZGF0YSwgbG9hZGVyKSB7XG4gIGlmIChsb2FkZXIudGVzdFRleHQpIHtcbiAgICByZXR1cm4gbG9hZGVyLnRlc3RUZXh0KGRhdGEpO1xuICB9XG4gIGNvbnN0IHRlc3RzID0gQXJyYXkuaXNBcnJheShsb2FkZXIudGVzdHMpID8gbG9hZGVyLnRlc3RzIDogW2xvYWRlci50ZXN0c107XG4gIHJldHVybiB0ZXN0cy5zb21lKHRlc3QgPT4gZGF0YS5zdGFydHNXaXRoKHRlc3QpKTtcbn1cbmZ1bmN0aW9uIHRlc3REYXRhQWdhaW5zdEJpbmFyeShkYXRhLCBieXRlT2Zmc2V0LCBsb2FkZXIpIHtcbiAgY29uc3QgdGVzdHMgPSBBcnJheS5pc0FycmF5KGxvYWRlci50ZXN0cykgPyBsb2FkZXIudGVzdHMgOiBbbG9hZGVyLnRlc3RzXTtcbiAgcmV0dXJuIHRlc3RzLnNvbWUodGVzdCA9PiB0ZXN0QmluYXJ5KGRhdGEsIGJ5dGVPZmZzZXQsIGxvYWRlciwgdGVzdCkpO1xufVxuZnVuY3Rpb24gdGVzdEJpbmFyeShkYXRhLCBieXRlT2Zmc2V0LCBsb2FkZXIsIHRlc3QpIHtcbiAgaWYgKHRlc3QgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikge1xuICAgIHJldHVybiBjb21wYXJlQXJyYXlCdWZmZXJzKHRlc3QsIGRhdGEsIHRlc3QuYnl0ZUxlbmd0aCk7XG4gIH1cbiAgc3dpdGNoICh0eXBlb2YgdGVzdCkge1xuICAgIGNhc2UgJ2Z1bmN0aW9uJzpcbiAgICAgIHJldHVybiB0ZXN0KGRhdGEpO1xuICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICBjb25zdCBtYWdpYyA9IGdldE1hZ2ljU3RyaW5nKGRhdGEsIGJ5dGVPZmZzZXQsIHRlc3QubGVuZ3RoKTtcbiAgICAgIHJldHVybiB0ZXN0ID09PSBtYWdpYztcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5mdW5jdGlvbiBnZXRGaXJzdENoYXJhY3RlcnMoZGF0YSkge1xuICBsZXQgbGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiA1O1xuICBpZiAodHlwZW9mIGRhdGEgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIGRhdGEuc2xpY2UoMCwgbGVuZ3RoKTtcbiAgfSBlbHNlIGlmIChBcnJheUJ1ZmZlci5pc1ZpZXcoZGF0YSkpIHtcbiAgICByZXR1cm4gZ2V0TWFnaWNTdHJpbmcoZGF0YS5idWZmZXIsIGRhdGEuYnl0ZU9mZnNldCwgbGVuZ3RoKTtcbiAgfSBlbHNlIGlmIChkYXRhIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHtcbiAgICBjb25zdCBieXRlT2Zmc2V0ID0gMDtcbiAgICByZXR1cm4gZ2V0TWFnaWNTdHJpbmcoZGF0YSwgYnl0ZU9mZnNldCwgbGVuZ3RoKTtcbiAgfVxuICByZXR1cm4gJyc7XG59XG5mdW5jdGlvbiBnZXRNYWdpY1N0cmluZyhhcnJheUJ1ZmZlciwgYnl0ZU9mZnNldCwgbGVuZ3RoKSB7XG4gIGlmIChhcnJheUJ1ZmZlci5ieXRlTGVuZ3RoIDwgYnl0ZU9mZnNldCArIGxlbmd0aCkge1xuICAgIHJldHVybiAnJztcbiAgfVxuICBjb25zdCBkYXRhVmlldyA9IG5ldyBEYXRhVmlldyhhcnJheUJ1ZmZlcik7XG4gIGxldCBtYWdpYyA9ICcnO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgbWFnaWMgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShkYXRhVmlldy5nZXRVaW50OChieXRlT2Zmc2V0ICsgaSkpO1xuICB9XG4gIHJldHVybiBtYWdpYztcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNlbGVjdC1sb2FkZXIuanMubWFwIiwiaW1wb3J0IHsgcmVzb2x2ZVBhdGggfSBmcm9tICdAbG9hZGVycy5nbC9sb2FkZXItdXRpbHMnO1xuaW1wb3J0IHsgbWFrZVJlc3BvbnNlIH0gZnJvbSBcIi4uL3V0aWxzL3Jlc3BvbnNlLXV0aWxzLmpzXCI7XG5leHBvcnQgZnVuY3Rpb24gaXNOb2RlUGF0aCh1cmwpIHtcbiAgcmV0dXJuICFpc1JlcXVlc3RVUkwodXJsKSAmJiAhaXNEYXRhVVJMKHVybCk7XG59XG5leHBvcnQgZnVuY3Rpb24gaXNSZXF1ZXN0VVJMKHVybCkge1xuICByZXR1cm4gdXJsLnN0YXJ0c1dpdGgoJ2h0dHA6JykgfHwgdXJsLnN0YXJ0c1dpdGgoJ2h0dHBzOicpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGlzRGF0YVVSTCh1cmwpIHtcbiAgcmV0dXJuIHVybC5zdGFydHNXaXRoKCdkYXRhOicpO1xufVxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGZldGNoRmlsZSh1cmxPckRhdGEsIGZldGNoT3B0aW9ucykge1xuICBpZiAodHlwZW9mIHVybE9yRGF0YSA9PT0gJ3N0cmluZycpIHtcbiAgICBjb25zdCB1cmwgPSByZXNvbHZlUGF0aCh1cmxPckRhdGEpO1xuICAgIGlmIChpc05vZGVQYXRoKHVybCkpIHtcbiAgICAgIHZhciBfZ2xvYmFsVGhpcyRsb2FkZXJzO1xuICAgICAgaWYgKChfZ2xvYmFsVGhpcyRsb2FkZXJzID0gZ2xvYmFsVGhpcy5sb2FkZXJzKSAhPT0gbnVsbCAmJiBfZ2xvYmFsVGhpcyRsb2FkZXJzICE9PSB2b2lkIDAgJiYgX2dsb2JhbFRoaXMkbG9hZGVycy5mZXRjaE5vZGUpIHtcbiAgICAgICAgdmFyIF9nbG9iYWxUaGlzJGxvYWRlcnMyO1xuICAgICAgICByZXR1cm4gKF9nbG9iYWxUaGlzJGxvYWRlcnMyID0gZ2xvYmFsVGhpcy5sb2FkZXJzKSA9PT0gbnVsbCB8fCBfZ2xvYmFsVGhpcyRsb2FkZXJzMiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2dsb2JhbFRoaXMkbG9hZGVyczIuZmV0Y2hOb2RlKHVybCwgZmV0Y2hPcHRpb25zKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGF3YWl0IGZldGNoKHVybCwgZmV0Y2hPcHRpb25zKTtcbiAgfVxuICByZXR1cm4gYXdhaXQgbWFrZVJlc3BvbnNlKHVybE9yRGF0YSk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1mZXRjaC1maWxlLmpzLm1hcCIsImltcG9ydCB7IGNvbmNhdGVuYXRlQXJyYXlCdWZmZXJzQXN5bmMgfSBmcm9tICdAbG9hZGVycy5nbC9sb2FkZXItdXRpbHMnO1xuaW1wb3J0IHsgaXNSZXNwb25zZSwgaXNSZWFkYWJsZVN0cmVhbSwgaXNBc3luY0l0ZXJhYmxlLCBpc0l0ZXJhYmxlLCBpc0l0ZXJhdG9yLCBpc0Jsb2IsIGlzQnVmZmVyIH0gZnJvbSBcIi4uLy4uL2phdmFzY3JpcHQtdXRpbHMvaXMtdHlwZS5qc1wiO1xuaW1wb3J0IHsgbWFrZUl0ZXJhdG9yIH0gZnJvbSBcIi4uLy4uL2l0ZXJhdG9ycy9tYWtlLWl0ZXJhdG9yL21ha2UtaXRlcmF0b3IuanNcIjtcbmltcG9ydCB7IGNoZWNrUmVzcG9uc2UsIG1ha2VSZXNwb25zZSB9IGZyb20gXCIuLi91dGlscy9yZXNwb25zZS11dGlscy5qc1wiO1xuY29uc3QgRVJSX0RBVEEgPSAnQ2Fubm90IGNvbnZlcnQgc3VwcGxpZWQgZGF0YSB0eXBlJztcbmV4cG9ydCBmdW5jdGlvbiBnZXRBcnJheUJ1ZmZlck9yU3RyaW5nRnJvbURhdGFTeW5jKGRhdGEsIGxvYWRlciwgb3B0aW9ucykge1xuICBpZiAobG9hZGVyLnRleHQgJiYgdHlwZW9mIGRhdGEgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIGRhdGE7XG4gIH1cbiAgaWYgKGlzQnVmZmVyKGRhdGEpKSB7XG4gICAgZGF0YSA9IGRhdGEuYnVmZmVyO1xuICB9XG4gIGlmIChkYXRhIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHtcbiAgICBjb25zdCBhcnJheUJ1ZmZlciA9IGRhdGE7XG4gICAgaWYgKGxvYWRlci50ZXh0ICYmICFsb2FkZXIuYmluYXJ5KSB7XG4gICAgICBjb25zdCB0ZXh0RGVjb2RlciA9IG5ldyBUZXh0RGVjb2RlcigndXRmOCcpO1xuICAgICAgcmV0dXJuIHRleHREZWNvZGVyLmRlY29kZShhcnJheUJ1ZmZlcik7XG4gICAgfVxuICAgIHJldHVybiBhcnJheUJ1ZmZlcjtcbiAgfVxuICBpZiAoQXJyYXlCdWZmZXIuaXNWaWV3KGRhdGEpKSB7XG4gICAgaWYgKGxvYWRlci50ZXh0ICYmICFsb2FkZXIuYmluYXJ5KSB7XG4gICAgICBjb25zdCB0ZXh0RGVjb2RlciA9IG5ldyBUZXh0RGVjb2RlcigndXRmOCcpO1xuICAgICAgcmV0dXJuIHRleHREZWNvZGVyLmRlY29kZShkYXRhKTtcbiAgICB9XG4gICAgbGV0IGFycmF5QnVmZmVyID0gZGF0YS5idWZmZXI7XG4gICAgY29uc3QgYnl0ZUxlbmd0aCA9IGRhdGEuYnl0ZUxlbmd0aCB8fCBkYXRhLmxlbmd0aDtcbiAgICBpZiAoZGF0YS5ieXRlT2Zmc2V0ICE9PSAwIHx8IGJ5dGVMZW5ndGggIT09IGFycmF5QnVmZmVyLmJ5dGVMZW5ndGgpIHtcbiAgICAgIGFycmF5QnVmZmVyID0gYXJyYXlCdWZmZXIuc2xpY2UoZGF0YS5ieXRlT2Zmc2V0LCBkYXRhLmJ5dGVPZmZzZXQgKyBieXRlTGVuZ3RoKTtcbiAgICB9XG4gICAgcmV0dXJuIGFycmF5QnVmZmVyO1xuICB9XG4gIHRocm93IG5ldyBFcnJvcihFUlJfREFUQSk7XG59XG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0QXJyYXlCdWZmZXJPclN0cmluZ0Zyb21EYXRhKGRhdGEsIGxvYWRlciwgb3B0aW9ucykge1xuICBjb25zdCBpc0FycmF5QnVmZmVyID0gZGF0YSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyIHx8IEFycmF5QnVmZmVyLmlzVmlldyhkYXRhKTtcbiAgaWYgKHR5cGVvZiBkYXRhID09PSAnc3RyaW5nJyB8fCBpc0FycmF5QnVmZmVyKSB7XG4gICAgcmV0dXJuIGdldEFycmF5QnVmZmVyT3JTdHJpbmdGcm9tRGF0YVN5bmMoZGF0YSwgbG9hZGVyLCBvcHRpb25zKTtcbiAgfVxuICBpZiAoaXNCbG9iKGRhdGEpKSB7XG4gICAgZGF0YSA9IGF3YWl0IG1ha2VSZXNwb25zZShkYXRhKTtcbiAgfVxuICBpZiAoaXNSZXNwb25zZShkYXRhKSkge1xuICAgIGNvbnN0IHJlc3BvbnNlID0gZGF0YTtcbiAgICBhd2FpdCBjaGVja1Jlc3BvbnNlKHJlc3BvbnNlKTtcbiAgICByZXR1cm4gbG9hZGVyLmJpbmFyeSA/IGF3YWl0IHJlc3BvbnNlLmFycmF5QnVmZmVyKCkgOiBhd2FpdCByZXNwb25zZS50ZXh0KCk7XG4gIH1cbiAgaWYgKGlzUmVhZGFibGVTdHJlYW0oZGF0YSkpIHtcbiAgICBkYXRhID0gbWFrZUl0ZXJhdG9yKGRhdGEsIG9wdGlvbnMpO1xuICB9XG4gIGlmIChpc0l0ZXJhYmxlKGRhdGEpIHx8IGlzQXN5bmNJdGVyYWJsZShkYXRhKSkge1xuICAgIHJldHVybiBjb25jYXRlbmF0ZUFycmF5QnVmZmVyc0FzeW5jKGRhdGEpO1xuICB9XG4gIHRocm93IG5ldyBFcnJvcihFUlJfREFUQSk7XG59XG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0QXN5bmNJdGVyYWJsZUZyb21EYXRhKGRhdGEsIG9wdGlvbnMpIHtcbiAgaWYgKGlzSXRlcmF0b3IoZGF0YSkpIHtcbiAgICByZXR1cm4gZGF0YTtcbiAgfVxuICBpZiAoaXNSZXNwb25zZShkYXRhKSkge1xuICAgIGNvbnN0IHJlc3BvbnNlID0gZGF0YTtcbiAgICBhd2FpdCBjaGVja1Jlc3BvbnNlKHJlc3BvbnNlKTtcbiAgICBjb25zdCBib2R5ID0gYXdhaXQgcmVzcG9uc2UuYm9keTtcbiAgICByZXR1cm4gbWFrZUl0ZXJhdG9yKGJvZHksIG9wdGlvbnMpO1xuICB9XG4gIGlmIChpc0Jsb2IoZGF0YSkgfHwgaXNSZWFkYWJsZVN0cmVhbShkYXRhKSkge1xuICAgIHJldHVybiBtYWtlSXRlcmF0b3IoZGF0YSwgb3B0aW9ucyk7XG4gIH1cbiAgaWYgKGlzQXN5bmNJdGVyYWJsZShkYXRhKSkge1xuICAgIHJldHVybiBkYXRhO1xuICB9XG4gIHJldHVybiBnZXRJdGVyYWJsZUZyb21EYXRhKGRhdGEpO1xufVxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldFJlYWRhYmxlU3RyZWFtKGRhdGEpIHtcbiAgaWYgKGlzUmVhZGFibGVTdHJlYW0oZGF0YSkpIHtcbiAgICByZXR1cm4gZGF0YTtcbiAgfVxuICBpZiAoaXNSZXNwb25zZShkYXRhKSkge1xuICAgIHJldHVybiBkYXRhLmJvZHk7XG4gIH1cbiAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBtYWtlUmVzcG9uc2UoZGF0YSk7XG4gIHJldHVybiByZXNwb25zZS5ib2R5O1xufVxuZnVuY3Rpb24gZ2V0SXRlcmFibGVGcm9tRGF0YShkYXRhKSB7XG4gIGlmIChBcnJheUJ1ZmZlci5pc1ZpZXcoZGF0YSkpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24qIG9uZUNodW5rKCkge1xuICAgICAgeWllbGQgZGF0YS5idWZmZXI7XG4gICAgfSgpO1xuICB9XG4gIGlmIChkYXRhIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24qIG9uZUNodW5rKCkge1xuICAgICAgeWllbGQgZGF0YTtcbiAgICB9KCk7XG4gIH1cbiAgaWYgKGlzSXRlcmF0b3IoZGF0YSkpIHtcbiAgICByZXR1cm4gZGF0YTtcbiAgfVxuICBpZiAoaXNJdGVyYWJsZShkYXRhKSkge1xuICAgIHJldHVybiBkYXRhW1N5bWJvbC5pdGVyYXRvcl0oKTtcbiAgfVxuICB0aHJvdyBuZXcgRXJyb3IoRVJSX0RBVEEpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Z2V0LWRhdGEuanMubWFwIiwiaW1wb3J0IHsgaXNPYmplY3QgfSBmcm9tIFwiLi4vLi4vamF2YXNjcmlwdC11dGlscy9pcy10eXBlLmpzXCI7XG5pbXBvcnQgeyBmZXRjaEZpbGUgfSBmcm9tIFwiLi4vZmV0Y2gvZmV0Y2gtZmlsZS5qc1wiO1xuaW1wb3J0IHsgZ2V0R2xvYmFsTG9hZGVyT3B0aW9ucyB9IGZyb20gXCIuL29wdGlvbi11dGlscy5qc1wiO1xuZXhwb3J0IGZ1bmN0aW9uIGdldEZldGNoRnVuY3Rpb24ob3B0aW9ucywgY29udGV4dCkge1xuICBjb25zdCBnbG9iYWxPcHRpb25zID0gZ2V0R2xvYmFsTG9hZGVyT3B0aW9ucygpO1xuICBjb25zdCBsb2FkZXJPcHRpb25zID0gb3B0aW9ucyB8fCBnbG9iYWxPcHRpb25zO1xuICBpZiAodHlwZW9mIGxvYWRlck9wdGlvbnMuZmV0Y2ggPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gbG9hZGVyT3B0aW9ucy5mZXRjaDtcbiAgfVxuICBpZiAoaXNPYmplY3QobG9hZGVyT3B0aW9ucy5mZXRjaCkpIHtcbiAgICByZXR1cm4gdXJsID0+IGZldGNoRmlsZSh1cmwsIGxvYWRlck9wdGlvbnMuZmV0Y2gpO1xuICB9XG4gIGlmIChjb250ZXh0ICE9PSBudWxsICYmIGNvbnRleHQgIT09IHZvaWQgMCAmJiBjb250ZXh0LmZldGNoKSB7XG4gICAgcmV0dXJuIGNvbnRleHQgPT09IG51bGwgfHwgY29udGV4dCA9PT0gdm9pZCAwID8gdm9pZCAwIDogY29udGV4dC5mZXRjaDtcbiAgfVxuICByZXR1cm4gZmV0Y2hGaWxlO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Z2V0LWZldGNoLWZ1bmN0aW9uLmpzLm1hcCIsImltcG9ydCB7IGdldEZldGNoRnVuY3Rpb24gfSBmcm9tIFwiLi9nZXQtZmV0Y2gtZnVuY3Rpb24uanNcIjtcbmltcG9ydCB7IGV4dHJhY3RRdWVyeVN0cmluZywgc3RyaXBRdWVyeVN0cmluZyB9IGZyb20gXCIuLi91dGlscy91cmwtdXRpbHMuanNcIjtcbmltcG9ydCB7IHBhdGggfSBmcm9tICdAbG9hZGVycy5nbC9sb2FkZXItdXRpbHMnO1xuZXhwb3J0IGZ1bmN0aW9uIGdldExvYWRlckNvbnRleHQoY29udGV4dCwgb3B0aW9ucywgcGFyZW50Q29udGV4dCkge1xuICBpZiAocGFyZW50Q29udGV4dCkge1xuICAgIHJldHVybiBwYXJlbnRDb250ZXh0O1xuICB9XG4gIGNvbnN0IG5ld0NvbnRleHQgPSB7XG4gICAgZmV0Y2g6IGdldEZldGNoRnVuY3Rpb24ob3B0aW9ucywgY29udGV4dCksXG4gICAgLi4uY29udGV4dFxuICB9O1xuICBpZiAobmV3Q29udGV4dC51cmwpIHtcbiAgICBjb25zdCBiYXNlVXJsID0gc3RyaXBRdWVyeVN0cmluZyhuZXdDb250ZXh0LnVybCk7XG4gICAgbmV3Q29udGV4dC5iYXNlVXJsID0gYmFzZVVybDtcbiAgICBuZXdDb250ZXh0LnF1ZXJ5U3RyaW5nID0gZXh0cmFjdFF1ZXJ5U3RyaW5nKG5ld0NvbnRleHQudXJsKTtcbiAgICBuZXdDb250ZXh0LmZpbGVuYW1lID0gcGF0aC5maWxlbmFtZShiYXNlVXJsKTtcbiAgICBuZXdDb250ZXh0LmJhc2VVcmwgPSBwYXRoLmRpcm5hbWUoYmFzZVVybCk7XG4gIH1cbiAgaWYgKCFBcnJheS5pc0FycmF5KG5ld0NvbnRleHQubG9hZGVycykpIHtcbiAgICBuZXdDb250ZXh0LmxvYWRlcnMgPSBudWxsO1xuICB9XG4gIHJldHVybiBuZXdDb250ZXh0O1xufVxuZXhwb3J0IGZ1bmN0aW9uIGdldExvYWRlcnNGcm9tQ29udGV4dChsb2FkZXJzLCBjb250ZXh0KSB7XG4gIGlmIChsb2FkZXJzICYmICFBcnJheS5pc0FycmF5KGxvYWRlcnMpKSB7XG4gICAgcmV0dXJuIGxvYWRlcnM7XG4gIH1cbiAgbGV0IGNhbmRpZGF0ZUxvYWRlcnM7XG4gIGlmIChsb2FkZXJzKSB7XG4gICAgY2FuZGlkYXRlTG9hZGVycyA9IEFycmF5LmlzQXJyYXkobG9hZGVycykgPyBsb2FkZXJzIDogW2xvYWRlcnNdO1xuICB9XG4gIGlmIChjb250ZXh0ICYmIGNvbnRleHQubG9hZGVycykge1xuICAgIGNvbnN0IGNvbnRleHRMb2FkZXJzID0gQXJyYXkuaXNBcnJheShjb250ZXh0LmxvYWRlcnMpID8gY29udGV4dC5sb2FkZXJzIDogW2NvbnRleHQubG9hZGVyc107XG4gICAgY2FuZGlkYXRlTG9hZGVycyA9IGNhbmRpZGF0ZUxvYWRlcnMgPyBbLi4uY2FuZGlkYXRlTG9hZGVycywgLi4uY29udGV4dExvYWRlcnNdIDogY29udGV4dExvYWRlcnM7XG4gIH1cbiAgcmV0dXJuIGNhbmRpZGF0ZUxvYWRlcnMgJiYgY2FuZGlkYXRlTG9hZGVycy5sZW5ndGggPyBjYW5kaWRhdGVMb2FkZXJzIDogdW5kZWZpbmVkO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bG9hZGVyLWNvbnRleHQuanMubWFwIiwiaW1wb3J0IHsgTG9nIH0gZnJvbSAnQHByb2JlLmdsL2xvZyc7XG5leHBvcnQgY29uc3QgcHJvYmVMb2cgPSBuZXcgTG9nKHtcbiAgaWQ6ICdsb2FkZXJzLmdsJ1xufSk7XG5leHBvcnQgY2xhc3MgTnVsbExvZyB7XG4gIGxvZygpIHtcbiAgICByZXR1cm4gKCkgPT4ge307XG4gIH1cbiAgaW5mbygpIHtcbiAgICByZXR1cm4gKCkgPT4ge307XG4gIH1cbiAgd2FybigpIHtcbiAgICByZXR1cm4gKCkgPT4ge307XG4gIH1cbiAgZXJyb3IoKSB7XG4gICAgcmV0dXJuICgpID0+IHt9O1xuICB9XG59XG5leHBvcnQgY2xhc3MgQ29uc29sZUxvZyB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuY29uc29sZSA9IHZvaWQgMDtcbiAgICB0aGlzLmNvbnNvbGUgPSBjb25zb2xlO1xuICB9XG4gIGxvZygpIHtcbiAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgIGFyZ3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmNvbnNvbGUubG9nLmJpbmQodGhpcy5jb25zb2xlLCAuLi5hcmdzKTtcbiAgfVxuICBpbmZvKCkge1xuICAgIGZvciAodmFyIF9sZW4yID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuMiksIF9rZXkyID0gMDsgX2tleTIgPCBfbGVuMjsgX2tleTIrKykge1xuICAgICAgYXJnc1tfa2V5Ml0gPSBhcmd1bWVudHNbX2tleTJdO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5jb25zb2xlLmluZm8uYmluZCh0aGlzLmNvbnNvbGUsIC4uLmFyZ3MpO1xuICB9XG4gIHdhcm4oKSB7XG4gICAgZm9yICh2YXIgX2xlbjMgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4zKSwgX2tleTMgPSAwOyBfa2V5MyA8IF9sZW4zOyBfa2V5MysrKSB7XG4gICAgICBhcmdzW19rZXkzXSA9IGFyZ3VtZW50c1tfa2V5M107XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmNvbnNvbGUud2Fybi5iaW5kKHRoaXMuY29uc29sZSwgLi4uYXJncyk7XG4gIH1cbiAgZXJyb3IoKSB7XG4gICAgZm9yICh2YXIgX2xlbjQgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW40KSwgX2tleTQgPSAwOyBfa2V5NCA8IF9sZW40OyBfa2V5NCsrKSB7XG4gICAgICBhcmdzW19rZXk0XSA9IGFyZ3VtZW50c1tfa2V5NF07XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmNvbnNvbGUuZXJyb3IuYmluZCh0aGlzLmNvbnNvbGUsIC4uLmFyZ3MpO1xuICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1sb2dnZXJzLmpzLm1hcCIsImltcG9ydCB7IGFzc2VydCB9IGZyb20gJ0Bsb2FkZXJzLmdsL2xvYWRlci11dGlscyc7XG5leHBvcnQgZnVuY3Rpb24gaXNMb2FkZXJPYmplY3QobG9hZGVyKSB7XG4gIHZhciBfbG9hZGVyO1xuICBpZiAoIWxvYWRlcikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAoQXJyYXkuaXNBcnJheShsb2FkZXIpKSB7XG4gICAgbG9hZGVyID0gbG9hZGVyWzBdO1xuICB9XG4gIGNvbnN0IGhhc0V4dGVuc2lvbnMgPSBBcnJheS5pc0FycmF5KChfbG9hZGVyID0gbG9hZGVyKSA9PT0gbnVsbCB8fCBfbG9hZGVyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfbG9hZGVyLmV4dGVuc2lvbnMpO1xuICByZXR1cm4gaGFzRXh0ZW5zaW9ucztcbn1cbmV4cG9ydCBmdW5jdGlvbiBub3JtYWxpemVMb2FkZXIobG9hZGVyKSB7XG4gIHZhciBfbG9hZGVyMiwgX2xvYWRlcjM7XG4gIGFzc2VydChsb2FkZXIsICdudWxsIGxvYWRlcicpO1xuICBhc3NlcnQoaXNMb2FkZXJPYmplY3QobG9hZGVyKSwgJ2ludmFsaWQgbG9hZGVyJyk7XG4gIGxldCBvcHRpb25zO1xuICBpZiAoQXJyYXkuaXNBcnJheShsb2FkZXIpKSB7XG4gICAgb3B0aW9ucyA9IGxvYWRlclsxXTtcbiAgICBsb2FkZXIgPSBsb2FkZXJbMF07XG4gICAgbG9hZGVyID0ge1xuICAgICAgLi4ubG9hZGVyLFxuICAgICAgb3B0aW9uczoge1xuICAgICAgICAuLi5sb2FkZXIub3B0aW9ucyxcbiAgICAgICAgLi4ub3B0aW9uc1xuICAgICAgfVxuICAgIH07XG4gIH1cbiAgaWYgKChfbG9hZGVyMiA9IGxvYWRlcikgIT09IG51bGwgJiYgX2xvYWRlcjIgIT09IHZvaWQgMCAmJiBfbG9hZGVyMi5wYXJzZVRleHRTeW5jIHx8IChfbG9hZGVyMyA9IGxvYWRlcikgIT09IG51bGwgJiYgX2xvYWRlcjMgIT09IHZvaWQgMCAmJiBfbG9hZGVyMy5wYXJzZVRleHQpIHtcbiAgICBsb2FkZXIudGV4dCA9IHRydWU7XG4gIH1cbiAgaWYgKCFsb2FkZXIudGV4dCkge1xuICAgIGxvYWRlci5iaW5hcnkgPSB0cnVlO1xuICB9XG4gIHJldHVybiBsb2FkZXI7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1ub3JtYWxpemUtbG9hZGVyLmpzLm1hcCIsImltcG9ydCB7IGlzQnJvd3NlciB9IGZyb20gJ0Bsb2FkZXJzLmdsL2xvYWRlci11dGlscyc7XG5pbXBvcnQgeyBDb25zb2xlTG9nIH0gZnJvbSBcIi4vbG9nZ2Vycy5qc1wiO1xuZXhwb3J0IGNvbnN0IERFRkFVTFRfTE9BREVSX09QVElPTlMgPSB7XG4gIGZldGNoOiBudWxsLFxuICBtaW1lVHlwZTogdW5kZWZpbmVkLFxuICBub3Rocm93OiBmYWxzZSxcbiAgbG9nOiBuZXcgQ29uc29sZUxvZygpLFxuICB1c2VMb2NhbExpYnJhcmllczogZmFsc2UsXG4gIENETjogJ2h0dHBzOi8vdW5wa2cuY29tL0Bsb2FkZXJzLmdsJyxcbiAgd29ya2VyOiB0cnVlLFxuICBtYXhDb25jdXJyZW5jeTogMyxcbiAgbWF4TW9iaWxlQ29uY3VycmVuY3k6IDEsXG4gIHJldXNlV29ya2VyczogaXNCcm93c2VyLFxuICBfbm9kZVdvcmtlcnM6IGZhbHNlLFxuICBfd29ya2VyVHlwZTogJycsXG4gIGxpbWl0OiAwLFxuICBfbGltaXRNQjogMCxcbiAgYmF0Y2hTaXplOiAnYXV0bycsXG4gIGJhdGNoRGVib3VuY2VNczogMCxcbiAgbWV0YWRhdGE6IGZhbHNlLFxuICB0cmFuc2Zvcm1zOiBbXVxufTtcbmV4cG9ydCBjb25zdCBSRU1PVkVEX0xPQURFUl9PUFRJT05TID0ge1xuICB0aHJvd3M6ICdub3Rocm93JyxcbiAgZGF0YVR5cGU6ICcobm8gbG9uZ2VyIHVzZWQpJyxcbiAgdXJpOiAnYmFzZVVyaScsXG4gIG1ldGhvZDogJ2ZldGNoLm1ldGhvZCcsXG4gIGhlYWRlcnM6ICdmZXRjaC5oZWFkZXJzJyxcbiAgYm9keTogJ2ZldGNoLmJvZHknLFxuICBtb2RlOiAnZmV0Y2gubW9kZScsXG4gIGNyZWRlbnRpYWxzOiAnZmV0Y2guY3JlZGVudGlhbHMnLFxuICBjYWNoZTogJ2ZldGNoLmNhY2hlJyxcbiAgcmVkaXJlY3Q6ICdmZXRjaC5yZWRpcmVjdCcsXG4gIHJlZmVycmVyOiAnZmV0Y2gucmVmZXJyZXInLFxuICByZWZlcnJlclBvbGljeTogJ2ZldGNoLnJlZmVycmVyUG9saWN5JyxcbiAgaW50ZWdyaXR5OiAnZmV0Y2guaW50ZWdyaXR5JyxcbiAga2VlcGFsaXZlOiAnZmV0Y2gua2VlcGFsaXZlJyxcbiAgc2lnbmFsOiAnZmV0Y2guc2lnbmFsJ1xufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW9wdGlvbi1kZWZhdWx0cy5qcy5tYXAiLCJpbXBvcnQgeyBpc1B1cmVPYmplY3QsIGlzT2JqZWN0IH0gZnJvbSBcIi4uLy4uL2phdmFzY3JpcHQtdXRpbHMvaXMtdHlwZS5qc1wiO1xuaW1wb3J0IHsgcHJvYmVMb2csIE51bGxMb2cgfSBmcm9tIFwiLi9sb2dnZXJzLmpzXCI7XG5pbXBvcnQgeyBERUZBVUxUX0xPQURFUl9PUFRJT05TLCBSRU1PVkVEX0xPQURFUl9PUFRJT05TIH0gZnJvbSBcIi4vb3B0aW9uLWRlZmF1bHRzLmpzXCI7XG5leHBvcnQgZnVuY3Rpb24gZ2V0R2xvYmFsTG9hZGVyU3RhdGUoKSB7XG4gIGdsb2JhbFRoaXMubG9hZGVycyA9IGdsb2JhbFRoaXMubG9hZGVycyB8fCB7fTtcbiAgY29uc3Qge1xuICAgIGxvYWRlcnNcbiAgfSA9IGdsb2JhbFRoaXM7XG4gIGxvYWRlcnMuX3N0YXRlID0gbG9hZGVycy5fc3RhdGUgfHwge307XG4gIHJldHVybiBsb2FkZXJzLl9zdGF0ZTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBnZXRHbG9iYWxMb2FkZXJPcHRpb25zKCkge1xuICBjb25zdCBzdGF0ZSA9IGdldEdsb2JhbExvYWRlclN0YXRlKCk7XG4gIHN0YXRlLmdsb2JhbE9wdGlvbnMgPSBzdGF0ZS5nbG9iYWxPcHRpb25zIHx8IHtcbiAgICAuLi5ERUZBVUxUX0xPQURFUl9PUFRJT05TXG4gIH07XG4gIHJldHVybiBzdGF0ZS5nbG9iYWxPcHRpb25zO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHNldEdsb2JhbE9wdGlvbnMob3B0aW9ucykge1xuICBjb25zdCBzdGF0ZSA9IGdldEdsb2JhbExvYWRlclN0YXRlKCk7XG4gIGNvbnN0IGdsb2JhbE9wdGlvbnMgPSBnZXRHbG9iYWxMb2FkZXJPcHRpb25zKCk7XG4gIHN0YXRlLmdsb2JhbE9wdGlvbnMgPSBub3JtYWxpemVPcHRpb25zSW50ZXJuYWwoZ2xvYmFsT3B0aW9ucywgb3B0aW9ucyk7XG59XG5leHBvcnQgZnVuY3Rpb24gbm9ybWFsaXplT3B0aW9ucyhvcHRpb25zLCBsb2FkZXIsIGxvYWRlcnMsIHVybCkge1xuICBsb2FkZXJzID0gbG9hZGVycyB8fCBbXTtcbiAgbG9hZGVycyA9IEFycmF5LmlzQXJyYXkobG9hZGVycykgPyBsb2FkZXJzIDogW2xvYWRlcnNdO1xuICB2YWxpZGF0ZU9wdGlvbnMob3B0aW9ucywgbG9hZGVycyk7XG4gIHJldHVybiBub3JtYWxpemVPcHRpb25zSW50ZXJuYWwobG9hZGVyLCBvcHRpb25zLCB1cmwpO1xufVxuZnVuY3Rpb24gdmFsaWRhdGVPcHRpb25zKG9wdGlvbnMsIGxvYWRlcnMpIHtcbiAgdmFsaWRhdGVPcHRpb25zT2JqZWN0KG9wdGlvbnMsIG51bGwsIERFRkFVTFRfTE9BREVSX09QVElPTlMsIFJFTU9WRURfTE9BREVSX09QVElPTlMsIGxvYWRlcnMpO1xuICBmb3IgKGNvbnN0IGxvYWRlciBvZiBsb2FkZXJzKSB7XG4gICAgY29uc3QgaWRPcHRpb25zID0gb3B0aW9ucyAmJiBvcHRpb25zW2xvYWRlci5pZF0gfHwge307XG4gICAgY29uc3QgbG9hZGVyT3B0aW9ucyA9IGxvYWRlci5vcHRpb25zICYmIGxvYWRlci5vcHRpb25zW2xvYWRlci5pZF0gfHwge307XG4gICAgY29uc3QgZGVwcmVjYXRlZE9wdGlvbnMgPSBsb2FkZXIuZGVwcmVjYXRlZE9wdGlvbnMgJiYgbG9hZGVyLmRlcHJlY2F0ZWRPcHRpb25zW2xvYWRlci5pZF0gfHwge307XG4gICAgdmFsaWRhdGVPcHRpb25zT2JqZWN0KGlkT3B0aW9ucywgbG9hZGVyLmlkLCBsb2FkZXJPcHRpb25zLCBkZXByZWNhdGVkT3B0aW9ucywgbG9hZGVycyk7XG4gIH1cbn1cbmZ1bmN0aW9uIHZhbGlkYXRlT3B0aW9uc09iamVjdChvcHRpb25zLCBpZCwgZGVmYXVsdE9wdGlvbnMsIGRlcHJlY2F0ZWRPcHRpb25zLCBsb2FkZXJzKSB7XG4gIGNvbnN0IGxvYWRlck5hbWUgPSBpZCB8fCAnVG9wIGxldmVsJztcbiAgY29uc3QgcHJlZml4ID0gaWQgPyBgJHtpZH0uYCA6ICcnO1xuICBmb3IgKGNvbnN0IGtleSBpbiBvcHRpb25zKSB7XG4gICAgY29uc3QgaXNTdWJPcHRpb25zID0gIWlkICYmIGlzT2JqZWN0KG9wdGlvbnNba2V5XSk7XG4gICAgY29uc3QgaXNCYXNlVXJpT3B0aW9uID0ga2V5ID09PSAnYmFzZVVyaScgJiYgIWlkO1xuICAgIGNvbnN0IGlzV29ya2VyVXJsT3B0aW9uID0ga2V5ID09PSAnd29ya2VyVXJsJyAmJiBpZDtcbiAgICBpZiAoIShrZXkgaW4gZGVmYXVsdE9wdGlvbnMpICYmICFpc0Jhc2VVcmlPcHRpb24gJiYgIWlzV29ya2VyVXJsT3B0aW9uKSB7XG4gICAgICBpZiAoa2V5IGluIGRlcHJlY2F0ZWRPcHRpb25zKSB7XG4gICAgICAgIHByb2JlTG9nLndhcm4oYCR7bG9hZGVyTmFtZX0gbG9hZGVyIG9wdGlvbiBcXCcke3ByZWZpeH0ke2tleX1cXCcgbm8gbG9uZ2VyIHN1cHBvcnRlZCwgdXNlIFxcJyR7ZGVwcmVjYXRlZE9wdGlvbnNba2V5XX1cXCdgKSgpO1xuICAgICAgfSBlbHNlIGlmICghaXNTdWJPcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IHN1Z2dlc3Rpb24gPSBmaW5kU2ltaWxhck9wdGlvbihrZXksIGxvYWRlcnMpO1xuICAgICAgICBwcm9iZUxvZy53YXJuKGAke2xvYWRlck5hbWV9IGxvYWRlciBvcHRpb24gXFwnJHtwcmVmaXh9JHtrZXl9XFwnIG5vdCByZWNvZ25pemVkLiAke3N1Z2dlc3Rpb259YCkoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIGZpbmRTaW1pbGFyT3B0aW9uKG9wdGlvbktleSwgbG9hZGVycykge1xuICBjb25zdCBsb3dlckNhc2VPcHRpb25LZXkgPSBvcHRpb25LZXkudG9Mb3dlckNhc2UoKTtcbiAgbGV0IGJlc3RTdWdnZXN0aW9uID0gJyc7XG4gIGZvciAoY29uc3QgbG9hZGVyIG9mIGxvYWRlcnMpIHtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBsb2FkZXIub3B0aW9ucykge1xuICAgICAgaWYgKG9wdGlvbktleSA9PT0ga2V5KSB7XG4gICAgICAgIHJldHVybiBgRGlkIHlvdSBtZWFuIFxcJyR7bG9hZGVyLmlkfS4ke2tleX1cXCc/YDtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGxvd2VyQ2FzZUtleSA9IGtleS50b0xvd2VyQ2FzZSgpO1xuICAgICAgY29uc3QgaXNQYXJ0aWFsTWF0Y2ggPSBsb3dlckNhc2VPcHRpb25LZXkuc3RhcnRzV2l0aChsb3dlckNhc2VLZXkpIHx8IGxvd2VyQ2FzZUtleS5zdGFydHNXaXRoKGxvd2VyQ2FzZU9wdGlvbktleSk7XG4gICAgICBpZiAoaXNQYXJ0aWFsTWF0Y2gpIHtcbiAgICAgICAgYmVzdFN1Z2dlc3Rpb24gPSBiZXN0U3VnZ2VzdGlvbiB8fCBgRGlkIHlvdSBtZWFuIFxcJyR7bG9hZGVyLmlkfS4ke2tleX1cXCc/YDtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIGJlc3RTdWdnZXN0aW9uO1xufVxuZnVuY3Rpb24gbm9ybWFsaXplT3B0aW9uc0ludGVybmFsKGxvYWRlciwgb3B0aW9ucywgdXJsKSB7XG4gIGNvbnN0IGxvYWRlckRlZmF1bHRPcHRpb25zID0gbG9hZGVyLm9wdGlvbnMgfHwge307XG4gIGNvbnN0IG1lcmdlZE9wdGlvbnMgPSB7XG4gICAgLi4ubG9hZGVyRGVmYXVsdE9wdGlvbnNcbiAgfTtcbiAgYWRkVXJsT3B0aW9ucyhtZXJnZWRPcHRpb25zLCB1cmwpO1xuICBpZiAobWVyZ2VkT3B0aW9ucy5sb2cgPT09IG51bGwpIHtcbiAgICBtZXJnZWRPcHRpb25zLmxvZyA9IG5ldyBOdWxsTG9nKCk7XG4gIH1cbiAgbWVyZ2VOZXN0ZWRGaWVsZHMobWVyZ2VkT3B0aW9ucywgZ2V0R2xvYmFsTG9hZGVyT3B0aW9ucygpKTtcbiAgbWVyZ2VOZXN0ZWRGaWVsZHMobWVyZ2VkT3B0aW9ucywgb3B0aW9ucyk7XG4gIHJldHVybiBtZXJnZWRPcHRpb25zO1xufVxuZnVuY3Rpb24gbWVyZ2VOZXN0ZWRGaWVsZHMobWVyZ2VkT3B0aW9ucywgb3B0aW9ucykge1xuICBmb3IgKGNvbnN0IGtleSBpbiBvcHRpb25zKSB7XG4gICAgaWYgKGtleSBpbiBvcHRpb25zKSB7XG4gICAgICBjb25zdCB2YWx1ZSA9IG9wdGlvbnNba2V5XTtcbiAgICAgIGlmIChpc1B1cmVPYmplY3QodmFsdWUpICYmIGlzUHVyZU9iamVjdChtZXJnZWRPcHRpb25zW2tleV0pKSB7XG4gICAgICAgIG1lcmdlZE9wdGlvbnNba2V5XSA9IHtcbiAgICAgICAgICAuLi5tZXJnZWRPcHRpb25zW2tleV0sXG4gICAgICAgICAgLi4ub3B0aW9uc1trZXldXG4gICAgICAgIH07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBtZXJnZWRPcHRpb25zW2tleV0gPSBvcHRpb25zW2tleV07XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBhZGRVcmxPcHRpb25zKG9wdGlvbnMsIHVybCkge1xuICBpZiAodXJsICYmICEoJ2Jhc2VVcmknIGluIG9wdGlvbnMpKSB7XG4gICAgb3B0aW9ucy5iYXNlVXJpID0gdXJsO1xuICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1vcHRpb24tdXRpbHMuanMubWFwIiwiaW1wb3J0IHsgTG9nIH0gZnJvbSAnQHByb2JlLmdsL2xvZyc7XG5leHBvcnQgY29uc3QgbG9nID0gbmV3IExvZyh7XG4gIGlkOiAnbG9hZGVycy5nbCdcbn0pO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bG9nLmpzLm1hcCIsImNvbnN0IERBVEFfVVJMX1BBVFRFUk4gPSAvXmRhdGE6KFstXFx3Ll0rXFwvWy1cXHcuK10rKSg7fCwpLztcbmNvbnN0IE1JTUVfVFlQRV9QQVRURVJOID0gL14oWy1cXHcuXStcXC9bLVxcdy4rXSspLztcbmV4cG9ydCBmdW5jdGlvbiBwYXJzZU1JTUVUeXBlKG1pbWVTdHJpbmcpIHtcbiAgY29uc3QgbWF0Y2hlcyA9IE1JTUVfVFlQRV9QQVRURVJOLmV4ZWMobWltZVN0cmluZyk7XG4gIGlmIChtYXRjaGVzKSB7XG4gICAgcmV0dXJuIG1hdGNoZXNbMV07XG4gIH1cbiAgcmV0dXJuIG1pbWVTdHJpbmc7XG59XG5leHBvcnQgZnVuY3Rpb24gcGFyc2VNSU1FVHlwZUZyb21VUkwodXJsKSB7XG4gIGNvbnN0IG1hdGNoZXMgPSBEQVRBX1VSTF9QQVRURVJOLmV4ZWModXJsKTtcbiAgaWYgKG1hdGNoZXMpIHtcbiAgICByZXR1cm4gbWF0Y2hlc1sxXTtcbiAgfVxuICByZXR1cm4gJyc7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1taW1lLXR5cGUtdXRpbHMuanMubWFwIiwiaW1wb3J0IHsgaXNSZXNwb25zZSwgaXNCbG9iIH0gZnJvbSBcIi4uLy4uL2phdmFzY3JpcHQtdXRpbHMvaXMtdHlwZS5qc1wiO1xuaW1wb3J0IHsgcGFyc2VNSU1FVHlwZSwgcGFyc2VNSU1FVHlwZUZyb21VUkwgfSBmcm9tIFwiLi9taW1lLXR5cGUtdXRpbHMuanNcIjtcbmltcG9ydCB7IHN0cmlwUXVlcnlTdHJpbmcgfSBmcm9tIFwiLi91cmwtdXRpbHMuanNcIjtcbmV4cG9ydCBmdW5jdGlvbiBnZXRSZXNvdXJjZVVybChyZXNvdXJjZSkge1xuICBpZiAoaXNSZXNwb25zZShyZXNvdXJjZSkpIHtcbiAgICBjb25zdCByZXNwb25zZSA9IHJlc291cmNlO1xuICAgIHJldHVybiByZXNwb25zZS51cmw7XG4gIH1cbiAgaWYgKGlzQmxvYihyZXNvdXJjZSkpIHtcbiAgICBjb25zdCBibG9iID0gcmVzb3VyY2U7XG4gICAgcmV0dXJuIGJsb2IubmFtZSB8fCAnJztcbiAgfVxuICBpZiAodHlwZW9mIHJlc291cmNlID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiByZXNvdXJjZTtcbiAgfVxuICByZXR1cm4gJyc7XG59XG5leHBvcnQgZnVuY3Rpb24gZ2V0UmVzb3VyY2VNSU1FVHlwZShyZXNvdXJjZSkge1xuICBpZiAoaXNSZXNwb25zZShyZXNvdXJjZSkpIHtcbiAgICBjb25zdCByZXNwb25zZSA9IHJlc291cmNlO1xuICAgIGNvbnN0IGNvbnRlbnRUeXBlSGVhZGVyID0gcmVzcG9uc2UuaGVhZGVycy5nZXQoJ2NvbnRlbnQtdHlwZScpIHx8ICcnO1xuICAgIGNvbnN0IG5vUXVlcnlVcmwgPSBzdHJpcFF1ZXJ5U3RyaW5nKHJlc3BvbnNlLnVybCk7XG4gICAgcmV0dXJuIHBhcnNlTUlNRVR5cGUoY29udGVudFR5cGVIZWFkZXIpIHx8IHBhcnNlTUlNRVR5cGVGcm9tVVJMKG5vUXVlcnlVcmwpO1xuICB9XG4gIGlmIChpc0Jsb2IocmVzb3VyY2UpKSB7XG4gICAgY29uc3QgYmxvYiA9IHJlc291cmNlO1xuICAgIHJldHVybiBibG9iLnR5cGUgfHwgJyc7XG4gIH1cbiAgaWYgKHR5cGVvZiByZXNvdXJjZSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gcGFyc2VNSU1FVHlwZUZyb21VUkwocmVzb3VyY2UpO1xuICB9XG4gIHJldHVybiAnJztcbn1cbmV4cG9ydCBmdW5jdGlvbiBnZXRSZXNvdXJjZUNvbnRlbnRMZW5ndGgocmVzb3VyY2UpIHtcbiAgaWYgKGlzUmVzcG9uc2UocmVzb3VyY2UpKSB7XG4gICAgY29uc3QgcmVzcG9uc2UgPSByZXNvdXJjZTtcbiAgICByZXR1cm4gcmVzcG9uc2UuaGVhZGVyc1snY29udGVudC1sZW5ndGgnXSB8fCAtMTtcbiAgfVxuICBpZiAoaXNCbG9iKHJlc291cmNlKSkge1xuICAgIGNvbnN0IGJsb2IgPSByZXNvdXJjZTtcbiAgICByZXR1cm4gYmxvYi5zaXplO1xuICB9XG4gIGlmICh0eXBlb2YgcmVzb3VyY2UgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIHJlc291cmNlLmxlbmd0aDtcbiAgfVxuICBpZiAocmVzb3VyY2UgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikge1xuICAgIHJldHVybiByZXNvdXJjZS5ieXRlTGVuZ3RoO1xuICB9XG4gIGlmIChBcnJheUJ1ZmZlci5pc1ZpZXcocmVzb3VyY2UpKSB7XG4gICAgcmV0dXJuIHJlc291cmNlLmJ5dGVMZW5ndGg7XG4gIH1cbiAgcmV0dXJuIC0xO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmVzb3VyY2UtdXRpbHMuanMubWFwIiwiaW1wb3J0IHsgaXNSZXNwb25zZSB9IGZyb20gXCIuLi8uLi9qYXZhc2NyaXB0LXV0aWxzL2lzLXR5cGUuanNcIjtcbmltcG9ydCB7IGdldFJlc291cmNlQ29udGVudExlbmd0aCwgZ2V0UmVzb3VyY2VVcmwsIGdldFJlc291cmNlTUlNRVR5cGUgfSBmcm9tIFwiLi9yZXNvdXJjZS11dGlscy5qc1wiO1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIG1ha2VSZXNwb25zZShyZXNvdXJjZSkge1xuICBpZiAoaXNSZXNwb25zZShyZXNvdXJjZSkpIHtcbiAgICByZXR1cm4gcmVzb3VyY2U7XG4gIH1cbiAgY29uc3QgaGVhZGVycyA9IHt9O1xuICBjb25zdCBjb250ZW50TGVuZ3RoID0gZ2V0UmVzb3VyY2VDb250ZW50TGVuZ3RoKHJlc291cmNlKTtcbiAgaWYgKGNvbnRlbnRMZW5ndGggPj0gMCkge1xuICAgIGhlYWRlcnNbJ2NvbnRlbnQtbGVuZ3RoJ10gPSBTdHJpbmcoY29udGVudExlbmd0aCk7XG4gIH1cbiAgY29uc3QgdXJsID0gZ2V0UmVzb3VyY2VVcmwocmVzb3VyY2UpO1xuICBjb25zdCB0eXBlID0gZ2V0UmVzb3VyY2VNSU1FVHlwZShyZXNvdXJjZSk7XG4gIGlmICh0eXBlKSB7XG4gICAgaGVhZGVyc1snY29udGVudC10eXBlJ10gPSB0eXBlO1xuICB9XG4gIGNvbnN0IGluaXRpYWxEYXRhVXJsID0gYXdhaXQgZ2V0SW5pdGlhbERhdGFVcmwocmVzb3VyY2UpO1xuICBpZiAoaW5pdGlhbERhdGFVcmwpIHtcbiAgICBoZWFkZXJzWyd4LWZpcnN0LWJ5dGVzJ10gPSBpbml0aWFsRGF0YVVybDtcbiAgfVxuICBpZiAodHlwZW9mIHJlc291cmNlID09PSAnc3RyaW5nJykge1xuICAgIHJlc291cmNlID0gbmV3IFRleHRFbmNvZGVyKCkuZW5jb2RlKHJlc291cmNlKTtcbiAgfVxuICBjb25zdCByZXNwb25zZSA9IG5ldyBSZXNwb25zZShyZXNvdXJjZSwge1xuICAgIGhlYWRlcnNcbiAgfSk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShyZXNwb25zZSwgJ3VybCcsIHtcbiAgICB2YWx1ZTogdXJsXG4gIH0pO1xuICByZXR1cm4gcmVzcG9uc2U7XG59XG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gY2hlY2tSZXNwb25zZShyZXNwb25zZSkge1xuICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgY29uc3QgbWVzc2FnZSA9IGF3YWl0IGdldFJlc3BvbnNlRXJyb3IocmVzcG9uc2UpO1xuICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgfVxufVxuZXhwb3J0IGZ1bmN0aW9uIGNoZWNrUmVzcG9uc2VTeW5jKHJlc3BvbnNlKSB7XG4gIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICBsZXQgbWVzc2FnZSA9IGAke3Jlc3BvbnNlLnN0YXR1c30gJHtyZXNwb25zZS5zdGF0dXNUZXh0fWA7XG4gICAgbWVzc2FnZSA9IG1lc3NhZ2UubGVuZ3RoID4gNjAgPyBgJHttZXNzYWdlLnNsaWNlKDAsIDYwKX0uLi5gIDogbWVzc2FnZTtcbiAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSk7XG4gIH1cbn1cbmFzeW5jIGZ1bmN0aW9uIGdldFJlc3BvbnNlRXJyb3IocmVzcG9uc2UpIHtcbiAgbGV0IG1lc3NhZ2UgPSBgRmFpbGVkIHRvIGZldGNoIHJlc291cmNlICR7cmVzcG9uc2UudXJsfSAoJHtyZXNwb25zZS5zdGF0dXN9KTogYDtcbiAgdHJ5IHtcbiAgICBjb25zdCBjb250ZW50VHlwZSA9IHJlc3BvbnNlLmhlYWRlcnMuZ2V0KCdDb250ZW50LVR5cGUnKTtcbiAgICBsZXQgdGV4dCA9IHJlc3BvbnNlLnN0YXR1c1RleHQ7XG4gICAgaWYgKGNvbnRlbnRUeXBlICE9PSBudWxsICYmIGNvbnRlbnRUeXBlICE9PSB2b2lkIDAgJiYgY29udGVudFR5cGUuaW5jbHVkZXMoJ2FwcGxpY2F0aW9uL2pzb24nKSkge1xuICAgICAgdGV4dCArPSBgICR7YXdhaXQgcmVzcG9uc2UudGV4dCgpfWA7XG4gICAgfVxuICAgIG1lc3NhZ2UgKz0gdGV4dDtcbiAgICBtZXNzYWdlID0gbWVzc2FnZS5sZW5ndGggPiA2MCA/IGAke21lc3NhZ2Uuc2xpY2UoMCwgNjApfS4uLmAgOiBtZXNzYWdlO1xuICB9IGNhdGNoIChlcnJvcikge31cbiAgcmV0dXJuIG1lc3NhZ2U7XG59XG5hc3luYyBmdW5jdGlvbiBnZXRJbml0aWFsRGF0YVVybChyZXNvdXJjZSkge1xuICBjb25zdCBJTklUSUFMX0RBVEFfTEVOR1RIID0gNTtcbiAgaWYgKHR5cGVvZiByZXNvdXJjZSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gYGRhdGE6LCR7cmVzb3VyY2Uuc2xpY2UoMCwgSU5JVElBTF9EQVRBX0xFTkdUSCl9YDtcbiAgfVxuICBpZiAocmVzb3VyY2UgaW5zdGFuY2VvZiBCbG9iKSB7XG4gICAgY29uc3QgYmxvYlNsaWNlID0gcmVzb3VyY2Uuc2xpY2UoMCwgNSk7XG4gICAgcmV0dXJuIGF3YWl0IG5ldyBQcm9taXNlKHJlc29sdmUgPT4ge1xuICAgICAgY29uc3QgcmVhZGVyID0gbmV3IEZpbGVSZWFkZXIoKTtcbiAgICAgIHJlYWRlci5vbmxvYWQgPSBldmVudCA9PiB7XG4gICAgICAgIHZhciBfZXZlbnQkdGFyZ2V0O1xuICAgICAgICByZXR1cm4gcmVzb2x2ZShldmVudCA9PT0gbnVsbCB8fCBldmVudCA9PT0gdm9pZCAwID8gdm9pZCAwIDogKF9ldmVudCR0YXJnZXQgPSBldmVudC50YXJnZXQpID09PSBudWxsIHx8IF9ldmVudCR0YXJnZXQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9ldmVudCR0YXJnZXQucmVzdWx0KTtcbiAgICAgIH07XG4gICAgICByZWFkZXIucmVhZEFzRGF0YVVSTChibG9iU2xpY2UpO1xuICAgIH0pO1xuICB9XG4gIGlmIChyZXNvdXJjZSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB7XG4gICAgY29uc3Qgc2xpY2UgPSByZXNvdXJjZS5zbGljZSgwLCBJTklUSUFMX0RBVEFfTEVOR1RIKTtcbiAgICBjb25zdCBiYXNlNjQgPSBhcnJheUJ1ZmZlclRvQmFzZTY0KHNsaWNlKTtcbiAgICByZXR1cm4gYGRhdGE6YmFzZTY0LCR7YmFzZTY0fWA7XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiBhcnJheUJ1ZmZlclRvQmFzZTY0KGJ1ZmZlcikge1xuICBsZXQgYmluYXJ5ID0gJyc7XG4gIGNvbnN0IGJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkoYnVmZmVyKTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBieXRlcy5ieXRlTGVuZ3RoOyBpKyspIHtcbiAgICBiaW5hcnkgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShieXRlc1tpXSk7XG4gIH1cbiAgcmV0dXJuIGJ0b2EoYmluYXJ5KTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJlc3BvbnNlLXV0aWxzLmpzLm1hcCIsImNvbnN0IFFVRVJZX1NUUklOR19QQVRURVJOID0gL1xcPy4qLztcbmV4cG9ydCBmdW5jdGlvbiBleHRyYWN0UXVlcnlTdHJpbmcodXJsKSB7XG4gIGNvbnN0IG1hdGNoZXMgPSB1cmwubWF0Y2goUVVFUllfU1RSSU5HX1BBVFRFUk4pO1xuICByZXR1cm4gbWF0Y2hlcyAmJiBtYXRjaGVzWzBdO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHN0cmlwUXVlcnlTdHJpbmcodXJsKSB7XG4gIHJldHVybiB1cmwucmVwbGFjZShRVUVSWV9TVFJJTkdfUEFUVEVSTiwgJycpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dXJsLXV0aWxzLmpzLm1hcCIsImltcG9ydCB7IFZFUlNJT04gfSBmcm9tIFwiLi9saWIvdXRpbHMvdmVyc2lvbi5qc1wiO1xuaW1wb3J0IHsgcGFyc2VHTEJTeW5jIH0gZnJvbSBcIi4vbGliL3BhcnNlcnMvcGFyc2UtZ2xiLmpzXCI7XG5leHBvcnQgY29uc3QgR0xCTG9hZGVyID0ge1xuICBuYW1lOiAnR0xCJyxcbiAgaWQ6ICdnbGInLFxuICBtb2R1bGU6ICdnbHRmJyxcbiAgdmVyc2lvbjogVkVSU0lPTixcbiAgZXh0ZW5zaW9uczogWydnbGInXSxcbiAgbWltZVR5cGVzOiBbJ21vZGVsL2dsdGYtYmluYXJ5J10sXG4gIGJpbmFyeTogdHJ1ZSxcbiAgcGFyc2UsXG4gIHBhcnNlU3luYyxcbiAgb3B0aW9uczoge1xuICAgIGdsYjoge1xuICAgICAgc3RyaWN0OiBmYWxzZVxuICAgIH1cbiAgfVxufTtcbmFzeW5jIGZ1bmN0aW9uIHBhcnNlKGFycmF5QnVmZmVyLCBvcHRpb25zKSB7XG4gIHJldHVybiBwYXJzZVN5bmMoYXJyYXlCdWZmZXIsIG9wdGlvbnMpO1xufVxuZnVuY3Rpb24gcGFyc2VTeW5jKGFycmF5QnVmZmVyLCBvcHRpb25zKSB7XG4gIGNvbnN0IHtcbiAgICBieXRlT2Zmc2V0ID0gMFxuICB9ID0gb3B0aW9ucyB8fCB7fTtcbiAgY29uc3QgZ2xiID0ge307XG4gIHBhcnNlR0xCU3luYyhnbGIsIGFycmF5QnVmZmVyLCBieXRlT2Zmc2V0LCBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuZ2xiKTtcbiAgcmV0dXJuIGdsYjtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWdsYi1sb2FkZXIuanMubWFwIiwiaW1wb3J0IHsgcGFkVG9OQnl0ZXMsIGFzc2VydCB9IGZyb20gJ0Bsb2FkZXJzLmdsL2xvYWRlci11dGlscyc7XG5jb25zdCBMSVRUTEVfRU5ESUFOID0gdHJ1ZTtcbmNvbnN0IE1BR0lDX2dsVEYgPSAweDY3NmM1NDQ2O1xuY29uc3QgR0xCX0ZJTEVfSEVBREVSX1NJWkUgPSAxMjtcbmNvbnN0IEdMQl9DSFVOS19IRUFERVJfU0laRSA9IDg7XG5jb25zdCBHTEJfQ0hVTktfVFlQRV9KU09OID0gMHg0ZTRmNTM0YTtcbmNvbnN0IEdMQl9DSFVOS19UWVBFX0JJTiA9IDB4MDA0ZTQ5NDI7XG5jb25zdCBHTEJfVjFfQ09OVEVOVF9GT1JNQVRfSlNPTiA9IDB4MDtcbmNvbnN0IEdMQl9DSFVOS19UWVBFX0pTT05fWFZJWl9ERVBSRUNBVEVEID0gMDtcbmNvbnN0IEdMQl9DSFVOS19UWVBFX0JJWF9YVklaX0RFUFJFQ0FURUQgPSAxO1xuZnVuY3Rpb24gZ2V0TWFnaWNTdHJpbmcoZGF0YVZpZXcpIHtcbiAgbGV0IGJ5dGVPZmZzZXQgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IDA7XG4gIHJldHVybiBgXFxcbiR7U3RyaW5nLmZyb21DaGFyQ29kZShkYXRhVmlldy5nZXRVaW50OChieXRlT2Zmc2V0ICsgMCkpfVxcXG4ke1N0cmluZy5mcm9tQ2hhckNvZGUoZGF0YVZpZXcuZ2V0VWludDgoYnl0ZU9mZnNldCArIDEpKX1cXFxuJHtTdHJpbmcuZnJvbUNoYXJDb2RlKGRhdGFWaWV3LmdldFVpbnQ4KGJ5dGVPZmZzZXQgKyAyKSl9XFxcbiR7U3RyaW5nLmZyb21DaGFyQ29kZShkYXRhVmlldy5nZXRVaW50OChieXRlT2Zmc2V0ICsgMykpfWA7XG59XG5leHBvcnQgZnVuY3Rpb24gaXNHTEIoYXJyYXlCdWZmZXIpIHtcbiAgbGV0IGJ5dGVPZmZzZXQgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IDA7XG4gIGxldCBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fTtcbiAgY29uc3QgZGF0YVZpZXcgPSBuZXcgRGF0YVZpZXcoYXJyYXlCdWZmZXIpO1xuICBjb25zdCB7XG4gICAgbWFnaWMgPSBNQUdJQ19nbFRGXG4gIH0gPSBvcHRpb25zO1xuICBjb25zdCBtYWdpYzEgPSBkYXRhVmlldy5nZXRVaW50MzIoYnl0ZU9mZnNldCwgZmFsc2UpO1xuICByZXR1cm4gbWFnaWMxID09PSBtYWdpYyB8fCBtYWdpYzEgPT09IE1BR0lDX2dsVEY7XG59XG5leHBvcnQgZnVuY3Rpb24gcGFyc2VHTEJTeW5jKGdsYiwgYXJyYXlCdWZmZXIpIHtcbiAgbGV0IGJ5dGVPZmZzZXQgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IDA7XG4gIGxldCBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgJiYgYXJndW1lbnRzWzNdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbM10gOiB7fTtcbiAgY29uc3QgZGF0YVZpZXcgPSBuZXcgRGF0YVZpZXcoYXJyYXlCdWZmZXIpO1xuICBjb25zdCB0eXBlID0gZ2V0TWFnaWNTdHJpbmcoZGF0YVZpZXcsIGJ5dGVPZmZzZXQgKyAwKTtcbiAgY29uc3QgdmVyc2lvbiA9IGRhdGFWaWV3LmdldFVpbnQzMihieXRlT2Zmc2V0ICsgNCwgTElUVExFX0VORElBTik7XG4gIGNvbnN0IGJ5dGVMZW5ndGggPSBkYXRhVmlldy5nZXRVaW50MzIoYnl0ZU9mZnNldCArIDgsIExJVFRMRV9FTkRJQU4pO1xuICBPYmplY3QuYXNzaWduKGdsYiwge1xuICAgIGhlYWRlcjoge1xuICAgICAgYnl0ZU9mZnNldCxcbiAgICAgIGJ5dGVMZW5ndGgsXG4gICAgICBoYXNCaW5DaHVuazogZmFsc2VcbiAgICB9LFxuICAgIHR5cGUsXG4gICAgdmVyc2lvbixcbiAgICBqc29uOiB7fSxcbiAgICBiaW5DaHVua3M6IFtdXG4gIH0pO1xuICBieXRlT2Zmc2V0ICs9IEdMQl9GSUxFX0hFQURFUl9TSVpFO1xuICBzd2l0Y2ggKGdsYi52ZXJzaW9uKSB7XG4gICAgY2FzZSAxOlxuICAgICAgcmV0dXJuIHBhcnNlR0xCVjEoZ2xiLCBkYXRhVmlldywgYnl0ZU9mZnNldCk7XG4gICAgY2FzZSAyOlxuICAgICAgcmV0dXJuIHBhcnNlR0xCVjIoZ2xiLCBkYXRhVmlldywgYnl0ZU9mZnNldCwgb3B0aW9ucyA9IHt9KTtcbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIEdMQiB2ZXJzaW9uICR7Z2xiLnZlcnNpb259LiBPbmx5IHN1cHBvcnRzIHZlcnNpb24gMSBhbmQgMi5gKTtcbiAgfVxufVxuZnVuY3Rpb24gcGFyc2VHTEJWMShnbGIsIGRhdGFWaWV3LCBieXRlT2Zmc2V0KSB7XG4gIGFzc2VydChnbGIuaGVhZGVyLmJ5dGVMZW5ndGggPiBHTEJfRklMRV9IRUFERVJfU0laRSArIEdMQl9DSFVOS19IRUFERVJfU0laRSk7XG4gIGNvbnN0IGNvbnRlbnRMZW5ndGggPSBkYXRhVmlldy5nZXRVaW50MzIoYnl0ZU9mZnNldCArIDAsIExJVFRMRV9FTkRJQU4pO1xuICBjb25zdCBjb250ZW50Rm9ybWF0ID0gZGF0YVZpZXcuZ2V0VWludDMyKGJ5dGVPZmZzZXQgKyA0LCBMSVRUTEVfRU5ESUFOKTtcbiAgYnl0ZU9mZnNldCArPSBHTEJfQ0hVTktfSEVBREVSX1NJWkU7XG4gIGFzc2VydChjb250ZW50Rm9ybWF0ID09PSBHTEJfVjFfQ09OVEVOVF9GT1JNQVRfSlNPTik7XG4gIHBhcnNlSlNPTkNodW5rKGdsYiwgZGF0YVZpZXcsIGJ5dGVPZmZzZXQsIGNvbnRlbnRMZW5ndGgpO1xuICBieXRlT2Zmc2V0ICs9IGNvbnRlbnRMZW5ndGg7XG4gIGJ5dGVPZmZzZXQgKz0gcGFyc2VCSU5DaHVuayhnbGIsIGRhdGFWaWV3LCBieXRlT2Zmc2V0LCBnbGIuaGVhZGVyLmJ5dGVMZW5ndGgpO1xuICByZXR1cm4gYnl0ZU9mZnNldDtcbn1cbmZ1bmN0aW9uIHBhcnNlR0xCVjIoZ2xiLCBkYXRhVmlldywgYnl0ZU9mZnNldCwgb3B0aW9ucykge1xuICBhc3NlcnQoZ2xiLmhlYWRlci5ieXRlTGVuZ3RoID4gR0xCX0ZJTEVfSEVBREVSX1NJWkUgKyBHTEJfQ0hVTktfSEVBREVSX1NJWkUpO1xuICBwYXJzZUdMQkNodW5rc1N5bmMoZ2xiLCBkYXRhVmlldywgYnl0ZU9mZnNldCwgb3B0aW9ucyk7XG4gIHJldHVybiBieXRlT2Zmc2V0ICsgZ2xiLmhlYWRlci5ieXRlTGVuZ3RoO1xufVxuZnVuY3Rpb24gcGFyc2VHTEJDaHVua3NTeW5jKGdsYiwgZGF0YVZpZXcsIGJ5dGVPZmZzZXQsIG9wdGlvbnMpIHtcbiAgd2hpbGUgKGJ5dGVPZmZzZXQgKyA4IDw9IGdsYi5oZWFkZXIuYnl0ZUxlbmd0aCkge1xuICAgIGNvbnN0IGNodW5rTGVuZ3RoID0gZGF0YVZpZXcuZ2V0VWludDMyKGJ5dGVPZmZzZXQgKyAwLCBMSVRUTEVfRU5ESUFOKTtcbiAgICBjb25zdCBjaHVua0Zvcm1hdCA9IGRhdGFWaWV3LmdldFVpbnQzMihieXRlT2Zmc2V0ICsgNCwgTElUVExFX0VORElBTik7XG4gICAgYnl0ZU9mZnNldCArPSBHTEJfQ0hVTktfSEVBREVSX1NJWkU7XG4gICAgc3dpdGNoIChjaHVua0Zvcm1hdCkge1xuICAgICAgY2FzZSBHTEJfQ0hVTktfVFlQRV9KU09OOlxuICAgICAgICBwYXJzZUpTT05DaHVuayhnbGIsIGRhdGFWaWV3LCBieXRlT2Zmc2V0LCBjaHVua0xlbmd0aCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBHTEJfQ0hVTktfVFlQRV9CSU46XG4gICAgICAgIHBhcnNlQklOQ2h1bmsoZ2xiLCBkYXRhVmlldywgYnl0ZU9mZnNldCwgY2h1bmtMZW5ndGgpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgR0xCX0NIVU5LX1RZUEVfSlNPTl9YVklaX0RFUFJFQ0FURUQ6XG4gICAgICAgIGlmICghb3B0aW9ucy5zdHJpY3QpIHtcbiAgICAgICAgICBwYXJzZUpTT05DaHVuayhnbGIsIGRhdGFWaWV3LCBieXRlT2Zmc2V0LCBjaHVua0xlbmd0aCk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIEdMQl9DSFVOS19UWVBFX0JJWF9YVklaX0RFUFJFQ0FURUQ6XG4gICAgICAgIGlmICghb3B0aW9ucy5zdHJpY3QpIHtcbiAgICAgICAgICBwYXJzZUJJTkNodW5rKGdsYiwgZGF0YVZpZXcsIGJ5dGVPZmZzZXQsIGNodW5rTGVuZ3RoKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBieXRlT2Zmc2V0ICs9IHBhZFRvTkJ5dGVzKGNodW5rTGVuZ3RoLCA0KTtcbiAgfVxuICByZXR1cm4gYnl0ZU9mZnNldDtcbn1cbmZ1bmN0aW9uIHBhcnNlSlNPTkNodW5rKGdsYiwgZGF0YVZpZXcsIGJ5dGVPZmZzZXQsIGNodW5rTGVuZ3RoKSB7XG4gIGNvbnN0IGpzb25DaHVuayA9IG5ldyBVaW50OEFycmF5KGRhdGFWaWV3LmJ1ZmZlciwgYnl0ZU9mZnNldCwgY2h1bmtMZW5ndGgpO1xuICBjb25zdCB0ZXh0RGVjb2RlciA9IG5ldyBUZXh0RGVjb2RlcigndXRmOCcpO1xuICBjb25zdCBqc29uVGV4dCA9IHRleHREZWNvZGVyLmRlY29kZShqc29uQ2h1bmspO1xuICBnbGIuanNvbiA9IEpTT04ucGFyc2UoanNvblRleHQpO1xuICByZXR1cm4gcGFkVG9OQnl0ZXMoY2h1bmtMZW5ndGgsIDQpO1xufVxuZnVuY3Rpb24gcGFyc2VCSU5DaHVuayhnbGIsIGRhdGFWaWV3LCBieXRlT2Zmc2V0LCBjaHVua0xlbmd0aCkge1xuICBnbGIuaGVhZGVyLmhhc0JpbkNodW5rID0gdHJ1ZTtcbiAgZ2xiLmJpbkNodW5rcy5wdXNoKHtcbiAgICBieXRlT2Zmc2V0LFxuICAgIGJ5dGVMZW5ndGg6IGNodW5rTGVuZ3RoLFxuICAgIGFycmF5QnVmZmVyOiBkYXRhVmlldy5idWZmZXJcbiAgfSk7XG4gIHJldHVybiBwYWRUb05CeXRlcyhjaHVua0xlbmd0aCwgNCk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wYXJzZS1nbGIuanMubWFwIiwiZXhwb3J0IGNvbnN0IFZFUlNJT04gPSB0eXBlb2YgXCI0LjEuM1wiICE9PSAndW5kZWZpbmVkJyA/IFwiNC4xLjNcIiA6ICdsYXRlc3QnO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dmVyc2lvbi5qcy5tYXAiLCJleHBvcnQgZnVuY3Rpb24gY29tcGFyZUFycmF5QnVmZmVycyhhcnJheUJ1ZmZlcjEsIGFycmF5QnVmZmVyMiwgYnl0ZUxlbmd0aCkge1xuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCB8fCBhcnJheUJ1ZmZlcjEuYnl0ZUxlbmd0aDtcbiAgaWYgKGFycmF5QnVmZmVyMS5ieXRlTGVuZ3RoIDwgYnl0ZUxlbmd0aCB8fCBhcnJheUJ1ZmZlcjIuYnl0ZUxlbmd0aCA8IGJ5dGVMZW5ndGgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgY29uc3QgYXJyYXkxID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXlCdWZmZXIxKTtcbiAgY29uc3QgYXJyYXkyID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXlCdWZmZXIyKTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcnJheTEubGVuZ3RoOyArK2kpIHtcbiAgICBpZiAoYXJyYXkxW2ldICE9PSBhcnJheTJbaV0pIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5leHBvcnQgZnVuY3Rpb24gY29uY2F0ZW5hdGVBcnJheUJ1ZmZlcnMoKSB7XG4gIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBzb3VyY2VzID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgIHNvdXJjZXNbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gIH1cbiAgcmV0dXJuIGNvbmNhdGVuYXRlQXJyYXlCdWZmZXJzRnJvbUFycmF5KHNvdXJjZXMpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGNvbmNhdGVuYXRlQXJyYXlCdWZmZXJzRnJvbUFycmF5KHNvdXJjZXMpIHtcbiAgY29uc3Qgc291cmNlQXJyYXlzID0gc291cmNlcy5tYXAoc291cmNlMiA9PiBzb3VyY2UyIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIgPyBuZXcgVWludDhBcnJheShzb3VyY2UyKSA6IHNvdXJjZTIpO1xuICBjb25zdCBieXRlTGVuZ3RoID0gc291cmNlQXJyYXlzLnJlZHVjZSgobGVuZ3RoLCB0eXBlZEFycmF5KSA9PiBsZW5ndGggKyB0eXBlZEFycmF5LmJ5dGVMZW5ndGgsIDApO1xuICBjb25zdCByZXN1bHQgPSBuZXcgVWludDhBcnJheShieXRlTGVuZ3RoKTtcbiAgbGV0IG9mZnNldCA9IDA7XG4gIGZvciAoY29uc3Qgc291cmNlQXJyYXkgb2Ygc291cmNlQXJyYXlzKSB7XG4gICAgcmVzdWx0LnNldChzb3VyY2VBcnJheSwgb2Zmc2V0KTtcbiAgICBvZmZzZXQgKz0gc291cmNlQXJyYXkuYnl0ZUxlbmd0aDtcbiAgfVxuICByZXR1cm4gcmVzdWx0LmJ1ZmZlcjtcbn1cbmV4cG9ydCBmdW5jdGlvbiBjb25jYXRlbmF0ZVR5cGVkQXJyYXlzKCkge1xuICBmb3IgKHZhciBfbGVuMiA9IGFyZ3VtZW50cy5sZW5ndGgsIHR5cGVkQXJyYXlzID0gbmV3IEFycmF5KF9sZW4yKSwgX2tleTIgPSAwOyBfa2V5MiA8IF9sZW4yOyBfa2V5MisrKSB7XG4gICAgdHlwZWRBcnJheXNbX2tleTJdID0gYXJndW1lbnRzW19rZXkyXTtcbiAgfVxuICBjb25zdCBhcnJheXMgPSB0eXBlZEFycmF5cztcbiAgY29uc3QgVHlwZWRBcnJheUNvbnN0cnVjdG9yID0gYXJyYXlzICYmIGFycmF5cy5sZW5ndGggPiAxICYmIGFycmF5c1swXS5jb25zdHJ1Y3RvciB8fCBudWxsO1xuICBpZiAoIVR5cGVkQXJyYXlDb25zdHJ1Y3Rvcikge1xuICAgIHRocm93IG5ldyBFcnJvcignXCJjb25jYXRlbmF0ZVR5cGVkQXJyYXlzXCIgLSBpbmNvcnJlY3QgcXVhbnRpdHkgb2YgYXJndW1lbnRzIG9yIGFyZ3VtZW50cyBoYXZlIGluY29tcGF0aWJsZSBkYXRhIHR5cGVzJyk7XG4gIH1cbiAgY29uc3Qgc3VtTGVuZ3RoID0gYXJyYXlzLnJlZHVjZSgoYWNjLCB2YWx1ZSkgPT4gYWNjICsgdmFsdWUubGVuZ3RoLCAwKTtcbiAgY29uc3QgcmVzdWx0ID0gbmV3IFR5cGVkQXJyYXlDb25zdHJ1Y3RvcihzdW1MZW5ndGgpO1xuICBsZXQgb2Zmc2V0ID0gMDtcbiAgZm9yIChjb25zdCBhcnJheSBvZiBhcnJheXMpIHtcbiAgICByZXN1bHQuc2V0KGFycmF5LCBvZmZzZXQpO1xuICAgIG9mZnNldCArPSBhcnJheS5sZW5ndGg7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cbmV4cG9ydCBmdW5jdGlvbiBzbGljZUFycmF5QnVmZmVyKGFycmF5QnVmZmVyLCBieXRlT2Zmc2V0LCBieXRlTGVuZ3RoKSB7XG4gIGNvbnN0IHN1YkFycmF5ID0gYnl0ZUxlbmd0aCAhPT0gdW5kZWZpbmVkID8gbmV3IFVpbnQ4QXJyYXkoYXJyYXlCdWZmZXIpLnN1YmFycmF5KGJ5dGVPZmZzZXQsIGJ5dGVPZmZzZXQgKyBieXRlTGVuZ3RoKSA6IG5ldyBVaW50OEFycmF5KGFycmF5QnVmZmVyKS5zdWJhcnJheShieXRlT2Zmc2V0KTtcbiAgY29uc3QgYXJyYXlDb3B5ID0gbmV3IFVpbnQ4QXJyYXkoc3ViQXJyYXkpO1xuICByZXR1cm4gYXJyYXlDb3B5LmJ1ZmZlcjtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFycmF5LWJ1ZmZlci11dGlscy5qcy5tYXAiLCJpbXBvcnQgKiBhcyBub2RlIGZyb20gXCIuLi9ub2RlL2J1ZmZlci5qc1wiO1xuZXhwb3J0IGZ1bmN0aW9uIGlzQnVmZmVyKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSAmJiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmIHZhbHVlLmlzQnVmZmVyO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHRvQnVmZmVyKGRhdGEpIHtcbiAgcmV0dXJuIG5vZGUudG9CdWZmZXIgPyBub2RlLnRvQnVmZmVyKGRhdGEpIDogZGF0YTtcbn1cbmV4cG9ydCBmdW5jdGlvbiB0b0FycmF5QnVmZmVyKGRhdGEpIHtcbiAgaWYgKGlzQnVmZmVyKGRhdGEpKSB7XG4gICAgcmV0dXJuIG5vZGUudG9BcnJheUJ1ZmZlcihkYXRhKTtcbiAgfVxuICBpZiAoZGF0YSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB7XG4gICAgcmV0dXJuIGRhdGE7XG4gIH1cbiAgaWYgKEFycmF5QnVmZmVyLmlzVmlldyhkYXRhKSkge1xuICAgIGlmIChkYXRhLmJ5dGVPZmZzZXQgPT09IDAgJiYgZGF0YS5ieXRlTGVuZ3RoID09PSBkYXRhLmJ1ZmZlci5ieXRlTGVuZ3RoKSB7XG4gICAgICByZXR1cm4gZGF0YS5idWZmZXI7XG4gICAgfVxuICAgIHJldHVybiBkYXRhLmJ1ZmZlci5zbGljZShkYXRhLmJ5dGVPZmZzZXQsIGRhdGEuYnl0ZU9mZnNldCArIGRhdGEuYnl0ZUxlbmd0aCk7XG4gIH1cbiAgaWYgKHR5cGVvZiBkYXRhID09PSAnc3RyaW5nJykge1xuICAgIGNvbnN0IHRleHQgPSBkYXRhO1xuICAgIGNvbnN0IHVpbnQ4QXJyYXkgPSBuZXcgVGV4dEVuY29kZXIoKS5lbmNvZGUodGV4dCk7XG4gICAgcmV0dXJuIHVpbnQ4QXJyYXkuYnVmZmVyO1xuICB9XG4gIGlmIChkYXRhICYmIHR5cGVvZiBkYXRhID09PSAnb2JqZWN0JyAmJiBkYXRhLl90b0FycmF5QnVmZmVyKSB7XG4gICAgcmV0dXJuIGRhdGEuX3RvQXJyYXlCdWZmZXIoKTtcbiAgfVxuICB0aHJvdyBuZXcgRXJyb3IoJ3RvQXJyYXlCdWZmZXInKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1lbW9yeS1jb252ZXJzaW9uLXV0aWxzLmpzLm1hcCIsImltcG9ydCB7IGFzc2VydCB9IGZyb20gXCIuLi9lbnYtdXRpbHMvYXNzZXJ0LmpzXCI7XG5leHBvcnQgZnVuY3Rpb24gcGFkVG9OQnl0ZXMoYnl0ZUxlbmd0aCwgcGFkZGluZykge1xuICBhc3NlcnQoYnl0ZUxlbmd0aCA+PSAwKTtcbiAgYXNzZXJ0KHBhZGRpbmcgPiAwKTtcbiAgcmV0dXJuIGJ5dGVMZW5ndGggKyAocGFkZGluZyAtIDEpICYgfihwYWRkaW5nIC0gMSk7XG59XG5leHBvcnQgZnVuY3Rpb24gY29weUFycmF5QnVmZmVyKHRhcmdldEJ1ZmZlciwgc291cmNlQnVmZmVyLCBieXRlT2Zmc2V0KSB7XG4gIGxldCBieXRlTGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgJiYgYXJndW1lbnRzWzNdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbM10gOiBzb3VyY2VCdWZmZXIuYnl0ZUxlbmd0aDtcbiAgY29uc3QgdGFyZ2V0QXJyYXkgPSBuZXcgVWludDhBcnJheSh0YXJnZXRCdWZmZXIsIGJ5dGVPZmZzZXQsIGJ5dGVMZW5ndGgpO1xuICBjb25zdCBzb3VyY2VBcnJheSA9IG5ldyBVaW50OEFycmF5KHNvdXJjZUJ1ZmZlcik7XG4gIHRhcmdldEFycmF5LnNldChzb3VyY2VBcnJheSk7XG4gIHJldHVybiB0YXJnZXRCdWZmZXI7XG59XG5leHBvcnQgZnVuY3Rpb24gY29weVRvQXJyYXkoc291cmNlLCB0YXJnZXQsIHRhcmdldE9mZnNldCkge1xuICBsZXQgc291cmNlQXJyYXk7XG4gIGlmIChzb3VyY2UgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikge1xuICAgIHNvdXJjZUFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoc291cmNlKTtcbiAgfSBlbHNlIHtcbiAgICBjb25zdCBzcmNCeXRlT2Zmc2V0ID0gc291cmNlLmJ5dGVPZmZzZXQ7XG4gICAgY29uc3Qgc3JjQnl0ZUxlbmd0aCA9IHNvdXJjZS5ieXRlTGVuZ3RoO1xuICAgIHNvdXJjZUFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoc291cmNlLmJ1ZmZlciB8fCBzb3VyY2UuYXJyYXlCdWZmZXIsIHNyY0J5dGVPZmZzZXQsIHNyY0J5dGVMZW5ndGgpO1xuICB9XG4gIHRhcmdldC5zZXQoc291cmNlQXJyYXksIHRhcmdldE9mZnNldCk7XG4gIHJldHVybiB0YXJnZXRPZmZzZXQgKyBwYWRUb05CeXRlcyhzb3VyY2VBcnJheS5ieXRlTGVuZ3RoLCA0KTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1lbW9yeS1jb3B5LXV0aWxzLmpzLm1hcCIsImV4cG9ydCBmdW5jdGlvbiBhc3NlcnQoY29uZGl0aW9uLCBtZXNzYWdlKSB7XG4gIGlmICghY29uZGl0aW9uKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UgfHwgJ2xvYWRlciBhc3NlcnRpb24gZmFpbGVkLicpO1xuICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hc3NlcnQuanMubWFwIiwiY29uc3QgZ2xvYmFscyA9IHtcbiAgc2VsZjogdHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnICYmIHNlbGYsXG4gIHdpbmRvdzogdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LFxuICBnbG9iYWw6IHR5cGVvZiBnbG9iYWwgIT09ICd1bmRlZmluZWQnICYmIGdsb2JhbCxcbiAgZG9jdW1lbnQ6IHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcgJiYgZG9jdW1lbnRcbn07XG5jb25zdCBzZWxmXyA9IGdsb2JhbHMuc2VsZiB8fCBnbG9iYWxzLndpbmRvdyB8fCBnbG9iYWxzLmdsb2JhbCB8fCB7fTtcbmNvbnN0IHdpbmRvd18gPSBnbG9iYWxzLndpbmRvdyB8fCBnbG9iYWxzLnNlbGYgfHwgZ2xvYmFscy5nbG9iYWwgfHwge307XG5jb25zdCBnbG9iYWxfID0gZ2xvYmFscy5nbG9iYWwgfHwgZ2xvYmFscy5zZWxmIHx8IGdsb2JhbHMud2luZG93IHx8IHt9O1xuY29uc3QgZG9jdW1lbnRfID0gZ2xvYmFscy5kb2N1bWVudCB8fCB7fTtcbmV4cG9ydCB7IHNlbGZfIGFzIHNlbGYsIHdpbmRvd18gYXMgd2luZG93LCBnbG9iYWxfIGFzIGdsb2JhbCwgZG9jdW1lbnRfIGFzIGRvY3VtZW50IH07XG5leHBvcnQgY29uc3QgaXNCcm93c2VyID0gQm9vbGVhbih0eXBlb2YgcHJvY2VzcyAhPT0gJ29iamVjdCcgfHwgU3RyaW5nKHByb2Nlc3MpICE9PSAnW29iamVjdCBwcm9jZXNzXScgfHwgcHJvY2Vzcy5icm93c2VyKTtcbmV4cG9ydCBjb25zdCBpc1dvcmtlciA9IHR5cGVvZiBpbXBvcnRTY3JpcHRzID09PSAnZnVuY3Rpb24nO1xuY29uc3QgbWF0Y2hlcyA9IHR5cGVvZiBwcm9jZXNzICE9PSAndW5kZWZpbmVkJyAmJiBwcm9jZXNzLnZlcnNpb24gJiYgL3YoWzAtOV0qKS8uZXhlYyhwcm9jZXNzLnZlcnNpb24pO1xuZXhwb3J0IGNvbnN0IG5vZGVWZXJzaW9uID0gbWF0Y2hlcyAmJiBwYXJzZUZsb2F0KG1hdGNoZXNbMV0pIHx8IDA7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1nbG9iYWxzLmpzLm1hcCIsImltcG9ydCB7IGNvbmNhdGVuYXRlQXJyYXlCdWZmZXJzIH0gZnJvbSBcIi4uL2JpbmFyeS11dGlscy9hcnJheS1idWZmZXItdXRpbHMuanNcIjtcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBmb3JFYWNoKGl0ZXJhdG9yLCB2aXNpdG9yKSB7XG4gIHdoaWxlICh0cnVlKSB7XG4gICAgY29uc3Qge1xuICAgICAgZG9uZSxcbiAgICAgIHZhbHVlXG4gICAgfSA9IGF3YWl0IGl0ZXJhdG9yLm5leHQoKTtcbiAgICBpZiAoZG9uZSkge1xuICAgICAgaXRlcmF0b3IucmV0dXJuKCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGNhbmNlbCA9IHZpc2l0b3IodmFsdWUpO1xuICAgIGlmIChjYW5jZWwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gIH1cbn1cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBjb25jYXRlbmF0ZUFycmF5QnVmZmVyc0FzeW5jKGFzeW5jSXRlcmF0b3IpIHtcbiAgY29uc3QgYXJyYXlCdWZmZXJzID0gW107XG4gIGZvciBhd2FpdCAoY29uc3QgY2h1bmsgb2YgYXN5bmNJdGVyYXRvcikge1xuICAgIGFycmF5QnVmZmVycy5wdXNoKGNodW5rKTtcbiAgfVxuICByZXR1cm4gY29uY2F0ZW5hdGVBcnJheUJ1ZmZlcnMoLi4uYXJyYXlCdWZmZXJzKTtcbn1cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBjb25jYXRlbmF0ZVN0cmluZ3NBc3luYyhhc3luY0l0ZXJhdG9yKSB7XG4gIGNvbnN0IHN0cmluZ3MgPSBbXTtcbiAgZm9yIGF3YWl0IChjb25zdCBjaHVuayBvZiBhc3luY0l0ZXJhdG9yKSB7XG4gICAgc3RyaW5ncy5wdXNoKGNodW5rKTtcbiAgfVxuICByZXR1cm4gc3RyaW5ncy5qb2luKCcnKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFzeW5jLWl0ZXJhdGlvbi5qcy5tYXAiLCJleHBvcnQgZnVuY3Rpb24gdG9BcnJheUJ1ZmZlcihidWZmZXIpIHtcbiAgcmV0dXJuIGJ1ZmZlcjtcbn1cbmV4cG9ydCBmdW5jdGlvbiB0b0J1ZmZlcihiaW5hcnlEYXRhKSB7XG4gIHRocm93IG5ldyBFcnJvcignQnVmZmVyIG5vdCBzdXBwb3J0ZWQgaW4gYnJvd3NlcicpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YnVmZmVyLmJyb3dzZXIuanMubWFwIiwiZXhwb3J0IGZ1bmN0aW9uIG1lcmdlTG9hZGVyT3B0aW9ucyhiYXNlT3B0aW9ucywgbmV3T3B0aW9ucykge1xuICByZXR1cm4gbWVyZ2VPcHRpb25zUmVjdXJzaXZlbHkoYmFzZU9wdGlvbnMgfHwge30sIG5ld09wdGlvbnMpO1xufVxuZnVuY3Rpb24gbWVyZ2VPcHRpb25zUmVjdXJzaXZlbHkoYmFzZU9wdGlvbnMsIG5ld09wdGlvbnMpIHtcbiAgbGV0IGxldmVsID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiAwO1xuICBpZiAobGV2ZWwgPiAzKSB7XG4gICAgcmV0dXJuIG5ld09wdGlvbnM7XG4gIH1cbiAgY29uc3Qgb3B0aW9ucyA9IHtcbiAgICAuLi5iYXNlT3B0aW9uc1xuICB9O1xuICBmb3IgKGNvbnN0IFtrZXksIG5ld1ZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhuZXdPcHRpb25zKSkge1xuICAgIGlmIChuZXdWYWx1ZSAmJiB0eXBlb2YgbmV3VmFsdWUgPT09ICdvYmplY3QnICYmICFBcnJheS5pc0FycmF5KG5ld1ZhbHVlKSkge1xuICAgICAgb3B0aW9uc1trZXldID0gbWVyZ2VPcHRpb25zUmVjdXJzaXZlbHkob3B0aW9uc1trZXldIHx8IHt9LCBuZXdPcHRpb25zW2tleV0sIGxldmVsICsgMSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG9wdGlvbnNba2V5XSA9IG5ld09wdGlvbnNba2V5XTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG9wdGlvbnM7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tZXJnZS1sb2FkZXItb3B0aW9ucy5qcy5tYXAiLCJsZXQgcGF0aFByZWZpeCA9ICcnO1xuY29uc3QgZmlsZUFsaWFzZXMgPSB7fTtcbmV4cG9ydCBmdW5jdGlvbiBzZXRQYXRoUHJlZml4KHByZWZpeCkge1xuICBwYXRoUHJlZml4ID0gcHJlZml4O1xufVxuZXhwb3J0IGZ1bmN0aW9uIGdldFBhdGhQcmVmaXgoKSB7XG4gIHJldHVybiBwYXRoUHJlZml4O1xufVxuZXhwb3J0IGZ1bmN0aW9uIGFkZEFsaWFzZXMoYWxpYXNlcykge1xuICBPYmplY3QuYXNzaWduKGZpbGVBbGlhc2VzLCBhbGlhc2VzKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiByZXNvbHZlUGF0aChmaWxlbmFtZSkge1xuICBmb3IgKGNvbnN0IGFsaWFzIGluIGZpbGVBbGlhc2VzKSB7XG4gICAgaWYgKGZpbGVuYW1lLnN0YXJ0c1dpdGgoYWxpYXMpKSB7XG4gICAgICBjb25zdCByZXBsYWNlbWVudCA9IGZpbGVBbGlhc2VzW2FsaWFzXTtcbiAgICAgIGZpbGVuYW1lID0gZmlsZW5hbWUucmVwbGFjZShhbGlhcywgcmVwbGFjZW1lbnQpO1xuICAgIH1cbiAgfVxuICBpZiAoIWZpbGVuYW1lLnN0YXJ0c1dpdGgoJ2h0dHA6Ly8nKSAmJiAhZmlsZW5hbWUuc3RhcnRzV2l0aCgnaHR0cHM6Ly8nKSkge1xuICAgIGZpbGVuYW1lID0gYCR7cGF0aFByZWZpeH0ke2ZpbGVuYW1lfWA7XG4gIH1cbiAgcmV0dXJuIGZpbGVuYW1lO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZmlsZS1hbGlhc2VzLmpzLm1hcCIsImV4cG9ydCBmdW5jdGlvbiBnZXRDV0QoKSB7XG4gIHZhciBfd2luZG93JGxvY2F0aW9uO1xuICBpZiAodHlwZW9mIHByb2Nlc3MgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBwcm9jZXNzLmN3ZCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm4gcHJvY2Vzcy5jd2QoKTtcbiAgfVxuICBjb25zdCBwYXRobmFtZSA9IChfd2luZG93JGxvY2F0aW9uID0gd2luZG93LmxvY2F0aW9uKSA9PT0gbnVsbCB8fCBfd2luZG93JGxvY2F0aW9uID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfd2luZG93JGxvY2F0aW9uLnBhdGhuYW1lO1xuICByZXR1cm4gKHBhdGhuYW1lID09PSBudWxsIHx8IHBhdGhuYW1lID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwYXRobmFtZS5zbGljZSgwLCBwYXRobmFtZS5sYXN0SW5kZXhPZignLycpICsgMSkpIHx8ICcnO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Z2V0LWN3ZC5qcy5tYXAiLCJpbXBvcnQgeyBnZXRDV0QgfSBmcm9tIFwiLi9nZXQtY3dkLmpzXCI7XG5leHBvcnQgZnVuY3Rpb24gZmlsZW5hbWUodXJsKSB7XG4gIGNvbnN0IHNsYXNoSW5kZXggPSB1cmwgPyB1cmwubGFzdEluZGV4T2YoJy8nKSA6IC0xO1xuICByZXR1cm4gc2xhc2hJbmRleCA+PSAwID8gdXJsLnN1YnN0cihzbGFzaEluZGV4ICsgMSkgOiAnJztcbn1cbmV4cG9ydCBmdW5jdGlvbiBkaXJuYW1lKHVybCkge1xuICBjb25zdCBzbGFzaEluZGV4ID0gdXJsID8gdXJsLmxhc3RJbmRleE9mKCcvJykgOiAtMTtcbiAgcmV0dXJuIHNsYXNoSW5kZXggPj0gMCA/IHVybC5zdWJzdHIoMCwgc2xhc2hJbmRleCkgOiAnJztcbn1cbmV4cG9ydCBmdW5jdGlvbiBqb2luKCkge1xuICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgcGFydHMgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgcGFydHNbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gIH1cbiAgY29uc3Qgc2VwYXJhdG9yID0gJy8nO1xuICBwYXJ0cyA9IHBhcnRzLm1hcCgocGFydCwgaW5kZXgpID0+IHtcbiAgICBpZiAoaW5kZXgpIHtcbiAgICAgIHBhcnQgPSBwYXJ0LnJlcGxhY2UobmV3IFJlZ0V4cChgXiR7c2VwYXJhdG9yfWApLCAnJyk7XG4gICAgfVxuICAgIGlmIChpbmRleCAhPT0gcGFydHMubGVuZ3RoIC0gMSkge1xuICAgICAgcGFydCA9IHBhcnQucmVwbGFjZShuZXcgUmVnRXhwKGAke3NlcGFyYXRvcn0kYCksICcnKTtcbiAgICB9XG4gICAgcmV0dXJuIHBhcnQ7XG4gIH0pO1xuICByZXR1cm4gcGFydHMuam9pbihzZXBhcmF0b3IpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHJlc29sdmUoKSB7XG4gIGNvbnN0IHBhdGhzID0gW107XG4gIGZvciAobGV0IF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgcGF0aHNbX2ldID0gX2kgPCAwIHx8IGFyZ3VtZW50cy5sZW5ndGggPD0gX2kgPyB1bmRlZmluZWQgOiBhcmd1bWVudHNbX2ldO1xuICB9XG4gIGxldCByZXNvbHZlZFBhdGggPSAnJztcbiAgbGV0IHJlc29sdmVkQWJzb2x1dGUgPSBmYWxzZTtcbiAgbGV0IGN3ZDtcbiAgZm9yIChsZXQgaSA9IHBhdGhzLmxlbmd0aCAtIDE7IGkgPj0gLTEgJiYgIXJlc29sdmVkQWJzb2x1dGU7IGktLSkge1xuICAgIGxldCBwYXRoO1xuICAgIGlmIChpID49IDApIHtcbiAgICAgIHBhdGggPSBwYXRoc1tpXTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGN3ZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGN3ZCA9IGdldENXRCgpO1xuICAgICAgfVxuICAgICAgcGF0aCA9IGN3ZDtcbiAgICB9XG4gICAgaWYgKHBhdGgubGVuZ3RoID09PSAwKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgcmVzb2x2ZWRQYXRoID0gYCR7cGF0aH0vJHtyZXNvbHZlZFBhdGh9YDtcbiAgICByZXNvbHZlZEFic29sdXRlID0gcGF0aC5jaGFyQ29kZUF0KDApID09PSBTTEFTSDtcbiAgfVxuICByZXNvbHZlZFBhdGggPSBub3JtYWxpemVTdHJpbmdQb3NpeChyZXNvbHZlZFBhdGgsICFyZXNvbHZlZEFic29sdXRlKTtcbiAgaWYgKHJlc29sdmVkQWJzb2x1dGUpIHtcbiAgICByZXR1cm4gYC8ke3Jlc29sdmVkUGF0aH1gO1xuICB9IGVsc2UgaWYgKHJlc29sdmVkUGF0aC5sZW5ndGggPiAwKSB7XG4gICAgcmV0dXJuIHJlc29sdmVkUGF0aDtcbiAgfVxuICByZXR1cm4gJy4nO1xufVxuY29uc3QgU0xBU0ggPSA0NztcbmNvbnN0IERPVCA9IDQ2O1xuZnVuY3Rpb24gbm9ybWFsaXplU3RyaW5nUG9zaXgocGF0aCwgYWxsb3dBYm92ZVJvb3QpIHtcbiAgbGV0IHJlcyA9ICcnO1xuICBsZXQgbGFzdFNsYXNoID0gLTE7XG4gIGxldCBkb3RzID0gMDtcbiAgbGV0IGNvZGU7XG4gIGxldCBpc0Fib3ZlUm9vdCA9IGZhbHNlO1xuICBmb3IgKGxldCBpID0gMDsgaSA8PSBwYXRoLmxlbmd0aDsgKytpKSB7XG4gICAgaWYgKGkgPCBwYXRoLmxlbmd0aCkge1xuICAgICAgY29kZSA9IHBhdGguY2hhckNvZGVBdChpKTtcbiAgICB9IGVsc2UgaWYgKGNvZGUgPT09IFNMQVNIKSB7XG4gICAgICBicmVhaztcbiAgICB9IGVsc2Uge1xuICAgICAgY29kZSA9IFNMQVNIO1xuICAgIH1cbiAgICBpZiAoY29kZSA9PT0gU0xBU0gpIHtcbiAgICAgIGlmIChsYXN0U2xhc2ggPT09IGkgLSAxIHx8IGRvdHMgPT09IDEpIHt9IGVsc2UgaWYgKGxhc3RTbGFzaCAhPT0gaSAtIDEgJiYgZG90cyA9PT0gMikge1xuICAgICAgICBpZiAocmVzLmxlbmd0aCA8IDIgfHwgIWlzQWJvdmVSb290IHx8IHJlcy5jaGFyQ29kZUF0KHJlcy5sZW5ndGggLSAxKSAhPT0gRE9UIHx8IHJlcy5jaGFyQ29kZUF0KHJlcy5sZW5ndGggLSAyKSAhPT0gRE9UKSB7XG4gICAgICAgICAgaWYgKHJlcy5sZW5ndGggPiAyKSB7XG4gICAgICAgICAgICBjb25zdCBzdGFydCA9IHJlcy5sZW5ndGggLSAxO1xuICAgICAgICAgICAgbGV0IGogPSBzdGFydDtcbiAgICAgICAgICAgIGZvciAoOyBqID49IDA7IC0taikge1xuICAgICAgICAgICAgICBpZiAocmVzLmNoYXJDb2RlQXQoaikgPT09IFNMQVNIKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChqICE9PSBzdGFydCkge1xuICAgICAgICAgICAgICByZXMgPSBqID09PSAtMSA/ICcnIDogcmVzLnNsaWNlKDAsIGopO1xuICAgICAgICAgICAgICBsYXN0U2xhc2ggPSBpO1xuICAgICAgICAgICAgICBkb3RzID0gMDtcbiAgICAgICAgICAgICAgaXNBYm92ZVJvb3QgPSBmYWxzZTtcbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIGlmIChyZXMubGVuZ3RoID09PSAyIHx8IHJlcy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgIHJlcyA9ICcnO1xuICAgICAgICAgICAgbGFzdFNsYXNoID0gaTtcbiAgICAgICAgICAgIGRvdHMgPSAwO1xuICAgICAgICAgICAgaXNBYm92ZVJvb3QgPSBmYWxzZTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoYWxsb3dBYm92ZVJvb3QpIHtcbiAgICAgICAgICBpZiAocmVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHJlcyArPSAnLy4uJztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzID0gJy4uJztcbiAgICAgICAgICB9XG4gICAgICAgICAgaXNBYm92ZVJvb3QgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBzbGljZSA9IHBhdGguc2xpY2UobGFzdFNsYXNoICsgMSwgaSk7XG4gICAgICAgIGlmIChyZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgIHJlcyArPSBgLyR7c2xpY2V9YDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXMgPSBzbGljZTtcbiAgICAgICAgfVxuICAgICAgICBpc0Fib3ZlUm9vdCA9IGZhbHNlO1xuICAgICAgfVxuICAgICAgbGFzdFNsYXNoID0gaTtcbiAgICAgIGRvdHMgPSAwO1xuICAgIH0gZWxzZSBpZiAoY29kZSA9PT0gRE9UICYmIGRvdHMgIT09IC0xKSB7XG4gICAgICArK2RvdHM7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRvdHMgPSAtMTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlcztcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXBhdGguanMubWFwIiwiaW1wb3J0IHsgaXNCcm93c2VyIH0gZnJvbSAnQGxvYWRlcnMuZ2wvd29ya2VyLXV0aWxzJztcbmltcG9ydCB7IFdvcmtlckZhcm0sIGdldFdvcmtlclVSTCB9IGZyb20gJ0Bsb2FkZXJzLmdsL3dvcmtlci11dGlscyc7XG5leHBvcnQgZnVuY3Rpb24gY2FuUGFyc2VXaXRoV29ya2VyKGxvYWRlciwgb3B0aW9ucykge1xuICBpZiAoIVdvcmtlckZhcm0uaXNTdXBwb3J0ZWQoKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAoIWlzQnJvd3NlciAmJiAhKG9wdGlvbnMgIT09IG51bGwgJiYgb3B0aW9ucyAhPT0gdm9pZCAwICYmIG9wdGlvbnMuX25vZGVXb3JrZXJzKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gbG9hZGVyLndvcmtlciAmJiAob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLndvcmtlcik7XG59XG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gcGFyc2VXaXRoV29ya2VyKGxvYWRlciwgZGF0YSwgb3B0aW9ucywgY29udGV4dCwgcGFyc2VPbk1haW5UaHJlYWQpIHtcbiAgY29uc3QgbmFtZSA9IGxvYWRlci5pZDtcbiAgY29uc3QgdXJsID0gZ2V0V29ya2VyVVJMKGxvYWRlciwgb3B0aW9ucyk7XG4gIGNvbnN0IHdvcmtlckZhcm0gPSBXb3JrZXJGYXJtLmdldFdvcmtlckZhcm0ob3B0aW9ucyk7XG4gIGNvbnN0IHdvcmtlclBvb2wgPSB3b3JrZXJGYXJtLmdldFdvcmtlclBvb2woe1xuICAgIG5hbWUsXG4gICAgdXJsXG4gIH0pO1xuICBvcHRpb25zID0gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShvcHRpb25zKSk7XG4gIGNvbnRleHQgPSBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KGNvbnRleHQgfHwge30pKTtcbiAgY29uc3Qgam9iID0gYXdhaXQgd29ya2VyUG9vbC5zdGFydEpvYigncHJvY2Vzcy1vbi13b3JrZXInLCBvbk1lc3NhZ2UuYmluZChudWxsLCBwYXJzZU9uTWFpblRocmVhZCkpO1xuICBqb2IucG9zdE1lc3NhZ2UoJ3Byb2Nlc3MnLCB7XG4gICAgaW5wdXQ6IGRhdGEsXG4gICAgb3B0aW9ucyxcbiAgICBjb250ZXh0XG4gIH0pO1xuICBjb25zdCByZXN1bHQgPSBhd2FpdCBqb2IucmVzdWx0O1xuICByZXR1cm4gYXdhaXQgcmVzdWx0LnJlc3VsdDtcbn1cbmFzeW5jIGZ1bmN0aW9uIG9uTWVzc2FnZShwYXJzZU9uTWFpblRocmVhZCwgam9iLCB0eXBlLCBwYXlsb2FkKSB7XG4gIHN3aXRjaCAodHlwZSkge1xuICAgIGNhc2UgJ2RvbmUnOlxuICAgICAgam9iLmRvbmUocGF5bG9hZCk7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdlcnJvcic6XG4gICAgICBqb2IuZXJyb3IobmV3IEVycm9yKHBheWxvYWQuZXJyb3IpKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ3Byb2Nlc3MnOlxuICAgICAgY29uc3Qge1xuICAgICAgICBpZCxcbiAgICAgICAgaW5wdXQsXG4gICAgICAgIG9wdGlvbnNcbiAgICAgIH0gPSBwYXlsb2FkO1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcGFyc2VPbk1haW5UaHJlYWQoaW5wdXQsIG9wdGlvbnMpO1xuICAgICAgICBqb2IucG9zdE1lc3NhZ2UoJ2RvbmUnLCB7XG4gICAgICAgICAgaWQsXG4gICAgICAgICAgcmVzdWx0XG4gICAgICAgIH0pO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogJ3Vua25vd24gZXJyb3InO1xuICAgICAgICBqb2IucG9zdE1lc3NhZ2UoJ2Vycm9yJywge1xuICAgICAgICAgIGlkLFxuICAgICAgICAgIGVycm9yOiBtZXNzYWdlXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIGNvbnNvbGUud2FybihgcGFyc2Utd2l0aC13b3JrZXIgdW5rbm93biBtZXNzYWdlICR7dHlwZX1gKTtcbiAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cGFyc2Utd2l0aC13b3JrZXIuanMubWFwIiwiZXhwb3J0IGZ1bmN0aW9uIGFzc2VydChjb25kaXRpb24sIG1lc3NhZ2UpIHtcbiAgaWYgKCFjb25kaXRpb24pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSB8fCAnbG9hZGVycy5nbCBhc3NlcnRpb24gZmFpbGVkLicpO1xuICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hc3NlcnQuanMubWFwIiwiY29uc3QgZ2xvYmFscyA9IHtcbiAgc2VsZjogdHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnICYmIHNlbGYsXG4gIHdpbmRvdzogdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LFxuICBnbG9iYWw6IHR5cGVvZiBnbG9iYWwgIT09ICd1bmRlZmluZWQnICYmIGdsb2JhbCxcbiAgZG9jdW1lbnQ6IHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcgJiYgZG9jdW1lbnRcbn07XG5jb25zdCBzZWxmXyA9IGdsb2JhbHMuc2VsZiB8fCBnbG9iYWxzLndpbmRvdyB8fCBnbG9iYWxzLmdsb2JhbCB8fCB7fTtcbmNvbnN0IHdpbmRvd18gPSBnbG9iYWxzLndpbmRvdyB8fCBnbG9iYWxzLnNlbGYgfHwgZ2xvYmFscy5nbG9iYWwgfHwge307XG5jb25zdCBnbG9iYWxfID0gZ2xvYmFscy5nbG9iYWwgfHwgZ2xvYmFscy5zZWxmIHx8IGdsb2JhbHMud2luZG93IHx8IHt9O1xuY29uc3QgZG9jdW1lbnRfID0gZ2xvYmFscy5kb2N1bWVudCB8fCB7fTtcbmV4cG9ydCB7IHNlbGZfIGFzIHNlbGYsIHdpbmRvd18gYXMgd2luZG93LCBnbG9iYWxfIGFzIGdsb2JhbCwgZG9jdW1lbnRfIGFzIGRvY3VtZW50IH07XG5leHBvcnQgY29uc3QgaXNCcm93c2VyID0gdHlwZW9mIHByb2Nlc3MgIT09ICdvYmplY3QnIHx8IFN0cmluZyhwcm9jZXNzKSAhPT0gJ1tvYmplY3QgcHJvY2Vzc10nIHx8IHByb2Nlc3MuYnJvd3NlcjtcbmV4cG9ydCBjb25zdCBpc1dvcmtlciA9IHR5cGVvZiBpbXBvcnRTY3JpcHRzID09PSAnZnVuY3Rpb24nO1xuZXhwb3J0IGNvbnN0IGlzTW9iaWxlID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIHdpbmRvdy5vcmllbnRhdGlvbiAhPT0gJ3VuZGVmaW5lZCc7XG5jb25zdCBtYXRjaGVzID0gdHlwZW9mIHByb2Nlc3MgIT09ICd1bmRlZmluZWQnICYmIHByb2Nlc3MudmVyc2lvbiAmJiAvdihbMC05XSopLy5leGVjKHByb2Nlc3MudmVyc2lvbik7XG5leHBvcnQgY29uc3Qgbm9kZVZlcnNpb24gPSBtYXRjaGVzICYmIHBhcnNlRmxvYXQobWF0Y2hlc1sxXSkgfHwgMDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWdsb2JhbHMuanMubWFwIiwiZXhwb3J0IGNvbnN0IE5QTV9UQUcgPSAnbGF0ZXN0JztcbmZ1bmN0aW9uIGdldFZlcnNpb24oKSB7XG4gIHZhciBfZ2xvYmFsVGhpcyRfbG9hZGVyc2c7XG4gIGlmICghKChfZ2xvYmFsVGhpcyRfbG9hZGVyc2cgPSBnbG9iYWxUaGlzLl9sb2FkZXJzZ2xfKSAhPT0gbnVsbCAmJiBfZ2xvYmFsVGhpcyRfbG9hZGVyc2cgIT09IHZvaWQgMCAmJiBfZ2xvYmFsVGhpcyRfbG9hZGVyc2cudmVyc2lvbikpIHtcbiAgICBnbG9iYWxUaGlzLl9sb2FkZXJzZ2xfID0gZ2xvYmFsVGhpcy5fbG9hZGVyc2dsXyB8fCB7fTtcbiAgICBpZiAodHlwZW9mIFwiNC4xLjNcIiA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGNvbnNvbGUud2FybignbG9hZGVycy5nbDogVGhlIF9fVkVSU0lPTl9fIHZhcmlhYmxlIGlzIG5vdCBpbmplY3RlZCB1c2luZyBiYWJlbCBwbHVnaW4uIExhdGVzdCB1bnN0YWJsZSB3b3JrZXJzIHdvdWxkIGJlIGZldGNoZWQgZnJvbSB0aGUgQ0ROLicpO1xuICAgICAgZ2xvYmFsVGhpcy5fbG9hZGVyc2dsXy52ZXJzaW9uID0gTlBNX1RBRztcbiAgICB9IGVsc2Uge1xuICAgICAgZ2xvYmFsVGhpcy5fbG9hZGVyc2dsXy52ZXJzaW9uID0gXCI0LjEuM1wiO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZ2xvYmFsVGhpcy5fbG9hZGVyc2dsXy52ZXJzaW9uO1xufVxuZXhwb3J0IGNvbnN0IFZFUlNJT04gPSBnZXRWZXJzaW9uKCk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD12ZXJzaW9uLmpzLm1hcCIsImV4cG9ydCBjbGFzcyBOb2RlV29ya2VyIHtcbiAgdGVybWluYXRlKCkge31cbn1cbmV4cG9ydCBjb25zdCBwYXJlbnRQb3J0ID0gbnVsbDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXdvcmtlcl90aHJlYWRzLWJyb3dzZXIuanMubWFwIiwiaW1wb3J0IHsgYXNzZXJ0IH0gZnJvbSBcIi4uL2Vudi11dGlscy9hc3NlcnQuanNcIjtcbmltcG9ydCB7IGlzQnJvd3NlciB9IGZyb20gXCIuLi9lbnYtdXRpbHMvZ2xvYmFscy5qc1wiO1xuaW1wb3J0IHsgVkVSU0lPTiwgTlBNX1RBRyB9IGZyb20gXCIuLi9lbnYtdXRpbHMvdmVyc2lvbi5qc1wiO1xuZXhwb3J0IGZ1bmN0aW9uIGdldFdvcmtlck5hbWUod29ya2VyKSB7XG4gIGNvbnN0IHdhcm5pbmcgPSB3b3JrZXIudmVyc2lvbiAhPT0gVkVSU0lPTiA/IGAgKHdvcmtlci11dGlsc0Ake1ZFUlNJT059KWAgOiAnJztcbiAgcmV0dXJuIGAke3dvcmtlci5uYW1lfUAke3dvcmtlci52ZXJzaW9ufSR7d2FybmluZ31gO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGdldFdvcmtlclVSTCh3b3JrZXIpIHtcbiAgbGV0IG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICBjb25zdCB3b3JrZXJPcHRpb25zID0gb3B0aW9uc1t3b3JrZXIuaWRdIHx8IHt9O1xuICBjb25zdCB3b3JrZXJGaWxlID0gaXNCcm93c2VyID8gYCR7d29ya2VyLmlkfS13b3JrZXIuanNgIDogYCR7d29ya2VyLmlkfS13b3JrZXItbm9kZS5qc2A7XG4gIGxldCB1cmwgPSB3b3JrZXJPcHRpb25zLndvcmtlclVybDtcbiAgaWYgKCF1cmwgJiYgd29ya2VyLmlkID09PSAnY29tcHJlc3Npb24nKSB7XG4gICAgdXJsID0gb3B0aW9ucy53b3JrZXJVcmw7XG4gIH1cbiAgaWYgKG9wdGlvbnMuX3dvcmtlclR5cGUgPT09ICd0ZXN0Jykge1xuICAgIGlmIChpc0Jyb3dzZXIpIHtcbiAgICAgIHVybCA9IGBtb2R1bGVzLyR7d29ya2VyLm1vZHVsZX0vZGlzdC8ke3dvcmtlckZpbGV9YDtcbiAgICB9IGVsc2Uge1xuICAgICAgdXJsID0gYG1vZHVsZXMvJHt3b3JrZXIubW9kdWxlfS9zcmMvd29ya2Vycy8ke3dvcmtlci5pZH0td29ya2VyLW5vZGUudHNgO1xuICAgIH1cbiAgfVxuICBpZiAoIXVybCkge1xuICAgIGxldCB2ZXJzaW9uID0gd29ya2VyLnZlcnNpb247XG4gICAgaWYgKHZlcnNpb24gPT09ICdsYXRlc3QnKSB7XG4gICAgICB2ZXJzaW9uID0gTlBNX1RBRztcbiAgICB9XG4gICAgY29uc3QgdmVyc2lvblRhZyA9IHZlcnNpb24gPyBgQCR7dmVyc2lvbn1gIDogJyc7XG4gICAgdXJsID0gYGh0dHBzOi8vdW5wa2cuY29tL0Bsb2FkZXJzLmdsLyR7d29ya2VyLm1vZHVsZX0ke3ZlcnNpb25UYWd9L2Rpc3QvJHt3b3JrZXJGaWxlfWA7XG4gIH1cbiAgYXNzZXJ0KHVybCk7XG4gIHJldHVybiB1cmw7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1nZXQtd29ya2VyLXVybC5qcy5tYXAiLCJpbXBvcnQgeyBhc3NlcnQgfSBmcm9tIFwiLi4vZW52LXV0aWxzL2Fzc2VydC5qc1wiO1xuaW1wb3J0IHsgVkVSU0lPTiB9IGZyb20gXCIuLi9lbnYtdXRpbHMvdmVyc2lvbi5qc1wiO1xuZXhwb3J0IGZ1bmN0aW9uIHZhbGlkYXRlV29ya2VyVmVyc2lvbih3b3JrZXIpIHtcbiAgbGV0IGNvcmVWZXJzaW9uID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBWRVJTSU9OO1xuICBhc3NlcnQod29ya2VyLCAnbm8gd29ya2VyIHByb3ZpZGVkJyk7XG4gIGNvbnN0IHdvcmtlclZlcnNpb24gPSB3b3JrZXIudmVyc2lvbjtcbiAgaWYgKCFjb3JlVmVyc2lvbiB8fCAhd29ya2VyVmVyc2lvbikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cbmZ1bmN0aW9uIHBhcnNlVmVyc2lvbih2ZXJzaW9uKSB7XG4gIGNvbnN0IHBhcnRzID0gdmVyc2lvbi5zcGxpdCgnLicpLm1hcChOdW1iZXIpO1xuICByZXR1cm4ge1xuICAgIG1ham9yOiBwYXJ0c1swXSxcbiAgICBtaW5vcjogcGFydHNbMV1cbiAgfTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXZhbGlkYXRlLXdvcmtlci12ZXJzaW9uLmpzLm1hcCIsImltcG9ydCBXb3JrZXJQb29sIGZyb20gXCIuL3dvcmtlci1wb29sLmpzXCI7XG5pbXBvcnQgV29ya2VyVGhyZWFkIGZyb20gXCIuL3dvcmtlci10aHJlYWQuanNcIjtcbmNvbnN0IERFRkFVTFRfUFJPUFMgPSB7XG4gIG1heENvbmN1cnJlbmN5OiAzLFxuICBtYXhNb2JpbGVDb25jdXJyZW5jeTogMSxcbiAgcmV1c2VXb3JrZXJzOiB0cnVlLFxuICBvbkRlYnVnOiAoKSA9PiB7fVxufTtcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFdvcmtlckZhcm0ge1xuICBzdGF0aWMgaXNTdXBwb3J0ZWQoKSB7XG4gICAgcmV0dXJuIFdvcmtlclRocmVhZC5pc1N1cHBvcnRlZCgpO1xuICB9XG4gIHN0YXRpYyBnZXRXb3JrZXJGYXJtKCkge1xuICAgIGxldCBwcm9wcyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG4gICAgV29ya2VyRmFybS5fd29ya2VyRmFybSA9IFdvcmtlckZhcm0uX3dvcmtlckZhcm0gfHwgbmV3IFdvcmtlckZhcm0oe30pO1xuICAgIFdvcmtlckZhcm0uX3dvcmtlckZhcm0uc2V0UHJvcHMocHJvcHMpO1xuICAgIHJldHVybiBXb3JrZXJGYXJtLl93b3JrZXJGYXJtO1xuICB9XG4gIGNvbnN0cnVjdG9yKHByb3BzKSB7XG4gICAgdGhpcy5wcm9wcyA9IHZvaWQgMDtcbiAgICB0aGlzLndvcmtlclBvb2xzID0gbmV3IE1hcCgpO1xuICAgIHRoaXMucHJvcHMgPSB7XG4gICAgICAuLi5ERUZBVUxUX1BST1BTXG4gICAgfTtcbiAgICB0aGlzLnNldFByb3BzKHByb3BzKTtcbiAgICB0aGlzLndvcmtlclBvb2xzID0gbmV3IE1hcCgpO1xuICB9XG4gIGRlc3Ryb3koKSB7XG4gICAgZm9yIChjb25zdCB3b3JrZXJQb29sIG9mIHRoaXMud29ya2VyUG9vbHMudmFsdWVzKCkpIHtcbiAgICAgIHdvcmtlclBvb2wuZGVzdHJveSgpO1xuICAgIH1cbiAgICB0aGlzLndvcmtlclBvb2xzID0gbmV3IE1hcCgpO1xuICB9XG4gIHNldFByb3BzKHByb3BzKSB7XG4gICAgdGhpcy5wcm9wcyA9IHtcbiAgICAgIC4uLnRoaXMucHJvcHMsXG4gICAgICAuLi5wcm9wc1xuICAgIH07XG4gICAgZm9yIChjb25zdCB3b3JrZXJQb29sIG9mIHRoaXMud29ya2VyUG9vbHMudmFsdWVzKCkpIHtcbiAgICAgIHdvcmtlclBvb2wuc2V0UHJvcHModGhpcy5fZ2V0V29ya2VyUG9vbFByb3BzKCkpO1xuICAgIH1cbiAgfVxuICBnZXRXb3JrZXJQb29sKG9wdGlvbnMpIHtcbiAgICBjb25zdCB7XG4gICAgICBuYW1lLFxuICAgICAgc291cmNlLFxuICAgICAgdXJsXG4gICAgfSA9IG9wdGlvbnM7XG4gICAgbGV0IHdvcmtlclBvb2wgPSB0aGlzLndvcmtlclBvb2xzLmdldChuYW1lKTtcbiAgICBpZiAoIXdvcmtlclBvb2wpIHtcbiAgICAgIHdvcmtlclBvb2wgPSBuZXcgV29ya2VyUG9vbCh7XG4gICAgICAgIG5hbWUsXG4gICAgICAgIHNvdXJjZSxcbiAgICAgICAgdXJsXG4gICAgICB9KTtcbiAgICAgIHdvcmtlclBvb2wuc2V0UHJvcHModGhpcy5fZ2V0V29ya2VyUG9vbFByb3BzKCkpO1xuICAgICAgdGhpcy53b3JrZXJQb29scy5zZXQobmFtZSwgd29ya2VyUG9vbCk7XG4gICAgfVxuICAgIHJldHVybiB3b3JrZXJQb29sO1xuICB9XG4gIF9nZXRXb3JrZXJQb29sUHJvcHMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIG1heENvbmN1cnJlbmN5OiB0aGlzLnByb3BzLm1heENvbmN1cnJlbmN5LFxuICAgICAgbWF4TW9iaWxlQ29uY3VycmVuY3k6IHRoaXMucHJvcHMubWF4TW9iaWxlQ29uY3VycmVuY3ksXG4gICAgICByZXVzZVdvcmtlcnM6IHRoaXMucHJvcHMucmV1c2VXb3JrZXJzLFxuICAgICAgb25EZWJ1ZzogdGhpcy5wcm9wcy5vbkRlYnVnXG4gICAgfTtcbiAgfVxufVxuV29ya2VyRmFybS5fd29ya2VyRmFybSA9IHZvaWQgMDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXdvcmtlci1mYXJtLmpzLm1hcCIsImltcG9ydCB7IGFzc2VydCB9IGZyb20gXCIuLi9lbnYtdXRpbHMvYXNzZXJ0LmpzXCI7XG5leHBvcnQgZGVmYXVsdCBjbGFzcyBXb3JrZXJKb2Ige1xuICBjb25zdHJ1Y3Rvcihqb2JOYW1lLCB3b3JrZXJUaHJlYWQpIHtcbiAgICB0aGlzLm5hbWUgPSB2b2lkIDA7XG4gICAgdGhpcy53b3JrZXJUaHJlYWQgPSB2b2lkIDA7XG4gICAgdGhpcy5pc1J1bm5pbmcgPSB0cnVlO1xuICAgIHRoaXMucmVzdWx0ID0gdm9pZCAwO1xuICAgIHRoaXMuX3Jlc29sdmUgPSAoKSA9PiB7fTtcbiAgICB0aGlzLl9yZWplY3QgPSAoKSA9PiB7fTtcbiAgICB0aGlzLm5hbWUgPSBqb2JOYW1lO1xuICAgIHRoaXMud29ya2VyVGhyZWFkID0gd29ya2VyVGhyZWFkO1xuICAgIHRoaXMucmVzdWx0ID0gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgdGhpcy5fcmVzb2x2ZSA9IHJlc29sdmU7XG4gICAgICB0aGlzLl9yZWplY3QgPSByZWplY3Q7XG4gICAgfSk7XG4gIH1cbiAgcG9zdE1lc3NhZ2UodHlwZSwgcGF5bG9hZCkge1xuICAgIHRoaXMud29ya2VyVGhyZWFkLnBvc3RNZXNzYWdlKHtcbiAgICAgIHNvdXJjZTogJ2xvYWRlcnMuZ2wnLFxuICAgICAgdHlwZSxcbiAgICAgIHBheWxvYWRcbiAgICB9KTtcbiAgfVxuICBkb25lKHZhbHVlKSB7XG4gICAgYXNzZXJ0KHRoaXMuaXNSdW5uaW5nKTtcbiAgICB0aGlzLmlzUnVubmluZyA9IGZhbHNlO1xuICAgIHRoaXMuX3Jlc29sdmUodmFsdWUpO1xuICB9XG4gIGVycm9yKGVycm9yKSB7XG4gICAgYXNzZXJ0KHRoaXMuaXNSdW5uaW5nKTtcbiAgICB0aGlzLmlzUnVubmluZyA9IGZhbHNlO1xuICAgIHRoaXMuX3JlamVjdChlcnJvcik7XG4gIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXdvcmtlci1qb2IuanMubWFwIiwiaW1wb3J0IHsgaXNNb2JpbGUsIGlzQnJvd3NlciB9IGZyb20gXCIuLi9lbnYtdXRpbHMvZ2xvYmFscy5qc1wiO1xuaW1wb3J0IFdvcmtlclRocmVhZCBmcm9tIFwiLi93b3JrZXItdGhyZWFkLmpzXCI7XG5pbXBvcnQgV29ya2VySm9iIGZyb20gXCIuL3dvcmtlci1qb2IuanNcIjtcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFdvcmtlclBvb2wge1xuICBzdGF0aWMgaXNTdXBwb3J0ZWQoKSB7XG4gICAgcmV0dXJuIFdvcmtlclRocmVhZC5pc1N1cHBvcnRlZCgpO1xuICB9XG4gIGNvbnN0cnVjdG9yKHByb3BzKSB7XG4gICAgdGhpcy5uYW1lID0gJ3VubmFtZWQnO1xuICAgIHRoaXMuc291cmNlID0gdm9pZCAwO1xuICAgIHRoaXMudXJsID0gdm9pZCAwO1xuICAgIHRoaXMubWF4Q29uY3VycmVuY3kgPSAxO1xuICAgIHRoaXMubWF4TW9iaWxlQ29uY3VycmVuY3kgPSAxO1xuICAgIHRoaXMub25EZWJ1ZyA9ICgpID0+IHt9O1xuICAgIHRoaXMucmV1c2VXb3JrZXJzID0gdHJ1ZTtcbiAgICB0aGlzLnByb3BzID0ge307XG4gICAgdGhpcy5qb2JRdWV1ZSA9IFtdO1xuICAgIHRoaXMuaWRsZVF1ZXVlID0gW107XG4gICAgdGhpcy5jb3VudCA9IDA7XG4gICAgdGhpcy5pc0Rlc3Ryb3llZCA9IGZhbHNlO1xuICAgIHRoaXMuc291cmNlID0gcHJvcHMuc291cmNlO1xuICAgIHRoaXMudXJsID0gcHJvcHMudXJsO1xuICAgIHRoaXMuc2V0UHJvcHMocHJvcHMpO1xuICB9XG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy5pZGxlUXVldWUuZm9yRWFjaCh3b3JrZXIgPT4gd29ya2VyLmRlc3Ryb3koKSk7XG4gICAgdGhpcy5pc0Rlc3Ryb3llZCA9IHRydWU7XG4gIH1cbiAgc2V0UHJvcHMocHJvcHMpIHtcbiAgICB0aGlzLnByb3BzID0ge1xuICAgICAgLi4udGhpcy5wcm9wcyxcbiAgICAgIC4uLnByb3BzXG4gICAgfTtcbiAgICBpZiAocHJvcHMubmFtZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aGlzLm5hbWUgPSBwcm9wcy5uYW1lO1xuICAgIH1cbiAgICBpZiAocHJvcHMubWF4Q29uY3VycmVuY3kgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcy5tYXhDb25jdXJyZW5jeSA9IHByb3BzLm1heENvbmN1cnJlbmN5O1xuICAgIH1cbiAgICBpZiAocHJvcHMubWF4TW9iaWxlQ29uY3VycmVuY3kgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcy5tYXhNb2JpbGVDb25jdXJyZW5jeSA9IHByb3BzLm1heE1vYmlsZUNvbmN1cnJlbmN5O1xuICAgIH1cbiAgICBpZiAocHJvcHMucmV1c2VXb3JrZXJzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHRoaXMucmV1c2VXb3JrZXJzID0gcHJvcHMucmV1c2VXb3JrZXJzO1xuICAgIH1cbiAgICBpZiAocHJvcHMub25EZWJ1ZyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aGlzLm9uRGVidWcgPSBwcm9wcy5vbkRlYnVnO1xuICAgIH1cbiAgfVxuICBhc3luYyBzdGFydEpvYihuYW1lKSB7XG4gICAgbGV0IG9uTWVzc2FnZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogKGpvYiwgdHlwZSwgZGF0YSkgPT4gam9iLmRvbmUoZGF0YSk7XG4gICAgbGV0IG9uRXJyb3IgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IChqb2IsIGVycm9yKSA9PiBqb2IuZXJyb3IoZXJyb3IpO1xuICAgIGNvbnN0IHN0YXJ0UHJvbWlzZSA9IG5ldyBQcm9taXNlKG9uU3RhcnQgPT4ge1xuICAgICAgdGhpcy5qb2JRdWV1ZS5wdXNoKHtcbiAgICAgICAgbmFtZSxcbiAgICAgICAgb25NZXNzYWdlLFxuICAgICAgICBvbkVycm9yLFxuICAgICAgICBvblN0YXJ0XG4gICAgICB9KTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0pO1xuICAgIHRoaXMuX3N0YXJ0UXVldWVkSm9iKCk7XG4gICAgcmV0dXJuIGF3YWl0IHN0YXJ0UHJvbWlzZTtcbiAgfVxuICBhc3luYyBfc3RhcnRRdWV1ZWRKb2IoKSB7XG4gICAgaWYgKCF0aGlzLmpvYlF1ZXVlLmxlbmd0aCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB3b3JrZXJUaHJlYWQgPSB0aGlzLl9nZXRBdmFpbGFibGVXb3JrZXIoKTtcbiAgICBpZiAoIXdvcmtlclRocmVhZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBxdWV1ZWRKb2IgPSB0aGlzLmpvYlF1ZXVlLnNoaWZ0KCk7XG4gICAgaWYgKHF1ZXVlZEpvYikge1xuICAgICAgdGhpcy5vbkRlYnVnKHtcbiAgICAgICAgbWVzc2FnZTogJ1N0YXJ0aW5nIGpvYicsXG4gICAgICAgIG5hbWU6IHF1ZXVlZEpvYi5uYW1lLFxuICAgICAgICB3b3JrZXJUaHJlYWQsXG4gICAgICAgIGJhY2tsb2c6IHRoaXMuam9iUXVldWUubGVuZ3RoXG4gICAgICB9KTtcbiAgICAgIGNvbnN0IGpvYiA9IG5ldyBXb3JrZXJKb2IocXVldWVkSm9iLm5hbWUsIHdvcmtlclRocmVhZCk7XG4gICAgICB3b3JrZXJUaHJlYWQub25NZXNzYWdlID0gZGF0YSA9PiBxdWV1ZWRKb2Iub25NZXNzYWdlKGpvYiwgZGF0YS50eXBlLCBkYXRhLnBheWxvYWQpO1xuICAgICAgd29ya2VyVGhyZWFkLm9uRXJyb3IgPSBlcnJvciA9PiBxdWV1ZWRKb2Iub25FcnJvcihqb2IsIGVycm9yKTtcbiAgICAgIHF1ZXVlZEpvYi5vblN0YXJ0KGpvYik7XG4gICAgICB0cnkge1xuICAgICAgICBhd2FpdCBqb2IucmVzdWx0O1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihgV29ya2VyIGV4Y2VwdGlvbjogJHtlcnJvcn1gKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIHRoaXMucmV0dXJuV29ya2VyVG9RdWV1ZSh3b3JrZXJUaHJlYWQpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm5Xb3JrZXJUb1F1ZXVlKHdvcmtlcikge1xuICAgIGNvbnN0IHNob3VsZERlc3Ryb3lXb3JrZXIgPSAhaXNCcm93c2VyIHx8IHRoaXMuaXNEZXN0cm95ZWQgfHwgIXRoaXMucmV1c2VXb3JrZXJzIHx8IHRoaXMuY291bnQgPiB0aGlzLl9nZXRNYXhDb25jdXJyZW5jeSgpO1xuICAgIGlmIChzaG91bGREZXN0cm95V29ya2VyKSB7XG4gICAgICB3b3JrZXIuZGVzdHJveSgpO1xuICAgICAgdGhpcy5jb3VudC0tO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmlkbGVRdWV1ZS5wdXNoKHdvcmtlcik7XG4gICAgfVxuICAgIGlmICghdGhpcy5pc0Rlc3Ryb3llZCkge1xuICAgICAgdGhpcy5fc3RhcnRRdWV1ZWRKb2IoKTtcbiAgICB9XG4gIH1cbiAgX2dldEF2YWlsYWJsZVdvcmtlcigpIHtcbiAgICBpZiAodGhpcy5pZGxlUXVldWUubGVuZ3RoID4gMCkge1xuICAgICAgcmV0dXJuIHRoaXMuaWRsZVF1ZXVlLnNoaWZ0KCkgfHwgbnVsbDtcbiAgICB9XG4gICAgaWYgKHRoaXMuY291bnQgPCB0aGlzLl9nZXRNYXhDb25jdXJyZW5jeSgpKSB7XG4gICAgICB0aGlzLmNvdW50Kys7XG4gICAgICBjb25zdCBuYW1lID0gYCR7dGhpcy5uYW1lLnRvTG93ZXJDYXNlKCl9ICgjJHt0aGlzLmNvdW50fSBvZiAke3RoaXMubWF4Q29uY3VycmVuY3l9KWA7XG4gICAgICByZXR1cm4gbmV3IFdvcmtlclRocmVhZCh7XG4gICAgICAgIG5hbWUsXG4gICAgICAgIHNvdXJjZTogdGhpcy5zb3VyY2UsXG4gICAgICAgIHVybDogdGhpcy51cmxcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBfZ2V0TWF4Q29uY3VycmVuY3koKSB7XG4gICAgcmV0dXJuIGlzTW9iaWxlID8gdGhpcy5tYXhNb2JpbGVDb25jdXJyZW5jeSA6IHRoaXMubWF4Q29uY3VycmVuY3k7XG4gIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXdvcmtlci1wb29sLmpzLm1hcCIsImltcG9ydCB7IE5vZGVXb3JrZXIgfSBmcm9tIFwiLi4vbm9kZS93b3JrZXJfdGhyZWFkcy5qc1wiO1xuaW1wb3J0IHsgaXNCcm93c2VyIH0gZnJvbSBcIi4uL2Vudi11dGlscy9nbG9iYWxzLmpzXCI7XG5pbXBvcnQgeyBhc3NlcnQgfSBmcm9tIFwiLi4vZW52LXV0aWxzL2Fzc2VydC5qc1wiO1xuaW1wb3J0IHsgZ2V0TG9hZGFibGVXb3JrZXJVUkwgfSBmcm9tIFwiLi4vd29ya2VyLXV0aWxzL2dldC1sb2FkYWJsZS13b3JrZXItdXJsLmpzXCI7XG5pbXBvcnQgeyBnZXRUcmFuc2Zlckxpc3QgfSBmcm9tIFwiLi4vd29ya2VyLXV0aWxzL2dldC10cmFuc2Zlci1saXN0LmpzXCI7XG5jb25zdCBOT09QID0gKCkgPT4ge307XG5leHBvcnQgZGVmYXVsdCBjbGFzcyBXb3JrZXJUaHJlYWQge1xuICBzdGF0aWMgaXNTdXBwb3J0ZWQoKSB7XG4gICAgcmV0dXJuIHR5cGVvZiBXb3JrZXIgIT09ICd1bmRlZmluZWQnICYmIGlzQnJvd3NlciB8fCB0eXBlb2YgTm9kZVdvcmtlciAhPT0gJ3VuZGVmaW5lZCcgJiYgIWlzQnJvd3NlcjtcbiAgfVxuICBjb25zdHJ1Y3Rvcihwcm9wcykge1xuICAgIHRoaXMubmFtZSA9IHZvaWQgMDtcbiAgICB0aGlzLnNvdXJjZSA9IHZvaWQgMDtcbiAgICB0aGlzLnVybCA9IHZvaWQgMDtcbiAgICB0aGlzLnRlcm1pbmF0ZWQgPSBmYWxzZTtcbiAgICB0aGlzLndvcmtlciA9IHZvaWQgMDtcbiAgICB0aGlzLm9uTWVzc2FnZSA9IHZvaWQgMDtcbiAgICB0aGlzLm9uRXJyb3IgPSB2b2lkIDA7XG4gICAgdGhpcy5fbG9hZGFibGVVUkwgPSAnJztcbiAgICBjb25zdCB7XG4gICAgICBuYW1lLFxuICAgICAgc291cmNlLFxuICAgICAgdXJsXG4gICAgfSA9IHByb3BzO1xuICAgIGFzc2VydChzb3VyY2UgfHwgdXJsKTtcbiAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgIHRoaXMuc291cmNlID0gc291cmNlO1xuICAgIHRoaXMudXJsID0gdXJsO1xuICAgIHRoaXMub25NZXNzYWdlID0gTk9PUDtcbiAgICB0aGlzLm9uRXJyb3IgPSBlcnJvciA9PiBjb25zb2xlLmxvZyhlcnJvcik7XG4gICAgdGhpcy53b3JrZXIgPSBpc0Jyb3dzZXIgPyB0aGlzLl9jcmVhdGVCcm93c2VyV29ya2VyKCkgOiB0aGlzLl9jcmVhdGVOb2RlV29ya2VyKCk7XG4gIH1cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLm9uTWVzc2FnZSA9IE5PT1A7XG4gICAgdGhpcy5vbkVycm9yID0gTk9PUDtcbiAgICB0aGlzLndvcmtlci50ZXJtaW5hdGUoKTtcbiAgICB0aGlzLnRlcm1pbmF0ZWQgPSB0cnVlO1xuICB9XG4gIGdldCBpc1J1bm5pbmcoKSB7XG4gICAgcmV0dXJuIEJvb2xlYW4odGhpcy5vbk1lc3NhZ2UpO1xuICB9XG4gIHBvc3RNZXNzYWdlKGRhdGEsIHRyYW5zZmVyTGlzdCkge1xuICAgIHRyYW5zZmVyTGlzdCA9IHRyYW5zZmVyTGlzdCB8fCBnZXRUcmFuc2Zlckxpc3QoZGF0YSk7XG4gICAgdGhpcy53b3JrZXIucG9zdE1lc3NhZ2UoZGF0YSwgdHJhbnNmZXJMaXN0KTtcbiAgfVxuICBfZ2V0RXJyb3JGcm9tRXJyb3JFdmVudChldmVudCkge1xuICAgIGxldCBtZXNzYWdlID0gJ0ZhaWxlZCB0byBsb2FkICc7XG4gICAgbWVzc2FnZSArPSBgd29ya2VyICR7dGhpcy5uYW1lfSBmcm9tICR7dGhpcy51cmx9LiBgO1xuICAgIGlmIChldmVudC5tZXNzYWdlKSB7XG4gICAgICBtZXNzYWdlICs9IGAke2V2ZW50Lm1lc3NhZ2V9IGluIGA7XG4gICAgfVxuICAgIGlmIChldmVudC5saW5lbm8pIHtcbiAgICAgIG1lc3NhZ2UgKz0gYDoke2V2ZW50LmxpbmVub306JHtldmVudC5jb2xub31gO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IEVycm9yKG1lc3NhZ2UpO1xuICB9XG4gIF9jcmVhdGVCcm93c2VyV29ya2VyKCkge1xuICAgIHRoaXMuX2xvYWRhYmxlVVJMID0gZ2V0TG9hZGFibGVXb3JrZXJVUkwoe1xuICAgICAgc291cmNlOiB0aGlzLnNvdXJjZSxcbiAgICAgIHVybDogdGhpcy51cmxcbiAgICB9KTtcbiAgICBjb25zdCB3b3JrZXIgPSBuZXcgV29ya2VyKHRoaXMuX2xvYWRhYmxlVVJMLCB7XG4gICAgICBuYW1lOiB0aGlzLm5hbWVcbiAgICB9KTtcbiAgICB3b3JrZXIub25tZXNzYWdlID0gZXZlbnQgPT4ge1xuICAgICAgaWYgKCFldmVudC5kYXRhKSB7XG4gICAgICAgIHRoaXMub25FcnJvcihuZXcgRXJyb3IoJ05vIGRhdGEgcmVjZWl2ZWQnKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLm9uTWVzc2FnZShldmVudC5kYXRhKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHdvcmtlci5vbmVycm9yID0gZXJyb3IgPT4ge1xuICAgICAgdGhpcy5vbkVycm9yKHRoaXMuX2dldEVycm9yRnJvbUVycm9yRXZlbnQoZXJyb3IpKTtcbiAgICAgIHRoaXMudGVybWluYXRlZCA9IHRydWU7XG4gICAgfTtcbiAgICB3b3JrZXIub25tZXNzYWdlZXJyb3IgPSBldmVudCA9PiBjb25zb2xlLmVycm9yKGV2ZW50KTtcbiAgICByZXR1cm4gd29ya2VyO1xuICB9XG4gIF9jcmVhdGVOb2RlV29ya2VyKCkge1xuICAgIGxldCB3b3JrZXI7XG4gICAgaWYgKHRoaXMudXJsKSB7XG4gICAgICBjb25zdCBhYnNvbHV0ZSA9IHRoaXMudXJsLmluY2x1ZGVzKCc6LycpIHx8IHRoaXMudXJsLnN0YXJ0c1dpdGgoJy8nKTtcbiAgICAgIGNvbnN0IHVybCA9IGFic29sdXRlID8gdGhpcy51cmwgOiBgLi8ke3RoaXMudXJsfWA7XG4gICAgICB3b3JrZXIgPSBuZXcgTm9kZVdvcmtlcih1cmwsIHtcbiAgICAgICAgZXZhbDogZmFsc2VcbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAodGhpcy5zb3VyY2UpIHtcbiAgICAgIHdvcmtlciA9IG5ldyBOb2RlV29ya2VyKHRoaXMuc291cmNlLCB7XG4gICAgICAgIGV2YWw6IHRydWVcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ25vIHdvcmtlcicpO1xuICAgIH1cbiAgICB3b3JrZXIub24oJ21lc3NhZ2UnLCBkYXRhID0+IHtcbiAgICAgIHRoaXMub25NZXNzYWdlKGRhdGEpO1xuICAgIH0pO1xuICAgIHdvcmtlci5vbignZXJyb3InLCBlcnJvciA9PiB7XG4gICAgICB0aGlzLm9uRXJyb3IoZXJyb3IpO1xuICAgIH0pO1xuICAgIHdvcmtlci5vbignZXhpdCcsIGNvZGUgPT4ge30pO1xuICAgIHJldHVybiB3b3JrZXI7XG4gIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXdvcmtlci10aHJlYWQuanMubWFwIiwiaW1wb3J0IHsgYXNzZXJ0IH0gZnJvbSBcIi4uL2Vudi11dGlscy9hc3NlcnQuanNcIjtcbmNvbnN0IHdvcmtlclVSTENhY2hlID0gbmV3IE1hcCgpO1xuZXhwb3J0IGZ1bmN0aW9uIGdldExvYWRhYmxlV29ya2VyVVJMKHByb3BzKSB7XG4gIGFzc2VydChwcm9wcy5zb3VyY2UgJiYgIXByb3BzLnVybCB8fCAhcHJvcHMuc291cmNlICYmIHByb3BzLnVybCk7XG4gIGxldCB3b3JrZXJVUkwgPSB3b3JrZXJVUkxDYWNoZS5nZXQocHJvcHMuc291cmNlIHx8IHByb3BzLnVybCk7XG4gIGlmICghd29ya2VyVVJMKSB7XG4gICAgaWYgKHByb3BzLnVybCkge1xuICAgICAgd29ya2VyVVJMID0gZ2V0TG9hZGFibGVXb3JrZXJVUkxGcm9tVVJMKHByb3BzLnVybCk7XG4gICAgICB3b3JrZXJVUkxDYWNoZS5zZXQocHJvcHMudXJsLCB3b3JrZXJVUkwpO1xuICAgIH1cbiAgICBpZiAocHJvcHMuc291cmNlKSB7XG4gICAgICB3b3JrZXJVUkwgPSBnZXRMb2FkYWJsZVdvcmtlclVSTEZyb21Tb3VyY2UocHJvcHMuc291cmNlKTtcbiAgICAgIHdvcmtlclVSTENhY2hlLnNldChwcm9wcy5zb3VyY2UsIHdvcmtlclVSTCk7XG4gICAgfVxuICB9XG4gIGFzc2VydCh3b3JrZXJVUkwpO1xuICByZXR1cm4gd29ya2VyVVJMO1xufVxuZnVuY3Rpb24gZ2V0TG9hZGFibGVXb3JrZXJVUkxGcm9tVVJMKHVybCkge1xuICBpZiAoIXVybC5zdGFydHNXaXRoKCdodHRwJykpIHtcbiAgICByZXR1cm4gdXJsO1xuICB9XG4gIGNvbnN0IHdvcmtlclNvdXJjZSA9IGJ1aWxkU2NyaXB0U291cmNlKHVybCk7XG4gIHJldHVybiBnZXRMb2FkYWJsZVdvcmtlclVSTEZyb21Tb3VyY2Uod29ya2VyU291cmNlKTtcbn1cbmZ1bmN0aW9uIGdldExvYWRhYmxlV29ya2VyVVJMRnJvbVNvdXJjZSh3b3JrZXJTb3VyY2UpIHtcbiAgY29uc3QgYmxvYiA9IG5ldyBCbG9iKFt3b3JrZXJTb3VyY2VdLCB7XG4gICAgdHlwZTogJ2FwcGxpY2F0aW9uL2phdmFzY3JpcHQnXG4gIH0pO1xuICByZXR1cm4gVVJMLmNyZWF0ZU9iamVjdFVSTChibG9iKTtcbn1cbmZ1bmN0aW9uIGJ1aWxkU2NyaXB0U291cmNlKHdvcmtlclVybCkge1xuICByZXR1cm4gYFxcXG50cnkge1xuICBpbXBvcnRTY3JpcHRzKCcke3dvcmtlclVybH0nKTtcbn0gY2F0Y2ggKGVycm9yKSB7XG4gIGNvbnNvbGUuZXJyb3IoZXJyb3IpO1xuICB0aHJvdyBlcnJvcjtcbn1gO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Z2V0LWxvYWRhYmxlLXdvcmtlci11cmwuanMubWFwIiwiZXhwb3J0IGZ1bmN0aW9uIGdldFRyYW5zZmVyTGlzdChvYmplY3QpIHtcbiAgbGV0IHJlY3Vyc2l2ZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogdHJ1ZTtcbiAgbGV0IHRyYW5zZmVycyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyID8gYXJndW1lbnRzWzJdIDogdW5kZWZpbmVkO1xuICBjb25zdCB0cmFuc2ZlcnNTZXQgPSB0cmFuc2ZlcnMgfHwgbmV3IFNldCgpO1xuICBpZiAoIW9iamVjdCkge30gZWxzZSBpZiAoaXNUcmFuc2ZlcmFibGUob2JqZWN0KSkge1xuICAgIHRyYW5zZmVyc1NldC5hZGQob2JqZWN0KTtcbiAgfSBlbHNlIGlmIChpc1RyYW5zZmVyYWJsZShvYmplY3QuYnVmZmVyKSkge1xuICAgIHRyYW5zZmVyc1NldC5hZGQob2JqZWN0LmJ1ZmZlcik7XG4gIH0gZWxzZSBpZiAoQXJyYXlCdWZmZXIuaXNWaWV3KG9iamVjdCkpIHt9IGVsc2UgaWYgKHJlY3Vyc2l2ZSAmJiB0eXBlb2Ygb2JqZWN0ID09PSAnb2JqZWN0Jykge1xuICAgIGZvciAoY29uc3Qga2V5IGluIG9iamVjdCkge1xuICAgICAgZ2V0VHJhbnNmZXJMaXN0KG9iamVjdFtrZXldLCByZWN1cnNpdmUsIHRyYW5zZmVyc1NldCk7XG4gICAgfVxuICB9XG4gIHJldHVybiB0cmFuc2ZlcnMgPT09IHVuZGVmaW5lZCA/IEFycmF5LmZyb20odHJhbnNmZXJzU2V0KSA6IFtdO1xufVxuZnVuY3Rpb24gaXNUcmFuc2ZlcmFibGUob2JqZWN0KSB7XG4gIGlmICghb2JqZWN0KSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmIChvYmplY3QgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGlmICh0eXBlb2YgTWVzc2FnZVBvcnQgIT09ICd1bmRlZmluZWQnICYmIG9iamVjdCBpbnN0YW5jZW9mIE1lc3NhZ2VQb3J0KSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgaWYgKHR5cGVvZiBJbWFnZUJpdG1hcCAhPT0gJ3VuZGVmaW5lZCcgJiYgb2JqZWN0IGluc3RhbmNlb2YgSW1hZ2VCaXRtYXApIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBpZiAodHlwZW9mIE9mZnNjcmVlbkNhbnZhcyAhPT0gJ3VuZGVmaW5lZCcgJiYgb2JqZWN0IGluc3RhbmNlb2YgT2Zmc2NyZWVuQ2FudmFzKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGdldFRyYW5zZmVyTGlzdEZvcldyaXRlcihvYmplY3QpIHtcbiAgaWYgKG9iamVjdCA9PT0gbnVsbCkge1xuICAgIHJldHVybiB7fTtcbiAgfVxuICBjb25zdCBjbG9uZSA9IE9iamVjdC5hc3NpZ24oe30sIG9iamVjdCk7XG4gIE9iamVjdC5rZXlzKGNsb25lKS5mb3JFYWNoKGtleSA9PiB7XG4gICAgaWYgKHR5cGVvZiBvYmplY3Rba2V5XSA9PT0gJ29iamVjdCcgJiYgIUFycmF5QnVmZmVyLmlzVmlldyhvYmplY3Rba2V5XSkgJiYgIShvYmplY3Rba2V5XSBpbnN0YW5jZW9mIEFycmF5KSkge1xuICAgICAgY2xvbmVba2V5XSA9IGdldFRyYW5zZmVyTGlzdEZvcldyaXRlcihvYmplY3Rba2V5XSk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgY2xvbmVba2V5XSA9PT0gJ2Z1bmN0aW9uJyB8fCBjbG9uZVtrZXldIGluc3RhbmNlb2YgUmVnRXhwKSB7XG4gICAgICBjbG9uZVtrZXldID0ge307XG4gICAgfSBlbHNlIHtcbiAgICAgIGNsb25lW2tleV0gPSBvYmplY3Rba2V5XTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gY2xvbmU7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1nZXQtdHJhbnNmZXItbGlzdC5qcy5tYXAiLCIvLyBFeHRyYWN0IGluamVjdGVkIHZlcnNpb24gZnJvbSBwYWNrYWdlLmpzb24gKGluamVjdGVkIGJ5IGJhYmVsIHBsdWdpbilcbi8vIEB0cy1leHBlY3QtZXJyb3JcbmV4cG9ydCBjb25zdCBWRVJTSU9OID0gdHlwZW9mIFwiNC4wLjdcIiAhPT0gJ3VuZGVmaW5lZCcgPyBcIjQuMC43XCIgOiAndW50cmFuc3BpbGVkIHNvdXJjZSc7XG4vLyBFTlZJUk9OTUVOVFxuZXhwb3J0IHsgc2VsZiwgd2luZG93LCBnbG9iYWwsIGRvY3VtZW50LCBwcm9jZXNzLCBjb25zb2xlIH0gZnJvbSBcIi4vbGliL2dsb2JhbHMuanNcIjtcbmV4cG9ydCB7IGlzQnJvd3NlciB9IGZyb20gXCIuL2xpYi9pcy1icm93c2VyLmpzXCI7XG5leHBvcnQgeyBnZXRCcm93c2VyLCBpc01vYmlsZSB9IGZyb20gXCIuL2xpYi9nZXQtYnJvd3Nlci5qc1wiO1xuZXhwb3J0IHsgaXNFbGVjdHJvbiB9IGZyb20gXCIuL2xpYi9pcy1lbGVjdHJvbi5qc1wiO1xuLy8gRU5WSVJPTk1FTlQnUyBBU1NFUlQgSVMgNS0xNUtCLCBTTyBXRSBQUk9WSURFIE9VUiBPV05cbmV4cG9ydCB7IGFzc2VydCB9IGZyb20gXCIuL3V0aWxzL2Fzc2VydC5qc1wiO1xuLy8gVE9ETyAtIHdpc2ggd2UgY291bGQganVzdCBleHBvcnQgYSBjb25zdGFudFxuLy8gZXhwb3J0IGNvbnN0IGlzQnJvd3NlciA9IGNoZWNrSWZCcm93c2VyKCk7XG4iLCIvLyBDb3B5cmlnaHQgKGMpIDIwMTcgVWJlciBUZWNobm9sb2dpZXMsIEluYy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4vLyBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4vLyBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4vLyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4vLyBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbi8vIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbi8vIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1Jcbi8vIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuLy8gRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4vLyBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4vLyBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuLy8gT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuLy8gVEhFIFNPRlRXQVJFLlxuLy8gVGhpcyBmdW5jdGlvbiBpcyBuZWVkZWQgaW4gaW5pdGlhbGl6YXRpb24gc3RhZ2VzLFxuLy8gbWFrZSBzdXJlIGl0IGNhbiBiZSBpbXBvcnRlZCBpbiBpc29sYXRpb25cbmltcG9ydCB7IGlzQnJvd3NlciB9IGZyb20gXCIuL2lzLWJyb3dzZXIuanNcIjtcbmltcG9ydCB7IGlzRWxlY3Ryb24gfSBmcm9tIFwiLi9pcy1lbGVjdHJvbi5qc1wiO1xuaW1wb3J0IHsgbmF2aWdhdG9yIH0gZnJvbSBcIi4vZ2xvYmFscy5qc1wiO1xuZXhwb3J0IGZ1bmN0aW9uIGlzTW9iaWxlKCkge1xuICAgIHJldHVybiB0eXBlb2YgZ2xvYmFsVGhpcy5vcmllbnRhdGlvbiAhPT0gJ3VuZGVmaW5lZCc7XG59XG4vLyBTaW1wbGUgYnJvd3NlciBkZXRlY3Rpb25cbi8vIGBtb2NrVXNlckFnZW50YCBwYXJhbWV0ZXIgYWxsb3dzIHVzZXIgYWdlbnQgdG8gYmUgb3ZlcnJpZGRlbiBmb3IgdGVzdGluZ1xuLyogZXNsaW50LWRpc2FibGUgY29tcGxleGl0eSAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldEJyb3dzZXIobW9ja1VzZXJBZ2VudCkge1xuICAgIGlmICghbW9ja1VzZXJBZ2VudCAmJiAhaXNCcm93c2VyKCkpIHtcbiAgICAgICAgcmV0dXJuICdOb2RlJztcbiAgICB9XG4gICAgaWYgKGlzRWxlY3Ryb24obW9ja1VzZXJBZ2VudCkpIHtcbiAgICAgICAgcmV0dXJuICdFbGVjdHJvbic7XG4gICAgfVxuICAgIGNvbnN0IHVzZXJBZ2VudCA9IG1vY2tVc2VyQWdlbnQgfHwgbmF2aWdhdG9yLnVzZXJBZ2VudCB8fCAnJztcbiAgICAvLyBOT1RFOiBPcmRlciBvZiB0ZXN0cyBtYXR0ZXIsIGFzIG1hbnkgYWdlbnRzIGxpc3QgQ2hyb21lIGV0Yy5cbiAgICBpZiAodXNlckFnZW50LmluZGV4T2YoJ0VkZ2UnKSA+IC0xKSB7XG4gICAgICAgIHJldHVybiAnRWRnZSc7XG4gICAgfVxuICAgIGlmIChnbG9iYWxUaGlzLmNocm9tZSkge1xuICAgICAgICByZXR1cm4gJ0Nocm9tZSc7XG4gICAgfVxuICAgIGlmIChnbG9iYWxUaGlzLnNhZmFyaSkge1xuICAgICAgICByZXR1cm4gJ1NhZmFyaSc7XG4gICAgfVxuICAgIGlmIChnbG9iYWxUaGlzLm1veklubmVyU2NyZWVuWCkge1xuICAgICAgICByZXR1cm4gJ0ZpcmVmb3gnO1xuICAgIH1cbiAgICByZXR1cm4gJ1Vua25vd24nO1xufVxuIiwiLy8gRG8gbm90IG5hbWUgdGhlc2UgdmFyaWFibGVzIHRoZSBzYW1lIGFzIHRoZSBnbG9iYWwgb2JqZWN0cyAtIHdpbGwgYnJlYWsgYnVuZGxpbmdcbmNvbnN0IGdsb2JhbF8gPSBnbG9iYWxUaGlzO1xuY29uc3Qgd2luZG93XyA9IGdsb2JhbFRoaXM7XG5jb25zdCBkb2N1bWVudF8gPSBnbG9iYWxUaGlzLmRvY3VtZW50IHx8IHt9O1xuY29uc3QgcHJvY2Vzc18gPSBnbG9iYWxUaGlzLnByb2Nlc3MgfHwge307XG5jb25zdCBjb25zb2xlXyA9IGdsb2JhbFRoaXMuY29uc29sZTtcbmNvbnN0IG5hdmlnYXRvcl8gPSBnbG9iYWxUaGlzLm5hdmlnYXRvciB8fCB7fTtcbmV4cG9ydCB7IGdsb2JhbF8gYXMgZ2xvYmFsLCBnbG9iYWxfIGFzIHNlbGYsIHdpbmRvd18gYXMgd2luZG93LCBkb2N1bWVudF8gYXMgZG9jdW1lbnQsIHByb2Nlc3NfIGFzIHByb2Nlc3MsIGNvbnNvbGVfIGFzIGNvbnNvbGUsIG5hdmlnYXRvcl8gYXMgbmF2aWdhdG9yIH07XG4iLCIvLyBUaGlzIGZ1bmN0aW9uIGlzIG5lZWRlZCBpbiBpbml0aWFsaXphdGlvbiBzdGFnZXMsXG4vLyBtYWtlIHN1cmUgaXQgY2FuIGJlIGltcG9ydGVkIGluIGlzb2xhdGlvblxuaW1wb3J0IHsgaXNFbGVjdHJvbiB9IGZyb20gXCIuL2lzLWVsZWN0cm9uLmpzXCI7XG4vKiogQ2hlY2sgaWYgaW4gYnJvd3NlciBieSBkdWNrLXR5cGluZyBOb2RlIGNvbnRleHQgKi9cbmV4cG9ydCBmdW5jdGlvbiBpc0Jyb3dzZXIoKSB7XG4gICAgY29uc3QgaXNOb2RlID0gXG4gICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgIHR5cGVvZiBwcm9jZXNzID09PSAnb2JqZWN0JyAmJiBTdHJpbmcocHJvY2VzcykgPT09ICdbb2JqZWN0IHByb2Nlc3NdJyAmJiAhcHJvY2Vzcz8uYnJvd3NlcjtcbiAgICByZXR1cm4gIWlzTm9kZSB8fCBpc0VsZWN0cm9uKCk7XG59XG4iLCIvLyBiYXNlZCBvbiBodHRwczovL2dpdGh1Yi5jb20vY2hldG9uL2lzLWVsZWN0cm9uXG4vLyBodHRwczovL2dpdGh1Yi5jb20vZWxlY3Ryb24vZWxlY3Ryb24vaXNzdWVzLzIyODhcbi8qIGVzbGludC1kaXNhYmxlIGNvbXBsZXhpdHkgKi9cbmV4cG9ydCBmdW5jdGlvbiBpc0VsZWN0cm9uKG1vY2tVc2VyQWdlbnQpIHtcbiAgICAvLyBSZW5kZXJlciBwcm9jZXNzXG4gICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cucHJvY2Vzcz8udHlwZSA9PT0gJ3JlbmRlcmVyJykge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgLy8gTWFpbiBwcm9jZXNzXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lXG4gICAgaWYgKHR5cGVvZiBwcm9jZXNzICE9PSAndW5kZWZpbmVkJyAmJiBCb29sZWFuKHByb2Nlc3MudmVyc2lvbnM/LlsnZWxlY3Ryb24nXSkpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIC8vIERldGVjdCB0aGUgdXNlciBhZ2VudCB3aGVuIHRoZSBgbm9kZUludGVncmF0aW9uYCBvcHRpb24gaXMgc2V0IHRvIHRydWVcbiAgICBjb25zdCByZWFsVXNlckFnZW50ID0gdHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudDtcbiAgICBjb25zdCB1c2VyQWdlbnQgPSBtb2NrVXNlckFnZW50IHx8IHJlYWxVc2VyQWdlbnQ7XG4gICAgcmV0dXJuIEJvb2xlYW4odXNlckFnZW50ICYmIHVzZXJBZ2VudC5pbmRleE9mKCdFbGVjdHJvbicpID49IDApO1xufVxuIiwiZXhwb3J0IGZ1bmN0aW9uIGFzc2VydChjb25kaXRpb24sIG1lc3NhZ2UpIHtcbiAgICBpZiAoIWNvbmRpdGlvbikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSB8fCAnQXNzZXJ0aW9uIGZhaWxlZCcpO1xuICAgIH1cbn1cbiIsIi8vIHByb2JlLmdsLCBNSVQgbGljZW5zZVxuLyogZXNsaW50LWRpc2FibGUgbm8tY29uc29sZSAqL1xuaW1wb3J0IHsgVkVSU0lPTiwgaXNCcm93c2VyIH0gZnJvbSAnQHByb2JlLmdsL2Vudic7XG5pbXBvcnQgeyBMb2NhbFN0b3JhZ2UgfSBmcm9tIFwiLi91dGlscy9sb2NhbC1zdG9yYWdlLmpzXCI7XG5pbXBvcnQgeyBmb3JtYXRUaW1lLCBsZWZ0UGFkIH0gZnJvbSBcIi4vdXRpbHMvZm9ybWF0dGVycy5qc1wiO1xuaW1wb3J0IHsgYWRkQ29sb3IgfSBmcm9tIFwiLi91dGlscy9jb2xvci5qc1wiO1xuaW1wb3J0IHsgYXV0b2JpbmQgfSBmcm9tIFwiLi91dGlscy9hdXRvYmluZC5qc1wiO1xuaW1wb3J0IGFzc2VydCBmcm9tIFwiLi91dGlscy9hc3NlcnQuanNcIjtcbmltcG9ydCB7IGdldEhpUmVzVGltZXN0YW1wIH0gZnJvbSBcIi4vdXRpbHMvaGktcmVzLXRpbWVzdGFtcC5qc1wiO1xuLy8gSW5zdHJ1bWVudGF0aW9uIGluIG90aGVyIHBhY2thZ2VzIG1heSBvdmVycmlkZSBjb25zb2xlIG1ldGhvZHMsIHNvIHByZXNlcnZlIHRoZW0gaGVyZVxuY29uc3Qgb3JpZ2luYWxDb25zb2xlID0ge1xuICAgIGRlYnVnOiBpc0Jyb3dzZXIoKSA/IGNvbnNvbGUuZGVidWcgfHwgY29uc29sZS5sb2cgOiBjb25zb2xlLmxvZyxcbiAgICBsb2c6IGNvbnNvbGUubG9nLFxuICAgIGluZm86IGNvbnNvbGUuaW5mbyxcbiAgICB3YXJuOiBjb25zb2xlLndhcm4sXG4gICAgZXJyb3I6IGNvbnNvbGUuZXJyb3Jcbn07XG5jb25zdCBERUZBVUxUX0xPR19DT05GSUdVUkFUSU9OID0ge1xuICAgIGVuYWJsZWQ6IHRydWUsXG4gICAgbGV2ZWw6IDBcbn07XG5mdW5jdGlvbiBub29wKCkgeyB9IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWVtcHR5LWZ1bmN0aW9uXG5jb25zdCBjYWNoZSA9IHt9O1xuY29uc3QgT05DRSA9IHsgb25jZTogdHJ1ZSB9O1xuLyoqIEEgY29uc29sZSB3cmFwcGVyICovXG5leHBvcnQgY2xhc3MgTG9nIHtcbiAgICBjb25zdHJ1Y3Rvcih7IGlkIH0gPSB7IGlkOiAnJyB9KSB7XG4gICAgICAgIHRoaXMuVkVSU0lPTiA9IFZFUlNJT047XG4gICAgICAgIHRoaXMuX3N0YXJ0VHMgPSBnZXRIaVJlc1RpbWVzdGFtcCgpO1xuICAgICAgICB0aGlzLl9kZWx0YVRzID0gZ2V0SGlSZXNUaW1lc3RhbXAoKTtcbiAgICAgICAgdGhpcy51c2VyRGF0YSA9IHt9O1xuICAgICAgICAvLyBUT0RPIC0gZml4IHN1cHBvcnQgZnJvbSB0aHJvdHRsaW5nIGdyb3Vwc1xuICAgICAgICB0aGlzLkxPR19USFJPVFRMRV9USU1FT1VUID0gMDsgLy8gVGltZSBiZWZvcmUgdGhyb3R0bGVkIG1lc3NhZ2VzIGFyZSBsb2dnZWQgYWdhaW5cbiAgICAgICAgdGhpcy5pZCA9IGlkO1xuICAgICAgICB0aGlzLnVzZXJEYXRhID0ge307XG4gICAgICAgIHRoaXMuX3N0b3JhZ2UgPSBuZXcgTG9jYWxTdG9yYWdlKGBfX3Byb2JlLSR7dGhpcy5pZH1fX2AsIERFRkFVTFRfTE9HX0NPTkZJR1VSQVRJT04pO1xuICAgICAgICB0aGlzLnRpbWVTdGFtcChgJHt0aGlzLmlkfSBzdGFydGVkYCk7XG4gICAgICAgIGF1dG9iaW5kKHRoaXMpO1xuICAgICAgICBPYmplY3Quc2VhbCh0aGlzKTtcbiAgICB9XG4gICAgc2V0IGxldmVsKG5ld0xldmVsKSB7XG4gICAgICAgIHRoaXMuc2V0TGV2ZWwobmV3TGV2ZWwpO1xuICAgIH1cbiAgICBnZXQgbGV2ZWwoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldExldmVsKCk7XG4gICAgfVxuICAgIGlzRW5hYmxlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3N0b3JhZ2UuY29uZmlnLmVuYWJsZWQ7XG4gICAgfVxuICAgIGdldExldmVsKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fc3RvcmFnZS5jb25maWcubGV2ZWw7XG4gICAgfVxuICAgIC8qKiBAcmV0dXJuIG1pbGxpc2Vjb25kcywgd2l0aCBmcmFjdGlvbnMgKi9cbiAgICBnZXRUb3RhbCgpIHtcbiAgICAgICAgcmV0dXJuIE51bWJlcigoZ2V0SGlSZXNUaW1lc3RhbXAoKSAtIHRoaXMuX3N0YXJ0VHMpLnRvUHJlY2lzaW9uKDEwKSk7XG4gICAgfVxuICAgIC8qKiBAcmV0dXJuIG1pbGxpc2Vjb25kcywgd2l0aCBmcmFjdGlvbnMgKi9cbiAgICBnZXREZWx0YSgpIHtcbiAgICAgICAgcmV0dXJuIE51bWJlcigoZ2V0SGlSZXNUaW1lc3RhbXAoKSAtIHRoaXMuX2RlbHRhVHMpLnRvUHJlY2lzaW9uKDEwKSk7XG4gICAgfVxuICAgIC8qKiBAZGVwcmVjYXRlZCB1c2UgbG9nTGV2ZWwgKi9cbiAgICBzZXQgcHJpb3JpdHkobmV3UHJpb3JpdHkpIHtcbiAgICAgICAgdGhpcy5sZXZlbCA9IG5ld1ByaW9yaXR5O1xuICAgIH1cbiAgICAvKiogQGRlcHJlY2F0ZWQgdXNlIGxvZ0xldmVsICovXG4gICAgZ2V0IHByaW9yaXR5KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5sZXZlbDtcbiAgICB9XG4gICAgLyoqIEBkZXByZWNhdGVkIHVzZSBsb2dMZXZlbCAqL1xuICAgIGdldFByaW9yaXR5KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5sZXZlbDtcbiAgICB9XG4gICAgLy8gQ29uZmlndXJlXG4gICAgZW5hYmxlKGVuYWJsZWQgPSB0cnVlKSB7XG4gICAgICAgIHRoaXMuX3N0b3JhZ2Uuc2V0Q29uZmlndXJhdGlvbih7IGVuYWJsZWQgfSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBzZXRMZXZlbChsZXZlbCkge1xuICAgICAgICB0aGlzLl9zdG9yYWdlLnNldENvbmZpZ3VyYXRpb24oeyBsZXZlbCB9KTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKiByZXR1cm4gdGhlIGN1cnJlbnQgc3RhdHVzIG9mIHRoZSBzZXR0aW5nICovXG4gICAgZ2V0KHNldHRpbmcpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3N0b3JhZ2UuY29uZmlnW3NldHRpbmddO1xuICAgIH1cbiAgICAvLyB1cGRhdGUgdGhlIHN0YXR1cyBvZiB0aGUgc2V0dGluZ1xuICAgIHNldChzZXR0aW5nLCB2YWx1ZSkge1xuICAgICAgICB0aGlzLl9zdG9yYWdlLnNldENvbmZpZ3VyYXRpb24oeyBbc2V0dGluZ106IHZhbHVlIH0pO1xuICAgIH1cbiAgICAvKiogTG9ncyB0aGUgY3VycmVudCBzZXR0aW5ncyBhcyBhIHRhYmxlICovXG4gICAgc2V0dGluZ3MoKSB7XG4gICAgICAgIGlmIChjb25zb2xlLnRhYmxlKSB7XG4gICAgICAgICAgICBjb25zb2xlLnRhYmxlKHRoaXMuX3N0b3JhZ2UuY29uZmlnKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKHRoaXMuX3N0b3JhZ2UuY29uZmlnKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBVbmNvbmRpdGlvbmFsIGxvZ2dpbmdcbiAgICBhc3NlcnQoY29uZGl0aW9uLCBtZXNzYWdlKSB7XG4gICAgICAgIGlmICghY29uZGl0aW9uKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSB8fCAnQXNzZXJ0aW9uIGZhaWxlZCcpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHdhcm4obWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZ2V0TG9nRnVuY3Rpb24oMCwgbWVzc2FnZSwgb3JpZ2luYWxDb25zb2xlLndhcm4sIGFyZ3VtZW50cywgT05DRSk7XG4gICAgfVxuICAgIGVycm9yKG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2dldExvZ0Z1bmN0aW9uKDAsIG1lc3NhZ2UsIG9yaWdpbmFsQ29uc29sZS5lcnJvciwgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgLyoqIFByaW50IGEgZGVwcmVjYXRpb24gd2FybmluZyAqL1xuICAgIGRlcHJlY2F0ZWQob2xkVXNhZ2UsIG5ld1VzYWdlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLndhcm4oYFxcYCR7b2xkVXNhZ2V9XFxgIGlzIGRlcHJlY2F0ZWQgYW5kIHdpbGwgYmUgcmVtb3ZlZCBcXFxuaW4gYSBsYXRlciB2ZXJzaW9uLiBVc2UgXFxgJHtuZXdVc2FnZX1cXGAgaW5zdGVhZGApO1xuICAgIH1cbiAgICAvKiogUHJpbnQgYSByZW1vdmFsIHdhcm5pbmcgKi9cbiAgICByZW1vdmVkKG9sZFVzYWdlLCBuZXdVc2FnZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5lcnJvcihgXFxgJHtvbGRVc2FnZX1cXGAgaGFzIGJlZW4gcmVtb3ZlZC4gVXNlIFxcYCR7bmV3VXNhZ2V9XFxgIGluc3RlYWRgKTtcbiAgICB9XG4gICAgcHJvYmUobG9nTGV2ZWwsIG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2dldExvZ0Z1bmN0aW9uKGxvZ0xldmVsLCBtZXNzYWdlLCBvcmlnaW5hbENvbnNvbGUubG9nLCBhcmd1bWVudHMsIHtcbiAgICAgICAgICAgIHRpbWU6IHRydWUsXG4gICAgICAgICAgICBvbmNlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBsb2cobG9nTGV2ZWwsIG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2dldExvZ0Z1bmN0aW9uKGxvZ0xldmVsLCBtZXNzYWdlLCBvcmlnaW5hbENvbnNvbGUuZGVidWcsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIGluZm8obG9nTGV2ZWwsIG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2dldExvZ0Z1bmN0aW9uKGxvZ0xldmVsLCBtZXNzYWdlLCBjb25zb2xlLmluZm8sIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIG9uY2UobG9nTGV2ZWwsIG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2dldExvZ0Z1bmN0aW9uKGxvZ0xldmVsLCBtZXNzYWdlLCBvcmlnaW5hbENvbnNvbGUuZGVidWcgfHwgb3JpZ2luYWxDb25zb2xlLmluZm8sIGFyZ3VtZW50cywgT05DRSk7XG4gICAgfVxuICAgIC8qKiBMb2dzIGFuIG9iamVjdCBhcyBhIHRhYmxlICovXG4gICAgdGFibGUobG9nTGV2ZWwsIHRhYmxlLCBjb2x1bW5zKSB7XG4gICAgICAgIGlmICh0YWJsZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2dldExvZ0Z1bmN0aW9uKGxvZ0xldmVsLCB0YWJsZSwgY29uc29sZS50YWJsZSB8fCBub29wLCAoY29sdW1ucyAmJiBbY29sdW1uc10pLCB7XG4gICAgICAgICAgICAgICAgdGFnOiBnZXRUYWJsZUhlYWRlcih0YWJsZSlcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBub29wO1xuICAgIH1cbiAgICB0aW1lKGxvZ0xldmVsLCBtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9nZXRMb2dGdW5jdGlvbihsb2dMZXZlbCwgbWVzc2FnZSwgY29uc29sZS50aW1lID8gY29uc29sZS50aW1lIDogY29uc29sZS5pbmZvKTtcbiAgICB9XG4gICAgdGltZUVuZChsb2dMZXZlbCwgbWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZ2V0TG9nRnVuY3Rpb24obG9nTGV2ZWwsIG1lc3NhZ2UsIGNvbnNvbGUudGltZUVuZCA/IGNvbnNvbGUudGltZUVuZCA6IGNvbnNvbGUuaW5mbyk7XG4gICAgfVxuICAgIHRpbWVTdGFtcChsb2dMZXZlbCwgbWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZ2V0TG9nRnVuY3Rpb24obG9nTGV2ZWwsIG1lc3NhZ2UsIGNvbnNvbGUudGltZVN0YW1wIHx8IG5vb3ApO1xuICAgIH1cbiAgICBncm91cChsb2dMZXZlbCwgbWVzc2FnZSwgb3B0cyA9IHsgY29sbGFwc2VkOiBmYWxzZSB9KSB7XG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSBub3JtYWxpemVBcmd1bWVudHMoeyBsb2dMZXZlbCwgbWVzc2FnZSwgb3B0cyB9KTtcbiAgICAgICAgY29uc3QgeyBjb2xsYXBzZWQgfSA9IG9wdHM7XG4gICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgb3B0aW9ucy5tZXRob2QgPSAoY29sbGFwc2VkID8gY29uc29sZS5ncm91cENvbGxhcHNlZCA6IGNvbnNvbGUuZ3JvdXApIHx8IGNvbnNvbGUuaW5mbztcbiAgICAgICAgcmV0dXJuIHRoaXMuX2dldExvZ0Z1bmN0aW9uKG9wdGlvbnMpO1xuICAgIH1cbiAgICBncm91cENvbGxhcHNlZChsb2dMZXZlbCwgbWVzc2FnZSwgb3B0cyA9IHt9KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdyb3VwKGxvZ0xldmVsLCBtZXNzYWdlLCBPYmplY3QuYXNzaWduKHt9LCBvcHRzLCB7IGNvbGxhcHNlZDogdHJ1ZSB9KSk7XG4gICAgfVxuICAgIGdyb3VwRW5kKGxvZ0xldmVsKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9nZXRMb2dGdW5jdGlvbihsb2dMZXZlbCwgJycsIGNvbnNvbGUuZ3JvdXBFbmQgfHwgbm9vcCk7XG4gICAgfVxuICAgIC8vIEVYUEVSSU1FTlRBTFxuICAgIHdpdGhHcm91cChsb2dMZXZlbCwgbWVzc2FnZSwgZnVuYykge1xuICAgICAgICB0aGlzLmdyb3VwKGxvZ0xldmVsLCBtZXNzYWdlKSgpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgZnVuYygpO1xuICAgICAgICB9XG4gICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgdGhpcy5ncm91cEVuZChsb2dMZXZlbCkoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB0cmFjZSgpIHtcbiAgICAgICAgaWYgKGNvbnNvbGUudHJhY2UpIHtcbiAgICAgICAgICAgIGNvbnNvbGUudHJhY2UoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBQUklWQVRFIE1FVEhPRFNcbiAgICAvKiogRGVkdWNlcyBsb2cgbGV2ZWwgZnJvbSBhIHZhcmlldHkgb2YgYXJndW1lbnRzICovXG4gICAgX3Nob3VsZExvZyhsb2dMZXZlbCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pc0VuYWJsZWQoKSAmJiB0aGlzLmdldExldmVsKCkgPj0gbm9ybWFsaXplTG9nTGV2ZWwobG9nTGV2ZWwpO1xuICAgIH1cbiAgICBfZ2V0TG9nRnVuY3Rpb24obG9nTGV2ZWwsIG1lc3NhZ2UsIG1ldGhvZCwgYXJncywgb3B0cykge1xuICAgICAgICBpZiAodGhpcy5fc2hvdWxkTG9nKGxvZ0xldmVsKSkge1xuICAgICAgICAgICAgLy8gbm9ybWFsaXplZCBvcHRzICsgdGltaW5nc1xuICAgICAgICAgICAgb3B0cyA9IG5vcm1hbGl6ZUFyZ3VtZW50cyh7IGxvZ0xldmVsLCBtZXNzYWdlLCBhcmdzLCBvcHRzIH0pO1xuICAgICAgICAgICAgbWV0aG9kID0gbWV0aG9kIHx8IG9wdHMubWV0aG9kO1xuICAgICAgICAgICAgYXNzZXJ0KG1ldGhvZCk7XG4gICAgICAgICAgICBvcHRzLnRvdGFsID0gdGhpcy5nZXRUb3RhbCgpO1xuICAgICAgICAgICAgb3B0cy5kZWx0YSA9IHRoaXMuZ2V0RGVsdGEoKTtcbiAgICAgICAgICAgIC8vIHJlc2V0IGRlbHRhIHRpbWVyXG4gICAgICAgICAgICB0aGlzLl9kZWx0YVRzID0gZ2V0SGlSZXNUaW1lc3RhbXAoKTtcbiAgICAgICAgICAgIGNvbnN0IHRhZyA9IG9wdHMudGFnIHx8IG9wdHMubWVzc2FnZTtcbiAgICAgICAgICAgIGlmIChvcHRzLm9uY2UgJiYgdGFnKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFjYWNoZVt0YWddKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhY2hlW3RhZ10gPSBnZXRIaVJlc1RpbWVzdGFtcCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5vb3A7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gVE9ETyAtIE1ha2UgdGhyb3R0bGluZyB3b3JrIHdpdGggZ3JvdXBzXG4gICAgICAgICAgICAvLyBpZiAob3B0cy5ub3Rocm90dGxlIHx8ICF0aHJvdHRsZSh0YWcsIHRoaXMuTE9HX1RIUk9UVExFX1RJTUVPVVQpKSB7XG4gICAgICAgICAgICAvLyAgIHJldHVybiBub29wO1xuICAgICAgICAgICAgLy8gfVxuICAgICAgICAgICAgbWVzc2FnZSA9IGRlY29yYXRlTWVzc2FnZSh0aGlzLmlkLCBvcHRzLm1lc3NhZ2UsIG9wdHMpO1xuICAgICAgICAgICAgLy8gQmluZCBjb25zb2xlIGZ1bmN0aW9uIHNvIHRoYXQgaXQgY2FuIGJlIGNhbGxlZCBhZnRlciBiZWluZyByZXR1cm5lZFxuICAgICAgICAgICAgcmV0dXJuIG1ldGhvZC5iaW5kKGNvbnNvbGUsIG1lc3NhZ2UsIC4uLm9wdHMuYXJncyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5vb3A7XG4gICAgfVxufVxuTG9nLlZFUlNJT04gPSBWRVJTSU9OO1xuLyoqXG4gKiBHZXQgbG9nTGV2ZWwgZnJvbSBmaXJzdCBhcmd1bWVudDpcbiAqIC0gbG9nKGxvZ0xldmVsLCBtZXNzYWdlLCBhcmdzKSA9PiBsb2dMZXZlbFxuICogLSBsb2cobWVzc2FnZSwgYXJncykgPT4gMFxuICogLSBsb2coe2xvZ0xldmVsLCAuLi59LCBtZXNzYWdlLCBhcmdzKSA9PiBsb2dMZXZlbFxuICogLSBsb2coe2xvZ0xldmVsLCBtZXNzYWdlLCBhcmdzfSkgPT4gbG9nTGV2ZWxcbiAqL1xuZnVuY3Rpb24gbm9ybWFsaXplTG9nTGV2ZWwobG9nTGV2ZWwpIHtcbiAgICBpZiAoIWxvZ0xldmVsKSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICBsZXQgcmVzb2x2ZWRMZXZlbDtcbiAgICBzd2l0Y2ggKHR5cGVvZiBsb2dMZXZlbCkge1xuICAgICAgICBjYXNlICdudW1iZXInOlxuICAgICAgICAgICAgcmVzb2x2ZWRMZXZlbCA9IGxvZ0xldmVsO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICAgICAgICAvLyBCYWNrd2FyZCBjb21wYXRpYmlsaXR5XG4gICAgICAgICAgICAvLyBUT0RPIC0gZGVwcmVjYXRlIGBwcmlvcml0eWBcbiAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgICAgIHJlc29sdmVkTGV2ZWwgPSBsb2dMZXZlbC5sb2dMZXZlbCB8fCBsb2dMZXZlbC5wcmlvcml0eSB8fCAwO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICB9XG4gICAgLy8gJ2xvZyBsZXZlbCBtdXN0IGJlIGEgbnVtYmVyJ1xuICAgIGFzc2VydChOdW1iZXIuaXNGaW5pdGUocmVzb2x2ZWRMZXZlbCkgJiYgcmVzb2x2ZWRMZXZlbCA+PSAwKTtcbiAgICByZXR1cm4gcmVzb2x2ZWRMZXZlbDtcbn1cbi8qKlxuICogXCJOb3JtYWxpemVzXCIgdGhlIHZhcmlvdXMgYXJndW1lbnQgcGF0dGVybnMgaW50byBhbiBvYmplY3Qgd2l0aCBrbm93biB0eXBlc1xuICogLSBsb2cobG9nTGV2ZWwsIG1lc3NhZ2UsIGFyZ3MpID0+IHtsb2dMZXZlbCwgbWVzc2FnZSwgYXJnc31cbiAqIC0gbG9nKG1lc3NhZ2UsIGFyZ3MpID0+IHtsb2dMZXZlbDogMCwgbWVzc2FnZSwgYXJnc31cbiAqIC0gbG9nKHtsb2dMZXZlbCwgLi4ufSwgbWVzc2FnZSwgYXJncykgPT4ge2xvZ0xldmVsLCBtZXNzYWdlLCBhcmdzfVxuICogLSBsb2coe2xvZ0xldmVsLCBtZXNzYWdlLCBhcmdzfSkgPT4ge2xvZ0xldmVsLCBtZXNzYWdlLCBhcmdzfVxuICovXG5leHBvcnQgZnVuY3Rpb24gbm9ybWFsaXplQXJndW1lbnRzKG9wdHMpIHtcbiAgICBjb25zdCB7IGxvZ0xldmVsLCBtZXNzYWdlIH0gPSBvcHRzO1xuICAgIG9wdHMubG9nTGV2ZWwgPSBub3JtYWxpemVMb2dMZXZlbChsb2dMZXZlbCk7XG4gICAgLy8gV2UgdXNlIGBhcmd1bWVudHNgIGluc3RlYWQgb2YgcmVzdCBwYXJhbWV0ZXJzICguLi5hcmdzKSBiZWNhdXNlIElFXG4gICAgLy8gZG9lcyBub3Qgc3VwcG9ydCB0aGUgc3ludGF4LiBSZXN0IHBhcmFtZXRlcnMgaXMgdHJhbnNwaWxlZCB0byBjb2RlIHdpdGhcbiAgICAvLyBwZXJmIGltcGFjdC4gRG9pbmcgaXQgaGVyZSBpbnN0ZWFkIGF2b2lkcyBjb25zdHJ1Y3RpbmcgYXJncyB3aGVuIGxvZ2dpbmcgaXNcbiAgICAvLyBkaXNhYmxlZC5cbiAgICAvLyBUT0RPIC0gcmVtb3ZlIHdoZW4vaWYgSUUgc3VwcG9ydCBpcyBkcm9wcGVkXG4gICAgY29uc3QgYXJncyA9IG9wdHMuYXJncyA/IEFycmF5LmZyb20ob3B0cy5hcmdzKSA6IFtdO1xuICAgIC8vIGFyZ3Mgc2hvdWxkIG9ubHkgY29udGFpbiBhcmd1bWVudHMgdGhhdCBhcHBlYXIgYWZ0ZXIgYG1lc3NhZ2VgXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWVtcHR5XG4gICAgd2hpbGUgKGFyZ3MubGVuZ3RoICYmIGFyZ3Muc2hpZnQoKSAhPT0gbWVzc2FnZSkgeyB9XG4gICAgc3dpdGNoICh0eXBlb2YgbG9nTGV2ZWwpIHtcbiAgICAgICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgICAgY2FzZSAnZnVuY3Rpb24nOlxuICAgICAgICAgICAgaWYgKG1lc3NhZ2UgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGFyZ3MudW5zaGlmdChtZXNzYWdlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9wdHMubWVzc2FnZSA9IGxvZ0xldmVsO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICAgICAgICBPYmplY3QuYXNzaWduKG9wdHMsIGxvZ0xldmVsKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgIH1cbiAgICAvLyBSZXNvbHZlIGZ1bmN0aW9ucyBpbnRvIHN0cmluZ3MgYnkgY2FsbGluZyB0aGVtXG4gICAgaWYgKHR5cGVvZiBvcHRzLm1lc3NhZ2UgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgb3B0cy5tZXNzYWdlID0gb3B0cy5tZXNzYWdlKCk7XG4gICAgfVxuICAgIGNvbnN0IG1lc3NhZ2VUeXBlID0gdHlwZW9mIG9wdHMubWVzc2FnZTtcbiAgICAvLyAnbG9nIG1lc3NhZ2UgbXVzdCBiZSBhIHN0cmluZycgb3Igb2JqZWN0XG4gICAgYXNzZXJ0KG1lc3NhZ2VUeXBlID09PSAnc3RyaW5nJyB8fCBtZXNzYWdlVHlwZSA9PT0gJ29iamVjdCcpO1xuICAgIC8vIG9yaWdpbmFsIG9wdHMgKyBub3JtYWxpemVkIG9wdHMgKyBvcHRzIGFyZyArIGZpeGVkIHVwIG1lc3NhZ2VcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihvcHRzLCB7IGFyZ3MgfSwgb3B0cy5vcHRzKTtcbn1cbmZ1bmN0aW9uIGRlY29yYXRlTWVzc2FnZShpZCwgbWVzc2FnZSwgb3B0cykge1xuICAgIGlmICh0eXBlb2YgbWVzc2FnZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgY29uc3QgdGltZSA9IG9wdHMudGltZSA/IGxlZnRQYWQoZm9ybWF0VGltZShvcHRzLnRvdGFsKSkgOiAnJztcbiAgICAgICAgbWVzc2FnZSA9IG9wdHMudGltZSA/IGAke2lkfTogJHt0aW1lfSAgJHttZXNzYWdlfWAgOiBgJHtpZH06ICR7bWVzc2FnZX1gO1xuICAgICAgICBtZXNzYWdlID0gYWRkQ29sb3IobWVzc2FnZSwgb3B0cy5jb2xvciwgb3B0cy5iYWNrZ3JvdW5kKTtcbiAgICB9XG4gICAgcmV0dXJuIG1lc3NhZ2U7XG59XG5mdW5jdGlvbiBnZXRUYWJsZUhlYWRlcih0YWJsZSkge1xuICAgIGZvciAoY29uc3Qga2V5IGluIHRhYmxlKSB7XG4gICAgICAgIGZvciAoY29uc3QgdGl0bGUgaW4gdGFibGVba2V5XSkge1xuICAgICAgICAgICAgcmV0dXJuIHRpdGxlIHx8ICd1bnRpdGxlZCc7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuICdlbXB0eSc7XG59XG4iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBhc3NlcnQoY29uZGl0aW9uLCBtZXNzYWdlKSB7XG4gICAgaWYgKCFjb25kaXRpb24pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UgfHwgJ0Fzc2VydGlvbiBmYWlsZWQnKTtcbiAgICB9XG59XG4iLCIvLyBDb3B5cmlnaHQgKGMpIDIwMTUgLSAyMDE3IFViZXIgVGVjaG5vbG9naWVzLCBJbmMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuLy8gb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuLy8gaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuLy8gdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuLy8gY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4vLyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4vLyBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4vLyBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbi8vIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuLy8gQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuLy8gTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbi8vIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cbi8vIFRIRSBTT0ZUV0FSRS5cbi8qKlxuICogQmluZHMgdGhlIFwidGhpc1wiIGFyZ3VtZW50IG9mIGFsbCBmdW5jdGlvbnMgb24gYSBjbGFzcyBpbnN0YW5jZSB0byB0aGUgaW5zdGFuY2VcbiAqIEBwYXJhbSBvYmogLSBjbGFzcyBpbnN0YW5jZSAodHlwaWNhbGx5IGEgcmVhY3QgY29tcG9uZW50KVxuICovXG5leHBvcnQgZnVuY3Rpb24gYXV0b2JpbmQob2JqLCBwcmVkZWZpbmVkID0gWydjb25zdHJ1Y3RvciddKSB7XG4gICAgY29uc3QgcHJvdG8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Yob2JqKTtcbiAgICBjb25zdCBwcm9wTmFtZXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhwcm90byk7XG4gICAgY29uc3Qgb2JqZWN0ID0gb2JqO1xuICAgIGZvciAoY29uc3Qga2V5IG9mIHByb3BOYW1lcykge1xuICAgICAgICBjb25zdCB2YWx1ZSA9IG9iamVjdFtrZXldO1xuICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBpZiAoIXByZWRlZmluZWQuZmluZChuYW1lID0+IGtleSA9PT0gbmFtZSkpIHtcbiAgICAgICAgICAgICAgICBvYmplY3Rba2V5XSA9IHZhbHVlLmJpbmQob2JqKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cbiIsImltcG9ydCB7IGlzQnJvd3NlciB9IGZyb20gJ0Bwcm9iZS5nbC9lbnYnO1xuZXhwb3J0IHZhciBDT0xPUjtcbihmdW5jdGlvbiAoQ09MT1IpIHtcbiAgICBDT0xPUltDT0xPUltcIkJMQUNLXCJdID0gMzBdID0gXCJCTEFDS1wiO1xuICAgIENPTE9SW0NPTE9SW1wiUkVEXCJdID0gMzFdID0gXCJSRURcIjtcbiAgICBDT0xPUltDT0xPUltcIkdSRUVOXCJdID0gMzJdID0gXCJHUkVFTlwiO1xuICAgIENPTE9SW0NPTE9SW1wiWUVMTE9XXCJdID0gMzNdID0gXCJZRUxMT1dcIjtcbiAgICBDT0xPUltDT0xPUltcIkJMVUVcIl0gPSAzNF0gPSBcIkJMVUVcIjtcbiAgICBDT0xPUltDT0xPUltcIk1BR0VOVEFcIl0gPSAzNV0gPSBcIk1BR0VOVEFcIjtcbiAgICBDT0xPUltDT0xPUltcIkNZQU5cIl0gPSAzNl0gPSBcIkNZQU5cIjtcbiAgICBDT0xPUltDT0xPUltcIldISVRFXCJdID0gMzddID0gXCJXSElURVwiO1xuICAgIENPTE9SW0NPTE9SW1wiQlJJR0hUX0JMQUNLXCJdID0gOTBdID0gXCJCUklHSFRfQkxBQ0tcIjtcbiAgICBDT0xPUltDT0xPUltcIkJSSUdIVF9SRURcIl0gPSA5MV0gPSBcIkJSSUdIVF9SRURcIjtcbiAgICBDT0xPUltDT0xPUltcIkJSSUdIVF9HUkVFTlwiXSA9IDkyXSA9IFwiQlJJR0hUX0dSRUVOXCI7XG4gICAgQ09MT1JbQ09MT1JbXCJCUklHSFRfWUVMTE9XXCJdID0gOTNdID0gXCJCUklHSFRfWUVMTE9XXCI7XG4gICAgQ09MT1JbQ09MT1JbXCJCUklHSFRfQkxVRVwiXSA9IDk0XSA9IFwiQlJJR0hUX0JMVUVcIjtcbiAgICBDT0xPUltDT0xPUltcIkJSSUdIVF9NQUdFTlRBXCJdID0gOTVdID0gXCJCUklHSFRfTUFHRU5UQVwiO1xuICAgIENPTE9SW0NPTE9SW1wiQlJJR0hUX0NZQU5cIl0gPSA5Nl0gPSBcIkJSSUdIVF9DWUFOXCI7XG4gICAgQ09MT1JbQ09MT1JbXCJCUklHSFRfV0hJVEVcIl0gPSA5N10gPSBcIkJSSUdIVF9XSElURVwiO1xufSkoQ09MT1IgfHwgKENPTE9SID0ge30pKTtcbmNvbnN0IEJBQ0tHUk9VTkRfSU5DUkVNRU5UID0gMTA7XG5mdW5jdGlvbiBnZXRDb2xvcihjb2xvcikge1xuICAgIGlmICh0eXBlb2YgY29sb3IgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybiBjb2xvcjtcbiAgICB9XG4gICAgY29sb3IgPSBjb2xvci50b1VwcGVyQ2FzZSgpO1xuICAgIHJldHVybiBDT0xPUltjb2xvcl0gfHwgQ09MT1IuV0hJVEU7XG59XG5leHBvcnQgZnVuY3Rpb24gYWRkQ29sb3Ioc3RyaW5nLCBjb2xvciwgYmFja2dyb3VuZCkge1xuICAgIGlmICghaXNCcm93c2VyICYmIHR5cGVvZiBzdHJpbmcgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGlmIChjb2xvcikge1xuICAgICAgICAgICAgY29uc3QgY29sb3JDb2RlID0gZ2V0Q29sb3IoY29sb3IpO1xuICAgICAgICAgICAgc3RyaW5nID0gYFxcdTAwMWJbJHtjb2xvckNvZGV9bSR7c3RyaW5nfVxcdTAwMWJbMzltYDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYmFja2dyb3VuZCkge1xuICAgICAgICAgICAgLy8gYmFja2dyb3VuZCBjb2xvcnMgdmFsdWVzIGFyZSArMTBcbiAgICAgICAgICAgIGNvbnN0IGNvbG9yQ29kZSA9IGdldENvbG9yKGJhY2tncm91bmQpO1xuICAgICAgICAgICAgc3RyaW5nID0gYFxcdTAwMWJbJHtjb2xvckNvZGUgKyBCQUNLR1JPVU5EX0lOQ1JFTUVOVH1tJHtzdHJpbmd9XFx1MDAxYls0OW1gO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzdHJpbmc7XG59XG4iLCIvLyBwcm9iZS5nbCwgTUlUIGxpY2Vuc2Vcbi8qKlxuICogRm9ybWF0IHRpbWVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZvcm1hdFRpbWUobXMpIHtcbiAgICBsZXQgZm9ybWF0dGVkO1xuICAgIGlmIChtcyA8IDEwKSB7XG4gICAgICAgIGZvcm1hdHRlZCA9IGAke21zLnRvRml4ZWQoMil9bXNgO1xuICAgIH1cbiAgICBlbHNlIGlmIChtcyA8IDEwMCkge1xuICAgICAgICBmb3JtYXR0ZWQgPSBgJHttcy50b0ZpeGVkKDEpfW1zYDtcbiAgICB9XG4gICAgZWxzZSBpZiAobXMgPCAxMDAwKSB7XG4gICAgICAgIGZvcm1hdHRlZCA9IGAke21zLnRvRml4ZWQoMCl9bXNgO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgZm9ybWF0dGVkID0gYCR7KG1zIC8gMTAwMCkudG9GaXhlZCgyKX1zYDtcbiAgICB9XG4gICAgcmV0dXJuIGZvcm1hdHRlZDtcbn1cbmV4cG9ydCBmdW5jdGlvbiBsZWZ0UGFkKHN0cmluZywgbGVuZ3RoID0gOCkge1xuICAgIGNvbnN0IHBhZExlbmd0aCA9IE1hdGgubWF4KGxlbmd0aCAtIHN0cmluZy5sZW5ndGgsIDApO1xuICAgIHJldHVybiBgJHsnICcucmVwZWF0KHBhZExlbmd0aCl9JHtzdHJpbmd9YDtcbn1cbmV4cG9ydCBmdW5jdGlvbiByaWdodFBhZChzdHJpbmcsIGxlbmd0aCA9IDgpIHtcbiAgICBjb25zdCBwYWRMZW5ndGggPSBNYXRoLm1heChsZW5ndGggLSBzdHJpbmcubGVuZ3RoLCAwKTtcbiAgICByZXR1cm4gYCR7c3RyaW5nfSR7JyAnLnJlcGVhdChwYWRMZW5ndGgpfWA7XG59XG5leHBvcnQgZnVuY3Rpb24gZm9ybWF0VmFsdWUodiwgb3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3QgRVBTSUxPTiA9IDFlLTE2O1xuICAgIGNvbnN0IHsgaXNJbnRlZ2VyID0gZmFsc2UgfSA9IG9wdGlvbnM7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkodikgfHwgQXJyYXlCdWZmZXIuaXNWaWV3KHYpKSB7XG4gICAgICAgIHJldHVybiBmb3JtYXRBcnJheVZhbHVlKHYsIG9wdGlvbnMpO1xuICAgIH1cbiAgICBpZiAoIU51bWJlci5pc0Zpbml0ZSh2KSkge1xuICAgICAgICByZXR1cm4gU3RyaW5nKHYpO1xuICAgIH1cbiAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgaWYgKE1hdGguYWJzKHYpIDwgRVBTSUxPTikge1xuICAgICAgICByZXR1cm4gaXNJbnRlZ2VyID8gJzAnIDogJzAuJztcbiAgICB9XG4gICAgaWYgKGlzSW50ZWdlcikge1xuICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgIHJldHVybiB2LnRvRml4ZWQoMCk7XG4gICAgfVxuICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICBpZiAoTWF0aC5hYnModikgPiAxMDAgJiYgTWF0aC5hYnModikgPCAxMDAwMCkge1xuICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgIHJldHVybiB2LnRvRml4ZWQoMCk7XG4gICAgfVxuICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICBjb25zdCBzdHJpbmcgPSB2LnRvUHJlY2lzaW9uKDIpO1xuICAgIGNvbnN0IGRlY2ltYWwgPSBzdHJpbmcuaW5kZXhPZignLjAnKTtcbiAgICByZXR1cm4gZGVjaW1hbCA9PT0gc3RyaW5nLmxlbmd0aCAtIDIgPyBzdHJpbmcuc2xpY2UoMCwgLTEpIDogc3RyaW5nO1xufVxuLyoqIEhlbHBlciB0byBmb3JtYXRWYWx1ZSAqL1xuZnVuY3Rpb24gZm9ybWF0QXJyYXlWYWx1ZSh2LCBvcHRpb25zKSB7XG4gICAgY29uc3QgeyBtYXhFbHRzID0gMTYsIHNpemUgPSAxIH0gPSBvcHRpb25zO1xuICAgIGxldCBzdHJpbmcgPSAnWyc7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB2Lmxlbmd0aCAmJiBpIDwgbWF4RWx0czsgKytpKSB7XG4gICAgICAgIGlmIChpID4gMCkge1xuICAgICAgICAgICAgc3RyaW5nICs9IGAsJHtpICUgc2l6ZSA9PT0gMCA/ICcgJyA6ICcnfWA7XG4gICAgICAgIH1cbiAgICAgICAgc3RyaW5nICs9IGZvcm1hdFZhbHVlKHZbaV0sIG9wdGlvbnMpO1xuICAgIH1cbiAgICBjb25zdCB0ZXJtaW5hdG9yID0gdi5sZW5ndGggPiBtYXhFbHRzID8gJy4uLicgOiAnXSc7XG4gICAgcmV0dXJuIGAke3N0cmluZ30ke3Rlcm1pbmF0b3J9YDtcbn1cbiIsIi8vIHByb2JlLmdsLCBNSVQgbGljZW5zZVxuaW1wb3J0IHsgd2luZG93LCBwcm9jZXNzLCBpc0Jyb3dzZXIgfSBmcm9tICdAcHJvYmUuZ2wvZW52Jztcbi8qKiBHZXQgYmVzdCB0aW1lciBhdmFpbGFibGUuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0SGlSZXNUaW1lc3RhbXAoKSB7XG4gICAgbGV0IHRpbWVzdGFtcDtcbiAgICBpZiAoaXNCcm93c2VyKCkgJiYgd2luZG93LnBlcmZvcm1hbmNlKSB7XG4gICAgICAgIHRpbWVzdGFtcCA9IHdpbmRvdz8ucGVyZm9ybWFuY2U/Lm5vdz8uKCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKCdocnRpbWUnIGluIHByb2Nlc3MpIHtcbiAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICBjb25zdCB0aW1lUGFydHMgPSBwcm9jZXNzPy5ocnRpbWU/LigpO1xuICAgICAgICB0aW1lc3RhbXAgPSB0aW1lUGFydHNbMF0gKiAxMDAwICsgdGltZVBhcnRzWzFdIC8gMWU2O1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdGltZXN0YW1wID0gRGF0ZS5ub3coKTtcbiAgICB9XG4gICAgcmV0dXJuIHRpbWVzdGFtcDtcbn1cbiIsIi8vIHByb2JlLmdsLCBNSVQgbGljZW5zZVxuZnVuY3Rpb24gZ2V0U3RvcmFnZSh0eXBlKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3Qgc3RvcmFnZSA9IHdpbmRvd1t0eXBlXTtcbiAgICAgICAgY29uc3QgeCA9ICdfX3N0b3JhZ2VfdGVzdF9fJztcbiAgICAgICAgc3RvcmFnZS5zZXRJdGVtKHgsIHgpO1xuICAgICAgICBzdG9yYWdlLnJlbW92ZUl0ZW0oeCk7XG4gICAgICAgIHJldHVybiBzdG9yYWdlO1xuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG59XG4vLyBTdG9yZSBrZXlzIGluIGxvY2FsIHN0b3JhZ2UgdmlhIHNpbXBsZSBpbnRlcmZhY2VcbmV4cG9ydCBjbGFzcyBMb2NhbFN0b3JhZ2Uge1xuICAgIGNvbnN0cnVjdG9yKGlkLCBkZWZhdWx0Q29uZmlnLCB0eXBlID0gJ3Nlc3Npb25TdG9yYWdlJykge1xuICAgICAgICB0aGlzLnN0b3JhZ2UgPSBnZXRTdG9yYWdlKHR5cGUpO1xuICAgICAgICB0aGlzLmlkID0gaWQ7XG4gICAgICAgIHRoaXMuY29uZmlnID0gZGVmYXVsdENvbmZpZztcbiAgICAgICAgdGhpcy5fbG9hZENvbmZpZ3VyYXRpb24oKTtcbiAgICB9XG4gICAgZ2V0Q29uZmlndXJhdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29uZmlnO1xuICAgIH1cbiAgICBzZXRDb25maWd1cmF0aW9uKGNvbmZpZ3VyYXRpb24pIHtcbiAgICAgICAgT2JqZWN0LmFzc2lnbih0aGlzLmNvbmZpZywgY29uZmlndXJhdGlvbik7XG4gICAgICAgIGlmICh0aGlzLnN0b3JhZ2UpIHtcbiAgICAgICAgICAgIGNvbnN0IHNlcmlhbGl6ZWQgPSBKU09OLnN0cmluZ2lmeSh0aGlzLmNvbmZpZyk7XG4gICAgICAgICAgICB0aGlzLnN0b3JhZ2Uuc2V0SXRlbSh0aGlzLmlkLCBzZXJpYWxpemVkKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBHZXQgY29uZmlnIGZyb20gcGVyc2lzdGVudCBzdG9yZSwgaWYgYXZhaWxhYmxlXG4gICAgX2xvYWRDb25maWd1cmF0aW9uKCkge1xuICAgICAgICBsZXQgY29uZmlndXJhdGlvbiA9IHt9O1xuICAgICAgICBpZiAodGhpcy5zdG9yYWdlKSB7XG4gICAgICAgICAgICBjb25zdCBzZXJpYWxpemVkQ29uZmlndXJhdGlvbiA9IHRoaXMuc3RvcmFnZS5nZXRJdGVtKHRoaXMuaWQpO1xuICAgICAgICAgICAgY29uZmlndXJhdGlvbiA9IHNlcmlhbGl6ZWRDb25maWd1cmF0aW9uID8gSlNPTi5wYXJzZShzZXJpYWxpemVkQ29uZmlndXJhdGlvbikgOiB7fTtcbiAgICAgICAgfVxuICAgICAgICBPYmplY3QuYXNzaWduKHRoaXMuY29uZmlnLCBjb25maWd1cmF0aW9uKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxufVxuIiwiLyogd2dwdS1tYXRyaXhAMy4wLjEsIGxpY2Vuc2UgTUlUICovXG5mdW5jdGlvbiB3cmFwQ29uc3RydWN0b3IoT3JpZ2luYWxDb25zdHJ1Y3RvciwgbW9kaWZpZXIpIHtcbiAgICByZXR1cm4gY2xhc3MgZXh0ZW5kcyBPcmlnaW5hbENvbnN0cnVjdG9yIHtcbiAgICAgICAgY29uc3RydWN0b3IoLi4uYXJncykge1xuICAgICAgICAgICAgc3VwZXIoLi4uYXJncyk7XG4gICAgICAgICAgICBtb2RpZmllcih0aGlzKTtcbiAgICAgICAgfVxuICAgIH07IC8vIFR5cGUgYXNzZXJ0aW9uIGlzIG5lY2Vzc2FyeSBoZXJlXG59XG5jb25zdCBaZXJvQXJyYXkgPSB3cmFwQ29uc3RydWN0b3IoKEFycmF5KSwgYSA9PiBhLmZpbGwoMCkpO1xuXG4vKlxuICogQ29weXJpZ2h0IDIwMjIgR3JlZ2cgVGF2YXJlc1xuICpcbiAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4gKiBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksXG4gKiB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uXG4gKiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSxcbiAqIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZVxuICogU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbiAqXG4gKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuICogYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gKlxuICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuICogSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4gKiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiAgSU4gTk8gRVZFTlQgU0hBTExcbiAqIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4gKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lOR1xuICogRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUlxuICogREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuICovXG5sZXQgRVBTSUxPTiA9IDAuMDAwMDAxO1xuLyoqXG4gKiBTZXQgdGhlIHZhbHVlIGZvciBFUFNJTE9OIGZvciB2YXJpb3VzIGNoZWNrc1xuICogQHBhcmFtIHYgLSBWYWx1ZSB0byB1c2UgZm9yIEVQU0lMT04uXG4gKiBAcmV0dXJucyBwcmV2aW91cyB2YWx1ZSBvZiBFUFNJTE9OO1xuICovXG5mdW5jdGlvbiBzZXRFcHNpbG9uKHYpIHtcbiAgICBjb25zdCBvbGQgPSBFUFNJTE9OO1xuICAgIEVQU0lMT04gPSB2O1xuICAgIHJldHVybiBvbGQ7XG59XG4vKipcbiAqIENvbnZlcnQgZGVncmVlcyB0byByYWRpYW5zXG4gKiBAcGFyYW0gZGVncmVlcyAtIEFuZ2xlIGluIGRlZ3JlZXNcbiAqIEByZXR1cm5zIGFuZ2xlIGNvbnZlcnRlZCB0byByYWRpYW5zXG4gKi9cbmZ1bmN0aW9uIGRlZ1RvUmFkKGRlZ3JlZXMpIHtcbiAgICByZXR1cm4gZGVncmVlcyAqIE1hdGguUEkgLyAxODA7XG59XG4vKipcbiAqIENvbnZlcnQgcmFkaWFucyB0byBkZWdyZWVzXG4gKiBAcGFyYW0gcmFkaWFucyAtIEFuZ2xlIGluIHJhZGlhbnNcbiAqIEByZXR1cm5zIGFuZ2xlIGNvbnZlcnRlZCB0byBkZWdyZWVzXG4gKi9cbmZ1bmN0aW9uIHJhZFRvRGVnKHJhZGlhbnMpIHtcbiAgICByZXR1cm4gcmFkaWFucyAqIDE4MCAvIE1hdGguUEk7XG59XG4vKipcbiAqIExlcnBzIGJldHdlZW4gYSBhbmQgYiB2aWEgdFxuICogQHBhcmFtIGEgLSBzdGFydGluZyB2YWx1ZVxuICogQHBhcmFtIGIgLSBlbmRpbmcgdmFsdWVcbiAqIEBwYXJhbSB0IC0gdmFsdWUgd2hlcmUgMCA9IGEgYW5kIDEgPSBiXG4gKiBAcmV0dXJucyBhICsgKGIgLSBhKSAqIHRcbiAqL1xuZnVuY3Rpb24gbGVycChhLCBiLCB0KSB7XG4gICAgcmV0dXJuIGEgKyAoYiAtIGEpICogdDtcbn1cbi8qKlxuICogQ29tcHV0ZSB0aGUgb3Bwb3NpdGUgb2YgbGVycC4gR2l2ZW4gYSBhbmQgYiBhbmQgYSB2YWx1ZSBiZXR3ZWVuXG4gKiBhIGFuZCBiIHJldHVybnMgYSB2YWx1ZSBiZXR3ZWVuIDAgYW5kIDEuIDAgaWYgYSwgMSBpZiBiLlxuICogTm90ZTogbm8gY2xhbXBpbmcgaXMgZG9uZS5cbiAqIEBwYXJhbSBhIC0gc3RhcnQgdmFsdWVcbiAqIEBwYXJhbSBiIC0gZW5kIHZhbHVlXG4gKiBAcGFyYW0gdiAtIHZhbHVlIGJldHdlZW4gYSBhbmQgYlxuICogQHJldHVybnMgKHYgLSBhKSAvIChiIC0gYSlcbiAqL1xuZnVuY3Rpb24gaW52ZXJzZUxlcnAoYSwgYiwgdikge1xuICAgIGNvbnN0IGQgPSBiIC0gYTtcbiAgICByZXR1cm4gKE1hdGguYWJzKGIgLSBhKSA8IEVQU0lMT04pXG4gICAgICAgID8gYVxuICAgICAgICA6ICh2IC0gYSkgLyBkO1xufVxuLyoqXG4gKiBDb21wdXRlIHRoZSBldWNsaWRlYW4gbW9kdWxvXG4gKlxuICogYGBgXG4gKiAvLyB0YWJsZSBmb3IgbiAvIDNcbiAqIC01LCAtNCwgLTMsIC0yLCAtMSwgIDAsICAxLCAgMiwgIDMsICA0LCAgNSAgIDwtIG5cbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogLTIgIC0xICAtMCAgLTIgIC0xICAgMCwgIDEsICAyLCAgMCwgIDEsICAyICAgPC0gbiAlIDNcbiAqICAxICAgMiAgIDAgICAxICAgMiAgIDAsICAxLCAgMiwgIDAsICAxLCAgMiAgIDwtIGV1Y2xpZGVhbk1vZHVsZShuLCAzKVxuICogYGBgXG4gKlxuICogQHBhcmFtIG4gLSBkaXZpZGVuZFxuICogQHBhcmFtIG0gLSBkaXZpc29yXG4gKiBAcmV0dXJucyB0aGUgZXVjbGlkZWFuIG1vZHVsbyBvZiBuIC8gbVxuICovXG5mdW5jdGlvbiBldWNsaWRlYW5Nb2R1bG8obiwgbSkge1xuICAgIHJldHVybiAoKG4gJSBtKSArIG0pICUgbTtcbn1cblxudmFyIHV0aWxzID0ge1xuICAgIF9fcHJvdG9fXzogbnVsbCxcbiAgICBnZXQgRVBTSUxPTiAoKSB7IHJldHVybiBFUFNJTE9OOyB9LFxuICAgIGRlZ1RvUmFkOiBkZWdUb1JhZCxcbiAgICBldWNsaWRlYW5Nb2R1bG86IGV1Y2xpZGVhbk1vZHVsbyxcbiAgICBpbnZlcnNlTGVycDogaW52ZXJzZUxlcnAsXG4gICAgbGVycDogbGVycCxcbiAgICByYWRUb0RlZzogcmFkVG9EZWcsXG4gICAgc2V0RXBzaWxvbjogc2V0RXBzaWxvblxufTtcblxuLypcbiAqIENvcHlyaWdodCAyMDIyIEdyZWdnIFRhdmFyZXNcbiAqXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuICogY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLFxuICogdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvblxuICogdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsXG4gKiBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGVcbiAqIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4gKlxuICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbiAqIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuICpcbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbiAqIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gIElOIE5PIEVWRU5UIFNIQUxMXG4gKiBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuICogTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkdcbiAqIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVJcbiAqIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cbiAqL1xuLyoqXG4gKiBHZW5lcmF0ZXMgYW0gdHlwZWQgQVBJIGZvciBWZWMzXG4gKi9cbmZ1bmN0aW9uIGdldEFQSUltcGwkNShDdG9yKSB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIFZlYzI7IG1heSBiZSBjYWxsZWQgd2l0aCB4LCB5LCB6IHRvIHNldCBpbml0aWFsIHZhbHVlcy5cbiAgICAgKlxuICAgICAqIE5vdGU6IFNpbmNlIHBhc3NpbmcgaW4gYSByYXcgSmF2YVNjcmlwdCBhcnJheVxuICAgICAqIGlzIHZhbGlkIGluIGFsbCBjaXJjdW1zdGFuY2VzLCBpZiB5b3Ugd2FudCB0b1xuICAgICAqIGZvcmNlIGEgSmF2YVNjcmlwdCBhcnJheSBpbnRvIGEgVmVjMidzIHNwZWNpZmllZCB0eXBlXG4gICAgICogaXQgd291bGQgYmUgZmFzdGVyIHRvIHVzZVxuICAgICAqXG4gICAgICogYGBgXG4gICAgICogY29uc3QgdiA9IHZlYzIuY2xvbmUoc29tZUpTQXJyYXkpO1xuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogQHBhcmFtIHggLSBJbml0aWFsIHggdmFsdWUuXG4gICAgICogQHBhcmFtIHkgLSBJbml0aWFsIHkgdmFsdWUuXG4gICAgICogQHJldHVybnMgdGhlIGNyZWF0ZWQgdmVjdG9yXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlKHggPSAwLCB5ID0gMCkge1xuICAgICAgICBjb25zdCBuZXdEc3QgPSBuZXcgQ3RvcigyKTtcbiAgICAgICAgaWYgKHggIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgbmV3RHN0WzBdID0geDtcbiAgICAgICAgICAgIGlmICh5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBuZXdEc3RbMV0gPSB5O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXdEc3Q7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBWZWMyOyBtYXkgYmUgY2FsbGVkIHdpdGggeCwgeSwgeiB0byBzZXQgaW5pdGlhbCB2YWx1ZXMuIChzYW1lIGFzIGNyZWF0ZSlcbiAgICAgKiBAcGFyYW0geCAtIEluaXRpYWwgeCB2YWx1ZS5cbiAgICAgKiBAcGFyYW0geSAtIEluaXRpYWwgeSB2YWx1ZS5cbiAgICAgKiBAcmV0dXJucyB0aGUgY3JlYXRlZCB2ZWN0b3JcbiAgICAgKi9cbiAgICBjb25zdCBmcm9tVmFsdWVzID0gY3JlYXRlO1xuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIHZhbHVlcyBvZiBhIFZlYzJcbiAgICAgKiBBbHNvIHNlZSB7QGxpbmsgdmVjMi5jcmVhdGV9IGFuZCB7QGxpbmsgdmVjMi5jb3B5fVxuICAgICAqXG4gICAgICogQHBhcmFtIHggZmlyc3QgdmFsdWVcbiAgICAgKiBAcGFyYW0geSBzZWNvbmQgdmFsdWVcbiAgICAgKiBAcGFyYW0gZHN0IC0gdmVjdG9yIHRvIGhvbGQgcmVzdWx0LiBJZiBub3QgcGFzc2VkIGluIGEgbmV3IG9uZSBpcyBjcmVhdGVkLlxuICAgICAqIEByZXR1cm5zIEEgdmVjdG9yIHdpdGggaXRzIGVsZW1lbnRzIHNldC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzZXQoeCwgeSwgZHN0KSB7XG4gICAgICAgIGNvbnN0IG5ld0RzdCA9IChkc3QgPz8gbmV3IEN0b3IoMikpO1xuICAgICAgICBuZXdEc3RbMF0gPSB4O1xuICAgICAgICBuZXdEc3RbMV0gPSB5O1xuICAgICAgICByZXR1cm4gbmV3RHN0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBcHBsaWVzIE1hdGguY2VpbCB0byBlYWNoIGVsZW1lbnQgb2YgdmVjdG9yXG4gICAgICogQHBhcmFtIHYgLSBPcGVyYW5kIHZlY3Rvci5cbiAgICAgKiBAcGFyYW0gZHN0IC0gdmVjdG9yIHRvIGhvbGQgcmVzdWx0LiBJZiBub3QgcGFzc2VkIGluIGEgbmV3IG9uZSBpcyBjcmVhdGVkLlxuICAgICAqIEByZXR1cm5zIEEgdmVjdG9yIHRoYXQgaXMgdGhlIGNlaWwgb2YgZWFjaCBlbGVtZW50IG9mIHYuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY2VpbCh2LCBkc3QpIHtcbiAgICAgICAgY29uc3QgbmV3RHN0ID0gKGRzdCA/PyBuZXcgQ3RvcigyKSk7XG4gICAgICAgIG5ld0RzdFswXSA9IE1hdGguY2VpbCh2WzBdKTtcbiAgICAgICAgbmV3RHN0WzFdID0gTWF0aC5jZWlsKHZbMV0pO1xuICAgICAgICByZXR1cm4gbmV3RHN0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBcHBsaWVzIE1hdGguZmxvb3IgdG8gZWFjaCBlbGVtZW50IG9mIHZlY3RvclxuICAgICAqIEBwYXJhbSB2IC0gT3BlcmFuZCB2ZWN0b3IuXG4gICAgICogQHBhcmFtIGRzdCAtIHZlY3RvciB0byBob2xkIHJlc3VsdC4gSWYgbm90IHBhc3NlZCBpbiBhIG5ldyBvbmUgaXMgY3JlYXRlZC5cbiAgICAgKiBAcmV0dXJucyBBIHZlY3RvciB0aGF0IGlzIHRoZSBmbG9vciBvZiBlYWNoIGVsZW1lbnQgb2Ygdi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmbG9vcih2LCBkc3QpIHtcbiAgICAgICAgY29uc3QgbmV3RHN0ID0gKGRzdCA/PyBuZXcgQ3RvcigyKSk7XG4gICAgICAgIG5ld0RzdFswXSA9IE1hdGguZmxvb3IodlswXSk7XG4gICAgICAgIG5ld0RzdFsxXSA9IE1hdGguZmxvb3IodlsxXSk7XG4gICAgICAgIHJldHVybiBuZXdEc3Q7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFwcGxpZXMgTWF0aC5yb3VuZCB0byBlYWNoIGVsZW1lbnQgb2YgdmVjdG9yXG4gICAgICogQHBhcmFtIHYgLSBPcGVyYW5kIHZlY3Rvci5cbiAgICAgKiBAcGFyYW0gZHN0IC0gdmVjdG9yIHRvIGhvbGQgcmVzdWx0LiBJZiBub3QgcGFzc2VkIGluIGEgbmV3IG9uZSBpcyBjcmVhdGVkLlxuICAgICAqIEByZXR1cm5zIEEgdmVjdG9yIHRoYXQgaXMgdGhlIHJvdW5kIG9mIGVhY2ggZWxlbWVudCBvZiB2LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHJvdW5kKHYsIGRzdCkge1xuICAgICAgICBjb25zdCBuZXdEc3QgPSAoZHN0ID8/IG5ldyBDdG9yKDIpKTtcbiAgICAgICAgbmV3RHN0WzBdID0gTWF0aC5yb3VuZCh2WzBdKTtcbiAgICAgICAgbmV3RHN0WzFdID0gTWF0aC5yb3VuZCh2WzFdKTtcbiAgICAgICAgcmV0dXJuIG5ld0RzdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2xhbXAgZWFjaCBlbGVtZW50IG9mIHZlY3RvciBiZXR3ZWVuIG1pbiBhbmQgbWF4XG4gICAgICogQHBhcmFtIHYgLSBPcGVyYW5kIHZlY3Rvci5cbiAgICAgKiBAcGFyYW0gbWF4IC0gTWluIHZhbHVlLCBkZWZhdWx0IDBcbiAgICAgKiBAcGFyYW0gbWluIC0gTWF4IHZhbHVlLCBkZWZhdWx0IDFcbiAgICAgKiBAcGFyYW0gZHN0IC0gdmVjdG9yIHRvIGhvbGQgcmVzdWx0LiBJZiBub3QgcGFzc2VkIGluIGEgbmV3IG9uZSBpcyBjcmVhdGVkLlxuICAgICAqIEByZXR1cm5zIEEgdmVjdG9yIHRoYXQgdGhlIGNsYW1wZWQgdmFsdWUgb2YgZWFjaCBlbGVtZW50IG9mIHYuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY2xhbXAodiwgbWluID0gMCwgbWF4ID0gMSwgZHN0KSB7XG4gICAgICAgIGNvbnN0IG5ld0RzdCA9IChkc3QgPz8gbmV3IEN0b3IoMikpO1xuICAgICAgICBuZXdEc3RbMF0gPSBNYXRoLm1pbihtYXgsIE1hdGgubWF4KG1pbiwgdlswXSkpO1xuICAgICAgICBuZXdEc3RbMV0gPSBNYXRoLm1pbihtYXgsIE1hdGgubWF4KG1pbiwgdlsxXSkpO1xuICAgICAgICByZXR1cm4gbmV3RHN0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGRzIHR3byB2ZWN0b3JzOyBhc3N1bWVzIGEgYW5kIGIgaGF2ZSB0aGUgc2FtZSBkaW1lbnNpb24uXG4gICAgICogQHBhcmFtIGEgLSBPcGVyYW5kIHZlY3Rvci5cbiAgICAgKiBAcGFyYW0gYiAtIE9wZXJhbmQgdmVjdG9yLlxuICAgICAqIEBwYXJhbSBkc3QgLSB2ZWN0b3IgdG8gaG9sZCByZXN1bHQuIElmIG5vdCBwYXNzZWQgaW4gYSBuZXcgb25lIGlzIGNyZWF0ZWQuXG4gICAgICogQHJldHVybnMgQSB2ZWN0b3IgdGhhdCBpcyB0aGUgc3VtIG9mIGEgYW5kIGIuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYWRkKGEsIGIsIGRzdCkge1xuICAgICAgICBjb25zdCBuZXdEc3QgPSAoZHN0ID8/IG5ldyBDdG9yKDIpKTtcbiAgICAgICAgbmV3RHN0WzBdID0gYVswXSArIGJbMF07XG4gICAgICAgIG5ld0RzdFsxXSA9IGFbMV0gKyBiWzFdO1xuICAgICAgICByZXR1cm4gbmV3RHN0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGRzIHR3byB2ZWN0b3JzLCBzY2FsaW5nIHRoZSAybmQ7IGFzc3VtZXMgYSBhbmQgYiBoYXZlIHRoZSBzYW1lIGRpbWVuc2lvbi5cbiAgICAgKiBAcGFyYW0gYSAtIE9wZXJhbmQgdmVjdG9yLlxuICAgICAqIEBwYXJhbSBiIC0gT3BlcmFuZCB2ZWN0b3IuXG4gICAgICogQHBhcmFtIHNjYWxlIC0gQW1vdW50IHRvIHNjYWxlIGJcbiAgICAgKiBAcGFyYW0gZHN0IC0gdmVjdG9yIHRvIGhvbGQgcmVzdWx0LiBJZiBub3QgcGFzc2VkIGluIGEgbmV3IG9uZSBpcyBjcmVhdGVkLlxuICAgICAqIEByZXR1cm5zIEEgdmVjdG9yIHRoYXQgaXMgdGhlIHN1bSBvZiBhICsgYiAqIHNjYWxlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGFkZFNjYWxlZChhLCBiLCBzY2FsZSwgZHN0KSB7XG4gICAgICAgIGNvbnN0IG5ld0RzdCA9IChkc3QgPz8gbmV3IEN0b3IoMikpO1xuICAgICAgICBuZXdEc3RbMF0gPSBhWzBdICsgYlswXSAqIHNjYWxlO1xuICAgICAgICBuZXdEc3RbMV0gPSBhWzFdICsgYlsxXSAqIHNjYWxlO1xuICAgICAgICByZXR1cm4gbmV3RHN0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBhbmdsZSBpbiByYWRpYW5zIGJldHdlZW4gdHdvIHZlY3RvcnMuXG4gICAgICogQHBhcmFtIGEgLSBPcGVyYW5kIHZlY3Rvci5cbiAgICAgKiBAcGFyYW0gYiAtIE9wZXJhbmQgdmVjdG9yLlxuICAgICAqIEByZXR1cm5zIFRoZSBhbmdsZSBpbiByYWRpYW5zIGJldHdlZW4gdGhlIDIgdmVjdG9ycy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBhbmdsZShhLCBiKSB7XG4gICAgICAgIGNvbnN0IGF4ID0gYVswXTtcbiAgICAgICAgY29uc3QgYXkgPSBhWzFdO1xuICAgICAgICBjb25zdCBieCA9IGJbMF07XG4gICAgICAgIGNvbnN0IGJ5ID0gYlsxXTtcbiAgICAgICAgY29uc3QgbWFnMSA9IE1hdGguc3FydChheCAqIGF4ICsgYXkgKiBheSk7XG4gICAgICAgIGNvbnN0IG1hZzIgPSBNYXRoLnNxcnQoYnggKiBieCArIGJ5ICogYnkpO1xuICAgICAgICBjb25zdCBtYWcgPSBtYWcxICogbWFnMjtcbiAgICAgICAgY29uc3QgY29zaW5lID0gbWFnICYmIGRvdChhLCBiKSAvIG1hZztcbiAgICAgICAgcmV0dXJuIE1hdGguYWNvcyhjb3NpbmUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTdWJ0cmFjdHMgdHdvIHZlY3RvcnMuXG4gICAgICogQHBhcmFtIGEgLSBPcGVyYW5kIHZlY3Rvci5cbiAgICAgKiBAcGFyYW0gYiAtIE9wZXJhbmQgdmVjdG9yLlxuICAgICAqIEBwYXJhbSBkc3QgLSB2ZWN0b3IgdG8gaG9sZCByZXN1bHQuIElmIG5vdCBwYXNzZWQgaW4gYSBuZXcgb25lIGlzIGNyZWF0ZWQuXG4gICAgICogQHJldHVybnMgQSB2ZWN0b3IgdGhhdCBpcyB0aGUgZGlmZmVyZW5jZSBvZiBhIGFuZCBiLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHN1YnRyYWN0KGEsIGIsIGRzdCkge1xuICAgICAgICBjb25zdCBuZXdEc3QgPSAoZHN0ID8/IG5ldyBDdG9yKDIpKTtcbiAgICAgICAgbmV3RHN0WzBdID0gYVswXSAtIGJbMF07XG4gICAgICAgIG5ld0RzdFsxXSA9IGFbMV0gLSBiWzFdO1xuICAgICAgICByZXR1cm4gbmV3RHN0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTdWJ0cmFjdHMgdHdvIHZlY3RvcnMuXG4gICAgICogQHBhcmFtIGEgLSBPcGVyYW5kIHZlY3Rvci5cbiAgICAgKiBAcGFyYW0gYiAtIE9wZXJhbmQgdmVjdG9yLlxuICAgICAqIEBwYXJhbSBkc3QgLSB2ZWN0b3IgdG8gaG9sZCByZXN1bHQuIElmIG5vdCBwYXNzZWQgaW4gYSBuZXcgb25lIGlzIGNyZWF0ZWQuXG4gICAgICogQHJldHVybnMgQSB2ZWN0b3IgdGhhdCBpcyB0aGUgZGlmZmVyZW5jZSBvZiBhIGFuZCBiLlxuICAgICAqL1xuICAgIGNvbnN0IHN1YiA9IHN1YnRyYWN0O1xuICAgIC8qKlxuICAgICAqIENoZWNrIGlmIDIgdmVjdG9ycyBhcmUgYXBwcm94aW1hdGVseSBlcXVhbFxuICAgICAqIEBwYXJhbSBhIC0gT3BlcmFuZCB2ZWN0b3IuXG4gICAgICogQHBhcmFtIGIgLSBPcGVyYW5kIHZlY3Rvci5cbiAgICAgKiBAcmV0dXJucyB0cnVlIGlmIHZlY3RvcnMgYXJlIGFwcHJveGltYXRlbHkgZXF1YWxcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBlcXVhbHNBcHByb3hpbWF0ZWx5KGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIE1hdGguYWJzKGFbMF0gLSBiWzBdKSA8IEVQU0lMT04gJiZcbiAgICAgICAgICAgIE1hdGguYWJzKGFbMV0gLSBiWzFdKSA8IEVQU0lMT047XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENoZWNrIGlmIDIgdmVjdG9ycyBhcmUgZXhhY3RseSBlcXVhbFxuICAgICAqIEBwYXJhbSBhIC0gT3BlcmFuZCB2ZWN0b3IuXG4gICAgICogQHBhcmFtIGIgLSBPcGVyYW5kIHZlY3Rvci5cbiAgICAgKiBAcmV0dXJucyB0cnVlIGlmIHZlY3RvcnMgYXJlIGV4YWN0bHkgZXF1YWxcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBlcXVhbHMoYSwgYikge1xuICAgICAgICByZXR1cm4gYVswXSA9PT0gYlswXSAmJiBhWzFdID09PSBiWzFdO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQZXJmb3JtcyBsaW5lYXIgaW50ZXJwb2xhdGlvbiBvbiB0d28gdmVjdG9ycy5cbiAgICAgKiBHaXZlbiB2ZWN0b3JzIGEgYW5kIGIgYW5kIGludGVycG9sYXRpb24gY29lZmZpY2llbnQgdCwgcmV0dXJuc1xuICAgICAqIGEgKyB0ICogKGIgLSBhKS5cbiAgICAgKiBAcGFyYW0gYSAtIE9wZXJhbmQgdmVjdG9yLlxuICAgICAqIEBwYXJhbSBiIC0gT3BlcmFuZCB2ZWN0b3IuXG4gICAgICogQHBhcmFtIHQgLSBJbnRlcnBvbGF0aW9uIGNvZWZmaWNpZW50LlxuICAgICAqIEBwYXJhbSBkc3QgLSB2ZWN0b3IgdG8gaG9sZCByZXN1bHQuIElmIG5vdCBwYXNzZWQgaW4gYSBuZXcgb25lIGlzIGNyZWF0ZWQuXG4gICAgICogQHJldHVybnMgVGhlIGxpbmVhciBpbnRlcnBvbGF0ZWQgcmVzdWx0LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGxlcnAoYSwgYiwgdCwgZHN0KSB7XG4gICAgICAgIGNvbnN0IG5ld0RzdCA9IChkc3QgPz8gbmV3IEN0b3IoMikpO1xuICAgICAgICBuZXdEc3RbMF0gPSBhWzBdICsgdCAqIChiWzBdIC0gYVswXSk7XG4gICAgICAgIG5ld0RzdFsxXSA9IGFbMV0gKyB0ICogKGJbMV0gLSBhWzFdKTtcbiAgICAgICAgcmV0dXJuIG5ld0RzdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUGVyZm9ybXMgbGluZWFyIGludGVycG9sYXRpb24gb24gdHdvIHZlY3RvcnMuXG4gICAgICogR2l2ZW4gdmVjdG9ycyBhIGFuZCBiIGFuZCBpbnRlcnBvbGF0aW9uIGNvZWZmaWNpZW50IHZlY3RvciB0LCByZXR1cm5zXG4gICAgICogYSArIHQgKiAoYiAtIGEpLlxuICAgICAqIEBwYXJhbSBhIC0gT3BlcmFuZCB2ZWN0b3IuXG4gICAgICogQHBhcmFtIGIgLSBPcGVyYW5kIHZlY3Rvci5cbiAgICAgKiBAcGFyYW0gdCAtIEludGVycG9sYXRpb24gY29lZmZpY2llbnRzIHZlY3Rvci5cbiAgICAgKiBAcGFyYW0gZHN0IC0gdmVjdG9yIHRvIGhvbGQgcmVzdWx0LiBJZiBub3QgcGFzc2VkIGluIGEgbmV3IG9uZSBpcyBjcmVhdGVkLlxuICAgICAqIEByZXR1cm5zIHRoZSBsaW5lYXIgaW50ZXJwb2xhdGVkIHJlc3VsdC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBsZXJwVihhLCBiLCB0LCBkc3QpIHtcbiAgICAgICAgY29uc3QgbmV3RHN0ID0gKGRzdCA/PyBuZXcgQ3RvcigyKSk7XG4gICAgICAgIG5ld0RzdFswXSA9IGFbMF0gKyB0WzBdICogKGJbMF0gLSBhWzBdKTtcbiAgICAgICAgbmV3RHN0WzFdID0gYVsxXSArIHRbMV0gKiAoYlsxXSAtIGFbMV0pO1xuICAgICAgICByZXR1cm4gbmV3RHN0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gbWF4IHZhbHVlcyBvZiB0d28gdmVjdG9ycy5cbiAgICAgKiBHaXZlbiB2ZWN0b3JzIGEgYW5kIGIgcmV0dXJuc1xuICAgICAqIFttYXgoYVswXSwgYlswXSksIG1heChhWzFdLCBiWzFdKSwgbWF4KGFbMl0sIGJbMl0pXS5cbiAgICAgKiBAcGFyYW0gYSAtIE9wZXJhbmQgdmVjdG9yLlxuICAgICAqIEBwYXJhbSBiIC0gT3BlcmFuZCB2ZWN0b3IuXG4gICAgICogQHBhcmFtIGRzdCAtIHZlY3RvciB0byBob2xkIHJlc3VsdC4gSWYgbm90IHBhc3NlZCBpbiBhIG5ldyBvbmUgaXMgY3JlYXRlZC5cbiAgICAgKiBAcmV0dXJucyBUaGUgbWF4IGNvbXBvbmVudHMgdmVjdG9yLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG1heChhLCBiLCBkc3QpIHtcbiAgICAgICAgY29uc3QgbmV3RHN0ID0gKGRzdCA/PyBuZXcgQ3RvcigyKSk7XG4gICAgICAgIG5ld0RzdFswXSA9IE1hdGgubWF4KGFbMF0sIGJbMF0pO1xuICAgICAgICBuZXdEc3RbMV0gPSBNYXRoLm1heChhWzFdLCBiWzFdKTtcbiAgICAgICAgcmV0dXJuIG5ld0RzdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJuIG1pbiB2YWx1ZXMgb2YgdHdvIHZlY3RvcnMuXG4gICAgICogR2l2ZW4gdmVjdG9ycyBhIGFuZCBiIHJldHVybnNcbiAgICAgKiBbbWluKGFbMF0sIGJbMF0pLCBtaW4oYVsxXSwgYlsxXSksIG1pbihhWzJdLCBiWzJdKV0uXG4gICAgICogQHBhcmFtIGEgLSBPcGVyYW5kIHZlY3Rvci5cbiAgICAgKiBAcGFyYW0gYiAtIE9wZXJhbmQgdmVjdG9yLlxuICAgICAqIEBwYXJhbSBkc3QgLSB2ZWN0b3IgdG8gaG9sZCByZXN1bHQuIElmIG5vdCBwYXNzZWQgaW4gYSBuZXcgb25lIGlzIGNyZWF0ZWQuXG4gICAgICogQHJldHVybnMgVGhlIG1pbiBjb21wb25lbnRzIHZlY3Rvci5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBtaW4oYSwgYiwgZHN0KSB7XG4gICAgICAgIGNvbnN0IG5ld0RzdCA9IChkc3QgPz8gbmV3IEN0b3IoMikpO1xuICAgICAgICBuZXdEc3RbMF0gPSBNYXRoLm1pbihhWzBdLCBiWzBdKTtcbiAgICAgICAgbmV3RHN0WzFdID0gTWF0aC5taW4oYVsxXSwgYlsxXSk7XG4gICAgICAgIHJldHVybiBuZXdEc3Q7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE11bHRpcGxpZXMgYSB2ZWN0b3IgYnkgYSBzY2FsYXIuXG4gICAgICogQHBhcmFtIHYgLSBUaGUgdmVjdG9yLlxuICAgICAqIEBwYXJhbSBrIC0gVGhlIHNjYWxhci5cbiAgICAgKiBAcGFyYW0gZHN0IC0gdmVjdG9yIHRvIGhvbGQgcmVzdWx0LiBJZiBub3QgcGFzc2VkIGluIGEgbmV3IG9uZSBpcyBjcmVhdGVkLlxuICAgICAqIEByZXR1cm5zIFRoZSBzY2FsZWQgdmVjdG9yLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG11bFNjYWxhcih2LCBrLCBkc3QpIHtcbiAgICAgICAgY29uc3QgbmV3RHN0ID0gKGRzdCA/PyBuZXcgQ3RvcigyKSk7XG4gICAgICAgIG5ld0RzdFswXSA9IHZbMF0gKiBrO1xuICAgICAgICBuZXdEc3RbMV0gPSB2WzFdICogaztcbiAgICAgICAgcmV0dXJuIG5ld0RzdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTXVsdGlwbGllcyBhIHZlY3RvciBieSBhIHNjYWxhci4gKHNhbWUgYXMgbXVsU2NhbGFyKVxuICAgICAqIEBwYXJhbSB2IC0gVGhlIHZlY3Rvci5cbiAgICAgKiBAcGFyYW0gayAtIFRoZSBzY2FsYXIuXG4gICAgICogQHBhcmFtIGRzdCAtIHZlY3RvciB0byBob2xkIHJlc3VsdC4gSWYgbm90IHBhc3NlZCBpbiBhIG5ldyBvbmUgaXMgY3JlYXRlZC5cbiAgICAgKiBAcmV0dXJucyBUaGUgc2NhbGVkIHZlY3Rvci5cbiAgICAgKi9cbiAgICBjb25zdCBzY2FsZSA9IG11bFNjYWxhcjtcbiAgICAvKipcbiAgICAgKiBEaXZpZGVzIGEgdmVjdG9yIGJ5IGEgc2NhbGFyLlxuICAgICAqIEBwYXJhbSB2IC0gVGhlIHZlY3Rvci5cbiAgICAgKiBAcGFyYW0gayAtIFRoZSBzY2FsYXIuXG4gICAgICogQHBhcmFtIGRzdCAtIHZlY3RvciB0byBob2xkIHJlc3VsdC4gSWYgbm90IHBhc3NlZCBpbiBhIG5ldyBvbmUgaXMgY3JlYXRlZC5cbiAgICAgKiBAcmV0dXJucyBUaGUgc2NhbGVkIHZlY3Rvci5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBkaXZTY2FsYXIodiwgaywgZHN0KSB7XG4gICAgICAgIGNvbnN0IG5ld0RzdCA9IChkc3QgPz8gbmV3IEN0b3IoMikpO1xuICAgICAgICBuZXdEc3RbMF0gPSB2WzBdIC8gaztcbiAgICAgICAgbmV3RHN0WzFdID0gdlsxXSAvIGs7XG4gICAgICAgIHJldHVybiBuZXdEc3Q7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEludmVyc2UgYSB2ZWN0b3IuXG4gICAgICogQHBhcmFtIHYgLSBUaGUgdmVjdG9yLlxuICAgICAqIEBwYXJhbSBkc3QgLSB2ZWN0b3IgdG8gaG9sZCByZXN1bHQuIElmIG5vdCBwYXNzZWQgaW4gYSBuZXcgb25lIGlzIGNyZWF0ZWQuXG4gICAgICogQHJldHVybnMgVGhlIGludmVydGVkIHZlY3Rvci5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpbnZlcnNlKHYsIGRzdCkge1xuICAgICAgICBjb25zdCBuZXdEc3QgPSAoZHN0ID8/IG5ldyBDdG9yKDIpKTtcbiAgICAgICAgbmV3RHN0WzBdID0gMSAvIHZbMF07XG4gICAgICAgIG5ld0RzdFsxXSA9IDEgLyB2WzFdO1xuICAgICAgICByZXR1cm4gbmV3RHN0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJbnZlcnQgYSB2ZWN0b3IuIChzYW1lIGFzIGludmVyc2UpXG4gICAgICogQHBhcmFtIHYgLSBUaGUgdmVjdG9yLlxuICAgICAqIEBwYXJhbSBkc3QgLSB2ZWN0b3IgdG8gaG9sZCByZXN1bHQuIElmIG5vdCBwYXNzZWQgaW4gYSBuZXcgb25lIGlzIGNyZWF0ZWQuXG4gICAgICogQHJldHVybnMgVGhlIGludmVydGVkIHZlY3Rvci5cbiAgICAgKi9cbiAgICBjb25zdCBpbnZlcnQgPSBpbnZlcnNlO1xuICAgIC8qKlxuICAgICAqIENvbXB1dGVzIHRoZSBjcm9zcyBwcm9kdWN0IG9mIHR3byB2ZWN0b3JzOyBhc3N1bWVzIGJvdGggdmVjdG9ycyBoYXZlXG4gICAgICogdGhyZWUgZW50cmllcy5cbiAgICAgKiBAcGFyYW0gYSAtIE9wZXJhbmQgdmVjdG9yLlxuICAgICAqIEBwYXJhbSBiIC0gT3BlcmFuZCB2ZWN0b3IuXG4gICAgICogQHBhcmFtIGRzdCAtIHZlY3RvciB0byBob2xkIHJlc3VsdC4gSWYgbm90IHBhc3NlZCBpbiBhIG5ldyBvbmUgaXMgY3JlYXRlZC5cbiAgICAgKiBAcmV0dXJucyBUaGUgdmVjdG9yIG9mIGEgY3Jvc3MgYi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcm9zcyhhLCBiLCBkc3QpIHtcbiAgICAgICAgY29uc3QgbmV3RHN0ID0gKGRzdCA/PyBuZXcgQ3RvcigzKSk7XG4gICAgICAgIGNvbnN0IHogPSBhWzBdICogYlsxXSAtIGFbMV0gKiBiWzBdO1xuICAgICAgICBuZXdEc3RbMF0gPSAwO1xuICAgICAgICBuZXdEc3RbMV0gPSAwO1xuICAgICAgICBuZXdEc3RbMl0gPSB6O1xuICAgICAgICByZXR1cm4gbmV3RHN0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb21wdXRlcyB0aGUgZG90IHByb2R1Y3Qgb2YgdHdvIHZlY3RvcnM7IGFzc3VtZXMgYm90aCB2ZWN0b3JzIGhhdmVcbiAgICAgKiB0aHJlZSBlbnRyaWVzLlxuICAgICAqIEBwYXJhbSBhIC0gT3BlcmFuZCB2ZWN0b3IuXG4gICAgICogQHBhcmFtIGIgLSBPcGVyYW5kIHZlY3Rvci5cbiAgICAgKiBAcmV0dXJucyBkb3QgcHJvZHVjdFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGRvdChhLCBiKSB7XG4gICAgICAgIHJldHVybiBhWzBdICogYlswXSArIGFbMV0gKiBiWzFdO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb21wdXRlcyB0aGUgbGVuZ3RoIG9mIHZlY3RvclxuICAgICAqIEBwYXJhbSB2IC0gdmVjdG9yLlxuICAgICAqIEByZXR1cm5zIGxlbmd0aCBvZiB2ZWN0b3IuXG4gICAgICovXG4gICAgZnVuY3Rpb24gbGVuZ3RoKHYpIHtcbiAgICAgICAgY29uc3QgdjAgPSB2WzBdO1xuICAgICAgICBjb25zdCB2MSA9IHZbMV07XG4gICAgICAgIHJldHVybiBNYXRoLnNxcnQodjAgKiB2MCArIHYxICogdjEpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb21wdXRlcyB0aGUgbGVuZ3RoIG9mIHZlY3RvciAoc2FtZSBhcyBsZW5ndGgpXG4gICAgICogQHBhcmFtIHYgLSB2ZWN0b3IuXG4gICAgICogQHJldHVybnMgbGVuZ3RoIG9mIHZlY3Rvci5cbiAgICAgKi9cbiAgICBjb25zdCBsZW4gPSBsZW5ndGg7XG4gICAgLyoqXG4gICAgICogQ29tcHV0ZXMgdGhlIHNxdWFyZSBvZiB0aGUgbGVuZ3RoIG9mIHZlY3RvclxuICAgICAqIEBwYXJhbSB2IC0gdmVjdG9yLlxuICAgICAqIEByZXR1cm5zIHNxdWFyZSBvZiB0aGUgbGVuZ3RoIG9mIHZlY3Rvci5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBsZW5ndGhTcSh2KSB7XG4gICAgICAgIGNvbnN0IHYwID0gdlswXTtcbiAgICAgICAgY29uc3QgdjEgPSB2WzFdO1xuICAgICAgICByZXR1cm4gdjAgKiB2MCArIHYxICogdjE7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbXB1dGVzIHRoZSBzcXVhcmUgb2YgdGhlIGxlbmd0aCBvZiB2ZWN0b3IgKHNhbWUgYXMgbGVuZ3RoU3EpXG4gICAgICogQHBhcmFtIHYgLSB2ZWN0b3IuXG4gICAgICogQHJldHVybnMgc3F1YXJlIG9mIHRoZSBsZW5ndGggb2YgdmVjdG9yLlxuICAgICAqL1xuICAgIGNvbnN0IGxlblNxID0gbGVuZ3RoU3E7XG4gICAgLyoqXG4gICAgICogQ29tcHV0ZXMgdGhlIGRpc3RhbmNlIGJldHdlZW4gMiBwb2ludHNcbiAgICAgKiBAcGFyYW0gYSAtIHZlY3Rvci5cbiAgICAgKiBAcGFyYW0gYiAtIHZlY3Rvci5cbiAgICAgKiBAcmV0dXJucyBkaXN0YW5jZSBiZXR3ZWVuIGEgYW5kIGJcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBkaXN0YW5jZShhLCBiKSB7XG4gICAgICAgIGNvbnN0IGR4ID0gYVswXSAtIGJbMF07XG4gICAgICAgIGNvbnN0IGR5ID0gYVsxXSAtIGJbMV07XG4gICAgICAgIHJldHVybiBNYXRoLnNxcnQoZHggKiBkeCArIGR5ICogZHkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb21wdXRlcyB0aGUgZGlzdGFuY2UgYmV0d2VlbiAyIHBvaW50cyAoc2FtZSBhcyBkaXN0YW5jZSlcbiAgICAgKiBAcGFyYW0gYSAtIHZlY3Rvci5cbiAgICAgKiBAcGFyYW0gYiAtIHZlY3Rvci5cbiAgICAgKiBAcmV0dXJucyBkaXN0YW5jZSBiZXR3ZWVuIGEgYW5kIGJcbiAgICAgKi9cbiAgICBjb25zdCBkaXN0ID0gZGlzdGFuY2U7XG4gICAgLyoqXG4gICAgICogQ29tcHV0ZXMgdGhlIHNxdWFyZSBvZiB0aGUgZGlzdGFuY2UgYmV0d2VlbiAyIHBvaW50c1xuICAgICAqIEBwYXJhbSBhIC0gdmVjdG9yLlxuICAgICAqIEBwYXJhbSBiIC0gdmVjdG9yLlxuICAgICAqIEByZXR1cm5zIHNxdWFyZSBvZiB0aGUgZGlzdGFuY2UgYmV0d2VlbiBhIGFuZCBiXG4gICAgICovXG4gICAgZnVuY3Rpb24gZGlzdGFuY2VTcShhLCBiKSB7XG4gICAgICAgIGNvbnN0IGR4ID0gYVswXSAtIGJbMF07XG4gICAgICAgIGNvbnN0IGR5ID0gYVsxXSAtIGJbMV07XG4gICAgICAgIHJldHVybiBkeCAqIGR4ICsgZHkgKiBkeTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29tcHV0ZXMgdGhlIHNxdWFyZSBvZiB0aGUgZGlzdGFuY2UgYmV0d2VlbiAyIHBvaW50cyAoc2FtZSBhcyBkaXN0YW5jZVNxKVxuICAgICAqIEBwYXJhbSBhIC0gdmVjdG9yLlxuICAgICAqIEBwYXJhbSBiIC0gdmVjdG9yLlxuICAgICAqIEByZXR1cm5zIHNxdWFyZSBvZiB0aGUgZGlzdGFuY2UgYmV0d2VlbiBhIGFuZCBiXG4gICAgICovXG4gICAgY29uc3QgZGlzdFNxID0gZGlzdGFuY2VTcTtcbiAgICAvKipcbiAgICAgKiBEaXZpZGVzIGEgdmVjdG9yIGJ5IGl0cyBFdWNsaWRlYW4gbGVuZ3RoIGFuZCByZXR1cm5zIHRoZSBxdW90aWVudC5cbiAgICAgKiBAcGFyYW0gdiAtIFRoZSB2ZWN0b3IuXG4gICAgICogQHBhcmFtIGRzdCAtIHZlY3RvciB0byBob2xkIHJlc3VsdC4gSWYgbm90IHBhc3NlZCBpbiBhIG5ldyBvbmUgaXMgY3JlYXRlZC5cbiAgICAgKiBAcmV0dXJucyBUaGUgbm9ybWFsaXplZCB2ZWN0b3IuXG4gICAgICovXG4gICAgZnVuY3Rpb24gbm9ybWFsaXplKHYsIGRzdCkge1xuICAgICAgICBjb25zdCBuZXdEc3QgPSAoZHN0ID8/IG5ldyBDdG9yKDIpKTtcbiAgICAgICAgY29uc3QgdjAgPSB2WzBdO1xuICAgICAgICBjb25zdCB2MSA9IHZbMV07XG4gICAgICAgIGNvbnN0IGxlbiA9IE1hdGguc3FydCh2MCAqIHYwICsgdjEgKiB2MSk7XG4gICAgICAgIGlmIChsZW4gPiAwLjAwMDAxKSB7XG4gICAgICAgICAgICBuZXdEc3RbMF0gPSB2MCAvIGxlbjtcbiAgICAgICAgICAgIG5ld0RzdFsxXSA9IHYxIC8gbGVuO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbmV3RHN0WzBdID0gMDtcbiAgICAgICAgICAgIG5ld0RzdFsxXSA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ld0RzdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTmVnYXRlcyBhIHZlY3Rvci5cbiAgICAgKiBAcGFyYW0gdiAtIFRoZSB2ZWN0b3IuXG4gICAgICogQHBhcmFtIGRzdCAtIHZlY3RvciB0byBob2xkIHJlc3VsdC4gSWYgbm90IHBhc3NlZCBpbiBhIG5ldyBvbmUgaXMgY3JlYXRlZC5cbiAgICAgKiBAcmV0dXJucyAtdi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBuZWdhdGUodiwgZHN0KSB7XG4gICAgICAgIGNvbnN0IG5ld0RzdCA9IChkc3QgPz8gbmV3IEN0b3IoMikpO1xuICAgICAgICBuZXdEc3RbMF0gPSAtdlswXTtcbiAgICAgICAgbmV3RHN0WzFdID0gLXZbMV07XG4gICAgICAgIHJldHVybiBuZXdEc3Q7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvcGllcyBhIHZlY3Rvci4gKHNhbWUgYXMge0BsaW5rIHZlYzIuY2xvbmV9KVxuICAgICAqIEFsc28gc2VlIHtAbGluayB2ZWMyLmNyZWF0ZX0gYW5kIHtAbGluayB2ZWMyLnNldH1cbiAgICAgKiBAcGFyYW0gdiAtIFRoZSB2ZWN0b3IuXG4gICAgICogQHBhcmFtIGRzdCAtIHZlY3RvciB0byBob2xkIHJlc3VsdC4gSWYgbm90IHBhc3NlZCBpbiBhIG5ldyBvbmUgaXMgY3JlYXRlZC5cbiAgICAgKiBAcmV0dXJucyBBIGNvcHkgb2Ygdi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjb3B5KHYsIGRzdCkge1xuICAgICAgICBjb25zdCBuZXdEc3QgPSAoZHN0ID8/IG5ldyBDdG9yKDIpKTtcbiAgICAgICAgbmV3RHN0WzBdID0gdlswXTtcbiAgICAgICAgbmV3RHN0WzFdID0gdlsxXTtcbiAgICAgICAgcmV0dXJuIG5ld0RzdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2xvbmVzIGEgdmVjdG9yLiAoc2FtZSBhcyB7QGxpbmsgdmVjMi5jb3B5fSlcbiAgICAgKiBBbHNvIHNlZSB7QGxpbmsgdmVjMi5jcmVhdGV9IGFuZCB7QGxpbmsgdmVjMi5zZXR9XG4gICAgICogQHBhcmFtIHYgLSBUaGUgdmVjdG9yLlxuICAgICAqIEBwYXJhbSBkc3QgLSB2ZWN0b3IgdG8gaG9sZCByZXN1bHQuIElmIG5vdCBwYXNzZWQgaW4gYSBuZXcgb25lIGlzIGNyZWF0ZWQuXG4gICAgICogQHJldHVybnMgQSBjb3B5IG9mIHYuXG4gICAgICovXG4gICAgY29uc3QgY2xvbmUgPSBjb3B5O1xuICAgIC8qKlxuICAgICAqIE11bHRpcGxpZXMgYSB2ZWN0b3IgYnkgYW5vdGhlciB2ZWN0b3IgKGNvbXBvbmVudC13aXNlKTsgYXNzdW1lcyBhIGFuZFxuICAgICAqIGIgaGF2ZSB0aGUgc2FtZSBsZW5ndGguXG4gICAgICogQHBhcmFtIGEgLSBPcGVyYW5kIHZlY3Rvci5cbiAgICAgKiBAcGFyYW0gYiAtIE9wZXJhbmQgdmVjdG9yLlxuICAgICAqIEBwYXJhbSBkc3QgLSB2ZWN0b3IgdG8gaG9sZCByZXN1bHQuIElmIG5vdCBwYXNzZWQgaW4gYSBuZXcgb25lIGlzIGNyZWF0ZWQuXG4gICAgICogQHJldHVybnMgVGhlIHZlY3RvciBvZiBwcm9kdWN0cyBvZiBlbnRyaWVzIG9mIGEgYW5kIGIuXG4gICAgICovXG4gICAgZnVuY3Rpb24gbXVsdGlwbHkoYSwgYiwgZHN0KSB7XG4gICAgICAgIGNvbnN0IG5ld0RzdCA9IChkc3QgPz8gbmV3IEN0b3IoMikpO1xuICAgICAgICBuZXdEc3RbMF0gPSBhWzBdICogYlswXTtcbiAgICAgICAgbmV3RHN0WzFdID0gYVsxXSAqIGJbMV07XG4gICAgICAgIHJldHVybiBuZXdEc3Q7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE11bHRpcGxpZXMgYSB2ZWN0b3IgYnkgYW5vdGhlciB2ZWN0b3IgKGNvbXBvbmVudC13aXNlKTsgYXNzdW1lcyBhIGFuZFxuICAgICAqIGIgaGF2ZSB0aGUgc2FtZSBsZW5ndGguIChzYW1lIGFzIG11bClcbiAgICAgKiBAcGFyYW0gYSAtIE9wZXJhbmQgdmVjdG9yLlxuICAgICAqIEBwYXJhbSBiIC0gT3BlcmFuZCB2ZWN0b3IuXG4gICAgICogQHBhcmFtIGRzdCAtIHZlY3RvciB0byBob2xkIHJlc3VsdC4gSWYgbm90IHBhc3NlZCBpbiBhIG5ldyBvbmUgaXMgY3JlYXRlZC5cbiAgICAgKiBAcmV0dXJucyBUaGUgdmVjdG9yIG9mIHByb2R1Y3RzIG9mIGVudHJpZXMgb2YgYSBhbmQgYi5cbiAgICAgKi9cbiAgICBjb25zdCBtdWwgPSBtdWx0aXBseTtcbiAgICAvKipcbiAgICAgKiBEaXZpZGVzIGEgdmVjdG9yIGJ5IGFub3RoZXIgdmVjdG9yIChjb21wb25lbnQtd2lzZSk7IGFzc3VtZXMgYSBhbmRcbiAgICAgKiBiIGhhdmUgdGhlIHNhbWUgbGVuZ3RoLlxuICAgICAqIEBwYXJhbSBhIC0gT3BlcmFuZCB2ZWN0b3IuXG4gICAgICogQHBhcmFtIGIgLSBPcGVyYW5kIHZlY3Rvci5cbiAgICAgKiBAcGFyYW0gZHN0IC0gdmVjdG9yIHRvIGhvbGQgcmVzdWx0LiBJZiBub3QgcGFzc2VkIGluIGEgbmV3IG9uZSBpcyBjcmVhdGVkLlxuICAgICAqIEByZXR1cm5zIFRoZSB2ZWN0b3Igb2YgcXVvdGllbnRzIG9mIGVudHJpZXMgb2YgYSBhbmQgYi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBkaXZpZGUoYSwgYiwgZHN0KSB7XG4gICAgICAgIGNvbnN0IG5ld0RzdCA9IChkc3QgPz8gbmV3IEN0b3IoMikpO1xuICAgICAgICBuZXdEc3RbMF0gPSBhWzBdIC8gYlswXTtcbiAgICAgICAgbmV3RHN0WzFdID0gYVsxXSAvIGJbMV07XG4gICAgICAgIHJldHVybiBuZXdEc3Q7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERpdmlkZXMgYSB2ZWN0b3IgYnkgYW5vdGhlciB2ZWN0b3IgKGNvbXBvbmVudC13aXNlKTsgYXNzdW1lcyBhIGFuZFxuICAgICAqIGIgaGF2ZSB0aGUgc2FtZSBsZW5ndGguIChzYW1lIGFzIGRpdmlkZSlcbiAgICAgKiBAcGFyYW0gYSAtIE9wZXJhbmQgdmVjdG9yLlxuICAgICAqIEBwYXJhbSBiIC0gT3BlcmFuZCB2ZWN0b3IuXG4gICAgICogQHBhcmFtIGRzdCAtIHZlY3RvciB0byBob2xkIHJlc3VsdC4gSWYgbm90IHBhc3NlZCBpbiBhIG5ldyBvbmUgaXMgY3JlYXRlZC5cbiAgICAgKiBAcmV0dXJucyBUaGUgdmVjdG9yIG9mIHF1b3RpZW50cyBvZiBlbnRyaWVzIG9mIGEgYW5kIGIuXG4gICAgICovXG4gICAgY29uc3QgZGl2ID0gZGl2aWRlO1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSByYW5kb20gdW5pdCB2ZWN0b3IgKiBzY2FsZVxuICAgICAqIEBwYXJhbSBzY2FsZSAtIERlZmF1bHQgMVxuICAgICAqIEBwYXJhbSBkc3QgLSB2ZWN0b3IgdG8gaG9sZCByZXN1bHQuIElmIG5vdCBwYXNzZWQgaW4gYSBuZXcgb25lIGlzIGNyZWF0ZWQuXG4gICAgICogQHJldHVybnMgVGhlIHJhbmRvbSB2ZWN0b3IuXG4gICAgICovXG4gICAgZnVuY3Rpb24gcmFuZG9tKHNjYWxlID0gMSwgZHN0KSB7XG4gICAgICAgIGNvbnN0IG5ld0RzdCA9IChkc3QgPz8gbmV3IEN0b3IoMikpO1xuICAgICAgICBjb25zdCBhbmdsZSA9IE1hdGgucmFuZG9tKCkgKiAyICogTWF0aC5QSTtcbiAgICAgICAgbmV3RHN0WzBdID0gTWF0aC5jb3MoYW5nbGUpICogc2NhbGU7XG4gICAgICAgIG5ld0RzdFsxXSA9IE1hdGguc2luKGFuZ2xlKSAqIHNjYWxlO1xuICAgICAgICByZXR1cm4gbmV3RHN0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBaZXJvJ3MgYSB2ZWN0b3JcbiAgICAgKiBAcGFyYW0gZHN0IC0gdmVjdG9yIHRvIGhvbGQgcmVzdWx0LiBJZiBub3QgcGFzc2VkIGluIGEgbmV3IG9uZSBpcyBjcmVhdGVkLlxuICAgICAqIEByZXR1cm5zIFRoZSB6ZXJvZWQgdmVjdG9yLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHplcm8oZHN0KSB7XG4gICAgICAgIGNvbnN0IG5ld0RzdCA9IChkc3QgPz8gbmV3IEN0b3IoMikpO1xuICAgICAgICBuZXdEc3RbMF0gPSAwO1xuICAgICAgICBuZXdEc3RbMV0gPSAwO1xuICAgICAgICByZXR1cm4gbmV3RHN0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiB0cmFuc2Zvcm0gVmVjMiBieSA0eDQgbWF0cml4XG4gICAgICogQHBhcmFtIHYgLSB0aGUgdmVjdG9yXG4gICAgICogQHBhcmFtIG0gLSBUaGUgbWF0cml4LlxuICAgICAqIEBwYXJhbSBkc3QgLSBvcHRpb25hbCBWZWMyIHRvIHN0b3JlIHJlc3VsdC4gSWYgbm90IHBhc3NlZCBhIG5ldyBvbmUgaXMgY3JlYXRlZC5cbiAgICAgKiBAcmV0dXJucyB0aGUgdHJhbnNmb3JtZWQgdmVjdG9yXG4gICAgICovXG4gICAgZnVuY3Rpb24gdHJhbnNmb3JtTWF0NCh2LCBtLCBkc3QpIHtcbiAgICAgICAgY29uc3QgbmV3RHN0ID0gKGRzdCA/PyBuZXcgQ3RvcigyKSk7XG4gICAgICAgIGNvbnN0IHggPSB2WzBdO1xuICAgICAgICBjb25zdCB5ID0gdlsxXTtcbiAgICAgICAgbmV3RHN0WzBdID0geCAqIG1bMF0gKyB5ICogbVs0XSArIG1bMTJdO1xuICAgICAgICBuZXdEc3RbMV0gPSB4ICogbVsxXSArIHkgKiBtWzVdICsgbVsxM107XG4gICAgICAgIHJldHVybiBuZXdEc3Q7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRyYW5zZm9ybXMgdmVjNCBieSAzeDMgbWF0cml4XG4gICAgICpcbiAgICAgKiBAcGFyYW0gdiAtIHRoZSB2ZWN0b3JcbiAgICAgKiBAcGFyYW0gbSAtIFRoZSBtYXRyaXguXG4gICAgICogQHBhcmFtIGRzdCAtIG9wdGlvbmFsIFZlYzIgdG8gc3RvcmUgcmVzdWx0LiBJZiBub3QgcGFzc2VkIGEgbmV3IG9uZSBpcyBjcmVhdGVkLlxuICAgICAqIEByZXR1cm5zIHRoZSB0cmFuc2Zvcm1lZCB2ZWN0b3JcbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0cmFuc2Zvcm1NYXQzKHYsIG0sIGRzdCkge1xuICAgICAgICBjb25zdCBuZXdEc3QgPSAoZHN0ID8/IG5ldyBDdG9yKDIpKTtcbiAgICAgICAgY29uc3QgeCA9IHZbMF07XG4gICAgICAgIGNvbnN0IHkgPSB2WzFdO1xuICAgICAgICBuZXdEc3RbMF0gPSBtWzBdICogeCArIG1bNF0gKiB5ICsgbVs4XTtcbiAgICAgICAgbmV3RHN0WzFdID0gbVsxXSAqIHggKyBtWzVdICogeSArIG1bOV07XG4gICAgICAgIHJldHVybiBuZXdEc3Q7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJvdGF0ZSBhIDJEIHZlY3RvclxuICAgICAqXG4gICAgICogQHBhcmFtIGEgVGhlIHZlYzIgcG9pbnQgdG8gcm90YXRlXG4gICAgICogQHBhcmFtIGIgVGhlIG9yaWdpbiBvZiB0aGUgcm90YXRpb25cbiAgICAgKiBAcGFyYW0gcmFkIFRoZSBhbmdsZSBvZiByb3RhdGlvbiBpbiByYWRpYW5zXG4gICAgICogQHJldHVybnMgdGhlIHJvdGF0ZWQgdmVjdG9yXG4gICAgICovXG4gICAgZnVuY3Rpb24gcm90YXRlKGEsIGIsIHJhZCwgZHN0KSB7XG4gICAgICAgIGNvbnN0IG5ld0RzdCA9IChkc3QgPz8gbmV3IEN0b3IoMikpO1xuICAgICAgICAvLyBUcmFuc2xhdGUgcG9pbnQgdG8gdGhlIG9yaWdpblxuICAgICAgICBjb25zdCBwMCA9IGFbMF0gLSBiWzBdO1xuICAgICAgICBjb25zdCBwMSA9IGFbMV0gLSBiWzFdO1xuICAgICAgICBjb25zdCBzaW5DID0gTWF0aC5zaW4ocmFkKTtcbiAgICAgICAgY29uc3QgY29zQyA9IE1hdGguY29zKHJhZCk7XG4gICAgICAgIC8vcGVyZm9ybSByb3RhdGlvbiBhbmQgdHJhbnNsYXRlIHRvIGNvcnJlY3QgcG9zaXRpb25cbiAgICAgICAgbmV3RHN0WzBdID0gcDAgKiBjb3NDIC0gcDEgKiBzaW5DICsgYlswXTtcbiAgICAgICAgbmV3RHN0WzFdID0gcDAgKiBzaW5DICsgcDEgKiBjb3NDICsgYlsxXTtcbiAgICAgICAgcmV0dXJuIG5ld0RzdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVHJlYXQgYSAyRCB2ZWN0b3IgYXMgYSBkaXJlY3Rpb24gYW5kIHNldCBpdCdzIGxlbmd0aFxuICAgICAqXG4gICAgICogQHBhcmFtIGEgVGhlIHZlYzIgdG8gbGVuZ3RoZW5cbiAgICAgKiBAcGFyYW0gbGVuIFRoZSBsZW5ndGggb2YgdGhlIHJlc3VsdGluZyB2ZWN0b3JcbiAgICAgKiBAcmV0dXJucyBUaGUgbGVuZ3RoZW5lZCB2ZWN0b3JcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzZXRMZW5ndGgoYSwgbGVuLCBkc3QpIHtcbiAgICAgICAgY29uc3QgbmV3RHN0ID0gKGRzdCA/PyBuZXcgQ3RvcigyKSk7XG4gICAgICAgIG5vcm1hbGl6ZShhLCBuZXdEc3QpO1xuICAgICAgICByZXR1cm4gbXVsU2NhbGFyKG5ld0RzdCwgbGVuLCBuZXdEc3QpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBFbnN1cmUgYSB2ZWN0b3IgaXMgbm90IGxvbmdlciB0aGFuIGEgbWF4IGxlbmd0aFxuICAgICAqXG4gICAgICogQHBhcmFtIGEgVGhlIHZlYzIgdG8gbGltaXRcbiAgICAgKiBAcGFyYW0gbWF4TGVuIFRoZSBsb25nZXN0IGxlbmd0aCBvZiB0aGUgcmVzdWx0aW5nIHZlY3RvclxuICAgICAqIEByZXR1cm5zIFRoZSB2ZWN0b3IsIHNob3J0ZW5lZCB0byBtYXhMZW4gaWYgaXQncyB0b28gbG9uZ1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRydW5jYXRlKGEsIG1heExlbiwgZHN0KSB7XG4gICAgICAgIGNvbnN0IG5ld0RzdCA9IChkc3QgPz8gbmV3IEN0b3IoMikpO1xuICAgICAgICBpZiAobGVuZ3RoKGEpID4gbWF4TGVuKSB7XG4gICAgICAgICAgICByZXR1cm4gc2V0TGVuZ3RoKGEsIG1heExlbiwgbmV3RHN0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY29weShhLCBuZXdEc3QpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gdGhlIHZlY3RvciBleGFjdGx5IGJldHdlZW4gMiBlbmRwb2ludCB2ZWN0b3JzXG4gICAgICpcbiAgICAgKiBAcGFyYW0gYSBFbmRwb2ludCAxXG4gICAgICogQHBhcmFtIGIgRW5kcG9pbnQgMlxuICAgICAqIEByZXR1cm5zIFRoZSB2ZWN0b3IgZXhhY3RseSByZXNpZGluZyBiZXR3ZWVuIGVuZHBvaW50cyAxIGFuZCAyXG4gICAgICovXG4gICAgZnVuY3Rpb24gbWlkcG9pbnQoYSwgYiwgZHN0KSB7XG4gICAgICAgIGNvbnN0IG5ld0RzdCA9IChkc3QgPz8gbmV3IEN0b3IoMikpO1xuICAgICAgICByZXR1cm4gbGVycChhLCBiLCAwLjUsIG5ld0RzdCk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIGNyZWF0ZSxcbiAgICAgICAgZnJvbVZhbHVlcyxcbiAgICAgICAgc2V0LFxuICAgICAgICBjZWlsLFxuICAgICAgICBmbG9vcixcbiAgICAgICAgcm91bmQsXG4gICAgICAgIGNsYW1wLFxuICAgICAgICBhZGQsXG4gICAgICAgIGFkZFNjYWxlZCxcbiAgICAgICAgYW5nbGUsXG4gICAgICAgIHN1YnRyYWN0LFxuICAgICAgICBzdWIsXG4gICAgICAgIGVxdWFsc0FwcHJveGltYXRlbHksXG4gICAgICAgIGVxdWFscyxcbiAgICAgICAgbGVycCxcbiAgICAgICAgbGVycFYsXG4gICAgICAgIG1heCxcbiAgICAgICAgbWluLFxuICAgICAgICBtdWxTY2FsYXIsXG4gICAgICAgIHNjYWxlLFxuICAgICAgICBkaXZTY2FsYXIsXG4gICAgICAgIGludmVyc2UsXG4gICAgICAgIGludmVydCxcbiAgICAgICAgY3Jvc3MsXG4gICAgICAgIGRvdCxcbiAgICAgICAgbGVuZ3RoLFxuICAgICAgICBsZW4sXG4gICAgICAgIGxlbmd0aFNxLFxuICAgICAgICBsZW5TcSxcbiAgICAgICAgZGlzdGFuY2UsXG4gICAgICAgIGRpc3QsXG4gICAgICAgIGRpc3RhbmNlU3EsXG4gICAgICAgIGRpc3RTcSxcbiAgICAgICAgbm9ybWFsaXplLFxuICAgICAgICBuZWdhdGUsXG4gICAgICAgIGNvcHksXG4gICAgICAgIGNsb25lLFxuICAgICAgICBtdWx0aXBseSxcbiAgICAgICAgbXVsLFxuICAgICAgICBkaXZpZGUsXG4gICAgICAgIGRpdixcbiAgICAgICAgcmFuZG9tLFxuICAgICAgICB6ZXJvLFxuICAgICAgICB0cmFuc2Zvcm1NYXQ0LFxuICAgICAgICB0cmFuc2Zvcm1NYXQzLFxuICAgICAgICByb3RhdGUsXG4gICAgICAgIHNldExlbmd0aCxcbiAgICAgICAgdHJ1bmNhdGUsXG4gICAgICAgIG1pZHBvaW50LFxuICAgIH07XG59XG5jb25zdCBjYWNoZSQ1ID0gbmV3IE1hcCgpO1xuZnVuY3Rpb24gZ2V0QVBJJDUoQ3Rvcikge1xuICAgIGxldCBhcGkgPSBjYWNoZSQ1LmdldChDdG9yKTtcbiAgICBpZiAoIWFwaSkge1xuICAgICAgICBhcGkgPSBnZXRBUElJbXBsJDUoQ3Rvcik7XG4gICAgICAgIGNhY2hlJDUuc2V0KEN0b3IsIGFwaSk7XG4gICAgfVxuICAgIHJldHVybiBhcGk7XG59XG5cbi8qXG4gKiBDb3B5cmlnaHQgMjAyMiBHcmVnZyBUYXZhcmVzXG4gKlxuICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbiAqIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSxcbiAqIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb25cbiAqIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLFxuICogYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlXG4gKiBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuICpcbiAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4gKiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbiAqXG4gKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4gKiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbiAqIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuICBJTiBOTyBFVkVOVCBTSEFMTFxuICogVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbiAqIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HXG4gKiBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSXG4gKiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG4gKi9cbi8qKlxuICogR2VuZXJhdGVzIGEgdHlwZWQgQVBJIGZvciBNYXQzXG4gKiAqL1xuZnVuY3Rpb24gZ2V0QVBJSW1wbCQ0KEN0b3IpIHtcbiAgICBjb25zdCB2ZWMyID0gZ2V0QVBJJDUoQ3Rvcik7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgTWF0MyBmcm9tIHZhbHVlc1xuICAgICAqXG4gICAgICogTm90ZTogU2luY2UgcGFzc2luZyBpbiBhIHJhdyBKYXZhU2NyaXB0IGFycmF5XG4gICAgICogaXMgdmFsaWQgaW4gYWxsIGNpcmN1bXN0YW5jZXMsIGlmIHlvdSB3YW50IHRvXG4gICAgICogZm9yY2UgYSBKYXZhU2NyaXB0IGFycmF5IGludG8gYSBNYXQzJ3Mgc3BlY2lmaWVkIHR5cGVcbiAgICAgKiBpdCB3b3VsZCBiZSBmYXN0ZXIgdG8gdXNlXG4gICAgICpcbiAgICAgKiBgYGBcbiAgICAgKiBjb25zdCBtID0gbWF0My5jbG9uZShzb21lSlNBcnJheSk7XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdjAgLSB2YWx1ZSBmb3IgZWxlbWVudCAwXG4gICAgICogQHBhcmFtIHYxIC0gdmFsdWUgZm9yIGVsZW1lbnQgMVxuICAgICAqIEBwYXJhbSB2MiAtIHZhbHVlIGZvciBlbGVtZW50IDJcbiAgICAgKiBAcGFyYW0gdjMgLSB2YWx1ZSBmb3IgZWxlbWVudCAzXG4gICAgICogQHBhcmFtIHY0IC0gdmFsdWUgZm9yIGVsZW1lbnQgNFxuICAgICAqIEBwYXJhbSB2NSAtIHZhbHVlIGZvciBlbGVtZW50IDVcbiAgICAgKiBAcGFyYW0gdjYgLSB2YWx1ZSBmb3IgZWxlbWVudCA2XG4gICAgICogQHBhcmFtIHY3IC0gdmFsdWUgZm9yIGVsZW1lbnQgN1xuICAgICAqIEBwYXJhbSB2OCAtIHZhbHVlIGZvciBlbGVtZW50IDhcbiAgICAgKiBAcmV0dXJucyBtYXRyaXggY3JlYXRlZCBmcm9tIHZhbHVlcy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGUodjAsIHYxLCB2MiwgdjMsIHY0LCB2NSwgdjYsIHY3LCB2OCkge1xuICAgICAgICBjb25zdCBuZXdEc3QgPSBuZXcgQ3RvcigxMik7XG4gICAgICAgIC8vIHRvIG1ha2UgdGhlIGFycmF5IGhvbW9nZW5vdXNcbiAgICAgICAgbmV3RHN0WzNdID0gMDtcbiAgICAgICAgbmV3RHN0WzddID0gMDtcbiAgICAgICAgbmV3RHN0WzExXSA9IDA7XG4gICAgICAgIGlmICh2MCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBuZXdEc3RbMF0gPSB2MDtcbiAgICAgICAgICAgIGlmICh2MSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgbmV3RHN0WzFdID0gdjE7XG4gICAgICAgICAgICAgICAgaWYgKHYyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgbmV3RHN0WzJdID0gdjI7XG4gICAgICAgICAgICAgICAgICAgIGlmICh2MyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdEc3RbNF0gPSB2MztcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2NCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3RHN0WzVdID0gdjQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHY1ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3RHN0WzZdID0gdjU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2NiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXdEc3RbOF0gPSB2NjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2NyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3RHN0WzldID0gdjc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHY4ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3RHN0WzEwXSA9IHY4O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3RHN0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSB2YWx1ZXMgb2YgYSBNYXQzXG4gICAgICogQWxzbyBzZWUge0BsaW5rIG1hdDMuY3JlYXRlfSBhbmQge0BsaW5rIG1hdDMuY29weX1cbiAgICAgKlxuICAgICAqIEBwYXJhbSB2MCAtIHZhbHVlIGZvciBlbGVtZW50IDBcbiAgICAgKiBAcGFyYW0gdjEgLSB2YWx1ZSBmb3IgZWxlbWVudCAxXG4gICAgICogQHBhcmFtIHYyIC0gdmFsdWUgZm9yIGVsZW1lbnQgMlxuICAgICAqIEBwYXJhbSB2MyAtIHZhbHVlIGZvciBlbGVtZW50IDNcbiAgICAgKiBAcGFyYW0gdjQgLSB2YWx1ZSBmb3IgZWxlbWVudCA0XG4gICAgICogQHBhcmFtIHY1IC0gdmFsdWUgZm9yIGVsZW1lbnQgNVxuICAgICAqIEBwYXJhbSB2NiAtIHZhbHVlIGZvciBlbGVtZW50IDZcbiAgICAgKiBAcGFyYW0gdjcgLSB2YWx1ZSBmb3IgZWxlbWVudCA3XG4gICAgICogQHBhcmFtIHY4IC0gdmFsdWUgZm9yIGVsZW1lbnQgOFxuICAgICAqIEBwYXJhbSBkc3QgLSBtYXRyaXggdG8gaG9sZCByZXN1bHQuIElmIG5vdCBwYXNzZWQgYSBuZXcgb25lIGlzIGNyZWF0ZWQuXG4gICAgICogQHJldHVybnMgTWF0MyBzZXQgZnJvbSB2YWx1ZXMuXG4gICAgICovXG4gICAgZnVuY3Rpb24gc2V0KHYwLCB2MSwgdjIsIHYzLCB2NCwgdjUsIHY2LCB2NywgdjgsIGRzdCkge1xuICAgICAgICBjb25zdCBuZXdEc3QgPSAoZHN0ID8/IG5ldyBDdG9yKDEyKSk7XG4gICAgICAgIG5ld0RzdFswXSA9IHYwO1xuICAgICAgICBuZXdEc3RbMV0gPSB2MTtcbiAgICAgICAgbmV3RHN0WzJdID0gdjI7XG4gICAgICAgIG5ld0RzdFszXSA9IDA7XG4gICAgICAgIG5ld0RzdFs0XSA9IHYzO1xuICAgICAgICBuZXdEc3RbNV0gPSB2NDtcbiAgICAgICAgbmV3RHN0WzZdID0gdjU7XG4gICAgICAgIG5ld0RzdFs3XSA9IDA7XG4gICAgICAgIG5ld0RzdFs4XSA9IHY2O1xuICAgICAgICBuZXdEc3RbOV0gPSB2NztcbiAgICAgICAgbmV3RHN0WzEwXSA9IHY4O1xuICAgICAgICBuZXdEc3RbMTFdID0gMDtcbiAgICAgICAgcmV0dXJuIG5ld0RzdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIE1hdDMgZnJvbSB0aGUgdXBwZXIgbGVmdCAzeDMgcGFydCBvZiBhIE1hdDRcbiAgICAgKiBAcGFyYW0gbTQgLSBzb3VyY2UgbWF0cml4XG4gICAgICogQHBhcmFtIGRzdCAtIG1hdHJpeCB0byBob2xkIHJlc3VsdC4gSWYgbm90IHBhc3NlZCBhIG5ldyBvbmUgaXMgY3JlYXRlZC5cbiAgICAgKiBAcmV0dXJucyBNYXQzIG1hZGUgZnJvbSBtNFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZyb21NYXQ0KG00LCBkc3QpIHtcbiAgICAgICAgY29uc3QgbmV3RHN0ID0gKGRzdCA/PyBuZXcgQ3RvcigxMikpO1xuICAgICAgICBuZXdEc3RbMF0gPSBtNFswXTtcbiAgICAgICAgbmV3RHN0WzFdID0gbTRbMV07XG4gICAgICAgIG5ld0RzdFsyXSA9IG00WzJdO1xuICAgICAgICBuZXdEc3RbM10gPSAwO1xuICAgICAgICBuZXdEc3RbNF0gPSBtNFs0XTtcbiAgICAgICAgbmV3RHN0WzVdID0gbTRbNV07XG4gICAgICAgIG5ld0RzdFs2XSA9IG00WzZdO1xuICAgICAgICBuZXdEc3RbN10gPSAwO1xuICAgICAgICBuZXdEc3RbOF0gPSBtNFs4XTtcbiAgICAgICAgbmV3RHN0WzldID0gbTRbOV07XG4gICAgICAgIG5ld0RzdFsxMF0gPSBtNFsxMF07XG4gICAgICAgIG5ld0RzdFsxMV0gPSAwO1xuICAgICAgICByZXR1cm4gbmV3RHN0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgTWF0MyByb3RhdGlvbiBtYXRyaXggZnJvbSBhIHF1YXRlcm5pb25cbiAgICAgKiBAcGFyYW0gcSAtIHF1YXRlcm5pb24gdG8gY3JlYXRlIG1hdHJpeCBmcm9tXG4gICAgICogQHBhcmFtIGRzdCAtIG1hdHJpeCB0byBob2xkIHJlc3VsdC4gSWYgbm90IHBhc3NlZCBhIG5ldyBvbmUgaXMgY3JlYXRlZC5cbiAgICAgKiBAcmV0dXJucyBNYXQzIG1hZGUgZnJvbSBxXG4gICAgICovXG4gICAgZnVuY3Rpb24gZnJvbVF1YXQocSwgZHN0KSB7XG4gICAgICAgIGNvbnN0IG5ld0RzdCA9IChkc3QgPz8gbmV3IEN0b3IoMTIpKTtcbiAgICAgICAgY29uc3QgeCA9IHFbMF07XG4gICAgICAgIGNvbnN0IHkgPSBxWzFdO1xuICAgICAgICBjb25zdCB6ID0gcVsyXTtcbiAgICAgICAgY29uc3QgdyA9IHFbM107XG4gICAgICAgIGNvbnN0IHgyID0geCArIHg7XG4gICAgICAgIGNvbnN0IHkyID0geSArIHk7XG4gICAgICAgIGNvbnN0IHoyID0geiArIHo7XG4gICAgICAgIGNvbnN0IHh4ID0geCAqIHgyO1xuICAgICAgICBjb25zdCB5eCA9IHkgKiB4MjtcbiAgICAgICAgY29uc3QgeXkgPSB5ICogeTI7XG4gICAgICAgIGNvbnN0IHp4ID0geiAqIHgyO1xuICAgICAgICBjb25zdCB6eSA9IHogKiB5MjtcbiAgICAgICAgY29uc3QgenogPSB6ICogejI7XG4gICAgICAgIGNvbnN0IHd4ID0gdyAqIHgyO1xuICAgICAgICBjb25zdCB3eSA9IHcgKiB5MjtcbiAgICAgICAgY29uc3Qgd3ogPSB3ICogejI7XG4gICAgICAgIG5ld0RzdFswXSA9IDEgLSB5eSAtIHp6O1xuICAgICAgICBuZXdEc3RbMV0gPSB5eCArIHd6O1xuICAgICAgICBuZXdEc3RbMl0gPSB6eCAtIHd5O1xuICAgICAgICBuZXdEc3RbM10gPSAwO1xuICAgICAgICBuZXdEc3RbNF0gPSB5eCAtIHd6O1xuICAgICAgICBuZXdEc3RbNV0gPSAxIC0geHggLSB6ejtcbiAgICAgICAgbmV3RHN0WzZdID0genkgKyB3eDtcbiAgICAgICAgbmV3RHN0WzddID0gMDtcbiAgICAgICAgbmV3RHN0WzhdID0genggKyB3eTtcbiAgICAgICAgbmV3RHN0WzldID0genkgLSB3eDtcbiAgICAgICAgbmV3RHN0WzEwXSA9IDEgLSB4eCAtIHl5O1xuICAgICAgICBuZXdEc3RbMTFdID0gMDtcbiAgICAgICAgcmV0dXJuIG5ld0RzdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTmVnYXRlcyBhIG1hdHJpeC5cbiAgICAgKiBAcGFyYW0gbSAtIFRoZSBtYXRyaXguXG4gICAgICogQHBhcmFtIGRzdCAtIG1hdHJpeCB0byBob2xkIHJlc3VsdC4gSWYgbm90IHBhc3NlZCBhIG5ldyBvbmUgaXMgY3JlYXRlZC5cbiAgICAgKiBAcmV0dXJucyAtbS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBuZWdhdGUobSwgZHN0KSB7XG4gICAgICAgIGNvbnN0IG5ld0RzdCA9IChkc3QgPz8gbmV3IEN0b3IoMTIpKTtcbiAgICAgICAgbmV3RHN0WzBdID0gLW1bMF07XG4gICAgICAgIG5ld0RzdFsxXSA9IC1tWzFdO1xuICAgICAgICBuZXdEc3RbMl0gPSAtbVsyXTtcbiAgICAgICAgbmV3RHN0WzRdID0gLW1bNF07XG4gICAgICAgIG5ld0RzdFs1XSA9IC1tWzVdO1xuICAgICAgICBuZXdEc3RbNl0gPSAtbVs2XTtcbiAgICAgICAgbmV3RHN0WzhdID0gLW1bOF07XG4gICAgICAgIG5ld0RzdFs5XSA9IC1tWzldO1xuICAgICAgICBuZXdEc3RbMTBdID0gLW1bMTBdO1xuICAgICAgICByZXR1cm4gbmV3RHN0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb3BpZXMgYSBtYXRyaXguIChzYW1lIGFzIHtAbGluayBtYXQzLmNsb25lfSlcbiAgICAgKiBBbHNvIHNlZSB7QGxpbmsgbWF0My5jcmVhdGV9IGFuZCB7QGxpbmsgbWF0My5zZXR9XG4gICAgICogQHBhcmFtIG0gLSBUaGUgbWF0cml4LlxuICAgICAqIEBwYXJhbSBkc3QgLSBUaGUgbWF0cml4LiBJZiBub3QgcGFzc2VkIGEgbmV3IG9uZSBpcyBjcmVhdGVkLlxuICAgICAqIEByZXR1cm5zIEEgY29weSBvZiBtLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNvcHkobSwgZHN0KSB7XG4gICAgICAgIGNvbnN0IG5ld0RzdCA9IChkc3QgPz8gbmV3IEN0b3IoMTIpKTtcbiAgICAgICAgbmV3RHN0WzBdID0gbVswXTtcbiAgICAgICAgbmV3RHN0WzFdID0gbVsxXTtcbiAgICAgICAgbmV3RHN0WzJdID0gbVsyXTtcbiAgICAgICAgbmV3RHN0WzRdID0gbVs0XTtcbiAgICAgICAgbmV3RHN0WzVdID0gbVs1XTtcbiAgICAgICAgbmV3RHN0WzZdID0gbVs2XTtcbiAgICAgICAgbmV3RHN0WzhdID0gbVs4XTtcbiAgICAgICAgbmV3RHN0WzldID0gbVs5XTtcbiAgICAgICAgbmV3RHN0WzEwXSA9IG1bMTBdO1xuICAgICAgICByZXR1cm4gbmV3RHN0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb3BpZXMgYSBtYXRyaXggKHNhbWUgYXMge0BsaW5rIG1hdDMuY29weX0pXG4gICAgICogQWxzbyBzZWUge0BsaW5rIG1hdDMuY3JlYXRlfSBhbmQge0BsaW5rIG1hdDMuc2V0fVxuICAgICAqIEBwYXJhbSBtIC0gVGhlIG1hdHJpeC5cbiAgICAgKiBAcGFyYW0gZHN0IC0gVGhlIG1hdHJpeC4gSWYgbm90IHBhc3NlZCBhIG5ldyBvbmUgaXMgY3JlYXRlZC5cbiAgICAgKiBAcmV0dXJucyBBIGNvcHkgb2YgbS5cbiAgICAgKi9cbiAgICBjb25zdCBjbG9uZSA9IGNvcHk7XG4gICAgLyoqXG4gICAgICogQ2hlY2sgaWYgMiBtYXRyaWNlcyBhcmUgYXBwcm94aW1hdGVseSBlcXVhbFxuICAgICAqIEBwYXJhbSBhIE9wZXJhbmQgbWF0cml4LlxuICAgICAqIEBwYXJhbSBiIE9wZXJhbmQgbWF0cml4LlxuICAgICAqIEByZXR1cm5zIHRydWUgaWYgbWF0cmljZXMgYXJlIGFwcHJveGltYXRlbHkgZXF1YWxcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBlcXVhbHNBcHByb3hpbWF0ZWx5KGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIE1hdGguYWJzKGFbMF0gLSBiWzBdKSA8IEVQU0lMT04gJiZcbiAgICAgICAgICAgIE1hdGguYWJzKGFbMV0gLSBiWzFdKSA8IEVQU0lMT04gJiZcbiAgICAgICAgICAgIE1hdGguYWJzKGFbMl0gLSBiWzJdKSA8IEVQU0lMT04gJiZcbiAgICAgICAgICAgIE1hdGguYWJzKGFbNF0gLSBiWzRdKSA8IEVQU0lMT04gJiZcbiAgICAgICAgICAgIE1hdGguYWJzKGFbNV0gLSBiWzVdKSA8IEVQU0lMT04gJiZcbiAgICAgICAgICAgIE1hdGguYWJzKGFbNl0gLSBiWzZdKSA8IEVQU0lMT04gJiZcbiAgICAgICAgICAgIE1hdGguYWJzKGFbOF0gLSBiWzhdKSA8IEVQU0lMT04gJiZcbiAgICAgICAgICAgIE1hdGguYWJzKGFbOV0gLSBiWzldKSA8IEVQU0lMT04gJiZcbiAgICAgICAgICAgIE1hdGguYWJzKGFbMTBdIC0gYlsxMF0pIDwgRVBTSUxPTjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2hlY2sgaWYgMiBtYXRyaWNlcyBhcmUgZXhhY3RseSBlcXVhbFxuICAgICAqIEBwYXJhbSBhIE9wZXJhbmQgbWF0cml4LlxuICAgICAqIEBwYXJhbSBiIE9wZXJhbmQgbWF0cml4LlxuICAgICAqIEByZXR1cm5zIHRydWUgaWYgbWF0cmljZXMgYXJlIGV4YWN0bHkgZXF1YWxcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBlcXVhbHMoYSwgYikge1xuICAgICAgICByZXR1cm4gYVswXSA9PT0gYlswXSAmJlxuICAgICAgICAgICAgYVsxXSA9PT0gYlsxXSAmJlxuICAgICAgICAgICAgYVsyXSA9PT0gYlsyXSAmJlxuICAgICAgICAgICAgYVs0XSA9PT0gYls0XSAmJlxuICAgICAgICAgICAgYVs1XSA9PT0gYls1XSAmJlxuICAgICAgICAgICAgYVs2XSA9PT0gYls2XSAmJlxuICAgICAgICAgICAgYVs4XSA9PT0gYls4XSAmJlxuICAgICAgICAgICAgYVs5XSA9PT0gYls5XSAmJlxuICAgICAgICAgICAgYVsxMF0gPT09IGJbMTBdO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgMy1ieS0zIGlkZW50aXR5IG1hdHJpeC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBkc3QgLSBtYXRyaXggdG8gaG9sZCByZXN1bHQuIElmIG5vdCBwYXNzZWQgYSBuZXcgb25lIGlzIGNyZWF0ZWQuXG4gICAgICogQHJldHVybnMgQSAzLWJ5LTMgaWRlbnRpdHkgbWF0cml4LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlkZW50aXR5KGRzdCkge1xuICAgICAgICBjb25zdCBuZXdEc3QgPSAoZHN0ID8/IG5ldyBDdG9yKDEyKSk7XG4gICAgICAgIG5ld0RzdFswXSA9IDE7XG4gICAgICAgIG5ld0RzdFsxXSA9IDA7XG4gICAgICAgIG5ld0RzdFsyXSA9IDA7XG4gICAgICAgIG5ld0RzdFs0XSA9IDA7XG4gICAgICAgIG5ld0RzdFs1XSA9IDE7XG4gICAgICAgIG5ld0RzdFs2XSA9IDA7XG4gICAgICAgIG5ld0RzdFs4XSA9IDA7XG4gICAgICAgIG5ld0RzdFs5XSA9IDA7XG4gICAgICAgIG5ld0RzdFsxMF0gPSAxO1xuICAgICAgICByZXR1cm4gbmV3RHN0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUYWtlcyB0aGUgdHJhbnNwb3NlIG9mIGEgbWF0cml4LlxuICAgICAqIEBwYXJhbSBtIC0gVGhlIG1hdHJpeC5cbiAgICAgKiBAcGFyYW0gZHN0IC0gbWF0cml4IHRvIGhvbGQgcmVzdWx0LiBJZiBub3QgcGFzc2VkIGEgbmV3IG9uZSBpcyBjcmVhdGVkLlxuICAgICAqIEByZXR1cm5zIFRoZSB0cmFuc3Bvc2Ugb2YgbS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0cmFuc3Bvc2UobSwgZHN0KSB7XG4gICAgICAgIGNvbnN0IG5ld0RzdCA9IChkc3QgPz8gbmV3IEN0b3IoMTIpKTtcbiAgICAgICAgaWYgKG5ld0RzdCA9PT0gbSkge1xuICAgICAgICAgICAgbGV0IHQ7XG4gICAgICAgICAgICAvLyAwIDEgMlxuICAgICAgICAgICAgLy8gNCA1IDZcbiAgICAgICAgICAgIC8vIDggOSAxMFxuICAgICAgICAgICAgdCA9IG1bMV07XG4gICAgICAgICAgICBtWzFdID0gbVs0XTtcbiAgICAgICAgICAgIG1bNF0gPSB0O1xuICAgICAgICAgICAgdCA9IG1bMl07XG4gICAgICAgICAgICBtWzJdID0gbVs4XTtcbiAgICAgICAgICAgIG1bOF0gPSB0O1xuICAgICAgICAgICAgdCA9IG1bNl07XG4gICAgICAgICAgICBtWzZdID0gbVs5XTtcbiAgICAgICAgICAgIG1bOV0gPSB0O1xuICAgICAgICAgICAgcmV0dXJuIG5ld0RzdDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBtMDAgPSBtWzAgKiA0ICsgMF07XG4gICAgICAgIGNvbnN0IG0wMSA9IG1bMCAqIDQgKyAxXTtcbiAgICAgICAgY29uc3QgbTAyID0gbVswICogNCArIDJdO1xuICAgICAgICBjb25zdCBtMTAgPSBtWzEgKiA0ICsgMF07XG4gICAgICAgIGNvbnN0IG0xMSA9IG1bMSAqIDQgKyAxXTtcbiAgICAgICAgY29uc3QgbTEyID0gbVsxICogNCArIDJdO1xuICAgICAgICBjb25zdCBtMjAgPSBtWzIgKiA0ICsgMF07XG4gICAgICAgIGNvbnN0IG0yMSA9IG1bMiAqIDQgKyAxXTtcbiAgICAgICAgY29uc3QgbTIyID0gbVsyICogNCArIDJdO1xuICAgICAgICBuZXdEc3RbMF0gPSBtMDA7XG4gICAgICAgIG5ld0RzdFsxXSA9IG0xMDtcbiAgICAgICAgbmV3RHN0WzJdID0gbTIwO1xuICAgICAgICBuZXdEc3RbNF0gPSBtMDE7XG4gICAgICAgIG5ld0RzdFs1XSA9IG0xMTtcbiAgICAgICAgbmV3RHN0WzZdID0gbTIxO1xuICAgICAgICBuZXdEc3RbOF0gPSBtMDI7XG4gICAgICAgIG5ld0RzdFs5XSA9IG0xMjtcbiAgICAgICAgbmV3RHN0WzEwXSA9IG0yMjtcbiAgICAgICAgcmV0dXJuIG5ld0RzdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29tcHV0ZXMgdGhlIGludmVyc2Ugb2YgYSAzLWJ5LTMgbWF0cml4LlxuICAgICAqIEBwYXJhbSBtIC0gVGhlIG1hdHJpeC5cbiAgICAgKiBAcGFyYW0gZHN0IC0gbWF0cml4IHRvIGhvbGQgcmVzdWx0LiBJZiBub3QgcGFzc2VkIGEgbmV3IG9uZSBpcyBjcmVhdGVkLlxuICAgICAqIEByZXR1cm5zIFRoZSBpbnZlcnNlIG9mIG0uXG4gICAgICovXG4gICAgZnVuY3Rpb24gaW52ZXJzZShtLCBkc3QpIHtcbiAgICAgICAgY29uc3QgbmV3RHN0ID0gKGRzdCA/PyBuZXcgQ3RvcigxMikpO1xuICAgICAgICBjb25zdCBtMDAgPSBtWzAgKiA0ICsgMF07XG4gICAgICAgIGNvbnN0IG0wMSA9IG1bMCAqIDQgKyAxXTtcbiAgICAgICAgY29uc3QgbTAyID0gbVswICogNCArIDJdO1xuICAgICAgICBjb25zdCBtMTAgPSBtWzEgKiA0ICsgMF07XG4gICAgICAgIGNvbnN0IG0xMSA9IG1bMSAqIDQgKyAxXTtcbiAgICAgICAgY29uc3QgbTEyID0gbVsxICogNCArIDJdO1xuICAgICAgICBjb25zdCBtMjAgPSBtWzIgKiA0ICsgMF07XG4gICAgICAgIGNvbnN0IG0yMSA9IG1bMiAqIDQgKyAxXTtcbiAgICAgICAgY29uc3QgbTIyID0gbVsyICogNCArIDJdO1xuICAgICAgICBjb25zdCBiMDEgPSBtMjIgKiBtMTEgLSBtMTIgKiBtMjE7XG4gICAgICAgIGNvbnN0IGIxMSA9IC1tMjIgKiBtMTAgKyBtMTIgKiBtMjA7XG4gICAgICAgIGNvbnN0IGIyMSA9IG0yMSAqIG0xMCAtIG0xMSAqIG0yMDtcbiAgICAgICAgY29uc3QgaW52RGV0ID0gMSAvIChtMDAgKiBiMDEgKyBtMDEgKiBiMTEgKyBtMDIgKiBiMjEpO1xuICAgICAgICBuZXdEc3RbMF0gPSBiMDEgKiBpbnZEZXQ7XG4gICAgICAgIG5ld0RzdFsxXSA9ICgtbTIyICogbTAxICsgbTAyICogbTIxKSAqIGludkRldDtcbiAgICAgICAgbmV3RHN0WzJdID0gKG0xMiAqIG0wMSAtIG0wMiAqIG0xMSkgKiBpbnZEZXQ7XG4gICAgICAgIG5ld0RzdFs0XSA9IGIxMSAqIGludkRldDtcbiAgICAgICAgbmV3RHN0WzVdID0gKG0yMiAqIG0wMCAtIG0wMiAqIG0yMCkgKiBpbnZEZXQ7XG4gICAgICAgIG5ld0RzdFs2XSA9ICgtbTEyICogbTAwICsgbTAyICogbTEwKSAqIGludkRldDtcbiAgICAgICAgbmV3RHN0WzhdID0gYjIxICogaW52RGV0O1xuICAgICAgICBuZXdEc3RbOV0gPSAoLW0yMSAqIG0wMCArIG0wMSAqIG0yMCkgKiBpbnZEZXQ7XG4gICAgICAgIG5ld0RzdFsxMF0gPSAobTExICogbTAwIC0gbTAxICogbTEwKSAqIGludkRldDtcbiAgICAgICAgcmV0dXJuIG5ld0RzdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29tcHV0ZSB0aGUgZGV0ZXJtaW5hbnQgb2YgYSBtYXRyaXhcbiAgICAgKiBAcGFyYW0gbSAtIHRoZSBtYXRyaXhcbiAgICAgKiBAcmV0dXJucyB0aGUgZGV0ZXJtaW5hbnRcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBkZXRlcm1pbmFudChtKSB7XG4gICAgICAgIGNvbnN0IG0wMCA9IG1bMCAqIDQgKyAwXTtcbiAgICAgICAgY29uc3QgbTAxID0gbVswICogNCArIDFdO1xuICAgICAgICBjb25zdCBtMDIgPSBtWzAgKiA0ICsgMl07XG4gICAgICAgIGNvbnN0IG0xMCA9IG1bMSAqIDQgKyAwXTtcbiAgICAgICAgY29uc3QgbTExID0gbVsxICogNCArIDFdO1xuICAgICAgICBjb25zdCBtMTIgPSBtWzEgKiA0ICsgMl07XG4gICAgICAgIGNvbnN0IG0yMCA9IG1bMiAqIDQgKyAwXTtcbiAgICAgICAgY29uc3QgbTIxID0gbVsyICogNCArIDFdO1xuICAgICAgICBjb25zdCBtMjIgPSBtWzIgKiA0ICsgMl07XG4gICAgICAgIHJldHVybiBtMDAgKiAobTExICogbTIyIC0gbTIxICogbTEyKSAtXG4gICAgICAgICAgICBtMTAgKiAobTAxICogbTIyIC0gbTIxICogbTAyKSArXG4gICAgICAgICAgICBtMjAgKiAobTAxICogbTEyIC0gbTExICogbTAyKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29tcHV0ZXMgdGhlIGludmVyc2Ugb2YgYSAzLWJ5LTMgbWF0cml4LiAoc2FtZSBhcyBpbnZlcnNlKVxuICAgICAqIEBwYXJhbSBtIC0gVGhlIG1hdHJpeC5cbiAgICAgKiBAcGFyYW0gZHN0IC0gbWF0cml4IHRvIGhvbGQgcmVzdWx0LiBJZiBub3QgcGFzc2VkIGEgbmV3IG9uZSBpcyBjcmVhdGVkLlxuICAgICAqIEByZXR1cm5zIFRoZSBpbnZlcnNlIG9mIG0uXG4gICAgICovXG4gICAgY29uc3QgaW52ZXJ0ID0gaW52ZXJzZTtcbiAgICAvKipcbiAgICAgKiBNdWx0aXBsaWVzIHR3byAzLWJ5LTMgbWF0cmljZXMgd2l0aCBhIG9uIHRoZSBsZWZ0IGFuZCBiIG9uIHRoZSByaWdodFxuICAgICAqIEBwYXJhbSBhIC0gVGhlIG1hdHJpeCBvbiB0aGUgbGVmdC5cbiAgICAgKiBAcGFyYW0gYiAtIFRoZSBtYXRyaXggb24gdGhlIHJpZ2h0LlxuICAgICAqIEBwYXJhbSBkc3QgLSBtYXRyaXggdG8gaG9sZCByZXN1bHQuIElmIG5vdCBwYXNzZWQgYSBuZXcgb25lIGlzIGNyZWF0ZWQuXG4gICAgICogQHJldHVybnMgVGhlIG1hdHJpeCBwcm9kdWN0IG9mIGEgYW5kIGIuXG4gICAgICovXG4gICAgZnVuY3Rpb24gbXVsdGlwbHkoYSwgYiwgZHN0KSB7XG4gICAgICAgIGNvbnN0IG5ld0RzdCA9IChkc3QgPz8gbmV3IEN0b3IoMTIpKTtcbiAgICAgICAgY29uc3QgYTAwID0gYVswXTtcbiAgICAgICAgY29uc3QgYTAxID0gYVsxXTtcbiAgICAgICAgY29uc3QgYTAyID0gYVsyXTtcbiAgICAgICAgY29uc3QgYTEwID0gYVs0ICsgMF07XG4gICAgICAgIGNvbnN0IGExMSA9IGFbNCArIDFdO1xuICAgICAgICBjb25zdCBhMTIgPSBhWzQgKyAyXTtcbiAgICAgICAgY29uc3QgYTIwID0gYVs4ICsgMF07XG4gICAgICAgIGNvbnN0IGEyMSA9IGFbOCArIDFdO1xuICAgICAgICBjb25zdCBhMjIgPSBhWzggKyAyXTtcbiAgICAgICAgY29uc3QgYjAwID0gYlswXTtcbiAgICAgICAgY29uc3QgYjAxID0gYlsxXTtcbiAgICAgICAgY29uc3QgYjAyID0gYlsyXTtcbiAgICAgICAgY29uc3QgYjEwID0gYls0ICsgMF07XG4gICAgICAgIGNvbnN0IGIxMSA9IGJbNCArIDFdO1xuICAgICAgICBjb25zdCBiMTIgPSBiWzQgKyAyXTtcbiAgICAgICAgY29uc3QgYjIwID0gYls4ICsgMF07XG4gICAgICAgIGNvbnN0IGIyMSA9IGJbOCArIDFdO1xuICAgICAgICBjb25zdCBiMjIgPSBiWzggKyAyXTtcbiAgICAgICAgbmV3RHN0WzBdID0gYTAwICogYjAwICsgYTEwICogYjAxICsgYTIwICogYjAyO1xuICAgICAgICBuZXdEc3RbMV0gPSBhMDEgKiBiMDAgKyBhMTEgKiBiMDEgKyBhMjEgKiBiMDI7XG4gICAgICAgIG5ld0RzdFsyXSA9IGEwMiAqIGIwMCArIGExMiAqIGIwMSArIGEyMiAqIGIwMjtcbiAgICAgICAgbmV3RHN0WzRdID0gYTAwICogYjEwICsgYTEwICogYjExICsgYTIwICogYjEyO1xuICAgICAgICBuZXdEc3RbNV0gPSBhMDEgKiBiMTAgKyBhMTEgKiBiMTEgKyBhMjEgKiBiMTI7XG4gICAgICAgIG5ld0RzdFs2XSA9IGEwMiAqIGIxMCArIGExMiAqIGIxMSArIGEyMiAqIGIxMjtcbiAgICAgICAgbmV3RHN0WzhdID0gYTAwICogYjIwICsgYTEwICogYjIxICsgYTIwICogYjIyO1xuICAgICAgICBuZXdEc3RbOV0gPSBhMDEgKiBiMjAgKyBhMTEgKiBiMjEgKyBhMjEgKiBiMjI7XG4gICAgICAgIG5ld0RzdFsxMF0gPSBhMDIgKiBiMjAgKyBhMTIgKiBiMjEgKyBhMjIgKiBiMjI7XG4gICAgICAgIHJldHVybiBuZXdEc3Q7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE11bHRpcGxpZXMgdHdvIDMtYnktMyBtYXRyaWNlcyB3aXRoIGEgb24gdGhlIGxlZnQgYW5kIGIgb24gdGhlIHJpZ2h0IChzYW1lIGFzIG11bHRpcGx5KVxuICAgICAqIEBwYXJhbSBhIC0gVGhlIG1hdHJpeCBvbiB0aGUgbGVmdC5cbiAgICAgKiBAcGFyYW0gYiAtIFRoZSBtYXRyaXggb24gdGhlIHJpZ2h0LlxuICAgICAqIEBwYXJhbSBkc3QgLSBtYXRyaXggdG8gaG9sZCByZXN1bHQuIElmIG5vdCBwYXNzZWQgYSBuZXcgb25lIGlzIGNyZWF0ZWQuXG4gICAgICogQHJldHVybnMgVGhlIG1hdHJpeCBwcm9kdWN0IG9mIGEgYW5kIGIuXG4gICAgICovXG4gICAgY29uc3QgbXVsID0gbXVsdGlwbHk7XG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgdHJhbnNsYXRpb24gY29tcG9uZW50IG9mIGEgMy1ieS0zIG1hdHJpeCB0byB0aGUgZ2l2ZW5cbiAgICAgKiB2ZWN0b3IuXG4gICAgICogQHBhcmFtIGEgLSBUaGUgbWF0cml4LlxuICAgICAqIEBwYXJhbSB2IC0gVGhlIHZlY3Rvci5cbiAgICAgKiBAcGFyYW0gZHN0IC0gbWF0cml4IHRvIGhvbGQgcmVzdWx0LiBJZiBub3QgcGFzc2VkIGEgbmV3IG9uZSBpcyBjcmVhdGVkLlxuICAgICAqIEByZXR1cm5zIFRoZSBtYXRyaXggd2l0aCB0cmFuc2xhdGlvbiBzZXQuXG4gICAgICovXG4gICAgZnVuY3Rpb24gc2V0VHJhbnNsYXRpb24oYSwgdiwgZHN0KSB7XG4gICAgICAgIGNvbnN0IG5ld0RzdCA9IChkc3QgPz8gaWRlbnRpdHkoKSk7XG4gICAgICAgIGlmIChhICE9PSBuZXdEc3QpIHtcbiAgICAgICAgICAgIG5ld0RzdFswXSA9IGFbMF07XG4gICAgICAgICAgICBuZXdEc3RbMV0gPSBhWzFdO1xuICAgICAgICAgICAgbmV3RHN0WzJdID0gYVsyXTtcbiAgICAgICAgICAgIG5ld0RzdFs0XSA9IGFbNF07XG4gICAgICAgICAgICBuZXdEc3RbNV0gPSBhWzVdO1xuICAgICAgICAgICAgbmV3RHN0WzZdID0gYVs2XTtcbiAgICAgICAgfVxuICAgICAgICBuZXdEc3RbOF0gPSB2WzBdO1xuICAgICAgICBuZXdEc3RbOV0gPSB2WzFdO1xuICAgICAgICBuZXdEc3RbMTBdID0gMTtcbiAgICAgICAgcmV0dXJuIG5ld0RzdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgdHJhbnNsYXRpb24gY29tcG9uZW50IG9mIGEgMy1ieS0zIG1hdHJpeCBhcyBhIHZlY3RvciB3aXRoIDNcbiAgICAgKiBlbnRyaWVzLlxuICAgICAqIEBwYXJhbSBtIC0gVGhlIG1hdHJpeC5cbiAgICAgKiBAcGFyYW0gZHN0IC0gdmVjdG9yIHRvIGhvbGQgcmVzdWx0LiBJZiBub3QgcGFzc2VkIGEgbmV3IG9uZSBpcyBjcmVhdGVkLlxuICAgICAqIEByZXR1cm5zIFRoZSB0cmFuc2xhdGlvbiBjb21wb25lbnQgb2YgbS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBnZXRUcmFuc2xhdGlvbihtLCBkc3QpIHtcbiAgICAgICAgY29uc3QgbmV3RHN0ID0gKGRzdCA/PyB2ZWMyLmNyZWF0ZSgpKTtcbiAgICAgICAgbmV3RHN0WzBdID0gbVs4XTtcbiAgICAgICAgbmV3RHN0WzFdID0gbVs5XTtcbiAgICAgICAgcmV0dXJuIG5ld0RzdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhbiBheGlzIG9mIGEgM3gzIG1hdHJpeCBhcyBhIHZlY3RvciB3aXRoIDIgZW50cmllc1xuICAgICAqIEBwYXJhbSBtIC0gVGhlIG1hdHJpeC5cbiAgICAgKiBAcGFyYW0gYXhpcyAtIFRoZSBheGlzIDAgPSB4LCAxID0geSxcbiAgICAgKiBAcmV0dXJucyBUaGUgYXhpcyBjb21wb25lbnQgb2YgbS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBnZXRBeGlzKG0sIGF4aXMsIGRzdCkge1xuICAgICAgICBjb25zdCBuZXdEc3QgPSAoZHN0ID8/IHZlYzIuY3JlYXRlKCkpO1xuICAgICAgICBjb25zdCBvZmYgPSBheGlzICogNDtcbiAgICAgICAgbmV3RHN0WzBdID0gbVtvZmYgKyAwXTtcbiAgICAgICAgbmV3RHN0WzFdID0gbVtvZmYgKyAxXTtcbiAgICAgICAgcmV0dXJuIG5ld0RzdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyBhbiBheGlzIG9mIGEgM3gzIG1hdHJpeCBhcyBhIHZlY3RvciB3aXRoIDIgZW50cmllc1xuICAgICAqIEBwYXJhbSBtIC0gVGhlIG1hdHJpeC5cbiAgICAgKiBAcGFyYW0gdiAtIHRoZSBheGlzIHZlY3RvclxuICAgICAqIEBwYXJhbSBheGlzIC0gVGhlIGF4aXMgIDAgPSB4LCAxID0geTtcbiAgICAgKiBAcGFyYW0gZHN0IC0gVGhlIG1hdHJpeCB0byBzZXQuIElmIG5vdCBwYXNzZWQgYSBuZXcgb25lIGlzIGNyZWF0ZWQuXG4gICAgICogQHJldHVybnMgVGhlIG1hdHJpeCB3aXRoIGF4aXMgc2V0LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNldEF4aXMobSwgdiwgYXhpcywgZHN0KSB7XG4gICAgICAgIGNvbnN0IG5ld0RzdCA9IChkc3QgPT09IG0gPyBtIDogY29weShtLCBkc3QpKTtcbiAgICAgICAgY29uc3Qgb2ZmID0gYXhpcyAqIDQ7XG4gICAgICAgIG5ld0RzdFtvZmYgKyAwXSA9IHZbMF07XG4gICAgICAgIG5ld0RzdFtvZmYgKyAxXSA9IHZbMV07XG4gICAgICAgIHJldHVybiBuZXdEc3Q7XG4gICAgfVxuICAgIC8vLyoqXG4gICAgLy8gKiBSZXR1cm5zIHRoZSBzY2FsaW5nIGNvbXBvbmVudCBvZiB0aGUgbWF0cml4XG4gICAgLy8gKiBAcGFyYW0gbSAtIFRoZSBNYXRyaXhcbiAgICAvLyAqIEBwYXJhbSBkc3QgLSBUaGUgdmVjdG9yIHRvIHNldC4gSWYgbm90IHBhc3NlZCBhIG5ldyBvbmUgaXMgY3JlYXRlZC5cbiAgICAvLyAqL1xuICAgIGZ1bmN0aW9uIGdldFNjYWxpbmcobSwgZHN0KSB7XG4gICAgICAgIGNvbnN0IG5ld0RzdCA9IChkc3QgPz8gdmVjMi5jcmVhdGUoKSk7XG4gICAgICAgIGNvbnN0IHh4ID0gbVswXTtcbiAgICAgICAgY29uc3QgeHkgPSBtWzFdO1xuICAgICAgICBjb25zdCB5eCA9IG1bNF07XG4gICAgICAgIGNvbnN0IHl5ID0gbVs1XTtcbiAgICAgICAgbmV3RHN0WzBdID0gTWF0aC5zcXJ0KHh4ICogeHggKyB4eSAqIHh5KTtcbiAgICAgICAgbmV3RHN0WzFdID0gTWF0aC5zcXJ0KHl4ICogeXggKyB5eSAqIHl5KTtcbiAgICAgICAgcmV0dXJuIG5ld0RzdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIDMtYnktMyBtYXRyaXggd2hpY2ggdHJhbnNsYXRlcyBieSB0aGUgZ2l2ZW4gdmVjdG9yIHYuXG4gICAgICogQHBhcmFtIHYgLSBUaGUgdmVjdG9yIGJ5IHdoaWNoIHRvIHRyYW5zbGF0ZS5cbiAgICAgKiBAcGFyYW0gZHN0IC0gbWF0cml4IHRvIGhvbGQgcmVzdWx0LiBJZiBub3QgcGFzc2VkIGEgbmV3IG9uZSBpcyBjcmVhdGVkLlxuICAgICAqIEByZXR1cm5zIFRoZSB0cmFuc2xhdGlvbiBtYXRyaXguXG4gICAgICovXG4gICAgZnVuY3Rpb24gdHJhbnNsYXRpb24odiwgZHN0KSB7XG4gICAgICAgIGNvbnN0IG5ld0RzdCA9IChkc3QgPz8gbmV3IEN0b3IoMTIpKTtcbiAgICAgICAgbmV3RHN0WzBdID0gMTtcbiAgICAgICAgbmV3RHN0WzFdID0gMDtcbiAgICAgICAgbmV3RHN0WzJdID0gMDtcbiAgICAgICAgbmV3RHN0WzRdID0gMDtcbiAgICAgICAgbmV3RHN0WzVdID0gMTtcbiAgICAgICAgbmV3RHN0WzZdID0gMDtcbiAgICAgICAgbmV3RHN0WzhdID0gdlswXTtcbiAgICAgICAgbmV3RHN0WzldID0gdlsxXTtcbiAgICAgICAgbmV3RHN0WzEwXSA9IDE7XG4gICAgICAgIHJldHVybiBuZXdEc3Q7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRyYW5zbGF0ZXMgdGhlIGdpdmVuIDMtYnktMyBtYXRyaXggYnkgdGhlIGdpdmVuIHZlY3RvciB2LlxuICAgICAqIEBwYXJhbSBtIC0gVGhlIG1hdHJpeC5cbiAgICAgKiBAcGFyYW0gdiAtIFRoZSB2ZWN0b3IgYnkgd2hpY2ggdG8gdHJhbnNsYXRlLlxuICAgICAqIEBwYXJhbSBkc3QgLSBtYXRyaXggdG8gaG9sZCByZXN1bHQuIElmIG5vdCBwYXNzZWQgYSBuZXcgb25lIGlzIGNyZWF0ZWQuXG4gICAgICogQHJldHVybnMgVGhlIHRyYW5zbGF0ZWQgbWF0cml4LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRyYW5zbGF0ZShtLCB2LCBkc3QpIHtcbiAgICAgICAgY29uc3QgbmV3RHN0ID0gKGRzdCA/PyBuZXcgQ3RvcigxMikpO1xuICAgICAgICBjb25zdCB2MCA9IHZbMF07XG4gICAgICAgIGNvbnN0IHYxID0gdlsxXTtcbiAgICAgICAgY29uc3QgbTAwID0gbVswXTtcbiAgICAgICAgY29uc3QgbTAxID0gbVsxXTtcbiAgICAgICAgY29uc3QgbTAyID0gbVsyXTtcbiAgICAgICAgY29uc3QgbTEwID0gbVsxICogNCArIDBdO1xuICAgICAgICBjb25zdCBtMTEgPSBtWzEgKiA0ICsgMV07XG4gICAgICAgIGNvbnN0IG0xMiA9IG1bMSAqIDQgKyAyXTtcbiAgICAgICAgY29uc3QgbTIwID0gbVsyICogNCArIDBdO1xuICAgICAgICBjb25zdCBtMjEgPSBtWzIgKiA0ICsgMV07XG4gICAgICAgIGNvbnN0IG0yMiA9IG1bMiAqIDQgKyAyXTtcbiAgICAgICAgaWYgKG0gIT09IG5ld0RzdCkge1xuICAgICAgICAgICAgbmV3RHN0WzBdID0gbTAwO1xuICAgICAgICAgICAgbmV3RHN0WzFdID0gbTAxO1xuICAgICAgICAgICAgbmV3RHN0WzJdID0gbTAyO1xuICAgICAgICAgICAgbmV3RHN0WzRdID0gbTEwO1xuICAgICAgICAgICAgbmV3RHN0WzVdID0gbTExO1xuICAgICAgICAgICAgbmV3RHN0WzZdID0gbTEyO1xuICAgICAgICB9XG4gICAgICAgIG5ld0RzdFs4XSA9IG0wMCAqIHYwICsgbTEwICogdjEgKyBtMjA7XG4gICAgICAgIG5ld0RzdFs5XSA9IG0wMSAqIHYwICsgbTExICogdjEgKyBtMjE7XG4gICAgICAgIG5ld0RzdFsxMF0gPSBtMDIgKiB2MCArIG0xMiAqIHYxICsgbTIyO1xuICAgICAgICByZXR1cm4gbmV3RHN0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgMy1ieS0zIG1hdHJpeCB3aGljaCByb3RhdGVzICBieSB0aGUgZ2l2ZW4gYW5nbGUuXG4gICAgICogQHBhcmFtIGFuZ2xlSW5SYWRpYW5zIC0gVGhlIGFuZ2xlIGJ5IHdoaWNoIHRvIHJvdGF0ZSAoaW4gcmFkaWFucykuXG4gICAgICogQHBhcmFtIGRzdCAtIG1hdHJpeCB0byBob2xkIHJlc3VsdC4gSWYgbm90IHBhc3NlZCBhIG5ldyBvbmUgaXMgY3JlYXRlZC5cbiAgICAgKiBAcmV0dXJucyBUaGUgcm90YXRpb24gbWF0cml4LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHJvdGF0aW9uKGFuZ2xlSW5SYWRpYW5zLCBkc3QpIHtcbiAgICAgICAgY29uc3QgbmV3RHN0ID0gKGRzdCA/PyBuZXcgQ3RvcigxMikpO1xuICAgICAgICBjb25zdCBjID0gTWF0aC5jb3MoYW5nbGVJblJhZGlhbnMpO1xuICAgICAgICBjb25zdCBzID0gTWF0aC5zaW4oYW5nbGVJblJhZGlhbnMpO1xuICAgICAgICBuZXdEc3RbMF0gPSBjO1xuICAgICAgICBuZXdEc3RbMV0gPSBzO1xuICAgICAgICBuZXdEc3RbMl0gPSAwO1xuICAgICAgICBuZXdEc3RbNF0gPSAtcztcbiAgICAgICAgbmV3RHN0WzVdID0gYztcbiAgICAgICAgbmV3RHN0WzZdID0gMDtcbiAgICAgICAgbmV3RHN0WzhdID0gMDtcbiAgICAgICAgbmV3RHN0WzldID0gMDtcbiAgICAgICAgbmV3RHN0WzEwXSA9IDE7XG4gICAgICAgIHJldHVybiBuZXdEc3Q7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJvdGF0ZXMgdGhlIGdpdmVuIDMtYnktMyBtYXRyaXggIGJ5IHRoZSBnaXZlbiBhbmdsZS5cbiAgICAgKiBAcGFyYW0gbSAtIFRoZSBtYXRyaXguXG4gICAgICogQHBhcmFtIGFuZ2xlSW5SYWRpYW5zIC0gVGhlIGFuZ2xlIGJ5IHdoaWNoIHRvIHJvdGF0ZSAoaW4gcmFkaWFucykuXG4gICAgICogQHBhcmFtIGRzdCAtIG1hdHJpeCB0byBob2xkIHJlc3VsdC4gSWYgbm90IHBhc3NlZCBhIG5ldyBvbmUgaXMgY3JlYXRlZC5cbiAgICAgKiBAcmV0dXJucyBUaGUgcm90YXRlZCBtYXRyaXguXG4gICAgICovXG4gICAgZnVuY3Rpb24gcm90YXRlKG0sIGFuZ2xlSW5SYWRpYW5zLCBkc3QpIHtcbiAgICAgICAgY29uc3QgbmV3RHN0ID0gKGRzdCA/PyBuZXcgQ3RvcigxMikpO1xuICAgICAgICBjb25zdCBtMDAgPSBtWzAgKiA0ICsgMF07XG4gICAgICAgIGNvbnN0IG0wMSA9IG1bMCAqIDQgKyAxXTtcbiAgICAgICAgY29uc3QgbTAyID0gbVswICogNCArIDJdO1xuICAgICAgICBjb25zdCBtMTAgPSBtWzEgKiA0ICsgMF07XG4gICAgICAgIGNvbnN0IG0xMSA9IG1bMSAqIDQgKyAxXTtcbiAgICAgICAgY29uc3QgbTEyID0gbVsxICogNCArIDJdO1xuICAgICAgICBjb25zdCBjID0gTWF0aC5jb3MoYW5nbGVJblJhZGlhbnMpO1xuICAgICAgICBjb25zdCBzID0gTWF0aC5zaW4oYW5nbGVJblJhZGlhbnMpO1xuICAgICAgICBuZXdEc3RbMF0gPSBjICogbTAwICsgcyAqIG0xMDtcbiAgICAgICAgbmV3RHN0WzFdID0gYyAqIG0wMSArIHMgKiBtMTE7XG4gICAgICAgIG5ld0RzdFsyXSA9IGMgKiBtMDIgKyBzICogbTEyO1xuICAgICAgICBuZXdEc3RbNF0gPSBjICogbTEwIC0gcyAqIG0wMDtcbiAgICAgICAgbmV3RHN0WzVdID0gYyAqIG0xMSAtIHMgKiBtMDE7XG4gICAgICAgIG5ld0RzdFs2XSA9IGMgKiBtMTIgLSBzICogbTAyO1xuICAgICAgICBpZiAobSAhPT0gbmV3RHN0KSB7XG4gICAgICAgICAgICBuZXdEc3RbOF0gPSBtWzhdO1xuICAgICAgICAgICAgbmV3RHN0WzldID0gbVs5XTtcbiAgICAgICAgICAgIG5ld0RzdFsxMF0gPSBtWzEwXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3RHN0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgMy1ieS0zIG1hdHJpeCB3aGljaCBzY2FsZXMgaW4gZWFjaCBkaW1lbnNpb24gYnkgYW4gYW1vdW50IGdpdmVuIGJ5XG4gICAgICogdGhlIGNvcnJlc3BvbmRpbmcgZW50cnkgaW4gdGhlIGdpdmVuIHZlY3RvcjsgYXNzdW1lcyB0aGUgdmVjdG9yIGhhcyB0aHJlZVxuICAgICAqIGVudHJpZXMuXG4gICAgICogQHBhcmFtIHYgLSBBIHZlY3RvciBvZlxuICAgICAqICAgICAyIGVudHJpZXMgc3BlY2lmeWluZyB0aGUgZmFjdG9yIGJ5IHdoaWNoIHRvIHNjYWxlIGluIGVhY2ggZGltZW5zaW9uLlxuICAgICAqIEBwYXJhbSBkc3QgLSBtYXRyaXggdG8gaG9sZCByZXN1bHQuIElmIG5vdCBwYXNzZWQgYSBuZXcgb25lIGlzIGNyZWF0ZWQuXG4gICAgICogQHJldHVybnMgVGhlIHNjYWxpbmcgbWF0cml4LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNjYWxpbmcodiwgZHN0KSB7XG4gICAgICAgIGNvbnN0IG5ld0RzdCA9IChkc3QgPz8gbmV3IEN0b3IoMTIpKTtcbiAgICAgICAgbmV3RHN0WzBdID0gdlswXTtcbiAgICAgICAgbmV3RHN0WzFdID0gMDtcbiAgICAgICAgbmV3RHN0WzJdID0gMDtcbiAgICAgICAgbmV3RHN0WzRdID0gMDtcbiAgICAgICAgbmV3RHN0WzVdID0gdlsxXTtcbiAgICAgICAgbmV3RHN0WzZdID0gMDtcbiAgICAgICAgbmV3RHN0WzhdID0gMDtcbiAgICAgICAgbmV3RHN0WzldID0gMDtcbiAgICAgICAgbmV3RHN0WzEwXSA9IDE7XG4gICAgICAgIHJldHVybiBuZXdEc3Q7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNjYWxlcyB0aGUgZ2l2ZW4gMy1ieS0zIG1hdHJpeCBpbiBlYWNoIGRpbWVuc2lvbiBieSBhbiBhbW91bnRcbiAgICAgKiBnaXZlbiBieSB0aGUgY29ycmVzcG9uZGluZyBlbnRyeSBpbiB0aGUgZ2l2ZW4gdmVjdG9yOyBhc3N1bWVzIHRoZSB2ZWN0b3IgaGFzXG4gICAgICogdGhyZWUgZW50cmllcy5cbiAgICAgKiBAcGFyYW0gbSAtIFRoZSBtYXRyaXggdG8gYmUgbW9kaWZpZWQuXG4gICAgICogQHBhcmFtIHYgLSBBIHZlY3RvciBvZiAyIGVudHJpZXMgc3BlY2lmeWluZyB0aGVcbiAgICAgKiAgICAgZmFjdG9yIGJ5IHdoaWNoIHRvIHNjYWxlIGluIGVhY2ggZGltZW5zaW9uLlxuICAgICAqIEBwYXJhbSBkc3QgLSBtYXRyaXggdG8gaG9sZCByZXN1bHQuIElmIG5vdCBwYXNzZWQgYSBuZXcgb25lIGlzIGNyZWF0ZWQuXG4gICAgICogQHJldHVybnMgVGhlIHNjYWxlZCBtYXRyaXguXG4gICAgICovXG4gICAgZnVuY3Rpb24gc2NhbGUobSwgdiwgZHN0KSB7XG4gICAgICAgIGNvbnN0IG5ld0RzdCA9IChkc3QgPz8gbmV3IEN0b3IoMTIpKTtcbiAgICAgICAgY29uc3QgdjAgPSB2WzBdO1xuICAgICAgICBjb25zdCB2MSA9IHZbMV07XG4gICAgICAgIG5ld0RzdFswXSA9IHYwICogbVswICogNCArIDBdO1xuICAgICAgICBuZXdEc3RbMV0gPSB2MCAqIG1bMCAqIDQgKyAxXTtcbiAgICAgICAgbmV3RHN0WzJdID0gdjAgKiBtWzAgKiA0ICsgMl07XG4gICAgICAgIG5ld0RzdFs0XSA9IHYxICogbVsxICogNCArIDBdO1xuICAgICAgICBuZXdEc3RbNV0gPSB2MSAqIG1bMSAqIDQgKyAxXTtcbiAgICAgICAgbmV3RHN0WzZdID0gdjEgKiBtWzEgKiA0ICsgMl07XG4gICAgICAgIGlmIChtICE9PSBuZXdEc3QpIHtcbiAgICAgICAgICAgIG5ld0RzdFs4XSA9IG1bOF07XG4gICAgICAgICAgICBuZXdEc3RbOV0gPSBtWzldO1xuICAgICAgICAgICAgbmV3RHN0WzEwXSA9IG1bMTBdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXdEc3Q7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSAzLWJ5LTMgbWF0cml4IHdoaWNoIHNjYWxlcyB1bmlmb3JtbHkgaW4gZWFjaCBkaW1lbnNpb25cbiAgICAgKiBAcGFyYW0gcyAtIEFtb3VudCB0byBzY2FsZVxuICAgICAqIEBwYXJhbSBkc3QgLSBtYXRyaXggdG8gaG9sZCByZXN1bHQuIElmIG5vdCBwYXNzZWQgYSBuZXcgb25lIGlzIGNyZWF0ZWQuXG4gICAgICogQHJldHVybnMgVGhlIHNjYWxpbmcgbWF0cml4LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHVuaWZvcm1TY2FsaW5nKHMsIGRzdCkge1xuICAgICAgICBjb25zdCBuZXdEc3QgPSAoZHN0ID8/IG5ldyBDdG9yKDEyKSk7XG4gICAgICAgIG5ld0RzdFswXSA9IHM7XG4gICAgICAgIG5ld0RzdFsxXSA9IDA7XG4gICAgICAgIG5ld0RzdFsyXSA9IDA7XG4gICAgICAgIG5ld0RzdFs0XSA9IDA7XG4gICAgICAgIG5ld0RzdFs1XSA9IHM7XG4gICAgICAgIG5ld0RzdFs2XSA9IDA7XG4gICAgICAgIG5ld0RzdFs4XSA9IDA7XG4gICAgICAgIG5ld0RzdFs5XSA9IDA7XG4gICAgICAgIG5ld0RzdFsxMF0gPSAxO1xuICAgICAgICByZXR1cm4gbmV3RHN0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTY2FsZXMgdGhlIGdpdmVuIDMtYnktMyBtYXRyaXggaW4gZWFjaCBkaW1lbnNpb24gYnkgYW4gYW1vdW50XG4gICAgICogZ2l2ZW4uXG4gICAgICogQHBhcmFtIG0gLSBUaGUgbWF0cml4IHRvIGJlIG1vZGlmaWVkLlxuICAgICAqIEBwYXJhbSBzIC0gQW1vdW50IHRvIHNjYWxlLlxuICAgICAqIEBwYXJhbSBkc3QgLSBtYXRyaXggdG8gaG9sZCByZXN1bHQuIElmIG5vdCBwYXNzZWQgYSBuZXcgb25lIGlzIGNyZWF0ZWQuXG4gICAgICogQHJldHVybnMgVGhlIHNjYWxlZCBtYXRyaXguXG4gICAgICovXG4gICAgZnVuY3Rpb24gdW5pZm9ybVNjYWxlKG0sIHMsIGRzdCkge1xuICAgICAgICBjb25zdCBuZXdEc3QgPSAoZHN0ID8/IG5ldyBDdG9yKDEyKSk7XG4gICAgICAgIG5ld0RzdFswXSA9IHMgKiBtWzAgKiA0ICsgMF07XG4gICAgICAgIG5ld0RzdFsxXSA9IHMgKiBtWzAgKiA0ICsgMV07XG4gICAgICAgIG5ld0RzdFsyXSA9IHMgKiBtWzAgKiA0ICsgMl07XG4gICAgICAgIG5ld0RzdFs0XSA9IHMgKiBtWzEgKiA0ICsgMF07XG4gICAgICAgIG5ld0RzdFs1XSA9IHMgKiBtWzEgKiA0ICsgMV07XG4gICAgICAgIG5ld0RzdFs2XSA9IHMgKiBtWzEgKiA0ICsgMl07XG4gICAgICAgIGlmIChtICE9PSBuZXdEc3QpIHtcbiAgICAgICAgICAgIG5ld0RzdFs4XSA9IG1bOF07XG4gICAgICAgICAgICBuZXdEc3RbOV0gPSBtWzldO1xuICAgICAgICAgICAgbmV3RHN0WzEwXSA9IG1bMTBdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXdEc3Q7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIGNsb25lLFxuICAgICAgICBjcmVhdGUsXG4gICAgICAgIHNldCxcbiAgICAgICAgZnJvbU1hdDQsXG4gICAgICAgIGZyb21RdWF0LFxuICAgICAgICBuZWdhdGUsXG4gICAgICAgIGNvcHksXG4gICAgICAgIGVxdWFsc0FwcHJveGltYXRlbHksXG4gICAgICAgIGVxdWFscyxcbiAgICAgICAgaWRlbnRpdHksXG4gICAgICAgIHRyYW5zcG9zZSxcbiAgICAgICAgaW52ZXJzZSxcbiAgICAgICAgaW52ZXJ0LFxuICAgICAgICBkZXRlcm1pbmFudCxcbiAgICAgICAgbXVsLFxuICAgICAgICBtdWx0aXBseSxcbiAgICAgICAgc2V0VHJhbnNsYXRpb24sXG4gICAgICAgIGdldFRyYW5zbGF0aW9uLFxuICAgICAgICBnZXRBeGlzLFxuICAgICAgICBzZXRBeGlzLFxuICAgICAgICBnZXRTY2FsaW5nLFxuICAgICAgICB0cmFuc2xhdGlvbixcbiAgICAgICAgdHJhbnNsYXRlLFxuICAgICAgICByb3RhdGlvbixcbiAgICAgICAgcm90YXRlLFxuICAgICAgICBzY2FsaW5nLFxuICAgICAgICBzY2FsZSxcbiAgICAgICAgdW5pZm9ybVNjYWxpbmcsXG4gICAgICAgIHVuaWZvcm1TY2FsZSxcbiAgICB9O1xufVxuY29uc3QgY2FjaGUkNCA9IG5ldyBNYXAoKTtcbmZ1bmN0aW9uIGdldEFQSSQ0KEN0b3IpIHtcbiAgICBsZXQgYXBpID0gY2FjaGUkNC5nZXQoQ3Rvcik7XG4gICAgaWYgKCFhcGkpIHtcbiAgICAgICAgYXBpID0gZ2V0QVBJSW1wbCQ0KEN0b3IpO1xuICAgICAgICBjYWNoZSQ0LnNldChDdG9yLCBhcGkpO1xuICAgIH1cbiAgICByZXR1cm4gYXBpO1xufVxuXG4vKlxuICogQ29weXJpZ2h0IDIwMjIgR3JlZ2cgVGF2YXJlc1xuICpcbiAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4gKiBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksXG4gKiB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uXG4gKiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSxcbiAqIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZVxuICogU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbiAqXG4gKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuICogYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gKlxuICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuICogSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4gKiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiAgSU4gTk8gRVZFTlQgU0hBTExcbiAqIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4gKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lOR1xuICogRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUlxuICogREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuICovXG4vKipcbiAqIEdlbmVyYXRlcyBhbSB0eXBlZCBBUEkgZm9yIFZlYzNcbiAqICovXG5mdW5jdGlvbiBnZXRBUElJbXBsJDMoQ3Rvcikge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSB2ZWMzOyBtYXkgYmUgY2FsbGVkIHdpdGggeCwgeSwgeiB0byBzZXQgaW5pdGlhbCB2YWx1ZXMuXG4gICAgICogQHBhcmFtIHggLSBJbml0aWFsIHggdmFsdWUuXG4gICAgICogQHBhcmFtIHkgLSBJbml0aWFsIHkgdmFsdWUuXG4gICAgICogQHBhcmFtIHogLSBJbml0aWFsIHogdmFsdWUuXG4gICAgICogQHJldHVybnMgdGhlIGNyZWF0ZWQgdmVjdG9yXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlKHgsIHksIHopIHtcbiAgICAgICAgY29uc3QgbmV3RHN0ID0gbmV3IEN0b3IoMyk7XG4gICAgICAgIGlmICh4ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIG5ld0RzdFswXSA9IHg7XG4gICAgICAgICAgICBpZiAoeSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgbmV3RHN0WzFdID0geTtcbiAgICAgICAgICAgICAgICBpZiAoeiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIG5ld0RzdFsyXSA9IHo7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXdEc3Q7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSB2ZWMzOyBtYXkgYmUgY2FsbGVkIHdpdGggeCwgeSwgeiB0byBzZXQgaW5pdGlhbCB2YWx1ZXMuIChzYW1lIGFzIGNyZWF0ZSlcbiAgICAgKiBAcGFyYW0geCAtIEluaXRpYWwgeCB2YWx1ZS5cbiAgICAgKiBAcGFyYW0geSAtIEluaXRpYWwgeSB2YWx1ZS5cbiAgICAgKiBAcGFyYW0geiAtIEluaXRpYWwgeiB2YWx1ZS5cbiAgICAgKiBAcmV0dXJucyB0aGUgY3JlYXRlZCB2ZWN0b3JcbiAgICAgKi9cbiAgICBjb25zdCBmcm9tVmFsdWVzID0gY3JlYXRlO1xuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIHZhbHVlcyBvZiBhIFZlYzNcbiAgICAgKiBBbHNvIHNlZSB7QGxpbmsgdmVjMy5jcmVhdGV9IGFuZCB7QGxpbmsgdmVjMy5jb3B5fVxuICAgICAqXG4gICAgICogQHBhcmFtIHggZmlyc3QgdmFsdWVcbiAgICAgKiBAcGFyYW0geSBzZWNvbmQgdmFsdWVcbiAgICAgKiBAcGFyYW0geiB0aGlyZCB2YWx1ZVxuICAgICAqIEBwYXJhbSBkc3QgLSB2ZWN0b3IgdG8gaG9sZCByZXN1bHQuIElmIG5vdCBwYXNzZWQgaW4gYSBuZXcgb25lIGlzIGNyZWF0ZWQuXG4gICAgICogQHJldHVybnMgQSB2ZWN0b3Igd2l0aCBpdHMgZWxlbWVudHMgc2V0LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNldCh4LCB5LCB6LCBkc3QpIHtcbiAgICAgICAgY29uc3QgbmV3RHN0ID0gKGRzdCA/PyBuZXcgQ3RvcigzKSk7XG4gICAgICAgIG5ld0RzdFswXSA9IHg7XG4gICAgICAgIG5ld0RzdFsxXSA9IHk7XG4gICAgICAgIG5ld0RzdFsyXSA9IHo7XG4gICAgICAgIHJldHVybiBuZXdEc3Q7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFwcGxpZXMgTWF0aC5jZWlsIHRvIGVhY2ggZWxlbWVudCBvZiB2ZWN0b3JcbiAgICAgKiBAcGFyYW0gdiAtIE9wZXJhbmQgdmVjdG9yLlxuICAgICAqIEBwYXJhbSBkc3QgLSB2ZWN0b3IgdG8gaG9sZCByZXN1bHQuIElmIG5vdCBwYXNzZWQgaW4gYSBuZXcgb25lIGlzIGNyZWF0ZWQuXG4gICAgICogQHJldHVybnMgQSB2ZWN0b3IgdGhhdCBpcyB0aGUgY2VpbCBvZiBlYWNoIGVsZW1lbnQgb2Ygdi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjZWlsKHYsIGRzdCkge1xuICAgICAgICBjb25zdCBuZXdEc3QgPSAoZHN0ID8/IG5ldyBDdG9yKDMpKTtcbiAgICAgICAgbmV3RHN0WzBdID0gTWF0aC5jZWlsKHZbMF0pO1xuICAgICAgICBuZXdEc3RbMV0gPSBNYXRoLmNlaWwodlsxXSk7XG4gICAgICAgIG5ld0RzdFsyXSA9IE1hdGguY2VpbCh2WzJdKTtcbiAgICAgICAgcmV0dXJuIG5ld0RzdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQXBwbGllcyBNYXRoLmZsb29yIHRvIGVhY2ggZWxlbWVudCBvZiB2ZWN0b3JcbiAgICAgKiBAcGFyYW0gdiAtIE9wZXJhbmQgdmVjdG9yLlxuICAgICAqIEBwYXJhbSBkc3QgLSB2ZWN0b3IgdG8gaG9sZCByZXN1bHQuIElmIG5vdCBwYXNzZWQgaW4gYSBuZXcgb25lIGlzIGNyZWF0ZWQuXG4gICAgICogQHJldHVybnMgQSB2ZWN0b3IgdGhhdCBpcyB0aGUgZmxvb3Igb2YgZWFjaCBlbGVtZW50IG9mIHYuXG4gICAgICovXG4gICAgZnVuY3Rpb24gZmxvb3IodiwgZHN0KSB7XG4gICAgICAgIGNvbnN0IG5ld0RzdCA9IChkc3QgPz8gbmV3IEN0b3IoMykpO1xuICAgICAgICBuZXdEc3RbMF0gPSBNYXRoLmZsb29yKHZbMF0pO1xuICAgICAgICBuZXdEc3RbMV0gPSBNYXRoLmZsb29yKHZbMV0pO1xuICAgICAgICBuZXdEc3RbMl0gPSBNYXRoLmZsb29yKHZbMl0pO1xuICAgICAgICByZXR1cm4gbmV3RHN0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBcHBsaWVzIE1hdGgucm91bmQgdG8gZWFjaCBlbGVtZW50IG9mIHZlY3RvclxuICAgICAqIEBwYXJhbSB2IC0gT3BlcmFuZCB2ZWN0b3IuXG4gICAgICogQHBhcmFtIGRzdCAtIHZlY3RvciB0byBob2xkIHJlc3VsdC4gSWYgbm90IHBhc3NlZCBpbiBhIG5ldyBvbmUgaXMgY3JlYXRlZC5cbiAgICAgKiBAcmV0dXJucyBBIHZlY3RvciB0aGF0IGlzIHRoZSByb3VuZCBvZiBlYWNoIGVsZW1lbnQgb2Ygdi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiByb3VuZCh2LCBkc3QpIHtcbiAgICAgICAgY29uc3QgbmV3RHN0ID0gKGRzdCA/PyBuZXcgQ3RvcigzKSk7XG4gICAgICAgIG5ld0RzdFswXSA9IE1hdGgucm91bmQodlswXSk7XG4gICAgICAgIG5ld0RzdFsxXSA9IE1hdGgucm91bmQodlsxXSk7XG4gICAgICAgIG5ld0RzdFsyXSA9IE1hdGgucm91bmQodlsyXSk7XG4gICAgICAgIHJldHVybiBuZXdEc3Q7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENsYW1wIGVhY2ggZWxlbWVudCBvZiB2ZWN0b3IgYmV0d2VlbiBtaW4gYW5kIG1heFxuICAgICAqIEBwYXJhbSB2IC0gT3BlcmFuZCB2ZWN0b3IuXG4gICAgICogQHBhcmFtIG1heCAtIE1pbiB2YWx1ZSwgZGVmYXVsdCAwXG4gICAgICogQHBhcmFtIG1pbiAtIE1heCB2YWx1ZSwgZGVmYXVsdCAxXG4gICAgICogQHBhcmFtIGRzdCAtIHZlY3RvciB0byBob2xkIHJlc3VsdC4gSWYgbm90IHBhc3NlZCBpbiBhIG5ldyBvbmUgaXMgY3JlYXRlZC5cbiAgICAgKiBAcmV0dXJucyBBIHZlY3RvciB0aGF0IHRoZSBjbGFtcGVkIHZhbHVlIG9mIGVhY2ggZWxlbWVudCBvZiB2LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNsYW1wKHYsIG1pbiA9IDAsIG1heCA9IDEsIGRzdCkge1xuICAgICAgICBjb25zdCBuZXdEc3QgPSAoZHN0ID8/IG5ldyBDdG9yKDMpKTtcbiAgICAgICAgbmV3RHN0WzBdID0gTWF0aC5taW4obWF4LCBNYXRoLm1heChtaW4sIHZbMF0pKTtcbiAgICAgICAgbmV3RHN0WzFdID0gTWF0aC5taW4obWF4LCBNYXRoLm1heChtaW4sIHZbMV0pKTtcbiAgICAgICAgbmV3RHN0WzJdID0gTWF0aC5taW4obWF4LCBNYXRoLm1heChtaW4sIHZbMl0pKTtcbiAgICAgICAgcmV0dXJuIG5ld0RzdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWRkcyB0d28gdmVjdG9yczsgYXNzdW1lcyBhIGFuZCBiIGhhdmUgdGhlIHNhbWUgZGltZW5zaW9uLlxuICAgICAqIEBwYXJhbSBhIC0gT3BlcmFuZCB2ZWN0b3IuXG4gICAgICogQHBhcmFtIGIgLSBPcGVyYW5kIHZlY3Rvci5cbiAgICAgKiBAcGFyYW0gZHN0IC0gdmVjdG9yIHRvIGhvbGQgcmVzdWx0LiBJZiBub3QgcGFzc2VkIGluIGEgbmV3IG9uZSBpcyBjcmVhdGVkLlxuICAgICAqIEByZXR1cm5zIEEgdmVjdG9yIHRoYXQgaXMgdGhlIHN1bSBvZiBhIGFuZCBiLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGFkZChhLCBiLCBkc3QpIHtcbiAgICAgICAgY29uc3QgbmV3RHN0ID0gKGRzdCA/PyBuZXcgQ3RvcigzKSk7XG4gICAgICAgIG5ld0RzdFswXSA9IGFbMF0gKyBiWzBdO1xuICAgICAgICBuZXdEc3RbMV0gPSBhWzFdICsgYlsxXTtcbiAgICAgICAgbmV3RHN0WzJdID0gYVsyXSArIGJbMl07XG4gICAgICAgIHJldHVybiBuZXdEc3Q7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkZHMgdHdvIHZlY3RvcnMsIHNjYWxpbmcgdGhlIDJuZDsgYXNzdW1lcyBhIGFuZCBiIGhhdmUgdGhlIHNhbWUgZGltZW5zaW9uLlxuICAgICAqIEBwYXJhbSBhIC0gT3BlcmFuZCB2ZWN0b3IuXG4gICAgICogQHBhcmFtIGIgLSBPcGVyYW5kIHZlY3Rvci5cbiAgICAgKiBAcGFyYW0gc2NhbGUgLSBBbW91bnQgdG8gc2NhbGUgYlxuICAgICAqIEBwYXJhbSBkc3QgLSB2ZWN0b3IgdG8gaG9sZCByZXN1bHQuIElmIG5vdCBwYXNzZWQgaW4gYSBuZXcgb25lIGlzIGNyZWF0ZWQuXG4gICAgICogQHJldHVybnMgQSB2ZWN0b3IgdGhhdCBpcyB0aGUgc3VtIG9mIGEgKyBiICogc2NhbGUuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYWRkU2NhbGVkKGEsIGIsIHNjYWxlLCBkc3QpIHtcbiAgICAgICAgY29uc3QgbmV3RHN0ID0gKGRzdCA/PyBuZXcgQ3RvcigzKSk7XG4gICAgICAgIG5ld0RzdFswXSA9IGFbMF0gKyBiWzBdICogc2NhbGU7XG4gICAgICAgIG5ld0RzdFsxXSA9IGFbMV0gKyBiWzFdICogc2NhbGU7XG4gICAgICAgIG5ld0RzdFsyXSA9IGFbMl0gKyBiWzJdICogc2NhbGU7XG4gICAgICAgIHJldHVybiBuZXdEc3Q7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGFuZ2xlIGluIHJhZGlhbnMgYmV0d2VlbiB0d28gdmVjdG9ycy5cbiAgICAgKiBAcGFyYW0gYSAtIE9wZXJhbmQgdmVjdG9yLlxuICAgICAqIEBwYXJhbSBiIC0gT3BlcmFuZCB2ZWN0b3IuXG4gICAgICogQHJldHVybnMgVGhlIGFuZ2xlIGluIHJhZGlhbnMgYmV0d2VlbiB0aGUgMiB2ZWN0b3JzLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGFuZ2xlKGEsIGIpIHtcbiAgICAgICAgY29uc3QgYXggPSBhWzBdO1xuICAgICAgICBjb25zdCBheSA9IGFbMV07XG4gICAgICAgIGNvbnN0IGF6ID0gYVsyXTtcbiAgICAgICAgY29uc3QgYnggPSBiWzBdO1xuICAgICAgICBjb25zdCBieSA9IGJbMV07XG4gICAgICAgIGNvbnN0IGJ6ID0gYlsyXTtcbiAgICAgICAgY29uc3QgbWFnMSA9IE1hdGguc3FydChheCAqIGF4ICsgYXkgKiBheSArIGF6ICogYXopO1xuICAgICAgICBjb25zdCBtYWcyID0gTWF0aC5zcXJ0KGJ4ICogYnggKyBieSAqIGJ5ICsgYnogKiBieik7XG4gICAgICAgIGNvbnN0IG1hZyA9IG1hZzEgKiBtYWcyO1xuICAgICAgICBjb25zdCBjb3NpbmUgPSBtYWcgJiYgZG90KGEsIGIpIC8gbWFnO1xuICAgICAgICByZXR1cm4gTWF0aC5hY29zKGNvc2luZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFN1YnRyYWN0cyB0d28gdmVjdG9ycy5cbiAgICAgKiBAcGFyYW0gYSAtIE9wZXJhbmQgdmVjdG9yLlxuICAgICAqIEBwYXJhbSBiIC0gT3BlcmFuZCB2ZWN0b3IuXG4gICAgICogQHBhcmFtIGRzdCAtIHZlY3RvciB0byBob2xkIHJlc3VsdC4gSWYgbm90IHBhc3NlZCBpbiBhIG5ldyBvbmUgaXMgY3JlYXRlZC5cbiAgICAgKiBAcmV0dXJucyBBIHZlY3RvciB0aGF0IGlzIHRoZSBkaWZmZXJlbmNlIG9mIGEgYW5kIGIuXG4gICAgICovXG4gICAgZnVuY3Rpb24gc3VidHJhY3QoYSwgYiwgZHN0KSB7XG4gICAgICAgIGNvbnN0IG5ld0RzdCA9IChkc3QgPz8gbmV3IEN0b3IoMykpO1xuICAgICAgICBuZXdEc3RbMF0gPSBhWzBdIC0gYlswXTtcbiAgICAgICAgbmV3RHN0WzFdID0gYVsxXSAtIGJbMV07XG4gICAgICAgIG5ld0RzdFsyXSA9IGFbMl0gLSBiWzJdO1xuICAgICAgICByZXR1cm4gbmV3RHN0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTdWJ0cmFjdHMgdHdvIHZlY3RvcnMuXG4gICAgICogQHBhcmFtIGEgLSBPcGVyYW5kIHZlY3Rvci5cbiAgICAgKiBAcGFyYW0gYiAtIE9wZXJhbmQgdmVjdG9yLlxuICAgICAqIEBwYXJhbSBkc3QgLSB2ZWN0b3IgdG8gaG9sZCByZXN1bHQuIElmIG5vdCBwYXNzZWQgaW4gYSBuZXcgb25lIGlzIGNyZWF0ZWQuXG4gICAgICogQHJldHVybnMgQSB2ZWN0b3IgdGhhdCBpcyB0aGUgZGlmZmVyZW5jZSBvZiBhIGFuZCBiLlxuICAgICAqL1xuICAgIGNvbnN0IHN1YiA9IHN1YnRyYWN0O1xuICAgIC8qKlxuICAgICAqIENoZWNrIGlmIDIgdmVjdG9ycyBhcmUgYXBwcm94aW1hdGVseSBlcXVhbFxuICAgICAqIEBwYXJhbSBhIC0gT3BlcmFuZCB2ZWN0b3IuXG4gICAgICogQHBhcmFtIGIgLSBPcGVyYW5kIHZlY3Rvci5cbiAgICAgKiBAcmV0dXJucyB0cnVlIGlmIHZlY3RvcnMgYXJlIGFwcHJveGltYXRlbHkgZXF1YWxcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBlcXVhbHNBcHByb3hpbWF0ZWx5KGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIE1hdGguYWJzKGFbMF0gLSBiWzBdKSA8IEVQU0lMT04gJiZcbiAgICAgICAgICAgIE1hdGguYWJzKGFbMV0gLSBiWzFdKSA8IEVQU0lMT04gJiZcbiAgICAgICAgICAgIE1hdGguYWJzKGFbMl0gLSBiWzJdKSA8IEVQU0lMT047XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENoZWNrIGlmIDIgdmVjdG9ycyBhcmUgZXhhY3RseSBlcXVhbFxuICAgICAqIEBwYXJhbSBhIC0gT3BlcmFuZCB2ZWN0b3IuXG4gICAgICogQHBhcmFtIGIgLSBPcGVyYW5kIHZlY3Rvci5cbiAgICAgKiBAcmV0dXJucyB0cnVlIGlmIHZlY3RvcnMgYXJlIGV4YWN0bHkgZXF1YWxcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBlcXVhbHMoYSwgYikge1xuICAgICAgICByZXR1cm4gYVswXSA9PT0gYlswXSAmJiBhWzFdID09PSBiWzFdICYmIGFbMl0gPT09IGJbMl07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFBlcmZvcm1zIGxpbmVhciBpbnRlcnBvbGF0aW9uIG9uIHR3byB2ZWN0b3JzLlxuICAgICAqIEdpdmVuIHZlY3RvcnMgYSBhbmQgYiBhbmQgaW50ZXJwb2xhdGlvbiBjb2VmZmljaWVudCB0LCByZXR1cm5zXG4gICAgICogYSArIHQgKiAoYiAtIGEpLlxuICAgICAqIEBwYXJhbSBhIC0gT3BlcmFuZCB2ZWN0b3IuXG4gICAgICogQHBhcmFtIGIgLSBPcGVyYW5kIHZlY3Rvci5cbiAgICAgKiBAcGFyYW0gdCAtIEludGVycG9sYXRpb24gY29lZmZpY2llbnQuXG4gICAgICogQHBhcmFtIGRzdCAtIHZlY3RvciB0byBob2xkIHJlc3VsdC4gSWYgbm90IHBhc3NlZCBpbiBhIG5ldyBvbmUgaXMgY3JlYXRlZC5cbiAgICAgKiBAcmV0dXJucyBUaGUgbGluZWFyIGludGVycG9sYXRlZCByZXN1bHQuXG4gICAgICovXG4gICAgZnVuY3Rpb24gbGVycChhLCBiLCB0LCBkc3QpIHtcbiAgICAgICAgY29uc3QgbmV3RHN0ID0gKGRzdCA/PyBuZXcgQ3RvcigzKSk7XG4gICAgICAgIG5ld0RzdFswXSA9IGFbMF0gKyB0ICogKGJbMF0gLSBhWzBdKTtcbiAgICAgICAgbmV3RHN0WzFdID0gYVsxXSArIHQgKiAoYlsxXSAtIGFbMV0pO1xuICAgICAgICBuZXdEc3RbMl0gPSBhWzJdICsgdCAqIChiWzJdIC0gYVsyXSk7XG4gICAgICAgIHJldHVybiBuZXdEc3Q7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFBlcmZvcm1zIGxpbmVhciBpbnRlcnBvbGF0aW9uIG9uIHR3byB2ZWN0b3JzLlxuICAgICAqIEdpdmVuIHZlY3RvcnMgYSBhbmQgYiBhbmQgaW50ZXJwb2xhdGlvbiBjb2VmZmljaWVudCB2ZWN0b3IgdCwgcmV0dXJuc1xuICAgICAqIGEgKyB0ICogKGIgLSBhKS5cbiAgICAgKiBAcGFyYW0gYSAtIE9wZXJhbmQgdmVjdG9yLlxuICAgICAqIEBwYXJhbSBiIC0gT3BlcmFuZCB2ZWN0b3IuXG4gICAgICogQHBhcmFtIHQgLSBJbnRlcnBvbGF0aW9uIGNvZWZmaWNpZW50cyB2ZWN0b3IuXG4gICAgICogQHBhcmFtIGRzdCAtIHZlY3RvciB0byBob2xkIHJlc3VsdC4gSWYgbm90IHBhc3NlZCBpbiBhIG5ldyBvbmUgaXMgY3JlYXRlZC5cbiAgICAgKiBAcmV0dXJucyB0aGUgbGluZWFyIGludGVycG9sYXRlZCByZXN1bHQuXG4gICAgICovXG4gICAgZnVuY3Rpb24gbGVycFYoYSwgYiwgdCwgZHN0KSB7XG4gICAgICAgIGNvbnN0IG5ld0RzdCA9IChkc3QgPz8gbmV3IEN0b3IoMykpO1xuICAgICAgICBuZXdEc3RbMF0gPSBhWzBdICsgdFswXSAqIChiWzBdIC0gYVswXSk7XG4gICAgICAgIG5ld0RzdFsxXSA9IGFbMV0gKyB0WzFdICogKGJbMV0gLSBhWzFdKTtcbiAgICAgICAgbmV3RHN0WzJdID0gYVsyXSArIHRbMl0gKiAoYlsyXSAtIGFbMl0pO1xuICAgICAgICByZXR1cm4gbmV3RHN0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gbWF4IHZhbHVlcyBvZiB0d28gdmVjdG9ycy5cbiAgICAgKiBHaXZlbiB2ZWN0b3JzIGEgYW5kIGIgcmV0dXJuc1xuICAgICAqIFttYXgoYVswXSwgYlswXSksIG1heChhWzFdLCBiWzFdKSwgbWF4KGFbMl0sIGJbMl0pXS5cbiAgICAgKiBAcGFyYW0gYSAtIE9wZXJhbmQgdmVjdG9yLlxuICAgICAqIEBwYXJhbSBiIC0gT3BlcmFuZCB2ZWN0b3IuXG4gICAgICogQHBhcmFtIGRzdCAtIHZlY3RvciB0byBob2xkIHJlc3VsdC4gSWYgbm90IHBhc3NlZCBpbiBhIG5ldyBvbmUgaXMgY3JlYXRlZC5cbiAgICAgKiBAcmV0dXJucyBUaGUgbWF4IGNvbXBvbmVudHMgdmVjdG9yLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG1heChhLCBiLCBkc3QpIHtcbiAgICAgICAgY29uc3QgbmV3RHN0ID0gKGRzdCA/PyBuZXcgQ3RvcigzKSk7XG4gICAgICAgIG5ld0RzdFswXSA9IE1hdGgubWF4KGFbMF0sIGJbMF0pO1xuICAgICAgICBuZXdEc3RbMV0gPSBNYXRoLm1heChhWzFdLCBiWzFdKTtcbiAgICAgICAgbmV3RHN0WzJdID0gTWF0aC5tYXgoYVsyXSwgYlsyXSk7XG4gICAgICAgIHJldHVybiBuZXdEc3Q7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybiBtaW4gdmFsdWVzIG9mIHR3byB2ZWN0b3JzLlxuICAgICAqIEdpdmVuIHZlY3RvcnMgYSBhbmQgYiByZXR1cm5zXG4gICAgICogW21pbihhWzBdLCBiWzBdKSwgbWluKGFbMV0sIGJbMV0pLCBtaW4oYVsyXSwgYlsyXSldLlxuICAgICAqIEBwYXJhbSBhIC0gT3BlcmFuZCB2ZWN0b3IuXG4gICAgICogQHBhcmFtIGIgLSBPcGVyYW5kIHZlY3Rvci5cbiAgICAgKiBAcGFyYW0gZHN0IC0gdmVjdG9yIHRvIGhvbGQgcmVzdWx0LiBJZiBub3QgcGFzc2VkIGluIGEgbmV3IG9uZSBpcyBjcmVhdGVkLlxuICAgICAqIEByZXR1cm5zIFRoZSBtaW4gY29tcG9uZW50cyB2ZWN0b3IuXG4gICAgICovXG4gICAgZnVuY3Rpb24gbWluKGEsIGIsIGRzdCkge1xuICAgICAgICBjb25zdCBuZXdEc3QgPSAoZHN0ID8/IG5ldyBDdG9yKDMpKTtcbiAgICAgICAgbmV3RHN0WzBdID0gTWF0aC5taW4oYVswXSwgYlswXSk7XG4gICAgICAgIG5ld0RzdFsxXSA9IE1hdGgubWluKGFbMV0sIGJbMV0pO1xuICAgICAgICBuZXdEc3RbMl0gPSBNYXRoLm1pbihhWzJdLCBiWzJdKTtcbiAgICAgICAgcmV0dXJuIG5ld0RzdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTXVsdGlwbGllcyBhIHZlY3RvciBieSBhIHNjYWxhci5cbiAgICAgKiBAcGFyYW0gdiAtIFRoZSB2ZWN0b3IuXG4gICAgICogQHBhcmFtIGsgLSBUaGUgc2NhbGFyLlxuICAgICAqIEBwYXJhbSBkc3QgLSB2ZWN0b3IgdG8gaG9sZCByZXN1bHQuIElmIG5vdCBwYXNzZWQgaW4gYSBuZXcgb25lIGlzIGNyZWF0ZWQuXG4gICAgICogQHJldHVybnMgVGhlIHNjYWxlZCB2ZWN0b3IuXG4gICAgICovXG4gICAgZnVuY3Rpb24gbXVsU2NhbGFyKHYsIGssIGRzdCkge1xuICAgICAgICBjb25zdCBuZXdEc3QgPSAoZHN0ID8/IG5ldyBDdG9yKDMpKTtcbiAgICAgICAgbmV3RHN0WzBdID0gdlswXSAqIGs7XG4gICAgICAgIG5ld0RzdFsxXSA9IHZbMV0gKiBrO1xuICAgICAgICBuZXdEc3RbMl0gPSB2WzJdICogaztcbiAgICAgICAgcmV0dXJuIG5ld0RzdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTXVsdGlwbGllcyBhIHZlY3RvciBieSBhIHNjYWxhci4gKHNhbWUgYXMgbXVsU2NhbGFyKVxuICAgICAqIEBwYXJhbSB2IC0gVGhlIHZlY3Rvci5cbiAgICAgKiBAcGFyYW0gayAtIFRoZSBzY2FsYXIuXG4gICAgICogQHBhcmFtIGRzdCAtIHZlY3RvciB0byBob2xkIHJlc3VsdC4gSWYgbm90IHBhc3NlZCBpbiBhIG5ldyBvbmUgaXMgY3JlYXRlZC5cbiAgICAgKiBAcmV0dXJucyBUaGUgc2NhbGVkIHZlY3Rvci5cbiAgICAgKi9cbiAgICBjb25zdCBzY2FsZSA9IG11bFNjYWxhcjtcbiAgICAvKipcbiAgICAgKiBEaXZpZGVzIGEgdmVjdG9yIGJ5IGEgc2NhbGFyLlxuICAgICAqIEBwYXJhbSB2IC0gVGhlIHZlY3Rvci5cbiAgICAgKiBAcGFyYW0gayAtIFRoZSBzY2FsYXIuXG4gICAgICogQHBhcmFtIGRzdCAtIHZlY3RvciB0byBob2xkIHJlc3VsdC4gSWYgbm90IHBhc3NlZCBpbiBhIG5ldyBvbmUgaXMgY3JlYXRlZC5cbiAgICAgKiBAcmV0dXJucyBUaGUgc2NhbGVkIHZlY3Rvci5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBkaXZTY2FsYXIodiwgaywgZHN0KSB7XG4gICAgICAgIGNvbnN0IG5ld0RzdCA9IChkc3QgPz8gbmV3IEN0b3IoMykpO1xuICAgICAgICBuZXdEc3RbMF0gPSB2WzBdIC8gaztcbiAgICAgICAgbmV3RHN0WzFdID0gdlsxXSAvIGs7XG4gICAgICAgIG5ld0RzdFsyXSA9IHZbMl0gLyBrO1xuICAgICAgICByZXR1cm4gbmV3RHN0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJbnZlcnNlIGEgdmVjdG9yLlxuICAgICAqIEBwYXJhbSB2IC0gVGhlIHZlY3Rvci5cbiAgICAgKiBAcGFyYW0gZHN0IC0gdmVjdG9yIHRvIGhvbGQgcmVzdWx0LiBJZiBub3QgcGFzc2VkIGluIGEgbmV3IG9uZSBpcyBjcmVhdGVkLlxuICAgICAqIEByZXR1cm5zIFRoZSBpbnZlcnRlZCB2ZWN0b3IuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaW52ZXJzZSh2LCBkc3QpIHtcbiAgICAgICAgY29uc3QgbmV3RHN0ID0gKGRzdCA/PyBuZXcgQ3RvcigzKSk7XG4gICAgICAgIG5ld0RzdFswXSA9IDEgLyB2WzBdO1xuICAgICAgICBuZXdEc3RbMV0gPSAxIC8gdlsxXTtcbiAgICAgICAgbmV3RHN0WzJdID0gMSAvIHZbMl07XG4gICAgICAgIHJldHVybiBuZXdEc3Q7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEludmVydCBhIHZlY3Rvci4gKHNhbWUgYXMgaW52ZXJzZSlcbiAgICAgKiBAcGFyYW0gdiAtIFRoZSB2ZWN0b3IuXG4gICAgICogQHBhcmFtIGRzdCAtIHZlY3RvciB0byBob2xkIHJlc3VsdC4gSWYgbm90IHBhc3NlZCBpbiBhIG5ldyBvbmUgaXMgY3JlYXRlZC5cbiAgICAgKiBAcmV0dXJucyBUaGUgaW52ZXJ0ZWQgdmVjdG9yLlxuICAgICAqL1xuICAgIGNvbnN0IGludmVydCA9IGludmVyc2U7XG4gICAgLyoqXG4gICAgICogQ29tcHV0ZXMgdGhlIGNyb3NzIHByb2R1Y3Qgb2YgdHdvIHZlY3RvcnM7IGFzc3VtZXMgYm90aCB2ZWN0b3JzIGhhdmVcbiAgICAgKiB0aHJlZSBlbnRyaWVzLlxuICAgICAqIEBwYXJhbSBhIC0gT3BlcmFuZCB2ZWN0b3IuXG4gICAgICogQHBhcmFtIGIgLSBPcGVyYW5kIHZlY3Rvci5cbiAgICAgKiBAcGFyYW0gZHN0IC0gdmVjdG9yIHRvIGhvbGQgcmVzdWx0LiBJZiBub3QgcGFzc2VkIGluIGEgbmV3IG9uZSBpcyBjcmVhdGVkLlxuICAgICAqIEByZXR1cm5zIFRoZSB2ZWN0b3Igb2YgYSBjcm9zcyBiLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyb3NzKGEsIGIsIGRzdCkge1xuICAgICAgICBjb25zdCBuZXdEc3QgPSAoZHN0ID8/IG5ldyBDdG9yKDMpKTtcbiAgICAgICAgY29uc3QgdDEgPSBhWzJdICogYlswXSAtIGFbMF0gKiBiWzJdO1xuICAgICAgICBjb25zdCB0MiA9IGFbMF0gKiBiWzFdIC0gYVsxXSAqIGJbMF07XG4gICAgICAgIG5ld0RzdFswXSA9IGFbMV0gKiBiWzJdIC0gYVsyXSAqIGJbMV07XG4gICAgICAgIG5ld0RzdFsxXSA9IHQxO1xuICAgICAgICBuZXdEc3RbMl0gPSB0MjtcbiAgICAgICAgcmV0dXJuIG5ld0RzdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29tcHV0ZXMgdGhlIGRvdCBwcm9kdWN0IG9mIHR3byB2ZWN0b3JzOyBhc3N1bWVzIGJvdGggdmVjdG9ycyBoYXZlXG4gICAgICogdGhyZWUgZW50cmllcy5cbiAgICAgKiBAcGFyYW0gYSAtIE9wZXJhbmQgdmVjdG9yLlxuICAgICAqIEBwYXJhbSBiIC0gT3BlcmFuZCB2ZWN0b3IuXG4gICAgICogQHJldHVybnMgZG90IHByb2R1Y3RcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBkb3QoYSwgYikge1xuICAgICAgICByZXR1cm4gKGFbMF0gKiBiWzBdKSArIChhWzFdICogYlsxXSkgKyAoYVsyXSAqIGJbMl0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb21wdXRlcyB0aGUgbGVuZ3RoIG9mIHZlY3RvclxuICAgICAqIEBwYXJhbSB2IC0gdmVjdG9yLlxuICAgICAqIEByZXR1cm5zIGxlbmd0aCBvZiB2ZWN0b3IuXG4gICAgICovXG4gICAgZnVuY3Rpb24gbGVuZ3RoKHYpIHtcbiAgICAgICAgY29uc3QgdjAgPSB2WzBdO1xuICAgICAgICBjb25zdCB2MSA9IHZbMV07XG4gICAgICAgIGNvbnN0IHYyID0gdlsyXTtcbiAgICAgICAgcmV0dXJuIE1hdGguc3FydCh2MCAqIHYwICsgdjEgKiB2MSArIHYyICogdjIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb21wdXRlcyB0aGUgbGVuZ3RoIG9mIHZlY3RvciAoc2FtZSBhcyBsZW5ndGgpXG4gICAgICogQHBhcmFtIHYgLSB2ZWN0b3IuXG4gICAgICogQHJldHVybnMgbGVuZ3RoIG9mIHZlY3Rvci5cbiAgICAgKi9cbiAgICBjb25zdCBsZW4gPSBsZW5ndGg7XG4gICAgLyoqXG4gICAgICogQ29tcHV0ZXMgdGhlIHNxdWFyZSBvZiB0aGUgbGVuZ3RoIG9mIHZlY3RvclxuICAgICAqIEBwYXJhbSB2IC0gdmVjdG9yLlxuICAgICAqIEByZXR1cm5zIHNxdWFyZSBvZiB0aGUgbGVuZ3RoIG9mIHZlY3Rvci5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBsZW5ndGhTcSh2KSB7XG4gICAgICAgIGNvbnN0IHYwID0gdlswXTtcbiAgICAgICAgY29uc3QgdjEgPSB2WzFdO1xuICAgICAgICBjb25zdCB2MiA9IHZbMl07XG4gICAgICAgIHJldHVybiB2MCAqIHYwICsgdjEgKiB2MSArIHYyICogdjI7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbXB1dGVzIHRoZSBzcXVhcmUgb2YgdGhlIGxlbmd0aCBvZiB2ZWN0b3IgKHNhbWUgYXMgbGVuZ3RoU3EpXG4gICAgICogQHBhcmFtIHYgLSB2ZWN0b3IuXG4gICAgICogQHJldHVybnMgc3F1YXJlIG9mIHRoZSBsZW5ndGggb2YgdmVjdG9yLlxuICAgICAqL1xuICAgIGNvbnN0IGxlblNxID0gbGVuZ3RoU3E7XG4gICAgLyoqXG4gICAgICogQ29tcHV0ZXMgdGhlIGRpc3RhbmNlIGJldHdlZW4gMiBwb2ludHNcbiAgICAgKiBAcGFyYW0gYSAtIHZlY3Rvci5cbiAgICAgKiBAcGFyYW0gYiAtIHZlY3Rvci5cbiAgICAgKiBAcmV0dXJucyBkaXN0YW5jZSBiZXR3ZWVuIGEgYW5kIGJcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBkaXN0YW5jZShhLCBiKSB7XG4gICAgICAgIGNvbnN0IGR4ID0gYVswXSAtIGJbMF07XG4gICAgICAgIGNvbnN0IGR5ID0gYVsxXSAtIGJbMV07XG4gICAgICAgIGNvbnN0IGR6ID0gYVsyXSAtIGJbMl07XG4gICAgICAgIHJldHVybiBNYXRoLnNxcnQoZHggKiBkeCArIGR5ICogZHkgKyBkeiAqIGR6KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29tcHV0ZXMgdGhlIGRpc3RhbmNlIGJldHdlZW4gMiBwb2ludHMgKHNhbWUgYXMgZGlzdGFuY2UpXG4gICAgICogQHBhcmFtIGEgLSB2ZWN0b3IuXG4gICAgICogQHBhcmFtIGIgLSB2ZWN0b3IuXG4gICAgICogQHJldHVybnMgZGlzdGFuY2UgYmV0d2VlbiBhIGFuZCBiXG4gICAgICovXG4gICAgY29uc3QgZGlzdCA9IGRpc3RhbmNlO1xuICAgIC8qKlxuICAgICAqIENvbXB1dGVzIHRoZSBzcXVhcmUgb2YgdGhlIGRpc3RhbmNlIGJldHdlZW4gMiBwb2ludHNcbiAgICAgKiBAcGFyYW0gYSAtIHZlY3Rvci5cbiAgICAgKiBAcGFyYW0gYiAtIHZlY3Rvci5cbiAgICAgKiBAcmV0dXJucyBzcXVhcmUgb2YgdGhlIGRpc3RhbmNlIGJldHdlZW4gYSBhbmQgYlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGRpc3RhbmNlU3EoYSwgYikge1xuICAgICAgICBjb25zdCBkeCA9IGFbMF0gLSBiWzBdO1xuICAgICAgICBjb25zdCBkeSA9IGFbMV0gLSBiWzFdO1xuICAgICAgICBjb25zdCBkeiA9IGFbMl0gLSBiWzJdO1xuICAgICAgICByZXR1cm4gZHggKiBkeCArIGR5ICogZHkgKyBkeiAqIGR6O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb21wdXRlcyB0aGUgc3F1YXJlIG9mIHRoZSBkaXN0YW5jZSBiZXR3ZWVuIDIgcG9pbnRzIChzYW1lIGFzIGRpc3RhbmNlU3EpXG4gICAgICogQHBhcmFtIGEgLSB2ZWN0b3IuXG4gICAgICogQHBhcmFtIGIgLSB2ZWN0b3IuXG4gICAgICogQHJldHVybnMgc3F1YXJlIG9mIHRoZSBkaXN0YW5jZSBiZXR3ZWVuIGEgYW5kIGJcbiAgICAgKi9cbiAgICBjb25zdCBkaXN0U3EgPSBkaXN0YW5jZVNxO1xuICAgIC8qKlxuICAgICAqIERpdmlkZXMgYSB2ZWN0b3IgYnkgaXRzIEV1Y2xpZGVhbiBsZW5ndGggYW5kIHJldHVybnMgdGhlIHF1b3RpZW50LlxuICAgICAqIEBwYXJhbSB2IC0gVGhlIHZlY3Rvci5cbiAgICAgKiBAcGFyYW0gZHN0IC0gdmVjdG9yIHRvIGhvbGQgcmVzdWx0LiBJZiBub3QgcGFzc2VkIGluIGEgbmV3IG9uZSBpcyBjcmVhdGVkLlxuICAgICAqIEByZXR1cm5zIFRoZSBub3JtYWxpemVkIHZlY3Rvci5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBub3JtYWxpemUodiwgZHN0KSB7XG4gICAgICAgIGNvbnN0IG5ld0RzdCA9IChkc3QgPz8gbmV3IEN0b3IoMykpO1xuICAgICAgICBjb25zdCB2MCA9IHZbMF07XG4gICAgICAgIGNvbnN0IHYxID0gdlsxXTtcbiAgICAgICAgY29uc3QgdjIgPSB2WzJdO1xuICAgICAgICBjb25zdCBsZW4gPSBNYXRoLnNxcnQodjAgKiB2MCArIHYxICogdjEgKyB2MiAqIHYyKTtcbiAgICAgICAgaWYgKGxlbiA+IDAuMDAwMDEpIHtcbiAgICAgICAgICAgIG5ld0RzdFswXSA9IHYwIC8gbGVuO1xuICAgICAgICAgICAgbmV3RHN0WzFdID0gdjEgLyBsZW47XG4gICAgICAgICAgICBuZXdEc3RbMl0gPSB2MiAvIGxlbjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG5ld0RzdFswXSA9IDA7XG4gICAgICAgICAgICBuZXdEc3RbMV0gPSAwO1xuICAgICAgICAgICAgbmV3RHN0WzJdID0gMDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3RHN0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBOZWdhdGVzIGEgdmVjdG9yLlxuICAgICAqIEBwYXJhbSB2IC0gVGhlIHZlY3Rvci5cbiAgICAgKiBAcGFyYW0gZHN0IC0gdmVjdG9yIHRvIGhvbGQgcmVzdWx0LiBJZiBub3QgcGFzc2VkIGluIGEgbmV3IG9uZSBpcyBjcmVhdGVkLlxuICAgICAqIEByZXR1cm5zIC12LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG5lZ2F0ZSh2LCBkc3QpIHtcbiAgICAgICAgY29uc3QgbmV3RHN0ID0gKGRzdCA/PyBuZXcgQ3RvcigzKSk7XG4gICAgICAgIG5ld0RzdFswXSA9IC12WzBdO1xuICAgICAgICBuZXdEc3RbMV0gPSAtdlsxXTtcbiAgICAgICAgbmV3RHN0WzJdID0gLXZbMl07XG4gICAgICAgIHJldHVybiBuZXdEc3Q7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvcGllcyBhIHZlY3Rvci4gKHNhbWUgYXMge0BsaW5rIHZlYzMuY2xvbmV9KVxuICAgICAqIEFsc28gc2VlIHtAbGluayB2ZWMzLmNyZWF0ZX0gYW5kIHtAbGluayB2ZWMzLnNldH1cbiAgICAgKiBAcGFyYW0gdiAtIFRoZSB2ZWN0b3IuXG4gICAgICogQHBhcmFtIGRzdCAtIHZlY3RvciB0byBob2xkIHJlc3VsdC4gSWYgbm90IHBhc3NlZCBpbiBhIG5ldyBvbmUgaXMgY3JlYXRlZC5cbiAgICAgKiBAcmV0dXJucyBBIGNvcHkgb2Ygdi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjb3B5KHYsIGRzdCkge1xuICAgICAgICBjb25zdCBuZXdEc3QgPSAoZHN0ID8/IG5ldyBDdG9yKDMpKTtcbiAgICAgICAgbmV3RHN0WzBdID0gdlswXTtcbiAgICAgICAgbmV3RHN0WzFdID0gdlsxXTtcbiAgICAgICAgbmV3RHN0WzJdID0gdlsyXTtcbiAgICAgICAgcmV0dXJuIG5ld0RzdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2xvbmVzIGEgdmVjdG9yLiAoc2FtZSBhcyB7QGxpbmsgdmVjMy5jb3B5fSlcbiAgICAgKiBBbHNvIHNlZSB7QGxpbmsgdmVjMy5jcmVhdGV9IGFuZCB7QGxpbmsgdmVjMy5zZXR9XG4gICAgICogQHBhcmFtIHYgLSBUaGUgdmVjdG9yLlxuICAgICAqIEBwYXJhbSBkc3QgLSB2ZWN0b3IgdG8gaG9sZCByZXN1bHQuIElmIG5vdCBwYXNzZWQgaW4gYSBuZXcgb25lIGlzIGNyZWF0ZWQuXG4gICAgICogQHJldHVybnMgQSBjb3B5IG9mIHYuXG4gICAgICovXG4gICAgY29uc3QgY2xvbmUgPSBjb3B5O1xuICAgIC8qKlxuICAgICAqIE11bHRpcGxpZXMgYSB2ZWN0b3IgYnkgYW5vdGhlciB2ZWN0b3IgKGNvbXBvbmVudC13aXNlKTsgYXNzdW1lcyBhIGFuZFxuICAgICAqIGIgaGF2ZSB0aGUgc2FtZSBsZW5ndGguXG4gICAgICogQHBhcmFtIGEgLSBPcGVyYW5kIHZlY3Rvci5cbiAgICAgKiBAcGFyYW0gYiAtIE9wZXJhbmQgdmVjdG9yLlxuICAgICAqIEBwYXJhbSBkc3QgLSB2ZWN0b3IgdG8gaG9sZCByZXN1bHQuIElmIG5vdCBwYXNzZWQgaW4gYSBuZXcgb25lIGlzIGNyZWF0ZWQuXG4gICAgICogQHJldHVybnMgVGhlIHZlY3RvciBvZiBwcm9kdWN0cyBvZiBlbnRyaWVzIG9mIGEgYW5kIGIuXG4gICAgICovXG4gICAgZnVuY3Rpb24gbXVsdGlwbHkoYSwgYiwgZHN0KSB7XG4gICAgICAgIGNvbnN0IG5ld0RzdCA9IChkc3QgPz8gbmV3IEN0b3IoMykpO1xuICAgICAgICBuZXdEc3RbMF0gPSBhWzBdICogYlswXTtcbiAgICAgICAgbmV3RHN0WzFdID0gYVsxXSAqIGJbMV07XG4gICAgICAgIG5ld0RzdFsyXSA9IGFbMl0gKiBiWzJdO1xuICAgICAgICByZXR1cm4gbmV3RHN0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBNdWx0aXBsaWVzIGEgdmVjdG9yIGJ5IGFub3RoZXIgdmVjdG9yIChjb21wb25lbnQtd2lzZSk7IGFzc3VtZXMgYSBhbmRcbiAgICAgKiBiIGhhdmUgdGhlIHNhbWUgbGVuZ3RoLiAoc2FtZSBhcyBtdWwpXG4gICAgICogQHBhcmFtIGEgLSBPcGVyYW5kIHZlY3Rvci5cbiAgICAgKiBAcGFyYW0gYiAtIE9wZXJhbmQgdmVjdG9yLlxuICAgICAqIEBwYXJhbSBkc3QgLSB2ZWN0b3IgdG8gaG9sZCByZXN1bHQuIElmIG5vdCBwYXNzZWQgaW4gYSBuZXcgb25lIGlzIGNyZWF0ZWQuXG4gICAgICogQHJldHVybnMgVGhlIHZlY3RvciBvZiBwcm9kdWN0cyBvZiBlbnRyaWVzIG9mIGEgYW5kIGIuXG4gICAgICovXG4gICAgY29uc3QgbXVsID0gbXVsdGlwbHk7XG4gICAgLyoqXG4gICAgICogRGl2aWRlcyBhIHZlY3RvciBieSBhbm90aGVyIHZlY3RvciAoY29tcG9uZW50LXdpc2UpOyBhc3N1bWVzIGEgYW5kXG4gICAgICogYiBoYXZlIHRoZSBzYW1lIGxlbmd0aC5cbiAgICAgKiBAcGFyYW0gYSAtIE9wZXJhbmQgdmVjdG9yLlxuICAgICAqIEBwYXJhbSBiIC0gT3BlcmFuZCB2ZWN0b3IuXG4gICAgICogQHBhcmFtIGRzdCAtIHZlY3RvciB0byBob2xkIHJlc3VsdC4gSWYgbm90IHBhc3NlZCBpbiBhIG5ldyBvbmUgaXMgY3JlYXRlZC5cbiAgICAgKiBAcmV0dXJucyBUaGUgdmVjdG9yIG9mIHF1b3RpZW50cyBvZiBlbnRyaWVzIG9mIGEgYW5kIGIuXG4gICAgICovXG4gICAgZnVuY3Rpb24gZGl2aWRlKGEsIGIsIGRzdCkge1xuICAgICAgICBjb25zdCBuZXdEc3QgPSAoZHN0ID8/IG5ldyBDdG9yKDMpKTtcbiAgICAgICAgbmV3RHN0WzBdID0gYVswXSAvIGJbMF07XG4gICAgICAgIG5ld0RzdFsxXSA9IGFbMV0gLyBiWzFdO1xuICAgICAgICBuZXdEc3RbMl0gPSBhWzJdIC8gYlsyXTtcbiAgICAgICAgcmV0dXJuIG5ld0RzdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGl2aWRlcyBhIHZlY3RvciBieSBhbm90aGVyIHZlY3RvciAoY29tcG9uZW50LXdpc2UpOyBhc3N1bWVzIGEgYW5kXG4gICAgICogYiBoYXZlIHRoZSBzYW1lIGxlbmd0aC4gKHNhbWUgYXMgZGl2aWRlKVxuICAgICAqIEBwYXJhbSBhIC0gT3BlcmFuZCB2ZWN0b3IuXG4gICAgICogQHBhcmFtIGIgLSBPcGVyYW5kIHZlY3Rvci5cbiAgICAgKiBAcGFyYW0gZHN0IC0gdmVjdG9yIHRvIGhvbGQgcmVzdWx0LiBJZiBub3QgcGFzc2VkIGluIGEgbmV3IG9uZSBpcyBjcmVhdGVkLlxuICAgICAqIEByZXR1cm5zIFRoZSB2ZWN0b3Igb2YgcXVvdGllbnRzIG9mIGVudHJpZXMgb2YgYSBhbmQgYi5cbiAgICAgKi9cbiAgICBjb25zdCBkaXYgPSBkaXZpZGU7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIHJhbmRvbSB2ZWN0b3JcbiAgICAgKiBAcGFyYW0gc2NhbGUgLSBEZWZhdWx0IDFcbiAgICAgKiBAcGFyYW0gZHN0IC0gdmVjdG9yIHRvIGhvbGQgcmVzdWx0LiBJZiBub3QgcGFzc2VkIGluIGEgbmV3IG9uZSBpcyBjcmVhdGVkLlxuICAgICAqIEByZXR1cm5zIFRoZSByYW5kb20gdmVjdG9yLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHJhbmRvbShzY2FsZSA9IDEsIGRzdCkge1xuICAgICAgICBjb25zdCBuZXdEc3QgPSAoZHN0ID8/IG5ldyBDdG9yKDMpKTtcbiAgICAgICAgY29uc3QgYW5nbGUgPSBNYXRoLnJhbmRvbSgpICogMiAqIE1hdGguUEk7XG4gICAgICAgIGNvbnN0IHogPSBNYXRoLnJhbmRvbSgpICogMiAtIDE7XG4gICAgICAgIGNvbnN0IHpTY2FsZSA9IE1hdGguc3FydCgxIC0geiAqIHopICogc2NhbGU7XG4gICAgICAgIG5ld0RzdFswXSA9IE1hdGguY29zKGFuZ2xlKSAqIHpTY2FsZTtcbiAgICAgICAgbmV3RHN0WzFdID0gTWF0aC5zaW4oYW5nbGUpICogelNjYWxlO1xuICAgICAgICBuZXdEc3RbMl0gPSB6ICogc2NhbGU7XG4gICAgICAgIHJldHVybiBuZXdEc3Q7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFplcm8ncyBhIHZlY3RvclxuICAgICAqIEBwYXJhbSBkc3QgLSB2ZWN0b3IgdG8gaG9sZCByZXN1bHQuIElmIG5vdCBwYXNzZWQgaW4gYSBuZXcgb25lIGlzIGNyZWF0ZWQuXG4gICAgICogQHJldHVybnMgVGhlIHplcm9lZCB2ZWN0b3IuXG4gICAgICovXG4gICAgZnVuY3Rpb24gemVybyhkc3QpIHtcbiAgICAgICAgY29uc3QgbmV3RHN0ID0gKGRzdCA/PyBuZXcgQ3RvcigzKSk7XG4gICAgICAgIG5ld0RzdFswXSA9IDA7XG4gICAgICAgIG5ld0RzdFsxXSA9IDA7XG4gICAgICAgIG5ld0RzdFsyXSA9IDA7XG4gICAgICAgIHJldHVybiBuZXdEc3Q7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIHRyYW5zZm9ybSB2ZWMzIGJ5IDR4NCBtYXRyaXhcbiAgICAgKiBAcGFyYW0gdiAtIHRoZSB2ZWN0b3JcbiAgICAgKiBAcGFyYW0gbSAtIFRoZSBtYXRyaXguXG4gICAgICogQHBhcmFtIGRzdCAtIG9wdGlvbmFsIHZlYzMgdG8gc3RvcmUgcmVzdWx0LiBJZiBub3QgcGFzc2VkIGEgbmV3IG9uZSBpcyBjcmVhdGVkLlxuICAgICAqIEByZXR1cm5zIHRoZSB0cmFuc2Zvcm1lZCB2ZWN0b3JcbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0cmFuc2Zvcm1NYXQ0KHYsIG0sIGRzdCkge1xuICAgICAgICBjb25zdCBuZXdEc3QgPSAoZHN0ID8/IG5ldyBDdG9yKDMpKTtcbiAgICAgICAgY29uc3QgeCA9IHZbMF07XG4gICAgICAgIGNvbnN0IHkgPSB2WzFdO1xuICAgICAgICBjb25zdCB6ID0gdlsyXTtcbiAgICAgICAgY29uc3QgdyA9IChtWzNdICogeCArIG1bN10gKiB5ICsgbVsxMV0gKiB6ICsgbVsxNV0pIHx8IDE7XG4gICAgICAgIG5ld0RzdFswXSA9IChtWzBdICogeCArIG1bNF0gKiB5ICsgbVs4XSAqIHogKyBtWzEyXSkgLyB3O1xuICAgICAgICBuZXdEc3RbMV0gPSAobVsxXSAqIHggKyBtWzVdICogeSArIG1bOV0gKiB6ICsgbVsxM10pIC8gdztcbiAgICAgICAgbmV3RHN0WzJdID0gKG1bMl0gKiB4ICsgbVs2XSAqIHkgKyBtWzEwXSAqIHogKyBtWzE0XSkgLyB3O1xuICAgICAgICByZXR1cm4gbmV3RHN0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUcmFuc2Zvcm0gdmVjMyBieSB1cHBlciAzeDMgbWF0cml4IGluc2lkZSA0eDQgbWF0cml4LlxuICAgICAqIEBwYXJhbSB2IC0gVGhlIGRpcmVjdGlvbi5cbiAgICAgKiBAcGFyYW0gbSAtIFRoZSBtYXRyaXguXG4gICAgICogQHBhcmFtIGRzdCAtIG9wdGlvbmFsIHZlYzMgdG8gc3RvcmUgcmVzdWx0LiBJZiBub3QgcGFzc2VkIGEgbmV3IG9uZSBpcyBjcmVhdGVkLlxuICAgICAqIEByZXR1cm5zIFRoZSB0cmFuc2Zvcm1lZCB2ZWN0b3IuXG4gICAgICovXG4gICAgZnVuY3Rpb24gdHJhbnNmb3JtTWF0NFVwcGVyM3gzKHYsIG0sIGRzdCkge1xuICAgICAgICBjb25zdCBuZXdEc3QgPSAoZHN0ID8/IG5ldyBDdG9yKDMpKTtcbiAgICAgICAgY29uc3QgdjAgPSB2WzBdO1xuICAgICAgICBjb25zdCB2MSA9IHZbMV07XG4gICAgICAgIGNvbnN0IHYyID0gdlsyXTtcbiAgICAgICAgbmV3RHN0WzBdID0gdjAgKiBtWzAgKiA0ICsgMF0gKyB2MSAqIG1bMSAqIDQgKyAwXSArIHYyICogbVsyICogNCArIDBdO1xuICAgICAgICBuZXdEc3RbMV0gPSB2MCAqIG1bMCAqIDQgKyAxXSArIHYxICogbVsxICogNCArIDFdICsgdjIgKiBtWzIgKiA0ICsgMV07XG4gICAgICAgIG5ld0RzdFsyXSA9IHYwICogbVswICogNCArIDJdICsgdjEgKiBtWzEgKiA0ICsgMl0gKyB2MiAqIG1bMiAqIDQgKyAyXTtcbiAgICAgICAgcmV0dXJuIG5ld0RzdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVHJhbnNmb3JtcyB2ZWMzIGJ5IDN4MyBtYXRyaXhcbiAgICAgKlxuICAgICAqIEBwYXJhbSB2IC0gdGhlIHZlY3RvclxuICAgICAqIEBwYXJhbSBtIC0gVGhlIG1hdHJpeC5cbiAgICAgKiBAcGFyYW0gZHN0IC0gb3B0aW9uYWwgdmVjMyB0byBzdG9yZSByZXN1bHQuIElmIG5vdCBwYXNzZWQgYSBuZXcgb25lIGlzIGNyZWF0ZWQuXG4gICAgICogQHJldHVybnMgdGhlIHRyYW5zZm9ybWVkIHZlY3RvclxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRyYW5zZm9ybU1hdDModiwgbSwgZHN0KSB7XG4gICAgICAgIGNvbnN0IG5ld0RzdCA9IChkc3QgPz8gbmV3IEN0b3IoMykpO1xuICAgICAgICBjb25zdCB4ID0gdlswXTtcbiAgICAgICAgY29uc3QgeSA9IHZbMV07XG4gICAgICAgIGNvbnN0IHogPSB2WzJdO1xuICAgICAgICBuZXdEc3RbMF0gPSB4ICogbVswXSArIHkgKiBtWzRdICsgeiAqIG1bOF07XG4gICAgICAgIG5ld0RzdFsxXSA9IHggKiBtWzFdICsgeSAqIG1bNV0gKyB6ICogbVs5XTtcbiAgICAgICAgbmV3RHN0WzJdID0geCAqIG1bMl0gKyB5ICogbVs2XSArIHogKiBtWzEwXTtcbiAgICAgICAgcmV0dXJuIG5ld0RzdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVHJhbnNmb3JtcyB2ZWMzIGJ5IFF1YXRlcm5pb25cbiAgICAgKiBAcGFyYW0gdiAtIHRoZSB2ZWN0b3IgdG8gdHJhbnNmb3JtXG4gICAgICogQHBhcmFtIHEgLSB0aGUgcXVhdGVybmlvbiB0byB0cmFuc2Zvcm0gYnlcbiAgICAgKiBAcGFyYW0gZHN0IC0gb3B0aW9uYWwgdmVjMyB0byBzdG9yZSByZXN1bHQuIElmIG5vdCBwYXNzZWQgYSBuZXcgb25lIGlzIGNyZWF0ZWQuXG4gICAgICogQHJldHVybnMgdGhlIHRyYW5zZm9ybWVkXG4gICAgICovXG4gICAgZnVuY3Rpb24gdHJhbnNmb3JtUXVhdCh2LCBxLCBkc3QpIHtcbiAgICAgICAgY29uc3QgbmV3RHN0ID0gKGRzdCA/PyBuZXcgQ3RvcigzKSk7XG4gICAgICAgIGNvbnN0IHF4ID0gcVswXTtcbiAgICAgICAgY29uc3QgcXkgPSBxWzFdO1xuICAgICAgICBjb25zdCBxeiA9IHFbMl07XG4gICAgICAgIGNvbnN0IHcyID0gcVszXSAqIDI7XG4gICAgICAgIGNvbnN0IHggPSB2WzBdO1xuICAgICAgICBjb25zdCB5ID0gdlsxXTtcbiAgICAgICAgY29uc3QgeiA9IHZbMl07XG4gICAgICAgIGNvbnN0IHV2WCA9IHF5ICogeiAtIHF6ICogeTtcbiAgICAgICAgY29uc3QgdXZZID0gcXogKiB4IC0gcXggKiB6O1xuICAgICAgICBjb25zdCB1dlogPSBxeCAqIHkgLSBxeSAqIHg7XG4gICAgICAgIG5ld0RzdFswXSA9IHggKyB1dlggKiB3MiArIChxeSAqIHV2WiAtIHF6ICogdXZZKSAqIDI7XG4gICAgICAgIG5ld0RzdFsxXSA9IHkgKyB1dlkgKiB3MiArIChxeiAqIHV2WCAtIHF4ICogdXZaKSAqIDI7XG4gICAgICAgIG5ld0RzdFsyXSA9IHogKyB1dlogKiB3MiArIChxeCAqIHV2WSAtIHF5ICogdXZYKSAqIDI7XG4gICAgICAgIHJldHVybiBuZXdEc3Q7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHRyYW5zbGF0aW9uIGNvbXBvbmVudCBvZiBhIDQtYnktNCBtYXRyaXggYXMgYSB2ZWN0b3Igd2l0aCAzXG4gICAgICogZW50cmllcy5cbiAgICAgKiBAcGFyYW0gbSAtIFRoZSBtYXRyaXguXG4gICAgICogQHBhcmFtIGRzdCAtIHZlY3RvciB0byBob2xkIHJlc3VsdC4gSWYgbm90IHBhc3NlZCBhIG5ldyBvbmUgaXMgY3JlYXRlZC5cbiAgICAgKiBAcmV0dXJucyBUaGUgdHJhbnNsYXRpb24gY29tcG9uZW50IG9mIG0uXG4gICAgICovXG4gICAgZnVuY3Rpb24gZ2V0VHJhbnNsYXRpb24obSwgZHN0KSB7XG4gICAgICAgIGNvbnN0IG5ld0RzdCA9IChkc3QgPz8gbmV3IEN0b3IoMykpO1xuICAgICAgICBuZXdEc3RbMF0gPSBtWzEyXTtcbiAgICAgICAgbmV3RHN0WzFdID0gbVsxM107XG4gICAgICAgIG5ld0RzdFsyXSA9IG1bMTRdO1xuICAgICAgICByZXR1cm4gbmV3RHN0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGFuIGF4aXMgb2YgYSA0eDQgbWF0cml4IGFzIGEgdmVjdG9yIHdpdGggMyBlbnRyaWVzXG4gICAgICogQHBhcmFtIG0gLSBUaGUgbWF0cml4LlxuICAgICAqIEBwYXJhbSBheGlzIC0gVGhlIGF4aXMgMCA9IHgsIDEgPSB5LCAyID0gejtcbiAgICAgKiBAcmV0dXJucyBUaGUgYXhpcyBjb21wb25lbnQgb2YgbS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBnZXRBeGlzKG0sIGF4aXMsIGRzdCkge1xuICAgICAgICBjb25zdCBuZXdEc3QgPSAoZHN0ID8/IG5ldyBDdG9yKDMpKTtcbiAgICAgICAgY29uc3Qgb2ZmID0gYXhpcyAqIDQ7XG4gICAgICAgIG5ld0RzdFswXSA9IG1bb2ZmICsgMF07XG4gICAgICAgIG5ld0RzdFsxXSA9IG1bb2ZmICsgMV07XG4gICAgICAgIG5ld0RzdFsyXSA9IG1bb2ZmICsgMl07XG4gICAgICAgIHJldHVybiBuZXdEc3Q7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHNjYWxpbmcgY29tcG9uZW50IG9mIHRoZSBtYXRyaXhcbiAgICAgKiBAcGFyYW0gbSAtIFRoZSBNYXRyaXhcbiAgICAgKiBAcGFyYW0gZHN0IC0gVGhlIHZlY3RvciB0byBzZXQuIElmIG5vdCBwYXNzZWQgYSBuZXcgb25lIGlzIGNyZWF0ZWQuXG4gICAgICovXG4gICAgZnVuY3Rpb24gZ2V0U2NhbGluZyhtLCBkc3QpIHtcbiAgICAgICAgY29uc3QgbmV3RHN0ID0gKGRzdCA/PyBuZXcgQ3RvcigzKSk7XG4gICAgICAgIGNvbnN0IHh4ID0gbVswXTtcbiAgICAgICAgY29uc3QgeHkgPSBtWzFdO1xuICAgICAgICBjb25zdCB4eiA9IG1bMl07XG4gICAgICAgIGNvbnN0IHl4ID0gbVs0XTtcbiAgICAgICAgY29uc3QgeXkgPSBtWzVdO1xuICAgICAgICBjb25zdCB5eiA9IG1bNl07XG4gICAgICAgIGNvbnN0IHp4ID0gbVs4XTtcbiAgICAgICAgY29uc3QgenkgPSBtWzldO1xuICAgICAgICBjb25zdCB6eiA9IG1bMTBdO1xuICAgICAgICBuZXdEc3RbMF0gPSBNYXRoLnNxcnQoeHggKiB4eCArIHh5ICogeHkgKyB4eiAqIHh6KTtcbiAgICAgICAgbmV3RHN0WzFdID0gTWF0aC5zcXJ0KHl4ICogeXggKyB5eSAqIHl5ICsgeXogKiB5eik7XG4gICAgICAgIG5ld0RzdFsyXSA9IE1hdGguc3FydCh6eCAqIHp4ICsgenkgKiB6eSArIHp6ICogenopO1xuICAgICAgICByZXR1cm4gbmV3RHN0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSb3RhdGUgYSAzRCB2ZWN0b3IgYXJvdW5kIHRoZSB4LWF4aXNcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBhIFRoZSB2ZWMzIHBvaW50IHRvIHJvdGF0ZVxuICAgICAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBiIFRoZSBvcmlnaW4gb2YgdGhlIHJvdGF0aW9uXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHJhZCBUaGUgYW5nbGUgb2Ygcm90YXRpb24gaW4gcmFkaWFuc1xuICAgICAqIEBwYXJhbSBkc3QgLSBUaGUgdmVjdG9yIHRvIHNldC4gSWYgbm90IHBhc3NlZCBhIG5ldyBvbmUgaXMgY3JlYXRlZC5cbiAgICAgKiBAcmV0dXJucyB0aGUgcm90YXRlZCB2ZWN0b3JcbiAgICAgKi9cbiAgICBmdW5jdGlvbiByb3RhdGVYKGEsIGIsIHJhZCwgZHN0KSB7XG4gICAgICAgIGNvbnN0IG5ld0RzdCA9IChkc3QgPz8gbmV3IEN0b3IoMykpO1xuICAgICAgICBjb25zdCBwID0gW107XG4gICAgICAgIGNvbnN0IHIgPSBbXTtcbiAgICAgICAgLy9UcmFuc2xhdGUgcG9pbnQgdG8gdGhlIG9yaWdpblxuICAgICAgICBwWzBdID0gYVswXSAtIGJbMF07XG4gICAgICAgIHBbMV0gPSBhWzFdIC0gYlsxXTtcbiAgICAgICAgcFsyXSA9IGFbMl0gLSBiWzJdO1xuICAgICAgICAvL3BlcmZvcm0gcm90YXRpb25cbiAgICAgICAgclswXSA9IHBbMF07XG4gICAgICAgIHJbMV0gPSBwWzFdICogTWF0aC5jb3MocmFkKSAtIHBbMl0gKiBNYXRoLnNpbihyYWQpO1xuICAgICAgICByWzJdID0gcFsxXSAqIE1hdGguc2luKHJhZCkgKyBwWzJdICogTWF0aC5jb3MocmFkKTtcbiAgICAgICAgLy90cmFuc2xhdGUgdG8gY29ycmVjdCBwb3NpdGlvblxuICAgICAgICBuZXdEc3RbMF0gPSByWzBdICsgYlswXTtcbiAgICAgICAgbmV3RHN0WzFdID0gclsxXSArIGJbMV07XG4gICAgICAgIG5ld0RzdFsyXSA9IHJbMl0gKyBiWzJdO1xuICAgICAgICByZXR1cm4gbmV3RHN0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSb3RhdGUgYSAzRCB2ZWN0b3IgYXJvdW5kIHRoZSB5LWF4aXNcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBhIFRoZSB2ZWMzIHBvaW50IHRvIHJvdGF0ZVxuICAgICAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBiIFRoZSBvcmlnaW4gb2YgdGhlIHJvdGF0aW9uXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHJhZCBUaGUgYW5nbGUgb2Ygcm90YXRpb24gaW4gcmFkaWFuc1xuICAgICAqIEBwYXJhbSBkc3QgLSBUaGUgdmVjdG9yIHRvIHNldC4gSWYgbm90IHBhc3NlZCBhIG5ldyBvbmUgaXMgY3JlYXRlZC5cbiAgICAgKiBAcmV0dXJucyB0aGUgcm90YXRlZCB2ZWN0b3JcbiAgICAgKi9cbiAgICBmdW5jdGlvbiByb3RhdGVZKGEsIGIsIHJhZCwgZHN0KSB7XG4gICAgICAgIGNvbnN0IG5ld0RzdCA9IChkc3QgPz8gbmV3IEN0b3IoMykpO1xuICAgICAgICBjb25zdCBwID0gW107XG4gICAgICAgIGNvbnN0IHIgPSBbXTtcbiAgICAgICAgLy8gdHJhbnNsYXRlIHBvaW50IHRvIHRoZSBvcmlnaW5cbiAgICAgICAgcFswXSA9IGFbMF0gLSBiWzBdO1xuICAgICAgICBwWzFdID0gYVsxXSAtIGJbMV07XG4gICAgICAgIHBbMl0gPSBhWzJdIC0gYlsyXTtcbiAgICAgICAgLy8gcGVyZm9ybSByb3RhdGlvblxuICAgICAgICByWzBdID0gcFsyXSAqIE1hdGguc2luKHJhZCkgKyBwWzBdICogTWF0aC5jb3MocmFkKTtcbiAgICAgICAgclsxXSA9IHBbMV07XG4gICAgICAgIHJbMl0gPSBwWzJdICogTWF0aC5jb3MocmFkKSAtIHBbMF0gKiBNYXRoLnNpbihyYWQpO1xuICAgICAgICAvLyB0cmFuc2xhdGUgdG8gY29ycmVjdCBwb3NpdGlvblxuICAgICAgICBuZXdEc3RbMF0gPSByWzBdICsgYlswXTtcbiAgICAgICAgbmV3RHN0WzFdID0gclsxXSArIGJbMV07XG4gICAgICAgIG5ld0RzdFsyXSA9IHJbMl0gKyBiWzJdO1xuICAgICAgICByZXR1cm4gbmV3RHN0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSb3RhdGUgYSAzRCB2ZWN0b3IgYXJvdW5kIHRoZSB6LWF4aXNcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBhIFRoZSB2ZWMzIHBvaW50IHRvIHJvdGF0ZVxuICAgICAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBiIFRoZSBvcmlnaW4gb2YgdGhlIHJvdGF0aW9uXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHJhZCBUaGUgYW5nbGUgb2Ygcm90YXRpb24gaW4gcmFkaWFuc1xuICAgICAqIEBwYXJhbSBkc3QgLSBUaGUgdmVjdG9yIHRvIHNldC4gSWYgbm90IHBhc3NlZCBhIG5ldyBvbmUgaXMgY3JlYXRlZC5cbiAgICAgKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gICAgICovXG4gICAgZnVuY3Rpb24gcm90YXRlWihhLCBiLCByYWQsIGRzdCkge1xuICAgICAgICBjb25zdCBuZXdEc3QgPSAoZHN0ID8/IG5ldyBDdG9yKDMpKTtcbiAgICAgICAgY29uc3QgcCA9IFtdO1xuICAgICAgICBjb25zdCByID0gW107XG4gICAgICAgIC8vIHRyYW5zbGF0ZSBwb2ludCB0byB0aGUgb3JpZ2luXG4gICAgICAgIHBbMF0gPSBhWzBdIC0gYlswXTtcbiAgICAgICAgcFsxXSA9IGFbMV0gLSBiWzFdO1xuICAgICAgICBwWzJdID0gYVsyXSAtIGJbMl07XG4gICAgICAgIC8vIHBlcmZvcm0gcm90YXRpb25cbiAgICAgICAgclswXSA9IHBbMF0gKiBNYXRoLmNvcyhyYWQpIC0gcFsxXSAqIE1hdGguc2luKHJhZCk7XG4gICAgICAgIHJbMV0gPSBwWzBdICogTWF0aC5zaW4ocmFkKSArIHBbMV0gKiBNYXRoLmNvcyhyYWQpO1xuICAgICAgICByWzJdID0gcFsyXTtcbiAgICAgICAgLy8gdHJhbnNsYXRlIHRvIGNvcnJlY3QgcG9zaXRpb25cbiAgICAgICAgbmV3RHN0WzBdID0gclswXSArIGJbMF07XG4gICAgICAgIG5ld0RzdFsxXSA9IHJbMV0gKyBiWzFdO1xuICAgICAgICBuZXdEc3RbMl0gPSByWzJdICsgYlsyXTtcbiAgICAgICAgcmV0dXJuIG5ld0RzdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVHJlYXQgYSAzRCB2ZWN0b3IgYXMgYSBkaXJlY3Rpb24gYW5kIHNldCBpdCdzIGxlbmd0aFxuICAgICAqXG4gICAgICogQHBhcmFtIGEgVGhlIHZlYzMgdG8gbGVuZ3RoZW5cbiAgICAgKiBAcGFyYW0gbGVuIFRoZSBsZW5ndGggb2YgdGhlIHJlc3VsdGluZyB2ZWN0b3JcbiAgICAgKiBAcmV0dXJucyBUaGUgbGVuZ3RoZW5lZCB2ZWN0b3JcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzZXRMZW5ndGgoYSwgbGVuLCBkc3QpIHtcbiAgICAgICAgY29uc3QgbmV3RHN0ID0gKGRzdCA/PyBuZXcgQ3RvcigzKSk7XG4gICAgICAgIG5vcm1hbGl6ZShhLCBuZXdEc3QpO1xuICAgICAgICByZXR1cm4gbXVsU2NhbGFyKG5ld0RzdCwgbGVuLCBuZXdEc3QpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBFbnN1cmUgYSB2ZWN0b3IgaXMgbm90IGxvbmdlciB0aGFuIGEgbWF4IGxlbmd0aFxuICAgICAqXG4gICAgICogQHBhcmFtIGEgVGhlIHZlYzMgdG8gbGltaXRcbiAgICAgKiBAcGFyYW0gbWF4TGVuIFRoZSBsb25nZXN0IGxlbmd0aCBvZiB0aGUgcmVzdWx0aW5nIHZlY3RvclxuICAgICAqIEByZXR1cm5zIFRoZSB2ZWN0b3IsIHNob3J0ZW5lZCB0byBtYXhMZW4gaWYgaXQncyB0b28gbG9uZ1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRydW5jYXRlKGEsIG1heExlbiwgZHN0KSB7XG4gICAgICAgIGNvbnN0IG5ld0RzdCA9IChkc3QgPz8gbmV3IEN0b3IoMykpO1xuICAgICAgICBpZiAobGVuZ3RoKGEpID4gbWF4TGVuKSB7XG4gICAgICAgICAgICByZXR1cm4gc2V0TGVuZ3RoKGEsIG1heExlbiwgbmV3RHN0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY29weShhLCBuZXdEc3QpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gdGhlIHZlY3RvciBleGFjdGx5IGJldHdlZW4gMiBlbmRwb2ludCB2ZWN0b3JzXG4gICAgICpcbiAgICAgKiBAcGFyYW0gYSBFbmRwb2ludCAxXG4gICAgICogQHBhcmFtIGIgRW5kcG9pbnQgMlxuICAgICAqIEByZXR1cm5zIFRoZSB2ZWN0b3IgZXhhY3RseSByZXNpZGluZyBiZXR3ZWVuIGVuZHBvaW50cyAxIGFuZCAyXG4gICAgICovXG4gICAgZnVuY3Rpb24gbWlkcG9pbnQoYSwgYiwgZHN0KSB7XG4gICAgICAgIGNvbnN0IG5ld0RzdCA9IChkc3QgPz8gbmV3IEN0b3IoMykpO1xuICAgICAgICByZXR1cm4gbGVycChhLCBiLCAwLjUsIG5ld0RzdCk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIGNyZWF0ZSxcbiAgICAgICAgZnJvbVZhbHVlcyxcbiAgICAgICAgc2V0LFxuICAgICAgICBjZWlsLFxuICAgICAgICBmbG9vcixcbiAgICAgICAgcm91bmQsXG4gICAgICAgIGNsYW1wLFxuICAgICAgICBhZGQsXG4gICAgICAgIGFkZFNjYWxlZCxcbiAgICAgICAgYW5nbGUsXG4gICAgICAgIHN1YnRyYWN0LFxuICAgICAgICBzdWIsXG4gICAgICAgIGVxdWFsc0FwcHJveGltYXRlbHksXG4gICAgICAgIGVxdWFscyxcbiAgICAgICAgbGVycCxcbiAgICAgICAgbGVycFYsXG4gICAgICAgIG1heCxcbiAgICAgICAgbWluLFxuICAgICAgICBtdWxTY2FsYXIsXG4gICAgICAgIHNjYWxlLFxuICAgICAgICBkaXZTY2FsYXIsXG4gICAgICAgIGludmVyc2UsXG4gICAgICAgIGludmVydCxcbiAgICAgICAgY3Jvc3MsXG4gICAgICAgIGRvdCxcbiAgICAgICAgbGVuZ3RoLFxuICAgICAgICBsZW4sXG4gICAgICAgIGxlbmd0aFNxLFxuICAgICAgICBsZW5TcSxcbiAgICAgICAgZGlzdGFuY2UsXG4gICAgICAgIGRpc3QsXG4gICAgICAgIGRpc3RhbmNlU3EsXG4gICAgICAgIGRpc3RTcSxcbiAgICAgICAgbm9ybWFsaXplLFxuICAgICAgICBuZWdhdGUsXG4gICAgICAgIGNvcHksXG4gICAgICAgIGNsb25lLFxuICAgICAgICBtdWx0aXBseSxcbiAgICAgICAgbXVsLFxuICAgICAgICBkaXZpZGUsXG4gICAgICAgIGRpdixcbiAgICAgICAgcmFuZG9tLFxuICAgICAgICB6ZXJvLFxuICAgICAgICB0cmFuc2Zvcm1NYXQ0LFxuICAgICAgICB0cmFuc2Zvcm1NYXQ0VXBwZXIzeDMsXG4gICAgICAgIHRyYW5zZm9ybU1hdDMsXG4gICAgICAgIHRyYW5zZm9ybVF1YXQsXG4gICAgICAgIGdldFRyYW5zbGF0aW9uLFxuICAgICAgICBnZXRBeGlzLFxuICAgICAgICBnZXRTY2FsaW5nLFxuICAgICAgICByb3RhdGVYLFxuICAgICAgICByb3RhdGVZLFxuICAgICAgICByb3RhdGVaLFxuICAgICAgICBzZXRMZW5ndGgsXG4gICAgICAgIHRydW5jYXRlLFxuICAgICAgICBtaWRwb2ludCxcbiAgICB9O1xufVxuY29uc3QgY2FjaGUkMyA9IG5ldyBNYXAoKTtcbmZ1bmN0aW9uIGdldEFQSSQzKEN0b3IpIHtcbiAgICBsZXQgYXBpID0gY2FjaGUkMy5nZXQoQ3Rvcik7XG4gICAgaWYgKCFhcGkpIHtcbiAgICAgICAgYXBpID0gZ2V0QVBJSW1wbCQzKEN0b3IpO1xuICAgICAgICBjYWNoZSQzLnNldChDdG9yLCBhcGkpO1xuICAgIH1cbiAgICByZXR1cm4gYXBpO1xufVxuXG4vKipcbiAqIEdlbmVyYXRlcyBhIHR5cGVkIEFQSSBmb3IgTWF0NFxuICogKi9cbmZ1bmN0aW9uIGdldEFQSUltcGwkMihDdG9yKSB7XG4gICAgY29uc3QgdmVjMyA9IGdldEFQSSQzKEN0b3IpO1xuICAgIC8qKlxuICAgICAqIDR4NCBNYXRyaXggbWF0aCBtYXRoIGZ1bmN0aW9ucy5cbiAgICAgKlxuICAgICAqIEFsbW9zdCBhbGwgZnVuY3Rpb25zIHRha2UgYW4gb3B0aW9uYWwgYG5ld0RzdGAgYXJndW1lbnQuIElmIGl0IGlzIG5vdCBwYXNzZWQgaW4gdGhlXG4gICAgICogZnVuY3Rpb25zIHdpbGwgY3JlYXRlIGEgbmV3IG1hdHJpeC4gSW4gb3RoZXIgd29yZHMgeW91IGNhbiBkbyB0aGlzXG4gICAgICpcbiAgICAgKiAgICAgY29uc3QgbWF0ID0gbWF0NC50cmFuc2xhdGlvbihbMSwgMiwgM10pOyAgLy8gQ3JlYXRlcyBhIG5ldyB0cmFuc2xhdGlvbiBtYXRyaXhcbiAgICAgKlxuICAgICAqIG9yXG4gICAgICpcbiAgICAgKiAgICAgY29uc3QgbWF0ID0gbWF0NC5jcmVhdGUoKTtcbiAgICAgKiAgICAgbWF0NC50cmFuc2xhdGlvbihbMSwgMiwgM10sIG1hdCk7ICAvLyBQdXRzIHRyYW5zbGF0aW9uIG1hdHJpeCBpbiBtYXQuXG4gICAgICpcbiAgICAgKiBUaGUgZmlyc3Qgc3R5bGUgaXMgb2Z0ZW4gZWFzaWVyIGJ1dCBkZXBlbmRpbmcgb24gd2hlcmUgaXQncyB1c2VkIGl0IGdlbmVyYXRlcyBnYXJiYWdlIHdoZXJlXG4gICAgICogYXMgdGhlcmUgaXMgYWxtb3N0IG5ldmVyIGFsbG9jYXRpb24gd2l0aCB0aGUgc2Vjb25kIHN0eWxlLlxuICAgICAqXG4gICAgICogSXQgaXMgYWx3YXlzIHNhdmUgdG8gcGFzcyBhbnkgbWF0cml4IGFzIHRoZSBkZXN0aW5hdGlvbi4gU28gZm9yIGV4YW1wbGVcbiAgICAgKlxuICAgICAqICAgICBjb25zdCBtYXQgPSBtYXQ0LmlkZW50aXR5KCk7XG4gICAgICogICAgIGNvbnN0IHRyYW5zID0gbWF0NC50cmFuc2xhdGlvbihbMSwgMiwgM10pO1xuICAgICAqICAgICBtYXQ0Lm11bHRpcGx5KG1hdCwgdHJhbnMsIG1hdCk7ICAvLyBNdWx0aXBsaWVzIG1hdCAqIHRyYW5zIGFuZCBwdXRzIHJlc3VsdCBpbiBtYXQuXG4gICAgICpcbiAgICAgKi9cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBNYXQ0IGZyb20gdmFsdWVzXG4gICAgICpcbiAgICAgKiBOb3RlOiBTaW5jZSBwYXNzaW5nIGluIGEgcmF3IEphdmFTY3JpcHQgYXJyYXlcbiAgICAgKiBpcyB2YWxpZCBpbiBhbGwgY2lyY3Vtc3RhbmNlcywgaWYgeW91IHdhbnQgdG9cbiAgICAgKiBmb3JjZSBhIEphdmFTY3JpcHQgYXJyYXkgaW50byBhIE1hdDQncyBzcGVjaWZpZWQgdHlwZVxuICAgICAqIGl0IHdvdWxkIGJlIGZhc3RlciB0byB1c2VcbiAgICAgKlxuICAgICAqIGBgYFxuICAgICAqIGNvbnN0IG0gPSBtYXQ0LmNsb25lKHNvbWVKU0FycmF5KTtcbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIEBwYXJhbSB2MCAtIHZhbHVlIGZvciBlbGVtZW50IDBcbiAgICAgKiBAcGFyYW0gdjEgLSB2YWx1ZSBmb3IgZWxlbWVudCAxXG4gICAgICogQHBhcmFtIHYyIC0gdmFsdWUgZm9yIGVsZW1lbnQgMlxuICAgICAqIEBwYXJhbSB2MyAtIHZhbHVlIGZvciBlbGVtZW50IDNcbiAgICAgKiBAcGFyYW0gdjQgLSB2YWx1ZSBmb3IgZWxlbWVudCA0XG4gICAgICogQHBhcmFtIHY1IC0gdmFsdWUgZm9yIGVsZW1lbnQgNVxuICAgICAqIEBwYXJhbSB2NiAtIHZhbHVlIGZvciBlbGVtZW50IDZcbiAgICAgKiBAcGFyYW0gdjcgLSB2YWx1ZSBmb3IgZWxlbWVudCA3XG4gICAgICogQHBhcmFtIHY4IC0gdmFsdWUgZm9yIGVsZW1lbnQgOFxuICAgICAqIEBwYXJhbSB2OSAtIHZhbHVlIGZvciBlbGVtZW50IDlcbiAgICAgKiBAcGFyYW0gdjEwIC0gdmFsdWUgZm9yIGVsZW1lbnQgMTBcbiAgICAgKiBAcGFyYW0gdjExIC0gdmFsdWUgZm9yIGVsZW1lbnQgMTFcbiAgICAgKiBAcGFyYW0gdjEyIC0gdmFsdWUgZm9yIGVsZW1lbnQgMTJcbiAgICAgKiBAcGFyYW0gdjEzIC0gdmFsdWUgZm9yIGVsZW1lbnQgMTNcbiAgICAgKiBAcGFyYW0gdjE0IC0gdmFsdWUgZm9yIGVsZW1lbnQgMTRcbiAgICAgKiBAcGFyYW0gdjE1IC0gdmFsdWUgZm9yIGVsZW1lbnQgMTVcbiAgICAgKiBAcmV0dXJucyBjcmVhdGVkIGZyb20gdmFsdWVzLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZSh2MCwgdjEsIHYyLCB2MywgdjQsIHY1LCB2NiwgdjcsIHY4LCB2OSwgdjEwLCB2MTEsIHYxMiwgdjEzLCB2MTQsIHYxNSkge1xuICAgICAgICBjb25zdCBuZXdEc3QgPSBuZXcgQ3RvcigxNik7XG4gICAgICAgIGlmICh2MCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBuZXdEc3RbMF0gPSB2MDtcbiAgICAgICAgICAgIGlmICh2MSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgbmV3RHN0WzFdID0gdjE7XG4gICAgICAgICAgICAgICAgaWYgKHYyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgbmV3RHN0WzJdID0gdjI7XG4gICAgICAgICAgICAgICAgICAgIGlmICh2MyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdEc3RbM10gPSB2MztcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2NCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3RHN0WzRdID0gdjQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHY1ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3RHN0WzVdID0gdjU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2NiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXdEc3RbNl0gPSB2NjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2NyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3RHN0WzddID0gdjc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHY4ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3RHN0WzhdID0gdjg7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2OSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXdEc3RbOV0gPSB2OTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2MTAgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld0RzdFsxMF0gPSB2MTA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHYxMSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld0RzdFsxMV0gPSB2MTE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2MTIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3RHN0WzEyXSA9IHYxMjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2MTMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld0RzdFsxM10gPSB2MTM7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHYxNCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld0RzdFsxNF0gPSB2MTQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2MTUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3RHN0WzE1XSA9IHYxNTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3RHN0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSB2YWx1ZXMgb2YgYSBNYXQ0XG4gICAgICogQWxzbyBzZWUge0BsaW5rIG1hdDQuY3JlYXRlfSBhbmQge0BsaW5rIG1hdDQuY29weX1cbiAgICAgKlxuICAgICAqIEBwYXJhbSB2MCAtIHZhbHVlIGZvciBlbGVtZW50IDBcbiAgICAgKiBAcGFyYW0gdjEgLSB2YWx1ZSBmb3IgZWxlbWVudCAxXG4gICAgICogQHBhcmFtIHYyIC0gdmFsdWUgZm9yIGVsZW1lbnQgMlxuICAgICAqIEBwYXJhbSB2MyAtIHZhbHVlIGZvciBlbGVtZW50IDNcbiAgICAgKiBAcGFyYW0gdjQgLSB2YWx1ZSBmb3IgZWxlbWVudCA0XG4gICAgICogQHBhcmFtIHY1IC0gdmFsdWUgZm9yIGVsZW1lbnQgNVxuICAgICAqIEBwYXJhbSB2NiAtIHZhbHVlIGZvciBlbGVtZW50IDZcbiAgICAgKiBAcGFyYW0gdjcgLSB2YWx1ZSBmb3IgZWxlbWVudCA3XG4gICAgICogQHBhcmFtIHY4IC0gdmFsdWUgZm9yIGVsZW1lbnQgOFxuICAgICAqIEBwYXJhbSB2OSAtIHZhbHVlIGZvciBlbGVtZW50IDlcbiAgICAgKiBAcGFyYW0gdjEwIC0gdmFsdWUgZm9yIGVsZW1lbnQgMTBcbiAgICAgKiBAcGFyYW0gdjExIC0gdmFsdWUgZm9yIGVsZW1lbnQgMTFcbiAgICAgKiBAcGFyYW0gdjEyIC0gdmFsdWUgZm9yIGVsZW1lbnQgMTJcbiAgICAgKiBAcGFyYW0gdjEzIC0gdmFsdWUgZm9yIGVsZW1lbnQgMTNcbiAgICAgKiBAcGFyYW0gdjE0IC0gdmFsdWUgZm9yIGVsZW1lbnQgMTRcbiAgICAgKiBAcGFyYW0gdjE1IC0gdmFsdWUgZm9yIGVsZW1lbnQgMTVcbiAgICAgKiBAcGFyYW0gZHN0IC0gbWF0cml4IHRvIGhvbGQgcmVzdWx0LiBJZiBub3QgcGFzc2VkIGEgbmV3IG9uZSBpcyBjcmVhdGVkLlxuICAgICAqIEByZXR1cm5zIE1hdDQgY3JlYXRlZCBmcm9tIHZhbHVlcy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzZXQodjAsIHYxLCB2MiwgdjMsIHY0LCB2NSwgdjYsIHY3LCB2OCwgdjksIHYxMCwgdjExLCB2MTIsIHYxMywgdjE0LCB2MTUsIGRzdCkge1xuICAgICAgICBjb25zdCBuZXdEc3QgPSAoZHN0ID8/IG5ldyBDdG9yKDE2KSk7XG4gICAgICAgIG5ld0RzdFswXSA9IHYwO1xuICAgICAgICBuZXdEc3RbMV0gPSB2MTtcbiAgICAgICAgbmV3RHN0WzJdID0gdjI7XG4gICAgICAgIG5ld0RzdFszXSA9IHYzO1xuICAgICAgICBuZXdEc3RbNF0gPSB2NDtcbiAgICAgICAgbmV3RHN0WzVdID0gdjU7XG4gICAgICAgIG5ld0RzdFs2XSA9IHY2O1xuICAgICAgICBuZXdEc3RbN10gPSB2NztcbiAgICAgICAgbmV3RHN0WzhdID0gdjg7XG4gICAgICAgIG5ld0RzdFs5XSA9IHY5O1xuICAgICAgICBuZXdEc3RbMTBdID0gdjEwO1xuICAgICAgICBuZXdEc3RbMTFdID0gdjExO1xuICAgICAgICBuZXdEc3RbMTJdID0gdjEyO1xuICAgICAgICBuZXdEc3RbMTNdID0gdjEzO1xuICAgICAgICBuZXdEc3RbMTRdID0gdjE0O1xuICAgICAgICBuZXdEc3RbMTVdID0gdjE1O1xuICAgICAgICByZXR1cm4gbmV3RHN0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgTWF0NCBmcm9tIGEgTWF0M1xuICAgICAqIEBwYXJhbSBtMyAtIHNvdXJjZSBtYXRyaXhcbiAgICAgKiBAcGFyYW0gZHN0IC0gbWF0cml4IHRvIGhvbGQgcmVzdWx0LiBJZiBub3QgcGFzc2VkIGEgbmV3IG9uZSBpcyBjcmVhdGVkLlxuICAgICAqIEByZXR1cm5zIE1hdDQgbWFkZSBmcm9tIG0zXG4gICAgICovXG4gICAgZnVuY3Rpb24gZnJvbU1hdDMobTMsIGRzdCkge1xuICAgICAgICBjb25zdCBuZXdEc3QgPSAoZHN0ID8/IG5ldyBDdG9yKDE2KSk7XG4gICAgICAgIG5ld0RzdFswXSA9IG0zWzBdO1xuICAgICAgICBuZXdEc3RbMV0gPSBtM1sxXTtcbiAgICAgICAgbmV3RHN0WzJdID0gbTNbMl07XG4gICAgICAgIG5ld0RzdFszXSA9IDA7XG4gICAgICAgIG5ld0RzdFs0XSA9IG0zWzRdO1xuICAgICAgICBuZXdEc3RbNV0gPSBtM1s1XTtcbiAgICAgICAgbmV3RHN0WzZdID0gbTNbNl07XG4gICAgICAgIG5ld0RzdFs3XSA9IDA7XG4gICAgICAgIG5ld0RzdFs4XSA9IG0zWzhdO1xuICAgICAgICBuZXdEc3RbOV0gPSBtM1s5XTtcbiAgICAgICAgbmV3RHN0WzEwXSA9IG0zWzEwXTtcbiAgICAgICAgbmV3RHN0WzExXSA9IDA7XG4gICAgICAgIG5ld0RzdFsxMl0gPSAwO1xuICAgICAgICBuZXdEc3RbMTNdID0gMDtcbiAgICAgICAgbmV3RHN0WzE0XSA9IDA7XG4gICAgICAgIG5ld0RzdFsxNV0gPSAxO1xuICAgICAgICByZXR1cm4gbmV3RHN0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgTWF0NCByb3RhdGlvbiBtYXRyaXggZnJvbSBhIHF1YXRlcm5pb25cbiAgICAgKiBAcGFyYW0gcSAtIHF1YXRlcm5pb24gdG8gY3JlYXRlIG1hdHJpeCBmcm9tXG4gICAgICogQHBhcmFtIGRzdCAtIG1hdHJpeCB0byBob2xkIHJlc3VsdC4gSWYgbm90IHBhc3NlZCBhIG5ldyBvbmUgaXMgY3JlYXRlZC5cbiAgICAgKiBAcmV0dXJucyBNYXQ0IG1hZGUgZnJvbSBxXG4gICAgICovXG4gICAgZnVuY3Rpb24gZnJvbVF1YXQocSwgZHN0KSB7XG4gICAgICAgIGNvbnN0IG5ld0RzdCA9IChkc3QgPz8gbmV3IEN0b3IoMTYpKTtcbiAgICAgICAgY29uc3QgeCA9IHFbMF07XG4gICAgICAgIGNvbnN0IHkgPSBxWzFdO1xuICAgICAgICBjb25zdCB6ID0gcVsyXTtcbiAgICAgICAgY29uc3QgdyA9IHFbM107XG4gICAgICAgIGNvbnN0IHgyID0geCArIHg7XG4gICAgICAgIGNvbnN0IHkyID0geSArIHk7XG4gICAgICAgIGNvbnN0IHoyID0geiArIHo7XG4gICAgICAgIGNvbnN0IHh4ID0geCAqIHgyO1xuICAgICAgICBjb25zdCB5eCA9IHkgKiB4MjtcbiAgICAgICAgY29uc3QgeXkgPSB5ICogeTI7XG4gICAgICAgIGNvbnN0IHp4ID0geiAqIHgyO1xuICAgICAgICBjb25zdCB6eSA9IHogKiB5MjtcbiAgICAgICAgY29uc3QgenogPSB6ICogejI7XG4gICAgICAgIGNvbnN0IHd4ID0gdyAqIHgyO1xuICAgICAgICBjb25zdCB3eSA9IHcgKiB5MjtcbiAgICAgICAgY29uc3Qgd3ogPSB3ICogejI7XG4gICAgICAgIG5ld0RzdFswXSA9IDEgLSB5eSAtIHp6O1xuICAgICAgICBuZXdEc3RbMV0gPSB5eCArIHd6O1xuICAgICAgICBuZXdEc3RbMl0gPSB6eCAtIHd5O1xuICAgICAgICBuZXdEc3RbM10gPSAwO1xuICAgICAgICBuZXdEc3RbNF0gPSB5eCAtIHd6O1xuICAgICAgICBuZXdEc3RbNV0gPSAxIC0geHggLSB6ejtcbiAgICAgICAgbmV3RHN0WzZdID0genkgKyB3eDtcbiAgICAgICAgbmV3RHN0WzddID0gMDtcbiAgICAgICAgbmV3RHN0WzhdID0genggKyB3eTtcbiAgICAgICAgbmV3RHN0WzldID0genkgLSB3eDtcbiAgICAgICAgbmV3RHN0WzEwXSA9IDEgLSB4eCAtIHl5O1xuICAgICAgICBuZXdEc3RbMTFdID0gMDtcbiAgICAgICAgbmV3RHN0WzEyXSA9IDA7XG4gICAgICAgIG5ld0RzdFsxM10gPSAwO1xuICAgICAgICBuZXdEc3RbMTRdID0gMDtcbiAgICAgICAgbmV3RHN0WzE1XSA9IDE7XG4gICAgICAgIHJldHVybiBuZXdEc3Q7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE5lZ2F0ZXMgYSBtYXRyaXguXG4gICAgICogQHBhcmFtIG0gLSBUaGUgbWF0cml4LlxuICAgICAqIEBwYXJhbSBkc3QgLSBtYXRyaXggdG8gaG9sZCByZXN1bHQuIElmIG5vdCBwYXNzZWQgYSBuZXcgb25lIGlzIGNyZWF0ZWQuXG4gICAgICogQHJldHVybnMgLW0uXG4gICAgICovXG4gICAgZnVuY3Rpb24gbmVnYXRlKG0sIGRzdCkge1xuICAgICAgICBjb25zdCBuZXdEc3QgPSAoZHN0ID8/IG5ldyBDdG9yKDE2KSk7XG4gICAgICAgIG5ld0RzdFswXSA9IC1tWzBdO1xuICAgICAgICBuZXdEc3RbMV0gPSAtbVsxXTtcbiAgICAgICAgbmV3RHN0WzJdID0gLW1bMl07XG4gICAgICAgIG5ld0RzdFszXSA9IC1tWzNdO1xuICAgICAgICBuZXdEc3RbNF0gPSAtbVs0XTtcbiAgICAgICAgbmV3RHN0WzVdID0gLW1bNV07XG4gICAgICAgIG5ld0RzdFs2XSA9IC1tWzZdO1xuICAgICAgICBuZXdEc3RbN10gPSAtbVs3XTtcbiAgICAgICAgbmV3RHN0WzhdID0gLW1bOF07XG4gICAgICAgIG5ld0RzdFs5XSA9IC1tWzldO1xuICAgICAgICBuZXdEc3RbMTBdID0gLW1bMTBdO1xuICAgICAgICBuZXdEc3RbMTFdID0gLW1bMTFdO1xuICAgICAgICBuZXdEc3RbMTJdID0gLW1bMTJdO1xuICAgICAgICBuZXdEc3RbMTNdID0gLW1bMTNdO1xuICAgICAgICBuZXdEc3RbMTRdID0gLW1bMTRdO1xuICAgICAgICBuZXdEc3RbMTVdID0gLW1bMTVdO1xuICAgICAgICByZXR1cm4gbmV3RHN0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb3BpZXMgYSBtYXRyaXguIChzYW1lIGFzIHtAbGluayBtYXQ0LmNsb25lfSlcbiAgICAgKiBBbHNvIHNlZSB7QGxpbmsgbWF0NC5jcmVhdGV9IGFuZCB7QGxpbmsgbWF0NC5zZXR9XG4gICAgICogQHBhcmFtIG0gLSBUaGUgbWF0cml4LlxuICAgICAqIEBwYXJhbSBkc3QgLSBUaGUgbWF0cml4LiBJZiBub3QgcGFzc2VkIGEgbmV3IG9uZSBpcyBjcmVhdGVkLlxuICAgICAqIEByZXR1cm5zIEEgY29weSBvZiBtLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNvcHkobSwgZHN0KSB7XG4gICAgICAgIGNvbnN0IG5ld0RzdCA9IChkc3QgPz8gbmV3IEN0b3IoMTYpKTtcbiAgICAgICAgbmV3RHN0WzBdID0gbVswXTtcbiAgICAgICAgbmV3RHN0WzFdID0gbVsxXTtcbiAgICAgICAgbmV3RHN0WzJdID0gbVsyXTtcbiAgICAgICAgbmV3RHN0WzNdID0gbVszXTtcbiAgICAgICAgbmV3RHN0WzRdID0gbVs0XTtcbiAgICAgICAgbmV3RHN0WzVdID0gbVs1XTtcbiAgICAgICAgbmV3RHN0WzZdID0gbVs2XTtcbiAgICAgICAgbmV3RHN0WzddID0gbVs3XTtcbiAgICAgICAgbmV3RHN0WzhdID0gbVs4XTtcbiAgICAgICAgbmV3RHN0WzldID0gbVs5XTtcbiAgICAgICAgbmV3RHN0WzEwXSA9IG1bMTBdO1xuICAgICAgICBuZXdEc3RbMTFdID0gbVsxMV07XG4gICAgICAgIG5ld0RzdFsxMl0gPSBtWzEyXTtcbiAgICAgICAgbmV3RHN0WzEzXSA9IG1bMTNdO1xuICAgICAgICBuZXdEc3RbMTRdID0gbVsxNF07XG4gICAgICAgIG5ld0RzdFsxNV0gPSBtWzE1XTtcbiAgICAgICAgcmV0dXJuIG5ld0RzdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29waWVzIGEgbWF0cml4IChzYW1lIGFzIHtAbGluayBtYXQ0LmNvcHl9KVxuICAgICAqIEFsc28gc2VlIHtAbGluayBtYXQ0LmNyZWF0ZX0gYW5kIHtAbGluayBtYXQ0LnNldH1cbiAgICAgKiBAcGFyYW0gbSAtIFRoZSBtYXRyaXguXG4gICAgICogQHBhcmFtIGRzdCAtIFRoZSBtYXRyaXguIElmIG5vdCBwYXNzZWQgYSBuZXcgb25lIGlzIGNyZWF0ZWQuXG4gICAgICogQHJldHVybnMgQSBjb3B5IG9mIG0uXG4gICAgICovXG4gICAgY29uc3QgY2xvbmUgPSBjb3B5O1xuICAgIC8qKlxuICAgICAqIENoZWNrIGlmIDIgbWF0cmljZXMgYXJlIGFwcHJveGltYXRlbHkgZXF1YWxcbiAgICAgKiBAcGFyYW0gYSAtIE9wZXJhbmQgbWF0cml4LlxuICAgICAqIEBwYXJhbSBiIC0gT3BlcmFuZCBtYXRyaXguXG4gICAgICogQHJldHVybnMgdHJ1ZSBpZiBtYXRyaWNlcyBhcmUgYXBwcm94aW1hdGVseSBlcXVhbFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGVxdWFsc0FwcHJveGltYXRlbHkoYSwgYikge1xuICAgICAgICByZXR1cm4gTWF0aC5hYnMoYVswXSAtIGJbMF0pIDwgRVBTSUxPTiAmJlxuICAgICAgICAgICAgTWF0aC5hYnMoYVsxXSAtIGJbMV0pIDwgRVBTSUxPTiAmJlxuICAgICAgICAgICAgTWF0aC5hYnMoYVsyXSAtIGJbMl0pIDwgRVBTSUxPTiAmJlxuICAgICAgICAgICAgTWF0aC5hYnMoYVszXSAtIGJbM10pIDwgRVBTSUxPTiAmJlxuICAgICAgICAgICAgTWF0aC5hYnMoYVs0XSAtIGJbNF0pIDwgRVBTSUxPTiAmJlxuICAgICAgICAgICAgTWF0aC5hYnMoYVs1XSAtIGJbNV0pIDwgRVBTSUxPTiAmJlxuICAgICAgICAgICAgTWF0aC5hYnMoYVs2XSAtIGJbNl0pIDwgRVBTSUxPTiAmJlxuICAgICAgICAgICAgTWF0aC5hYnMoYVs3XSAtIGJbN10pIDwgRVBTSUxPTiAmJlxuICAgICAgICAgICAgTWF0aC5hYnMoYVs4XSAtIGJbOF0pIDwgRVBTSUxPTiAmJlxuICAgICAgICAgICAgTWF0aC5hYnMoYVs5XSAtIGJbOV0pIDwgRVBTSUxPTiAmJlxuICAgICAgICAgICAgTWF0aC5hYnMoYVsxMF0gLSBiWzEwXSkgPCBFUFNJTE9OICYmXG4gICAgICAgICAgICBNYXRoLmFicyhhWzExXSAtIGJbMTFdKSA8IEVQU0lMT04gJiZcbiAgICAgICAgICAgIE1hdGguYWJzKGFbMTJdIC0gYlsxMl0pIDwgRVBTSUxPTiAmJlxuICAgICAgICAgICAgTWF0aC5hYnMoYVsxM10gLSBiWzEzXSkgPCBFUFNJTE9OICYmXG4gICAgICAgICAgICBNYXRoLmFicyhhWzE0XSAtIGJbMTRdKSA8IEVQU0lMT04gJiZcbiAgICAgICAgICAgIE1hdGguYWJzKGFbMTVdIC0gYlsxNV0pIDwgRVBTSUxPTjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2hlY2sgaWYgMiBtYXRyaWNlcyBhcmUgZXhhY3RseSBlcXVhbFxuICAgICAqIEBwYXJhbSBhIC0gT3BlcmFuZCBtYXRyaXguXG4gICAgICogQHBhcmFtIGIgLSBPcGVyYW5kIG1hdHJpeC5cbiAgICAgKiBAcmV0dXJucyB0cnVlIGlmIG1hdHJpY2VzIGFyZSBleGFjdGx5IGVxdWFsXG4gICAgICovXG4gICAgZnVuY3Rpb24gZXF1YWxzKGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIGFbMF0gPT09IGJbMF0gJiZcbiAgICAgICAgICAgIGFbMV0gPT09IGJbMV0gJiZcbiAgICAgICAgICAgIGFbMl0gPT09IGJbMl0gJiZcbiAgICAgICAgICAgIGFbM10gPT09IGJbM10gJiZcbiAgICAgICAgICAgIGFbNF0gPT09IGJbNF0gJiZcbiAgICAgICAgICAgIGFbNV0gPT09IGJbNV0gJiZcbiAgICAgICAgICAgIGFbNl0gPT09IGJbNl0gJiZcbiAgICAgICAgICAgIGFbN10gPT09IGJbN10gJiZcbiAgICAgICAgICAgIGFbOF0gPT09IGJbOF0gJiZcbiAgICAgICAgICAgIGFbOV0gPT09IGJbOV0gJiZcbiAgICAgICAgICAgIGFbMTBdID09PSBiWzEwXSAmJlxuICAgICAgICAgICAgYVsxMV0gPT09IGJbMTFdICYmXG4gICAgICAgICAgICBhWzEyXSA9PT0gYlsxMl0gJiZcbiAgICAgICAgICAgIGFbMTNdID09PSBiWzEzXSAmJlxuICAgICAgICAgICAgYVsxNF0gPT09IGJbMTRdICYmXG4gICAgICAgICAgICBhWzE1XSA9PT0gYlsxNV07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSA0LWJ5LTQgaWRlbnRpdHkgbWF0cml4LlxuICAgICAqXG4gICAgICogQHBhcmFtIGRzdCAtIG1hdHJpeCB0byBob2xkIHJlc3VsdC4gSWYgbm90IHBhc3NlZCBhIG5ldyBvbmUgaXMgY3JlYXRlZC5cbiAgICAgKiBAcmV0dXJucyBBIDQtYnktNCBpZGVudGl0eSBtYXRyaXguXG4gICAgICovXG4gICAgZnVuY3Rpb24gaWRlbnRpdHkoZHN0KSB7XG4gICAgICAgIGNvbnN0IG5ld0RzdCA9IChkc3QgPz8gbmV3IEN0b3IoMTYpKTtcbiAgICAgICAgbmV3RHN0WzBdID0gMTtcbiAgICAgICAgbmV3RHN0WzFdID0gMDtcbiAgICAgICAgbmV3RHN0WzJdID0gMDtcbiAgICAgICAgbmV3RHN0WzNdID0gMDtcbiAgICAgICAgbmV3RHN0WzRdID0gMDtcbiAgICAgICAgbmV3RHN0WzVdID0gMTtcbiAgICAgICAgbmV3RHN0WzZdID0gMDtcbiAgICAgICAgbmV3RHN0WzddID0gMDtcbiAgICAgICAgbmV3RHN0WzhdID0gMDtcbiAgICAgICAgbmV3RHN0WzldID0gMDtcbiAgICAgICAgbmV3RHN0WzEwXSA9IDE7XG4gICAgICAgIG5ld0RzdFsxMV0gPSAwO1xuICAgICAgICBuZXdEc3RbMTJdID0gMDtcbiAgICAgICAgbmV3RHN0WzEzXSA9IDA7XG4gICAgICAgIG5ld0RzdFsxNF0gPSAwO1xuICAgICAgICBuZXdEc3RbMTVdID0gMTtcbiAgICAgICAgcmV0dXJuIG5ld0RzdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGFrZXMgdGhlIHRyYW5zcG9zZSBvZiBhIG1hdHJpeC5cbiAgICAgKiBAcGFyYW0gbSAtIFRoZSBtYXRyaXguXG4gICAgICogQHBhcmFtIGRzdCAtIG1hdHJpeCB0byBob2xkIHJlc3VsdC4gSWYgbm90IHBhc3NlZCBhIG5ldyBvbmUgaXMgY3JlYXRlZC5cbiAgICAgKiBAcmV0dXJucyBUaGUgdHJhbnNwb3NlIG9mIG0uXG4gICAgICovXG4gICAgZnVuY3Rpb24gdHJhbnNwb3NlKG0sIGRzdCkge1xuICAgICAgICBjb25zdCBuZXdEc3QgPSAoZHN0ID8/IG5ldyBDdG9yKDE2KSk7XG4gICAgICAgIGlmIChuZXdEc3QgPT09IG0pIHtcbiAgICAgICAgICAgIGxldCB0O1xuICAgICAgICAgICAgdCA9IG1bMV07XG4gICAgICAgICAgICBtWzFdID0gbVs0XTtcbiAgICAgICAgICAgIG1bNF0gPSB0O1xuICAgICAgICAgICAgdCA9IG1bMl07XG4gICAgICAgICAgICBtWzJdID0gbVs4XTtcbiAgICAgICAgICAgIG1bOF0gPSB0O1xuICAgICAgICAgICAgdCA9IG1bM107XG4gICAgICAgICAgICBtWzNdID0gbVsxMl07XG4gICAgICAgICAgICBtWzEyXSA9IHQ7XG4gICAgICAgICAgICB0ID0gbVs2XTtcbiAgICAgICAgICAgIG1bNl0gPSBtWzldO1xuICAgICAgICAgICAgbVs5XSA9IHQ7XG4gICAgICAgICAgICB0ID0gbVs3XTtcbiAgICAgICAgICAgIG1bN10gPSBtWzEzXTtcbiAgICAgICAgICAgIG1bMTNdID0gdDtcbiAgICAgICAgICAgIHQgPSBtWzExXTtcbiAgICAgICAgICAgIG1bMTFdID0gbVsxNF07XG4gICAgICAgICAgICBtWzE0XSA9IHQ7XG4gICAgICAgICAgICByZXR1cm4gbmV3RHN0O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG0wMCA9IG1bMCAqIDQgKyAwXTtcbiAgICAgICAgY29uc3QgbTAxID0gbVswICogNCArIDFdO1xuICAgICAgICBjb25zdCBtMDIgPSBtWzAgKiA0ICsgMl07XG4gICAgICAgIGNvbnN0IG0wMyA9IG1bMCAqIDQgKyAzXTtcbiAgICAgICAgY29uc3QgbTEwID0gbVsxICogNCArIDBdO1xuICAgICAgICBjb25zdCBtMTEgPSBtWzEgKiA0ICsgMV07XG4gICAgICAgIGNvbnN0IG0xMiA9IG1bMSAqIDQgKyAyXTtcbiAgICAgICAgY29uc3QgbTEzID0gbVsxICogNCArIDNdO1xuICAgICAgICBjb25zdCBtMjAgPSBtWzIgKiA0ICsgMF07XG4gICAgICAgIGNvbnN0IG0yMSA9IG1bMiAqIDQgKyAxXTtcbiAgICAgICAgY29uc3QgbTIyID0gbVsyICogNCArIDJdO1xuICAgICAgICBjb25zdCBtMjMgPSBtWzIgKiA0ICsgM107XG4gICAgICAgIGNvbnN0IG0zMCA9IG1bMyAqIDQgKyAwXTtcbiAgICAgICAgY29uc3QgbTMxID0gbVszICogNCArIDFdO1xuICAgICAgICBjb25zdCBtMzIgPSBtWzMgKiA0ICsgMl07XG4gICAgICAgIGNvbnN0IG0zMyA9IG1bMyAqIDQgKyAzXTtcbiAgICAgICAgbmV3RHN0WzBdID0gbTAwO1xuICAgICAgICBuZXdEc3RbMV0gPSBtMTA7XG4gICAgICAgIG5ld0RzdFsyXSA9IG0yMDtcbiAgICAgICAgbmV3RHN0WzNdID0gbTMwO1xuICAgICAgICBuZXdEc3RbNF0gPSBtMDE7XG4gICAgICAgIG5ld0RzdFs1XSA9IG0xMTtcbiAgICAgICAgbmV3RHN0WzZdID0gbTIxO1xuICAgICAgICBuZXdEc3RbN10gPSBtMzE7XG4gICAgICAgIG5ld0RzdFs4XSA9IG0wMjtcbiAgICAgICAgbmV3RHN0WzldID0gbTEyO1xuICAgICAgICBuZXdEc3RbMTBdID0gbTIyO1xuICAgICAgICBuZXdEc3RbMTFdID0gbTMyO1xuICAgICAgICBuZXdEc3RbMTJdID0gbTAzO1xuICAgICAgICBuZXdEc3RbMTNdID0gbTEzO1xuICAgICAgICBuZXdEc3RbMTRdID0gbTIzO1xuICAgICAgICBuZXdEc3RbMTVdID0gbTMzO1xuICAgICAgICByZXR1cm4gbmV3RHN0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb21wdXRlcyB0aGUgaW52ZXJzZSBvZiBhIDQtYnktNCBtYXRyaXguXG4gICAgICogQHBhcmFtIG0gLSBUaGUgbWF0cml4LlxuICAgICAqIEBwYXJhbSBkc3QgLSBtYXRyaXggdG8gaG9sZCByZXN1bHQuIElmIG5vdCBwYXNzZWQgYSBuZXcgb25lIGlzIGNyZWF0ZWQuXG4gICAgICogQHJldHVybnMgVGhlIGludmVyc2Ugb2YgbS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpbnZlcnNlKG0sIGRzdCkge1xuICAgICAgICBjb25zdCBuZXdEc3QgPSAoZHN0ID8/IG5ldyBDdG9yKDE2KSk7XG4gICAgICAgIGNvbnN0IG0wMCA9IG1bMCAqIDQgKyAwXTtcbiAgICAgICAgY29uc3QgbTAxID0gbVswICogNCArIDFdO1xuICAgICAgICBjb25zdCBtMDIgPSBtWzAgKiA0ICsgMl07XG4gICAgICAgIGNvbnN0IG0wMyA9IG1bMCAqIDQgKyAzXTtcbiAgICAgICAgY29uc3QgbTEwID0gbVsxICogNCArIDBdO1xuICAgICAgICBjb25zdCBtMTEgPSBtWzEgKiA0ICsgMV07XG4gICAgICAgIGNvbnN0IG0xMiA9IG1bMSAqIDQgKyAyXTtcbiAgICAgICAgY29uc3QgbTEzID0gbVsxICogNCArIDNdO1xuICAgICAgICBjb25zdCBtMjAgPSBtWzIgKiA0ICsgMF07XG4gICAgICAgIGNvbnN0IG0yMSA9IG1bMiAqIDQgKyAxXTtcbiAgICAgICAgY29uc3QgbTIyID0gbVsyICogNCArIDJdO1xuICAgICAgICBjb25zdCBtMjMgPSBtWzIgKiA0ICsgM107XG4gICAgICAgIGNvbnN0IG0zMCA9IG1bMyAqIDQgKyAwXTtcbiAgICAgICAgY29uc3QgbTMxID0gbVszICogNCArIDFdO1xuICAgICAgICBjb25zdCBtMzIgPSBtWzMgKiA0ICsgMl07XG4gICAgICAgIGNvbnN0IG0zMyA9IG1bMyAqIDQgKyAzXTtcbiAgICAgICAgY29uc3QgdG1wMCA9IG0yMiAqIG0zMztcbiAgICAgICAgY29uc3QgdG1wMSA9IG0zMiAqIG0yMztcbiAgICAgICAgY29uc3QgdG1wMiA9IG0xMiAqIG0zMztcbiAgICAgICAgY29uc3QgdG1wMyA9IG0zMiAqIG0xMztcbiAgICAgICAgY29uc3QgdG1wNCA9IG0xMiAqIG0yMztcbiAgICAgICAgY29uc3QgdG1wNSA9IG0yMiAqIG0xMztcbiAgICAgICAgY29uc3QgdG1wNiA9IG0wMiAqIG0zMztcbiAgICAgICAgY29uc3QgdG1wNyA9IG0zMiAqIG0wMztcbiAgICAgICAgY29uc3QgdG1wOCA9IG0wMiAqIG0yMztcbiAgICAgICAgY29uc3QgdG1wOSA9IG0yMiAqIG0wMztcbiAgICAgICAgY29uc3QgdG1wMTAgPSBtMDIgKiBtMTM7XG4gICAgICAgIGNvbnN0IHRtcDExID0gbTEyICogbTAzO1xuICAgICAgICBjb25zdCB0bXAxMiA9IG0yMCAqIG0zMTtcbiAgICAgICAgY29uc3QgdG1wMTMgPSBtMzAgKiBtMjE7XG4gICAgICAgIGNvbnN0IHRtcDE0ID0gbTEwICogbTMxO1xuICAgICAgICBjb25zdCB0bXAxNSA9IG0zMCAqIG0xMTtcbiAgICAgICAgY29uc3QgdG1wMTYgPSBtMTAgKiBtMjE7XG4gICAgICAgIGNvbnN0IHRtcDE3ID0gbTIwICogbTExO1xuICAgICAgICBjb25zdCB0bXAxOCA9IG0wMCAqIG0zMTtcbiAgICAgICAgY29uc3QgdG1wMTkgPSBtMzAgKiBtMDE7XG4gICAgICAgIGNvbnN0IHRtcDIwID0gbTAwICogbTIxO1xuICAgICAgICBjb25zdCB0bXAyMSA9IG0yMCAqIG0wMTtcbiAgICAgICAgY29uc3QgdG1wMjIgPSBtMDAgKiBtMTE7XG4gICAgICAgIGNvbnN0IHRtcDIzID0gbTEwICogbTAxO1xuICAgICAgICBjb25zdCB0MCA9ICh0bXAwICogbTExICsgdG1wMyAqIG0yMSArIHRtcDQgKiBtMzEpIC1cbiAgICAgICAgICAgICh0bXAxICogbTExICsgdG1wMiAqIG0yMSArIHRtcDUgKiBtMzEpO1xuICAgICAgICBjb25zdCB0MSA9ICh0bXAxICogbTAxICsgdG1wNiAqIG0yMSArIHRtcDkgKiBtMzEpIC1cbiAgICAgICAgICAgICh0bXAwICogbTAxICsgdG1wNyAqIG0yMSArIHRtcDggKiBtMzEpO1xuICAgICAgICBjb25zdCB0MiA9ICh0bXAyICogbTAxICsgdG1wNyAqIG0xMSArIHRtcDEwICogbTMxKSAtXG4gICAgICAgICAgICAodG1wMyAqIG0wMSArIHRtcDYgKiBtMTEgKyB0bXAxMSAqIG0zMSk7XG4gICAgICAgIGNvbnN0IHQzID0gKHRtcDUgKiBtMDEgKyB0bXA4ICogbTExICsgdG1wMTEgKiBtMjEpIC1cbiAgICAgICAgICAgICh0bXA0ICogbTAxICsgdG1wOSAqIG0xMSArIHRtcDEwICogbTIxKTtcbiAgICAgICAgY29uc3QgZCA9IDEgLyAobTAwICogdDAgKyBtMTAgKiB0MSArIG0yMCAqIHQyICsgbTMwICogdDMpO1xuICAgICAgICBuZXdEc3RbMF0gPSBkICogdDA7XG4gICAgICAgIG5ld0RzdFsxXSA9IGQgKiB0MTtcbiAgICAgICAgbmV3RHN0WzJdID0gZCAqIHQyO1xuICAgICAgICBuZXdEc3RbM10gPSBkICogdDM7XG4gICAgICAgIG5ld0RzdFs0XSA9IGQgKiAoKHRtcDEgKiBtMTAgKyB0bXAyICogbTIwICsgdG1wNSAqIG0zMCkgLVxuICAgICAgICAgICAgKHRtcDAgKiBtMTAgKyB0bXAzICogbTIwICsgdG1wNCAqIG0zMCkpO1xuICAgICAgICBuZXdEc3RbNV0gPSBkICogKCh0bXAwICogbTAwICsgdG1wNyAqIG0yMCArIHRtcDggKiBtMzApIC1cbiAgICAgICAgICAgICh0bXAxICogbTAwICsgdG1wNiAqIG0yMCArIHRtcDkgKiBtMzApKTtcbiAgICAgICAgbmV3RHN0WzZdID0gZCAqICgodG1wMyAqIG0wMCArIHRtcDYgKiBtMTAgKyB0bXAxMSAqIG0zMCkgLVxuICAgICAgICAgICAgKHRtcDIgKiBtMDAgKyB0bXA3ICogbTEwICsgdG1wMTAgKiBtMzApKTtcbiAgICAgICAgbmV3RHN0WzddID0gZCAqICgodG1wNCAqIG0wMCArIHRtcDkgKiBtMTAgKyB0bXAxMCAqIG0yMCkgLVxuICAgICAgICAgICAgKHRtcDUgKiBtMDAgKyB0bXA4ICogbTEwICsgdG1wMTEgKiBtMjApKTtcbiAgICAgICAgbmV3RHN0WzhdID0gZCAqICgodG1wMTIgKiBtMTMgKyB0bXAxNSAqIG0yMyArIHRtcDE2ICogbTMzKSAtXG4gICAgICAgICAgICAodG1wMTMgKiBtMTMgKyB0bXAxNCAqIG0yMyArIHRtcDE3ICogbTMzKSk7XG4gICAgICAgIG5ld0RzdFs5XSA9IGQgKiAoKHRtcDEzICogbTAzICsgdG1wMTggKiBtMjMgKyB0bXAyMSAqIG0zMykgLVxuICAgICAgICAgICAgKHRtcDEyICogbTAzICsgdG1wMTkgKiBtMjMgKyB0bXAyMCAqIG0zMykpO1xuICAgICAgICBuZXdEc3RbMTBdID0gZCAqICgodG1wMTQgKiBtMDMgKyB0bXAxOSAqIG0xMyArIHRtcDIyICogbTMzKSAtXG4gICAgICAgICAgICAodG1wMTUgKiBtMDMgKyB0bXAxOCAqIG0xMyArIHRtcDIzICogbTMzKSk7XG4gICAgICAgIG5ld0RzdFsxMV0gPSBkICogKCh0bXAxNyAqIG0wMyArIHRtcDIwICogbTEzICsgdG1wMjMgKiBtMjMpIC1cbiAgICAgICAgICAgICh0bXAxNiAqIG0wMyArIHRtcDIxICogbTEzICsgdG1wMjIgKiBtMjMpKTtcbiAgICAgICAgbmV3RHN0WzEyXSA9IGQgKiAoKHRtcDE0ICogbTIyICsgdG1wMTcgKiBtMzIgKyB0bXAxMyAqIG0xMikgLVxuICAgICAgICAgICAgKHRtcDE2ICogbTMyICsgdG1wMTIgKiBtMTIgKyB0bXAxNSAqIG0yMikpO1xuICAgICAgICBuZXdEc3RbMTNdID0gZCAqICgodG1wMjAgKiBtMzIgKyB0bXAxMiAqIG0wMiArIHRtcDE5ICogbTIyKSAtXG4gICAgICAgICAgICAodG1wMTggKiBtMjIgKyB0bXAyMSAqIG0zMiArIHRtcDEzICogbTAyKSk7XG4gICAgICAgIG5ld0RzdFsxNF0gPSBkICogKCh0bXAxOCAqIG0xMiArIHRtcDIzICogbTMyICsgdG1wMTUgKiBtMDIpIC1cbiAgICAgICAgICAgICh0bXAyMiAqIG0zMiArIHRtcDE0ICogbTAyICsgdG1wMTkgKiBtMTIpKTtcbiAgICAgICAgbmV3RHN0WzE1XSA9IGQgKiAoKHRtcDIyICogbTIyICsgdG1wMTYgKiBtMDIgKyB0bXAyMSAqIG0xMikgLVxuICAgICAgICAgICAgKHRtcDIwICogbTEyICsgdG1wMjMgKiBtMjIgKyB0bXAxNyAqIG0wMikpO1xuICAgICAgICByZXR1cm4gbmV3RHN0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb21wdXRlIHRoZSBkZXRlcm1pbmFudCBvZiBhIG1hdHJpeFxuICAgICAqIEBwYXJhbSBtIC0gdGhlIG1hdHJpeFxuICAgICAqIEByZXR1cm5zIHRoZSBkZXRlcm1pbmFudFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGRldGVybWluYW50KG0pIHtcbiAgICAgICAgY29uc3QgbTAwID0gbVswICogNCArIDBdO1xuICAgICAgICBjb25zdCBtMDEgPSBtWzAgKiA0ICsgMV07XG4gICAgICAgIGNvbnN0IG0wMiA9IG1bMCAqIDQgKyAyXTtcbiAgICAgICAgY29uc3QgbTAzID0gbVswICogNCArIDNdO1xuICAgICAgICBjb25zdCBtMTAgPSBtWzEgKiA0ICsgMF07XG4gICAgICAgIGNvbnN0IG0xMSA9IG1bMSAqIDQgKyAxXTtcbiAgICAgICAgY29uc3QgbTEyID0gbVsxICogNCArIDJdO1xuICAgICAgICBjb25zdCBtMTMgPSBtWzEgKiA0ICsgM107XG4gICAgICAgIGNvbnN0IG0yMCA9IG1bMiAqIDQgKyAwXTtcbiAgICAgICAgY29uc3QgbTIxID0gbVsyICogNCArIDFdO1xuICAgICAgICBjb25zdCBtMjIgPSBtWzIgKiA0ICsgMl07XG4gICAgICAgIGNvbnN0IG0yMyA9IG1bMiAqIDQgKyAzXTtcbiAgICAgICAgY29uc3QgbTMwID0gbVszICogNCArIDBdO1xuICAgICAgICBjb25zdCBtMzEgPSBtWzMgKiA0ICsgMV07XG4gICAgICAgIGNvbnN0IG0zMiA9IG1bMyAqIDQgKyAyXTtcbiAgICAgICAgY29uc3QgbTMzID0gbVszICogNCArIDNdO1xuICAgICAgICBjb25zdCB0bXAwID0gbTIyICogbTMzO1xuICAgICAgICBjb25zdCB0bXAxID0gbTMyICogbTIzO1xuICAgICAgICBjb25zdCB0bXAyID0gbTEyICogbTMzO1xuICAgICAgICBjb25zdCB0bXAzID0gbTMyICogbTEzO1xuICAgICAgICBjb25zdCB0bXA0ID0gbTEyICogbTIzO1xuICAgICAgICBjb25zdCB0bXA1ID0gbTIyICogbTEzO1xuICAgICAgICBjb25zdCB0bXA2ID0gbTAyICogbTMzO1xuICAgICAgICBjb25zdCB0bXA3ID0gbTMyICogbTAzO1xuICAgICAgICBjb25zdCB0bXA4ID0gbTAyICogbTIzO1xuICAgICAgICBjb25zdCB0bXA5ID0gbTIyICogbTAzO1xuICAgICAgICBjb25zdCB0bXAxMCA9IG0wMiAqIG0xMztcbiAgICAgICAgY29uc3QgdG1wMTEgPSBtMTIgKiBtMDM7XG4gICAgICAgIGNvbnN0IHQwID0gKHRtcDAgKiBtMTEgKyB0bXAzICogbTIxICsgdG1wNCAqIG0zMSkgLVxuICAgICAgICAgICAgKHRtcDEgKiBtMTEgKyB0bXAyICogbTIxICsgdG1wNSAqIG0zMSk7XG4gICAgICAgIGNvbnN0IHQxID0gKHRtcDEgKiBtMDEgKyB0bXA2ICogbTIxICsgdG1wOSAqIG0zMSkgLVxuICAgICAgICAgICAgKHRtcDAgKiBtMDEgKyB0bXA3ICogbTIxICsgdG1wOCAqIG0zMSk7XG4gICAgICAgIGNvbnN0IHQyID0gKHRtcDIgKiBtMDEgKyB0bXA3ICogbTExICsgdG1wMTAgKiBtMzEpIC1cbiAgICAgICAgICAgICh0bXAzICogbTAxICsgdG1wNiAqIG0xMSArIHRtcDExICogbTMxKTtcbiAgICAgICAgY29uc3QgdDMgPSAodG1wNSAqIG0wMSArIHRtcDggKiBtMTEgKyB0bXAxMSAqIG0yMSkgLVxuICAgICAgICAgICAgKHRtcDQgKiBtMDEgKyB0bXA5ICogbTExICsgdG1wMTAgKiBtMjEpO1xuICAgICAgICByZXR1cm4gbTAwICogdDAgKyBtMTAgKiB0MSArIG0yMCAqIHQyICsgbTMwICogdDM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbXB1dGVzIHRoZSBpbnZlcnNlIG9mIGEgNC1ieS00IG1hdHJpeC4gKHNhbWUgYXMgaW52ZXJzZSlcbiAgICAgKiBAcGFyYW0gbSAtIFRoZSBtYXRyaXguXG4gICAgICogQHBhcmFtIGRzdCAtIG1hdHJpeCB0byBob2xkIHJlc3VsdC4gSWYgbm90IHBhc3NlZCBhIG5ldyBvbmUgaXMgY3JlYXRlZC5cbiAgICAgKiBAcmV0dXJucyBUaGUgaW52ZXJzZSBvZiBtLlxuICAgICAqL1xuICAgIGNvbnN0IGludmVydCA9IGludmVyc2U7XG4gICAgLyoqXG4gICAgICogTXVsdGlwbGllcyB0d28gNC1ieS00IG1hdHJpY2VzIHdpdGggYSBvbiB0aGUgbGVmdCBhbmQgYiBvbiB0aGUgcmlnaHRcbiAgICAgKiBAcGFyYW0gYSAtIFRoZSBtYXRyaXggb24gdGhlIGxlZnQuXG4gICAgICogQHBhcmFtIGIgLSBUaGUgbWF0cml4IG9uIHRoZSByaWdodC5cbiAgICAgKiBAcGFyYW0gZHN0IC0gbWF0cml4IHRvIGhvbGQgcmVzdWx0LiBJZiBub3QgcGFzc2VkIGEgbmV3IG9uZSBpcyBjcmVhdGVkLlxuICAgICAqIEByZXR1cm5zIFRoZSBtYXRyaXggcHJvZHVjdCBvZiBhIGFuZCBiLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG11bHRpcGx5KGEsIGIsIGRzdCkge1xuICAgICAgICBjb25zdCBuZXdEc3QgPSAoZHN0ID8/IG5ldyBDdG9yKDE2KSk7XG4gICAgICAgIGNvbnN0IGEwMCA9IGFbMF07XG4gICAgICAgIGNvbnN0IGEwMSA9IGFbMV07XG4gICAgICAgIGNvbnN0IGEwMiA9IGFbMl07XG4gICAgICAgIGNvbnN0IGEwMyA9IGFbM107XG4gICAgICAgIGNvbnN0IGExMCA9IGFbNCArIDBdO1xuICAgICAgICBjb25zdCBhMTEgPSBhWzQgKyAxXTtcbiAgICAgICAgY29uc3QgYTEyID0gYVs0ICsgMl07XG4gICAgICAgIGNvbnN0IGExMyA9IGFbNCArIDNdO1xuICAgICAgICBjb25zdCBhMjAgPSBhWzggKyAwXTtcbiAgICAgICAgY29uc3QgYTIxID0gYVs4ICsgMV07XG4gICAgICAgIGNvbnN0IGEyMiA9IGFbOCArIDJdO1xuICAgICAgICBjb25zdCBhMjMgPSBhWzggKyAzXTtcbiAgICAgICAgY29uc3QgYTMwID0gYVsxMiArIDBdO1xuICAgICAgICBjb25zdCBhMzEgPSBhWzEyICsgMV07XG4gICAgICAgIGNvbnN0IGEzMiA9IGFbMTIgKyAyXTtcbiAgICAgICAgY29uc3QgYTMzID0gYVsxMiArIDNdO1xuICAgICAgICBjb25zdCBiMDAgPSBiWzBdO1xuICAgICAgICBjb25zdCBiMDEgPSBiWzFdO1xuICAgICAgICBjb25zdCBiMDIgPSBiWzJdO1xuICAgICAgICBjb25zdCBiMDMgPSBiWzNdO1xuICAgICAgICBjb25zdCBiMTAgPSBiWzQgKyAwXTtcbiAgICAgICAgY29uc3QgYjExID0gYls0ICsgMV07XG4gICAgICAgIGNvbnN0IGIxMiA9IGJbNCArIDJdO1xuICAgICAgICBjb25zdCBiMTMgPSBiWzQgKyAzXTtcbiAgICAgICAgY29uc3QgYjIwID0gYls4ICsgMF07XG4gICAgICAgIGNvbnN0IGIyMSA9IGJbOCArIDFdO1xuICAgICAgICBjb25zdCBiMjIgPSBiWzggKyAyXTtcbiAgICAgICAgY29uc3QgYjIzID0gYls4ICsgM107XG4gICAgICAgIGNvbnN0IGIzMCA9IGJbMTIgKyAwXTtcbiAgICAgICAgY29uc3QgYjMxID0gYlsxMiArIDFdO1xuICAgICAgICBjb25zdCBiMzIgPSBiWzEyICsgMl07XG4gICAgICAgIGNvbnN0IGIzMyA9IGJbMTIgKyAzXTtcbiAgICAgICAgbmV3RHN0WzBdID0gYTAwICogYjAwICsgYTEwICogYjAxICsgYTIwICogYjAyICsgYTMwICogYjAzO1xuICAgICAgICBuZXdEc3RbMV0gPSBhMDEgKiBiMDAgKyBhMTEgKiBiMDEgKyBhMjEgKiBiMDIgKyBhMzEgKiBiMDM7XG4gICAgICAgIG5ld0RzdFsyXSA9IGEwMiAqIGIwMCArIGExMiAqIGIwMSArIGEyMiAqIGIwMiArIGEzMiAqIGIwMztcbiAgICAgICAgbmV3RHN0WzNdID0gYTAzICogYjAwICsgYTEzICogYjAxICsgYTIzICogYjAyICsgYTMzICogYjAzO1xuICAgICAgICBuZXdEc3RbNF0gPSBhMDAgKiBiMTAgKyBhMTAgKiBiMTEgKyBhMjAgKiBiMTIgKyBhMzAgKiBiMTM7XG4gICAgICAgIG5ld0RzdFs1XSA9IGEwMSAqIGIxMCArIGExMSAqIGIxMSArIGEyMSAqIGIxMiArIGEzMSAqIGIxMztcbiAgICAgICAgbmV3RHN0WzZdID0gYTAyICogYjEwICsgYTEyICogYjExICsgYTIyICogYjEyICsgYTMyICogYjEzO1xuICAgICAgICBuZXdEc3RbN10gPSBhMDMgKiBiMTAgKyBhMTMgKiBiMTEgKyBhMjMgKiBiMTIgKyBhMzMgKiBiMTM7XG4gICAgICAgIG5ld0RzdFs4XSA9IGEwMCAqIGIyMCArIGExMCAqIGIyMSArIGEyMCAqIGIyMiArIGEzMCAqIGIyMztcbiAgICAgICAgbmV3RHN0WzldID0gYTAxICogYjIwICsgYTExICogYjIxICsgYTIxICogYjIyICsgYTMxICogYjIzO1xuICAgICAgICBuZXdEc3RbMTBdID0gYTAyICogYjIwICsgYTEyICogYjIxICsgYTIyICogYjIyICsgYTMyICogYjIzO1xuICAgICAgICBuZXdEc3RbMTFdID0gYTAzICogYjIwICsgYTEzICogYjIxICsgYTIzICogYjIyICsgYTMzICogYjIzO1xuICAgICAgICBuZXdEc3RbMTJdID0gYTAwICogYjMwICsgYTEwICogYjMxICsgYTIwICogYjMyICsgYTMwICogYjMzO1xuICAgICAgICBuZXdEc3RbMTNdID0gYTAxICogYjMwICsgYTExICogYjMxICsgYTIxICogYjMyICsgYTMxICogYjMzO1xuICAgICAgICBuZXdEc3RbMTRdID0gYTAyICogYjMwICsgYTEyICogYjMxICsgYTIyICogYjMyICsgYTMyICogYjMzO1xuICAgICAgICBuZXdEc3RbMTVdID0gYTAzICogYjMwICsgYTEzICogYjMxICsgYTIzICogYjMyICsgYTMzICogYjMzO1xuICAgICAgICByZXR1cm4gbmV3RHN0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBNdWx0aXBsaWVzIHR3byA0LWJ5LTQgbWF0cmljZXMgd2l0aCBhIG9uIHRoZSBsZWZ0IGFuZCBiIG9uIHRoZSByaWdodCAoc2FtZSBhcyBtdWx0aXBseSlcbiAgICAgKiBAcGFyYW0gYSAtIFRoZSBtYXRyaXggb24gdGhlIGxlZnQuXG4gICAgICogQHBhcmFtIGIgLSBUaGUgbWF0cml4IG9uIHRoZSByaWdodC5cbiAgICAgKiBAcGFyYW0gZHN0IC0gbWF0cml4IHRvIGhvbGQgcmVzdWx0LiBJZiBub3QgcGFzc2VkIGEgbmV3IG9uZSBpcyBjcmVhdGVkLlxuICAgICAqIEByZXR1cm5zIFRoZSBtYXRyaXggcHJvZHVjdCBvZiBhIGFuZCBiLlxuICAgICAqL1xuICAgIGNvbnN0IG11bCA9IG11bHRpcGx5O1xuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIHRyYW5zbGF0aW9uIGNvbXBvbmVudCBvZiBhIDQtYnktNCBtYXRyaXggdG8gdGhlIGdpdmVuXG4gICAgICogdmVjdG9yLlxuICAgICAqIEBwYXJhbSBhIC0gVGhlIG1hdHJpeC5cbiAgICAgKiBAcGFyYW0gdiAtIFRoZSB2ZWN0b3IuXG4gICAgICogQHBhcmFtIGRzdCAtIG1hdHJpeCB0byBob2xkIHJlc3VsdC4gSWYgbm90IHBhc3NlZCBhIG5ldyBvbmUgaXMgY3JlYXRlZC5cbiAgICAgKiBAcmV0dXJucyBUaGUgbWF0cml4IHdpdGggdHJhbnNsYXRpb24gc2V0LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNldFRyYW5zbGF0aW9uKGEsIHYsIGRzdCkge1xuICAgICAgICBjb25zdCBuZXdEc3QgPSAoZHN0ID8/IGlkZW50aXR5KCkpO1xuICAgICAgICBpZiAoYSAhPT0gbmV3RHN0KSB7XG4gICAgICAgICAgICBuZXdEc3RbMF0gPSBhWzBdO1xuICAgICAgICAgICAgbmV3RHN0WzFdID0gYVsxXTtcbiAgICAgICAgICAgIG5ld0RzdFsyXSA9IGFbMl07XG4gICAgICAgICAgICBuZXdEc3RbM10gPSBhWzNdO1xuICAgICAgICAgICAgbmV3RHN0WzRdID0gYVs0XTtcbiAgICAgICAgICAgIG5ld0RzdFs1XSA9IGFbNV07XG4gICAgICAgICAgICBuZXdEc3RbNl0gPSBhWzZdO1xuICAgICAgICAgICAgbmV3RHN0WzddID0gYVs3XTtcbiAgICAgICAgICAgIG5ld0RzdFs4XSA9IGFbOF07XG4gICAgICAgICAgICBuZXdEc3RbOV0gPSBhWzldO1xuICAgICAgICAgICAgbmV3RHN0WzEwXSA9IGFbMTBdO1xuICAgICAgICAgICAgbmV3RHN0WzExXSA9IGFbMTFdO1xuICAgICAgICB9XG4gICAgICAgIG5ld0RzdFsxMl0gPSB2WzBdO1xuICAgICAgICBuZXdEc3RbMTNdID0gdlsxXTtcbiAgICAgICAgbmV3RHN0WzE0XSA9IHZbMl07XG4gICAgICAgIG5ld0RzdFsxNV0gPSAxO1xuICAgICAgICByZXR1cm4gbmV3RHN0O1xuICAgIH1cbiAgICAvLy8qKlxuICAgIC8vICogUmV0dXJucyB0aGUgdHJhbnNsYXRpb24gY29tcG9uZW50IG9mIGEgNC1ieS00IG1hdHJpeCBhcyBhIHZlY3RvciB3aXRoIDNcbiAgICAvLyAqIGVudHJpZXMuXG4gICAgLy8gKiBAcGFyYW0gbSAtIFRoZSBtYXRyaXguXG4gICAgLy8gKiBAcGFyYW0gZHN0IC0gdmVjdG9yIHRvIGhvbGQgcmVzdWx0LiBJZiBub3QgcGFzc2VkIGEgbmV3IG9uZSBpcyBjcmVhdGVkLlxuICAgIC8vICogQHJldHVybnMgVGhlIHRyYW5zbGF0aW9uIGNvbXBvbmVudCBvZiBtLlxuICAgIC8vICovXG4gICAgZnVuY3Rpb24gZ2V0VHJhbnNsYXRpb24obSwgZHN0KSB7XG4gICAgICAgIGNvbnN0IG5ld0RzdCA9IChkc3QgPz8gdmVjMy5jcmVhdGUoKSk7XG4gICAgICAgIG5ld0RzdFswXSA9IG1bMTJdO1xuICAgICAgICBuZXdEc3RbMV0gPSBtWzEzXTtcbiAgICAgICAgbmV3RHN0WzJdID0gbVsxNF07XG4gICAgICAgIHJldHVybiBuZXdEc3Q7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYW4gYXhpcyBvZiBhIDR4NCBtYXRyaXggYXMgYSB2ZWN0b3Igd2l0aCAzIGVudHJpZXNcbiAgICAgKiBAcGFyYW0gbSAtIFRoZSBtYXRyaXguXG4gICAgICogQHBhcmFtIGF4aXMgLSBUaGUgYXhpcyAwID0geCwgMSA9IHksIDIgPSB6O1xuICAgICAqIEByZXR1cm5zIFRoZSBheGlzIGNvbXBvbmVudCBvZiBtLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGdldEF4aXMobSwgYXhpcywgZHN0KSB7XG4gICAgICAgIGNvbnN0IG5ld0RzdCA9IChkc3QgPz8gdmVjMy5jcmVhdGUoKSk7XG4gICAgICAgIGNvbnN0IG9mZiA9IGF4aXMgKiA0O1xuICAgICAgICBuZXdEc3RbMF0gPSBtW29mZiArIDBdO1xuICAgICAgICBuZXdEc3RbMV0gPSBtW29mZiArIDFdO1xuICAgICAgICBuZXdEc3RbMl0gPSBtW29mZiArIDJdO1xuICAgICAgICByZXR1cm4gbmV3RHN0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIGFuIGF4aXMgb2YgYSA0eDQgbWF0cml4IGFzIGEgdmVjdG9yIHdpdGggMyBlbnRyaWVzXG4gICAgICogQHBhcmFtIG0gLSBUaGUgbWF0cml4LlxuICAgICAqIEBwYXJhbSB2IC0gdGhlIGF4aXMgdmVjdG9yXG4gICAgICogQHBhcmFtIGF4aXMgLSBUaGUgYXhpcyAgMCA9IHgsIDEgPSB5LCAyID0gejtcbiAgICAgKiBAcGFyYW0gZHN0IC0gVGhlIG1hdHJpeCB0byBzZXQuIElmIG5vdCBwYXNzZWQgYSBuZXcgb25lIGlzIGNyZWF0ZWQuXG4gICAgICogQHJldHVybnMgVGhlIG1hdHJpeCB3aXRoIGF4aXMgc2V0LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNldEF4aXMobSwgdiwgYXhpcywgZHN0KSB7XG4gICAgICAgIGNvbnN0IG5ld0RzdCA9IChkc3QgPT09IG0pID8gZHN0IDogY29weShtLCBkc3QpO1xuICAgICAgICBjb25zdCBvZmYgPSBheGlzICogNDtcbiAgICAgICAgbmV3RHN0W29mZiArIDBdID0gdlswXTtcbiAgICAgICAgbmV3RHN0W29mZiArIDFdID0gdlsxXTtcbiAgICAgICAgbmV3RHN0W29mZiArIDJdID0gdlsyXTtcbiAgICAgICAgcmV0dXJuIG5ld0RzdDtcbiAgICB9XG4gICAgLy8vKipcbiAgICAvLyAqIFJldHVybnMgdGhlIHNjYWxpbmcgY29tcG9uZW50IG9mIHRoZSBtYXRyaXhcbiAgICAvLyAqIEBwYXJhbSBtIC0gVGhlIE1hdHJpeFxuICAgIC8vICogQHBhcmFtIGRzdCAtIFRoZSB2ZWN0b3IgdG8gc2V0LiBJZiBub3QgcGFzc2VkIGEgbmV3IG9uZSBpcyBjcmVhdGVkLlxuICAgIC8vICovXG4gICAgZnVuY3Rpb24gZ2V0U2NhbGluZyhtLCBkc3QpIHtcbiAgICAgICAgY29uc3QgbmV3RHN0ID0gKGRzdCA/PyB2ZWMzLmNyZWF0ZSgpKTtcbiAgICAgICAgY29uc3QgeHggPSBtWzBdO1xuICAgICAgICBjb25zdCB4eSA9IG1bMV07XG4gICAgICAgIGNvbnN0IHh6ID0gbVsyXTtcbiAgICAgICAgY29uc3QgeXggPSBtWzRdO1xuICAgICAgICBjb25zdCB5eSA9IG1bNV07XG4gICAgICAgIGNvbnN0IHl6ID0gbVs2XTtcbiAgICAgICAgY29uc3QgenggPSBtWzhdO1xuICAgICAgICBjb25zdCB6eSA9IG1bOV07XG4gICAgICAgIGNvbnN0IHp6ID0gbVsxMF07XG4gICAgICAgIG5ld0RzdFswXSA9IE1hdGguc3FydCh4eCAqIHh4ICsgeHkgKiB4eSArIHh6ICogeHopO1xuICAgICAgICBuZXdEc3RbMV0gPSBNYXRoLnNxcnQoeXggKiB5eCArIHl5ICogeXkgKyB5eiAqIHl6KTtcbiAgICAgICAgbmV3RHN0WzJdID0gTWF0aC5zcXJ0KHp4ICogenggKyB6eSAqIHp5ICsgenogKiB6eik7XG4gICAgICAgIHJldHVybiBuZXdEc3Q7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbXB1dGVzIGEgNC1ieS00IHBlcnNwZWN0aXZlIHRyYW5zZm9ybWF0aW9uIG1hdHJpeCBnaXZlbiB0aGUgYW5ndWxhciBoZWlnaHRcbiAgICAgKiBvZiB0aGUgZnJ1c3R1bSwgdGhlIGFzcGVjdCByYXRpbywgYW5kIHRoZSBuZWFyIGFuZCBmYXIgY2xpcHBpbmcgcGxhbmVzLiAgVGhlXG4gICAgICogYXJndW1lbnRzIGRlZmluZSBhIGZydXN0dW0gZXh0ZW5kaW5nIGluIHRoZSBuZWdhdGl2ZSB6IGRpcmVjdGlvbi4gIFRoZSBnaXZlblxuICAgICAqIGFuZ2xlIGlzIHRoZSB2ZXJ0aWNhbCBhbmdsZSBvZiB0aGUgZnJ1c3R1bSwgYW5kIHRoZSBob3Jpem9udGFsIGFuZ2xlIGlzXG4gICAgICogZGV0ZXJtaW5lZCB0byBwcm9kdWNlIHRoZSBnaXZlbiBhc3BlY3QgcmF0aW8uICBUaGUgYXJndW1lbnRzIG5lYXIgYW5kIGZhciBhcmVcbiAgICAgKiB0aGUgZGlzdGFuY2VzIHRvIHRoZSBuZWFyIGFuZCBmYXIgY2xpcHBpbmcgcGxhbmVzLiAgTm90ZSB0aGF0IG5lYXIgYW5kIGZhclxuICAgICAqIGFyZSBub3QgeiBjb29yZGluYXRlcywgYnV0IHJhdGhlciB0aGV5IGFyZSBkaXN0YW5jZXMgYWxvbmcgdGhlIG5lZ2F0aXZlXG4gICAgICogei1heGlzLiAgVGhlIG1hdHJpeCBnZW5lcmF0ZWQgc2VuZHMgdGhlIHZpZXdpbmcgZnJ1c3R1bSB0byB0aGUgdW5pdCBib3guXG4gICAgICogV2UgYXNzdW1lIGEgdW5pdCBib3ggZXh0ZW5kaW5nIGZyb20gLTEgdG8gMSBpbiB0aGUgeCBhbmQgeSBkaW1lbnNpb25zIGFuZFxuICAgICAqIGZyb20gMCB0byAxIGluIHRoZSB6IGRpbWVuc2lvbi5cbiAgICAgKlxuICAgICAqIE5vdGU6IElmIHlvdSBwYXNzIGBJbmZpbml0eWAgZm9yIHpGYXIgdGhlbiBpdCB3aWxsIHByb2R1Y2UgYSBwcm9qZWN0aW9uIG1hdHJpeFxuICAgICAqIHJldHVybnMgLUluZmluaXR5IGZvciBaIHdoZW4gdHJhbnNmb3JtaW5nIGNvb3JkaW5hdGVzIHdpdGggWiA8PSAwIGFuZCArSW5maW5pdHkgZm9yIFpcbiAgICAgKiBvdGhlcndpc2UuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZmllbGRPZlZpZXdZSW5SYWRpYW5zIC0gVGhlIGNhbWVyYSBhbmdsZSBmcm9tIHRvcCB0byBib3R0b20gKGluIHJhZGlhbnMpLlxuICAgICAqIEBwYXJhbSBhc3BlY3QgLSBUaGUgYXNwZWN0IHJhdGlvIHdpZHRoIC8gaGVpZ2h0LlxuICAgICAqIEBwYXJhbSB6TmVhciAtIFRoZSBkZXB0aCAobmVnYXRpdmUgeiBjb29yZGluYXRlKVxuICAgICAqICAgICBvZiB0aGUgbmVhciBjbGlwcGluZyBwbGFuZS5cbiAgICAgKiBAcGFyYW0gekZhciAtIFRoZSBkZXB0aCAobmVnYXRpdmUgeiBjb29yZGluYXRlKVxuICAgICAqICAgICBvZiB0aGUgZmFyIGNsaXBwaW5nIHBsYW5lLlxuICAgICAqIEBwYXJhbSBkc3QgLSBtYXRyaXggdG8gaG9sZCByZXN1bHQuIElmIG5vdCBwYXNzZWQgYSBuZXcgb25lIGlzIGNyZWF0ZWQuXG4gICAgICogQHJldHVybnMgVGhlIHBlcnNwZWN0aXZlIG1hdHJpeC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBwZXJzcGVjdGl2ZShmaWVsZE9mVmlld1lJblJhZGlhbnMsIGFzcGVjdCwgek5lYXIsIHpGYXIsIGRzdCkge1xuICAgICAgICBjb25zdCBuZXdEc3QgPSAoZHN0ID8/IG5ldyBDdG9yKDE2KSk7XG4gICAgICAgIGNvbnN0IGYgPSBNYXRoLnRhbihNYXRoLlBJICogMC41IC0gMC41ICogZmllbGRPZlZpZXdZSW5SYWRpYW5zKTtcbiAgICAgICAgbmV3RHN0WzBdID0gZiAvIGFzcGVjdDtcbiAgICAgICAgbmV3RHN0WzFdID0gMDtcbiAgICAgICAgbmV3RHN0WzJdID0gMDtcbiAgICAgICAgbmV3RHN0WzNdID0gMDtcbiAgICAgICAgbmV3RHN0WzRdID0gMDtcbiAgICAgICAgbmV3RHN0WzVdID0gZjtcbiAgICAgICAgbmV3RHN0WzZdID0gMDtcbiAgICAgICAgbmV3RHN0WzddID0gMDtcbiAgICAgICAgbmV3RHN0WzhdID0gMDtcbiAgICAgICAgbmV3RHN0WzldID0gMDtcbiAgICAgICAgbmV3RHN0WzExXSA9IC0xO1xuICAgICAgICBuZXdEc3RbMTJdID0gMDtcbiAgICAgICAgbmV3RHN0WzEzXSA9IDA7XG4gICAgICAgIG5ld0RzdFsxNV0gPSAwO1xuICAgICAgICBpZiAoTnVtYmVyLmlzRmluaXRlKHpGYXIpKSB7XG4gICAgICAgICAgICBjb25zdCByYW5nZUludiA9IDEgLyAoek5lYXIgLSB6RmFyKTtcbiAgICAgICAgICAgIG5ld0RzdFsxMF0gPSB6RmFyICogcmFuZ2VJbnY7XG4gICAgICAgICAgICBuZXdEc3RbMTRdID0gekZhciAqIHpOZWFyICogcmFuZ2VJbnY7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBuZXdEc3RbMTBdID0gLTE7XG4gICAgICAgICAgICBuZXdEc3RbMTRdID0gLXpOZWFyO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXdEc3Q7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbXB1dGVzIGEgNC1ieS00IHJldmVyc2UteiBwZXJzcGVjdGl2ZSB0cmFuc2Zvcm1hdGlvbiBtYXRyaXggZ2l2ZW4gdGhlIGFuZ3VsYXIgaGVpZ2h0XG4gICAgICogb2YgdGhlIGZydXN0dW0sIHRoZSBhc3BlY3QgcmF0aW8sIGFuZCB0aGUgbmVhciBhbmQgZmFyIGNsaXBwaW5nIHBsYW5lcy4gIFRoZVxuICAgICAqIGFyZ3VtZW50cyBkZWZpbmUgYSBmcnVzdHVtIGV4dGVuZGluZyBpbiB0aGUgbmVnYXRpdmUgeiBkaXJlY3Rpb24uICBUaGUgZ2l2ZW5cbiAgICAgKiBhbmdsZSBpcyB0aGUgdmVydGljYWwgYW5nbGUgb2YgdGhlIGZydXN0dW0sIGFuZCB0aGUgaG9yaXpvbnRhbCBhbmdsZSBpc1xuICAgICAqIGRldGVybWluZWQgdG8gcHJvZHVjZSB0aGUgZ2l2ZW4gYXNwZWN0IHJhdGlvLiAgVGhlIGFyZ3VtZW50cyBuZWFyIGFuZCBmYXIgYXJlXG4gICAgICogdGhlIGRpc3RhbmNlcyB0byB0aGUgbmVhciBhbmQgZmFyIGNsaXBwaW5nIHBsYW5lcy4gIE5vdGUgdGhhdCBuZWFyIGFuZCBmYXJcbiAgICAgKiBhcmUgbm90IHogY29vcmRpbmF0ZXMsIGJ1dCByYXRoZXIgdGhleSBhcmUgZGlzdGFuY2VzIGFsb25nIHRoZSBuZWdhdGl2ZVxuICAgICAqIHotYXhpcy4gIFRoZSBtYXRyaXggZ2VuZXJhdGVkIHNlbmRzIHRoZSB2aWV3aW5nIGZydXN0dW0gdG8gdGhlIHVuaXQgYm94LlxuICAgICAqIFdlIGFzc3VtZSBhIHVuaXQgYm94IGV4dGVuZGluZyBmcm9tIC0xIHRvIDEgaW4gdGhlIHggYW5kIHkgZGltZW5zaW9ucyBhbmRcbiAgICAgKiBmcm9tIDEgKGF0IC16TmVhcikgdG8gMCAoYXQgLXpGYXIpIGluIHRoZSB6IGRpbWVuc2lvbi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBmaWVsZE9mVmlld1lJblJhZGlhbnMgLSBUaGUgY2FtZXJhIGFuZ2xlIGZyb20gdG9wIHRvIGJvdHRvbSAoaW4gcmFkaWFucykuXG4gICAgICogQHBhcmFtIGFzcGVjdCAtIFRoZSBhc3BlY3QgcmF0aW8gd2lkdGggLyBoZWlnaHQuXG4gICAgICogQHBhcmFtIHpOZWFyIC0gVGhlIGRlcHRoIChuZWdhdGl2ZSB6IGNvb3JkaW5hdGUpXG4gICAgICogICAgIG9mIHRoZSBuZWFyIGNsaXBwaW5nIHBsYW5lLlxuICAgICAqIEBwYXJhbSB6RmFyIC0gVGhlIGRlcHRoIChuZWdhdGl2ZSB6IGNvb3JkaW5hdGUpXG4gICAgICogICAgIG9mIHRoZSBmYXIgY2xpcHBpbmcgcGxhbmUuIChkZWZhdWx0ID0gSW5maW5pdHkpXG4gICAgICogQHBhcmFtIGRzdCAtIG1hdHJpeCB0byBob2xkIHJlc3VsdC4gSWYgbm90IHBhc3NlZCBhIG5ldyBvbmUgaXMgY3JlYXRlZC5cbiAgICAgKiBAcmV0dXJucyBUaGUgcGVyc3BlY3RpdmUgbWF0cml4LlxuICAgICAqLyBmdW5jdGlvbiBwZXJzcGVjdGl2ZVJldmVyc2VaKGZpZWxkT2ZWaWV3WUluUmFkaWFucywgYXNwZWN0LCB6TmVhciwgekZhciA9IEluZmluaXR5LCBkc3QpIHtcbiAgICAgICAgY29uc3QgbmV3RHN0ID0gKGRzdCA/PyBuZXcgQ3RvcigxNikpO1xuICAgICAgICBjb25zdCBmID0gMSAvIE1hdGgudGFuKGZpZWxkT2ZWaWV3WUluUmFkaWFucyAqIDAuNSk7XG4gICAgICAgIG5ld0RzdFswXSA9IGYgLyBhc3BlY3Q7XG4gICAgICAgIG5ld0RzdFsxXSA9IDA7XG4gICAgICAgIG5ld0RzdFsyXSA9IDA7XG4gICAgICAgIG5ld0RzdFszXSA9IDA7XG4gICAgICAgIG5ld0RzdFs0XSA9IDA7XG4gICAgICAgIG5ld0RzdFs1XSA9IGY7XG4gICAgICAgIG5ld0RzdFs2XSA9IDA7XG4gICAgICAgIG5ld0RzdFs3XSA9IDA7XG4gICAgICAgIG5ld0RzdFs4XSA9IDA7XG4gICAgICAgIG5ld0RzdFs5XSA9IDA7XG4gICAgICAgIG5ld0RzdFsxMV0gPSAtMTtcbiAgICAgICAgbmV3RHN0WzEyXSA9IDA7XG4gICAgICAgIG5ld0RzdFsxM10gPSAwO1xuICAgICAgICBuZXdEc3RbMTVdID0gMDtcbiAgICAgICAgaWYgKHpGYXIgPT09IEluZmluaXR5KSB7XG4gICAgICAgICAgICBuZXdEc3RbMTBdID0gMDtcbiAgICAgICAgICAgIG5ld0RzdFsxNF0gPSB6TmVhcjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IHJhbmdlSW52ID0gMSAvICh6RmFyIC0gek5lYXIpO1xuICAgICAgICAgICAgbmV3RHN0WzEwXSA9IHpOZWFyICogcmFuZ2VJbnY7XG4gICAgICAgICAgICBuZXdEc3RbMTRdID0gekZhciAqIHpOZWFyICogcmFuZ2VJbnY7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ld0RzdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29tcHV0ZXMgYSA0LWJ5LTQgb3J0aG9nb25hbCB0cmFuc2Zvcm1hdGlvbiBtYXRyaXggdGhhdCB0cmFuc2Zvcm1zIGZyb21cbiAgICAgKiB0aGUgZ2l2ZW4gdGhlIGxlZnQsIHJpZ2h0LCBib3R0b20sIGFuZCB0b3AgZGltZW5zaW9ucyB0byAtMSArMSBpbiB4LCBhbmQgeVxuICAgICAqIGFuZCAwIHRvICsxIGluIHouXG4gICAgICogQHBhcmFtIGxlZnQgLSBMZWZ0IHNpZGUgb2YgdGhlIG5lYXIgY2xpcHBpbmcgcGxhbmUgdmlld3BvcnQuXG4gICAgICogQHBhcmFtIHJpZ2h0IC0gUmlnaHQgc2lkZSBvZiB0aGUgbmVhciBjbGlwcGluZyBwbGFuZSB2aWV3cG9ydC5cbiAgICAgKiBAcGFyYW0gYm90dG9tIC0gQm90dG9tIG9mIHRoZSBuZWFyIGNsaXBwaW5nIHBsYW5lIHZpZXdwb3J0LlxuICAgICAqIEBwYXJhbSB0b3AgLSBUb3Agb2YgdGhlIG5lYXIgY2xpcHBpbmcgcGxhbmUgdmlld3BvcnQuXG4gICAgICogQHBhcmFtIG5lYXIgLSBUaGUgZGVwdGggKG5lZ2F0aXZlIHogY29vcmRpbmF0ZSlcbiAgICAgKiAgICAgb2YgdGhlIG5lYXIgY2xpcHBpbmcgcGxhbmUuXG4gICAgICogQHBhcmFtIGZhciAtIFRoZSBkZXB0aCAobmVnYXRpdmUgeiBjb29yZGluYXRlKVxuICAgICAqICAgICBvZiB0aGUgZmFyIGNsaXBwaW5nIHBsYW5lLlxuICAgICAqIEBwYXJhbSBkc3QgLSBPdXRwdXQgbWF0cml4LiBJZiBub3QgcGFzc2VkIGEgbmV3IG9uZSBpcyBjcmVhdGVkLlxuICAgICAqIEByZXR1cm5zIFRoZSBvcnRob2dyYXBoaWMgcHJvamVjdGlvbiBtYXRyaXguXG4gICAgICovXG4gICAgZnVuY3Rpb24gb3J0aG8obGVmdCwgcmlnaHQsIGJvdHRvbSwgdG9wLCBuZWFyLCBmYXIsIGRzdCkge1xuICAgICAgICBjb25zdCBuZXdEc3QgPSAoZHN0ID8/IG5ldyBDdG9yKDE2KSk7XG4gICAgICAgIG5ld0RzdFswXSA9IDIgLyAocmlnaHQgLSBsZWZ0KTtcbiAgICAgICAgbmV3RHN0WzFdID0gMDtcbiAgICAgICAgbmV3RHN0WzJdID0gMDtcbiAgICAgICAgbmV3RHN0WzNdID0gMDtcbiAgICAgICAgbmV3RHN0WzRdID0gMDtcbiAgICAgICAgbmV3RHN0WzVdID0gMiAvICh0b3AgLSBib3R0b20pO1xuICAgICAgICBuZXdEc3RbNl0gPSAwO1xuICAgICAgICBuZXdEc3RbN10gPSAwO1xuICAgICAgICBuZXdEc3RbOF0gPSAwO1xuICAgICAgICBuZXdEc3RbOV0gPSAwO1xuICAgICAgICBuZXdEc3RbMTBdID0gMSAvIChuZWFyIC0gZmFyKTtcbiAgICAgICAgbmV3RHN0WzExXSA9IDA7XG4gICAgICAgIG5ld0RzdFsxMl0gPSAocmlnaHQgKyBsZWZ0KSAvIChsZWZ0IC0gcmlnaHQpO1xuICAgICAgICBuZXdEc3RbMTNdID0gKHRvcCArIGJvdHRvbSkgLyAoYm90dG9tIC0gdG9wKTtcbiAgICAgICAgbmV3RHN0WzE0XSA9IG5lYXIgLyAobmVhciAtIGZhcik7XG4gICAgICAgIG5ld0RzdFsxNV0gPSAxO1xuICAgICAgICByZXR1cm4gbmV3RHN0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb21wdXRlcyBhIDQtYnktNCBwZXJzcGVjdGl2ZSB0cmFuc2Zvcm1hdGlvbiBtYXRyaXggZ2l2ZW4gdGhlIGxlZnQsIHJpZ2h0LFxuICAgICAqIHRvcCwgYm90dG9tLCBuZWFyIGFuZCBmYXIgY2xpcHBpbmcgcGxhbmVzLiBUaGUgYXJndW1lbnRzIGRlZmluZSBhIGZydXN0dW1cbiAgICAgKiBleHRlbmRpbmcgaW4gdGhlIG5lZ2F0aXZlIHogZGlyZWN0aW9uLiBUaGUgYXJndW1lbnRzIG5lYXIgYW5kIGZhciBhcmUgdGhlXG4gICAgICogZGlzdGFuY2VzIHRvIHRoZSBuZWFyIGFuZCBmYXIgY2xpcHBpbmcgcGxhbmVzLiBOb3RlIHRoYXQgbmVhciBhbmQgZmFyIGFyZSBub3RcbiAgICAgKiB6IGNvb3JkaW5hdGVzLCBidXQgcmF0aGVyIHRoZXkgYXJlIGRpc3RhbmNlcyBhbG9uZyB0aGUgbmVnYXRpdmUgei1heGlzLiBUaGVcbiAgICAgKiBtYXRyaXggZ2VuZXJhdGVkIHNlbmRzIHRoZSB2aWV3aW5nIGZydXN0dW0gdG8gdGhlIHVuaXQgYm94LiBXZSBhc3N1bWUgYSB1bml0XG4gICAgICogYm94IGV4dGVuZGluZyBmcm9tIC0xIHRvIDEgaW4gdGhlIHggYW5kIHkgZGltZW5zaW9ucyBhbmQgZnJvbSAwIHRvIDEgaW4gdGhlIHpcbiAgICAgKiBkaW1lbnNpb24uXG4gICAgICogQHBhcmFtIGxlZnQgLSBUaGUgeCBjb29yZGluYXRlIG9mIHRoZSBsZWZ0IHBsYW5lIG9mIHRoZSBib3guXG4gICAgICogQHBhcmFtIHJpZ2h0IC0gVGhlIHggY29vcmRpbmF0ZSBvZiB0aGUgcmlnaHQgcGxhbmUgb2YgdGhlIGJveC5cbiAgICAgKiBAcGFyYW0gYm90dG9tIC0gVGhlIHkgY29vcmRpbmF0ZSBvZiB0aGUgYm90dG9tIHBsYW5lIG9mIHRoZSBib3guXG4gICAgICogQHBhcmFtIHRvcCAtIFRoZSB5IGNvb3JkaW5hdGUgb2YgdGhlIHJpZ2h0IHBsYW5lIG9mIHRoZSBib3guXG4gICAgICogQHBhcmFtIG5lYXIgLSBUaGUgbmVnYXRpdmUgeiBjb29yZGluYXRlIG9mIHRoZSBuZWFyIHBsYW5lIG9mIHRoZSBib3guXG4gICAgICogQHBhcmFtIGZhciAtIFRoZSBuZWdhdGl2ZSB6IGNvb3JkaW5hdGUgb2YgdGhlIGZhciBwbGFuZSBvZiB0aGUgYm94LlxuICAgICAqIEBwYXJhbSBkc3QgLSBPdXRwdXQgbWF0cml4LiBJZiBub3QgcGFzc2VkIGEgbmV3IG9uZSBpcyBjcmVhdGVkLlxuICAgICAqIEByZXR1cm5zIFRoZSBwZXJzcGVjdGl2ZSBwcm9qZWN0aW9uIG1hdHJpeC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmcnVzdHVtKGxlZnQsIHJpZ2h0LCBib3R0b20sIHRvcCwgbmVhciwgZmFyLCBkc3QpIHtcbiAgICAgICAgY29uc3QgbmV3RHN0ID0gKGRzdCA/PyBuZXcgQ3RvcigxNikpO1xuICAgICAgICBjb25zdCBkeCA9IChyaWdodCAtIGxlZnQpO1xuICAgICAgICBjb25zdCBkeSA9ICh0b3AgLSBib3R0b20pO1xuICAgICAgICBjb25zdCBkeiA9IChuZWFyIC0gZmFyKTtcbiAgICAgICAgbmV3RHN0WzBdID0gMiAqIG5lYXIgLyBkeDtcbiAgICAgICAgbmV3RHN0WzFdID0gMDtcbiAgICAgICAgbmV3RHN0WzJdID0gMDtcbiAgICAgICAgbmV3RHN0WzNdID0gMDtcbiAgICAgICAgbmV3RHN0WzRdID0gMDtcbiAgICAgICAgbmV3RHN0WzVdID0gMiAqIG5lYXIgLyBkeTtcbiAgICAgICAgbmV3RHN0WzZdID0gMDtcbiAgICAgICAgbmV3RHN0WzddID0gMDtcbiAgICAgICAgbmV3RHN0WzhdID0gKGxlZnQgKyByaWdodCkgLyBkeDtcbiAgICAgICAgbmV3RHN0WzldID0gKHRvcCArIGJvdHRvbSkgLyBkeTtcbiAgICAgICAgbmV3RHN0WzEwXSA9IGZhciAvIGR6O1xuICAgICAgICBuZXdEc3RbMTFdID0gLTE7XG4gICAgICAgIG5ld0RzdFsxMl0gPSAwO1xuICAgICAgICBuZXdEc3RbMTNdID0gMDtcbiAgICAgICAgbmV3RHN0WzE0XSA9IG5lYXIgKiBmYXIgLyBkejtcbiAgICAgICAgbmV3RHN0WzE1XSA9IDA7XG4gICAgICAgIHJldHVybiBuZXdEc3Q7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbXB1dGVzIGEgNC1ieS00IHJldmVyc2UteiBwZXJzcGVjdGl2ZSB0cmFuc2Zvcm1hdGlvbiBtYXRyaXggZ2l2ZW4gdGhlIGxlZnQsIHJpZ2h0LFxuICAgICAqIHRvcCwgYm90dG9tLCBuZWFyIGFuZCBmYXIgY2xpcHBpbmcgcGxhbmVzLiBUaGUgYXJndW1lbnRzIGRlZmluZSBhIGZydXN0dW1cbiAgICAgKiBleHRlbmRpbmcgaW4gdGhlIG5lZ2F0aXZlIHogZGlyZWN0aW9uLiBUaGUgYXJndW1lbnRzIG5lYXIgYW5kIGZhciBhcmUgdGhlXG4gICAgICogZGlzdGFuY2VzIHRvIHRoZSBuZWFyIGFuZCBmYXIgY2xpcHBpbmcgcGxhbmVzLiBOb3RlIHRoYXQgbmVhciBhbmQgZmFyIGFyZSBub3RcbiAgICAgKiB6IGNvb3JkaW5hdGVzLCBidXQgcmF0aGVyIHRoZXkgYXJlIGRpc3RhbmNlcyBhbG9uZyB0aGUgbmVnYXRpdmUgei1heGlzLiBUaGVcbiAgICAgKiBtYXRyaXggZ2VuZXJhdGVkIHNlbmRzIHRoZSB2aWV3aW5nIGZydXN0dW0gdG8gdGhlIHVuaXQgYm94LiBXZSBhc3N1bWUgYSB1bml0XG4gICAgICogYm94IGV4dGVuZGluZyBmcm9tIC0xIHRvIDEgaW4gdGhlIHggYW5kIHkgZGltZW5zaW9ucyBhbmQgZnJvbSAxICgtbmVhcikgdG8gMCAoLWZhcikgaW4gdGhlIHpcbiAgICAgKiBkaW1lbnNpb24uXG4gICAgICogQHBhcmFtIGxlZnQgLSBUaGUgeCBjb29yZGluYXRlIG9mIHRoZSBsZWZ0IHBsYW5lIG9mIHRoZSBib3guXG4gICAgICogQHBhcmFtIHJpZ2h0IC0gVGhlIHggY29vcmRpbmF0ZSBvZiB0aGUgcmlnaHQgcGxhbmUgb2YgdGhlIGJveC5cbiAgICAgKiBAcGFyYW0gYm90dG9tIC0gVGhlIHkgY29vcmRpbmF0ZSBvZiB0aGUgYm90dG9tIHBsYW5lIG9mIHRoZSBib3guXG4gICAgICogQHBhcmFtIHRvcCAtIFRoZSB5IGNvb3JkaW5hdGUgb2YgdGhlIHJpZ2h0IHBsYW5lIG9mIHRoZSBib3guXG4gICAgICogQHBhcmFtIG5lYXIgLSBUaGUgbmVnYXRpdmUgeiBjb29yZGluYXRlIG9mIHRoZSBuZWFyIHBsYW5lIG9mIHRoZSBib3guXG4gICAgICogQHBhcmFtIGZhciAtIFRoZSBuZWdhdGl2ZSB6IGNvb3JkaW5hdGUgb2YgdGhlIGZhciBwbGFuZSBvZiB0aGUgYm94LlxuICAgICAqIEBwYXJhbSBkc3QgLSBPdXRwdXQgbWF0cml4LiBJZiBub3QgcGFzc2VkIGEgbmV3IG9uZSBpcyBjcmVhdGVkLlxuICAgICAqIEByZXR1cm5zIFRoZSBwZXJzcGVjdGl2ZSBwcm9qZWN0aW9uIG1hdHJpeC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmcnVzdHVtUmV2ZXJzZVoobGVmdCwgcmlnaHQsIGJvdHRvbSwgdG9wLCBuZWFyLCBmYXIgPSBJbmZpbml0eSwgZHN0KSB7XG4gICAgICAgIGNvbnN0IG5ld0RzdCA9IChkc3QgPz8gbmV3IEN0b3IoMTYpKTtcbiAgICAgICAgY29uc3QgZHggPSAocmlnaHQgLSBsZWZ0KTtcbiAgICAgICAgY29uc3QgZHkgPSAodG9wIC0gYm90dG9tKTtcbiAgICAgICAgbmV3RHN0WzBdID0gMiAqIG5lYXIgLyBkeDtcbiAgICAgICAgbmV3RHN0WzFdID0gMDtcbiAgICAgICAgbmV3RHN0WzJdID0gMDtcbiAgICAgICAgbmV3RHN0WzNdID0gMDtcbiAgICAgICAgbmV3RHN0WzRdID0gMDtcbiAgICAgICAgbmV3RHN0WzVdID0gMiAqIG5lYXIgLyBkeTtcbiAgICAgICAgbmV3RHN0WzZdID0gMDtcbiAgICAgICAgbmV3RHN0WzddID0gMDtcbiAgICAgICAgbmV3RHN0WzhdID0gKGxlZnQgKyByaWdodCkgLyBkeDtcbiAgICAgICAgbmV3RHN0WzldID0gKHRvcCArIGJvdHRvbSkgLyBkeTtcbiAgICAgICAgbmV3RHN0WzExXSA9IC0xO1xuICAgICAgICBuZXdEc3RbMTJdID0gMDtcbiAgICAgICAgbmV3RHN0WzEzXSA9IDA7XG4gICAgICAgIG5ld0RzdFsxNV0gPSAwO1xuICAgICAgICBpZiAoZmFyID09PSBJbmZpbml0eSkge1xuICAgICAgICAgICAgbmV3RHN0WzEwXSA9IDA7XG4gICAgICAgICAgICBuZXdEc3RbMTRdID0gbmVhcjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IHJhbmdlSW52ID0gMSAvIChmYXIgLSBuZWFyKTtcbiAgICAgICAgICAgIG5ld0RzdFsxMF0gPSBuZWFyICogcmFuZ2VJbnY7XG4gICAgICAgICAgICBuZXdEc3RbMTRdID0gZmFyICogbmVhciAqIHJhbmdlSW52O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXdEc3Q7XG4gICAgfVxuICAgIGNvbnN0IHhBeGlzID0gdmVjMy5jcmVhdGUoKTtcbiAgICBjb25zdCB5QXhpcyA9IHZlYzMuY3JlYXRlKCk7XG4gICAgY29uc3QgekF4aXMgPSB2ZWMzLmNyZWF0ZSgpO1xuICAgIC8qKlxuICAgICAqIENvbXB1dGVzIGEgNC1ieS00IGFpbSB0cmFuc2Zvcm1hdGlvbi5cbiAgICAgKlxuICAgICAqIFRoaXMgaXMgYSBtYXRyaXggd2hpY2ggcG9zaXRpb25zIGFuIG9iamVjdCBhaW1pbmcgZG93biBwb3NpdGl2ZSBaLlxuICAgICAqIHRvd2FyZCB0aGUgdGFyZ2V0LlxuICAgICAqXG4gICAgICogTm90ZTogdGhpcyBpcyAqKk5PVCoqIHRoZSBpbnZlcnNlIG9mIGxvb2tBdCBhcyBsb29rQXQgbG9va3MgYXQgbmVnYXRpdmUgWi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBwb3NpdGlvbiAtIFRoZSBwb3NpdGlvbiBvZiB0aGUgb2JqZWN0LlxuICAgICAqIEBwYXJhbSB0YXJnZXQgLSBUaGUgcG9zaXRpb24gbWVhbnQgdG8gYmUgYWltZWQgYXQuXG4gICAgICogQHBhcmFtIHVwIC0gQSB2ZWN0b3IgcG9pbnRpbmcgdXAuXG4gICAgICogQHBhcmFtIGRzdCAtIG1hdHJpeCB0byBob2xkIHJlc3VsdC4gSWYgbm90IHBhc3NlZCBhIG5ldyBvbmUgaXMgY3JlYXRlZC5cbiAgICAgKiBAcmV0dXJucyBUaGUgYWltIG1hdHJpeC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBhaW0ocG9zaXRpb24sIHRhcmdldCwgdXAsIGRzdCkge1xuICAgICAgICBjb25zdCBuZXdEc3QgPSAoZHN0ID8/IG5ldyBDdG9yKDE2KSk7XG4gICAgICAgIHZlYzMubm9ybWFsaXplKHZlYzMuc3VidHJhY3QodGFyZ2V0LCBwb3NpdGlvbiwgekF4aXMpLCB6QXhpcyk7XG4gICAgICAgIHZlYzMubm9ybWFsaXplKHZlYzMuY3Jvc3ModXAsIHpBeGlzLCB4QXhpcyksIHhBeGlzKTtcbiAgICAgICAgdmVjMy5ub3JtYWxpemUodmVjMy5jcm9zcyh6QXhpcywgeEF4aXMsIHlBeGlzKSwgeUF4aXMpO1xuICAgICAgICBuZXdEc3RbMF0gPSB4QXhpc1swXTtcbiAgICAgICAgbmV3RHN0WzFdID0geEF4aXNbMV07XG4gICAgICAgIG5ld0RzdFsyXSA9IHhBeGlzWzJdO1xuICAgICAgICBuZXdEc3RbM10gPSAwO1xuICAgICAgICBuZXdEc3RbNF0gPSB5QXhpc1swXTtcbiAgICAgICAgbmV3RHN0WzVdID0geUF4aXNbMV07XG4gICAgICAgIG5ld0RzdFs2XSA9IHlBeGlzWzJdO1xuICAgICAgICBuZXdEc3RbN10gPSAwO1xuICAgICAgICBuZXdEc3RbOF0gPSB6QXhpc1swXTtcbiAgICAgICAgbmV3RHN0WzldID0gekF4aXNbMV07XG4gICAgICAgIG5ld0RzdFsxMF0gPSB6QXhpc1syXTtcbiAgICAgICAgbmV3RHN0WzExXSA9IDA7XG4gICAgICAgIG5ld0RzdFsxMl0gPSBwb3NpdGlvblswXTtcbiAgICAgICAgbmV3RHN0WzEzXSA9IHBvc2l0aW9uWzFdO1xuICAgICAgICBuZXdEc3RbMTRdID0gcG9zaXRpb25bMl07XG4gICAgICAgIG5ld0RzdFsxNV0gPSAxO1xuICAgICAgICByZXR1cm4gbmV3RHN0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb21wdXRlcyBhIDQtYnktNCBjYW1lcmEgYWltIHRyYW5zZm9ybWF0aW9uLlxuICAgICAqXG4gICAgICogVGhpcyBpcyBhIG1hdHJpeCB3aGljaCBwb3NpdGlvbnMgYW4gb2JqZWN0IGFpbWluZyBkb3duIG5lZ2F0aXZlIFouXG4gICAgICogdG93YXJkIHRoZSB0YXJnZXQuXG4gICAgICpcbiAgICAgKiBOb3RlOiB0aGlzIGlzIHRoZSBpbnZlcnNlIG9mIGBsb29rQXRgXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZXllIC0gVGhlIHBvc2l0aW9uIG9mIHRoZSBvYmplY3QuXG4gICAgICogQHBhcmFtIHRhcmdldCAtIFRoZSBwb3NpdGlvbiBtZWFudCB0byBiZSBhaW1lZCBhdC5cbiAgICAgKiBAcGFyYW0gdXAgLSBBIHZlY3RvciBwb2ludGluZyB1cC5cbiAgICAgKiBAcGFyYW0gZHN0IC0gbWF0cml4IHRvIGhvbGQgcmVzdWx0LiBJZiBub3QgcGFzc2VkIGEgbmV3IG9uZSBpcyBjcmVhdGVkLlxuICAgICAqIEByZXR1cm5zIFRoZSBhaW0gbWF0cml4LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNhbWVyYUFpbShleWUsIHRhcmdldCwgdXAsIGRzdCkge1xuICAgICAgICBjb25zdCBuZXdEc3QgPSAoZHN0ID8/IG5ldyBDdG9yKDE2KSk7XG4gICAgICAgIHZlYzMubm9ybWFsaXplKHZlYzMuc3VidHJhY3QoZXllLCB0YXJnZXQsIHpBeGlzKSwgekF4aXMpO1xuICAgICAgICB2ZWMzLm5vcm1hbGl6ZSh2ZWMzLmNyb3NzKHVwLCB6QXhpcywgeEF4aXMpLCB4QXhpcyk7XG4gICAgICAgIHZlYzMubm9ybWFsaXplKHZlYzMuY3Jvc3MoekF4aXMsIHhBeGlzLCB5QXhpcyksIHlBeGlzKTtcbiAgICAgICAgbmV3RHN0WzBdID0geEF4aXNbMF07XG4gICAgICAgIG5ld0RzdFsxXSA9IHhBeGlzWzFdO1xuICAgICAgICBuZXdEc3RbMl0gPSB4QXhpc1syXTtcbiAgICAgICAgbmV3RHN0WzNdID0gMDtcbiAgICAgICAgbmV3RHN0WzRdID0geUF4aXNbMF07XG4gICAgICAgIG5ld0RzdFs1XSA9IHlBeGlzWzFdO1xuICAgICAgICBuZXdEc3RbNl0gPSB5QXhpc1syXTtcbiAgICAgICAgbmV3RHN0WzddID0gMDtcbiAgICAgICAgbmV3RHN0WzhdID0gekF4aXNbMF07XG4gICAgICAgIG5ld0RzdFs5XSA9IHpBeGlzWzFdO1xuICAgICAgICBuZXdEc3RbMTBdID0gekF4aXNbMl07XG4gICAgICAgIG5ld0RzdFsxMV0gPSAwO1xuICAgICAgICBuZXdEc3RbMTJdID0gZXllWzBdO1xuICAgICAgICBuZXdEc3RbMTNdID0gZXllWzFdO1xuICAgICAgICBuZXdEc3RbMTRdID0gZXllWzJdO1xuICAgICAgICBuZXdEc3RbMTVdID0gMTtcbiAgICAgICAgcmV0dXJuIG5ld0RzdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29tcHV0ZXMgYSA0LWJ5LTQgdmlldyB0cmFuc2Zvcm1hdGlvbi5cbiAgICAgKlxuICAgICAqIFRoaXMgaXMgYSB2aWV3IG1hdHJpeCB3aGljaCB0cmFuc2Zvcm1zIGFsbCBvdGhlciBvYmplY3RzXG4gICAgICogdG8gYmUgaW4gdGhlIHNwYWNlIG9mIHRoZSB2aWV3IGRlZmluZWQgYnkgdGhlIHBhcmFtZXRlcnMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZXllIC0gVGhlIHBvc2l0aW9uIG9mIHRoZSBvYmplY3QuXG4gICAgICogQHBhcmFtIHRhcmdldCAtIFRoZSBwb3NpdGlvbiBtZWFudCB0byBiZSBhaW1lZCBhdC5cbiAgICAgKiBAcGFyYW0gdXAgLSBBIHZlY3RvciBwb2ludGluZyB1cC5cbiAgICAgKiBAcGFyYW0gZHN0IC0gbWF0cml4IHRvIGhvbGQgcmVzdWx0LiBJZiBub3QgcGFzc2VkIGEgbmV3IG9uZSBpcyBjcmVhdGVkLlxuICAgICAqIEByZXR1cm5zIFRoZSBsb29rLWF0IG1hdHJpeC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBsb29rQXQoZXllLCB0YXJnZXQsIHVwLCBkc3QpIHtcbiAgICAgICAgY29uc3QgbmV3RHN0ID0gKGRzdCA/PyBuZXcgQ3RvcigxNikpO1xuICAgICAgICB2ZWMzLm5vcm1hbGl6ZSh2ZWMzLnN1YnRyYWN0KGV5ZSwgdGFyZ2V0LCB6QXhpcyksIHpBeGlzKTtcbiAgICAgICAgdmVjMy5ub3JtYWxpemUodmVjMy5jcm9zcyh1cCwgekF4aXMsIHhBeGlzKSwgeEF4aXMpO1xuICAgICAgICB2ZWMzLm5vcm1hbGl6ZSh2ZWMzLmNyb3NzKHpBeGlzLCB4QXhpcywgeUF4aXMpLCB5QXhpcyk7XG4gICAgICAgIG5ld0RzdFswXSA9IHhBeGlzWzBdO1xuICAgICAgICBuZXdEc3RbMV0gPSB5QXhpc1swXTtcbiAgICAgICAgbmV3RHN0WzJdID0gekF4aXNbMF07XG4gICAgICAgIG5ld0RzdFszXSA9IDA7XG4gICAgICAgIG5ld0RzdFs0XSA9IHhBeGlzWzFdO1xuICAgICAgICBuZXdEc3RbNV0gPSB5QXhpc1sxXTtcbiAgICAgICAgbmV3RHN0WzZdID0gekF4aXNbMV07XG4gICAgICAgIG5ld0RzdFs3XSA9IDA7XG4gICAgICAgIG5ld0RzdFs4XSA9IHhBeGlzWzJdO1xuICAgICAgICBuZXdEc3RbOV0gPSB5QXhpc1syXTtcbiAgICAgICAgbmV3RHN0WzEwXSA9IHpBeGlzWzJdO1xuICAgICAgICBuZXdEc3RbMTFdID0gMDtcbiAgICAgICAgbmV3RHN0WzEyXSA9IC0oeEF4aXNbMF0gKiBleWVbMF0gKyB4QXhpc1sxXSAqIGV5ZVsxXSArIHhBeGlzWzJdICogZXllWzJdKTtcbiAgICAgICAgbmV3RHN0WzEzXSA9IC0oeUF4aXNbMF0gKiBleWVbMF0gKyB5QXhpc1sxXSAqIGV5ZVsxXSArIHlBeGlzWzJdICogZXllWzJdKTtcbiAgICAgICAgbmV3RHN0WzE0XSA9IC0oekF4aXNbMF0gKiBleWVbMF0gKyB6QXhpc1sxXSAqIGV5ZVsxXSArIHpBeGlzWzJdICogZXllWzJdKTtcbiAgICAgICAgbmV3RHN0WzE1XSA9IDE7XG4gICAgICAgIHJldHVybiBuZXdEc3Q7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSA0LWJ5LTQgbWF0cml4IHdoaWNoIHRyYW5zbGF0ZXMgYnkgdGhlIGdpdmVuIHZlY3RvciB2LlxuICAgICAqIEBwYXJhbSB2IC0gVGhlIHZlY3RvciBieVxuICAgICAqICAgICB3aGljaCB0byB0cmFuc2xhdGUuXG4gICAgICogQHBhcmFtIGRzdCAtIG1hdHJpeCB0byBob2xkIHJlc3VsdC4gSWYgbm90IHBhc3NlZCBhIG5ldyBvbmUgaXMgY3JlYXRlZC5cbiAgICAgKiBAcmV0dXJucyBUaGUgdHJhbnNsYXRpb24gbWF0cml4LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRyYW5zbGF0aW9uKHYsIGRzdCkge1xuICAgICAgICBjb25zdCBuZXdEc3QgPSAoZHN0ID8/IG5ldyBDdG9yKDE2KSk7XG4gICAgICAgIG5ld0RzdFswXSA9IDE7XG4gICAgICAgIG5ld0RzdFsxXSA9IDA7XG4gICAgICAgIG5ld0RzdFsyXSA9IDA7XG4gICAgICAgIG5ld0RzdFszXSA9IDA7XG4gICAgICAgIG5ld0RzdFs0XSA9IDA7XG4gICAgICAgIG5ld0RzdFs1XSA9IDE7XG4gICAgICAgIG5ld0RzdFs2XSA9IDA7XG4gICAgICAgIG5ld0RzdFs3XSA9IDA7XG4gICAgICAgIG5ld0RzdFs4XSA9IDA7XG4gICAgICAgIG5ld0RzdFs5XSA9IDA7XG4gICAgICAgIG5ld0RzdFsxMF0gPSAxO1xuICAgICAgICBuZXdEc3RbMTFdID0gMDtcbiAgICAgICAgbmV3RHN0WzEyXSA9IHZbMF07XG4gICAgICAgIG5ld0RzdFsxM10gPSB2WzFdO1xuICAgICAgICBuZXdEc3RbMTRdID0gdlsyXTtcbiAgICAgICAgbmV3RHN0WzE1XSA9IDE7XG4gICAgICAgIHJldHVybiBuZXdEc3Q7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRyYW5zbGF0ZXMgdGhlIGdpdmVuIDQtYnktNCBtYXRyaXggYnkgdGhlIGdpdmVuIHZlY3RvciB2LlxuICAgICAqIEBwYXJhbSBtIC0gVGhlIG1hdHJpeC5cbiAgICAgKiBAcGFyYW0gdiAtIFRoZSB2ZWN0b3IgYnlcbiAgICAgKiAgICAgd2hpY2ggdG8gdHJhbnNsYXRlLlxuICAgICAqIEBwYXJhbSBkc3QgLSBtYXRyaXggdG8gaG9sZCByZXN1bHQuIElmIG5vdCBwYXNzZWQgYSBuZXcgb25lIGlzIGNyZWF0ZWQuXG4gICAgICogQHJldHVybnMgVGhlIHRyYW5zbGF0ZWQgbWF0cml4LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRyYW5zbGF0ZShtLCB2LCBkc3QpIHtcbiAgICAgICAgY29uc3QgbmV3RHN0ID0gKGRzdCA/PyBuZXcgQ3RvcigxNikpO1xuICAgICAgICBjb25zdCB2MCA9IHZbMF07XG4gICAgICAgIGNvbnN0IHYxID0gdlsxXTtcbiAgICAgICAgY29uc3QgdjIgPSB2WzJdO1xuICAgICAgICBjb25zdCBtMDAgPSBtWzBdO1xuICAgICAgICBjb25zdCBtMDEgPSBtWzFdO1xuICAgICAgICBjb25zdCBtMDIgPSBtWzJdO1xuICAgICAgICBjb25zdCBtMDMgPSBtWzNdO1xuICAgICAgICBjb25zdCBtMTAgPSBtWzEgKiA0ICsgMF07XG4gICAgICAgIGNvbnN0IG0xMSA9IG1bMSAqIDQgKyAxXTtcbiAgICAgICAgY29uc3QgbTEyID0gbVsxICogNCArIDJdO1xuICAgICAgICBjb25zdCBtMTMgPSBtWzEgKiA0ICsgM107XG4gICAgICAgIGNvbnN0IG0yMCA9IG1bMiAqIDQgKyAwXTtcbiAgICAgICAgY29uc3QgbTIxID0gbVsyICogNCArIDFdO1xuICAgICAgICBjb25zdCBtMjIgPSBtWzIgKiA0ICsgMl07XG4gICAgICAgIGNvbnN0IG0yMyA9IG1bMiAqIDQgKyAzXTtcbiAgICAgICAgY29uc3QgbTMwID0gbVszICogNCArIDBdO1xuICAgICAgICBjb25zdCBtMzEgPSBtWzMgKiA0ICsgMV07XG4gICAgICAgIGNvbnN0IG0zMiA9IG1bMyAqIDQgKyAyXTtcbiAgICAgICAgY29uc3QgbTMzID0gbVszICogNCArIDNdO1xuICAgICAgICBpZiAobSAhPT0gbmV3RHN0KSB7XG4gICAgICAgICAgICBuZXdEc3RbMF0gPSBtMDA7XG4gICAgICAgICAgICBuZXdEc3RbMV0gPSBtMDE7XG4gICAgICAgICAgICBuZXdEc3RbMl0gPSBtMDI7XG4gICAgICAgICAgICBuZXdEc3RbM10gPSBtMDM7XG4gICAgICAgICAgICBuZXdEc3RbNF0gPSBtMTA7XG4gICAgICAgICAgICBuZXdEc3RbNV0gPSBtMTE7XG4gICAgICAgICAgICBuZXdEc3RbNl0gPSBtMTI7XG4gICAgICAgICAgICBuZXdEc3RbN10gPSBtMTM7XG4gICAgICAgICAgICBuZXdEc3RbOF0gPSBtMjA7XG4gICAgICAgICAgICBuZXdEc3RbOV0gPSBtMjE7XG4gICAgICAgICAgICBuZXdEc3RbMTBdID0gbTIyO1xuICAgICAgICAgICAgbmV3RHN0WzExXSA9IG0yMztcbiAgICAgICAgfVxuICAgICAgICBuZXdEc3RbMTJdID0gbTAwICogdjAgKyBtMTAgKiB2MSArIG0yMCAqIHYyICsgbTMwO1xuICAgICAgICBuZXdEc3RbMTNdID0gbTAxICogdjAgKyBtMTEgKiB2MSArIG0yMSAqIHYyICsgbTMxO1xuICAgICAgICBuZXdEc3RbMTRdID0gbTAyICogdjAgKyBtMTIgKiB2MSArIG0yMiAqIHYyICsgbTMyO1xuICAgICAgICBuZXdEc3RbMTVdID0gbTAzICogdjAgKyBtMTMgKiB2MSArIG0yMyAqIHYyICsgbTMzO1xuICAgICAgICByZXR1cm4gbmV3RHN0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgNC1ieS00IG1hdHJpeCB3aGljaCByb3RhdGVzIGFyb3VuZCB0aGUgeC1heGlzIGJ5IHRoZSBnaXZlbiBhbmdsZS5cbiAgICAgKiBAcGFyYW0gYW5nbGVJblJhZGlhbnMgLSBUaGUgYW5nbGUgYnkgd2hpY2ggdG8gcm90YXRlIChpbiByYWRpYW5zKS5cbiAgICAgKiBAcGFyYW0gZHN0IC0gbWF0cml4IHRvIGhvbGQgcmVzdWx0LiBJZiBub3QgcGFzc2VkIGEgbmV3IG9uZSBpcyBjcmVhdGVkLlxuICAgICAqIEByZXR1cm5zIFRoZSByb3RhdGlvbiBtYXRyaXguXG4gICAgICovXG4gICAgZnVuY3Rpb24gcm90YXRpb25YKGFuZ2xlSW5SYWRpYW5zLCBkc3QpIHtcbiAgICAgICAgY29uc3QgbmV3RHN0ID0gKGRzdCA/PyBuZXcgQ3RvcigxNikpO1xuICAgICAgICBjb25zdCBjID0gTWF0aC5jb3MoYW5nbGVJblJhZGlhbnMpO1xuICAgICAgICBjb25zdCBzID0gTWF0aC5zaW4oYW5nbGVJblJhZGlhbnMpO1xuICAgICAgICBuZXdEc3RbMF0gPSAxO1xuICAgICAgICBuZXdEc3RbMV0gPSAwO1xuICAgICAgICBuZXdEc3RbMl0gPSAwO1xuICAgICAgICBuZXdEc3RbM10gPSAwO1xuICAgICAgICBuZXdEc3RbNF0gPSAwO1xuICAgICAgICBuZXdEc3RbNV0gPSBjO1xuICAgICAgICBuZXdEc3RbNl0gPSBzO1xuICAgICAgICBuZXdEc3RbN10gPSAwO1xuICAgICAgICBuZXdEc3RbOF0gPSAwO1xuICAgICAgICBuZXdEc3RbOV0gPSAtcztcbiAgICAgICAgbmV3RHN0WzEwXSA9IGM7XG4gICAgICAgIG5ld0RzdFsxMV0gPSAwO1xuICAgICAgICBuZXdEc3RbMTJdID0gMDtcbiAgICAgICAgbmV3RHN0WzEzXSA9IDA7XG4gICAgICAgIG5ld0RzdFsxNF0gPSAwO1xuICAgICAgICBuZXdEc3RbMTVdID0gMTtcbiAgICAgICAgcmV0dXJuIG5ld0RzdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUm90YXRlcyB0aGUgZ2l2ZW4gNC1ieS00IG1hdHJpeCBhcm91bmQgdGhlIHgtYXhpcyBieSB0aGUgZ2l2ZW5cbiAgICAgKiBhbmdsZS5cbiAgICAgKiBAcGFyYW0gbSAtIFRoZSBtYXRyaXguXG4gICAgICogQHBhcmFtIGFuZ2xlSW5SYWRpYW5zIC0gVGhlIGFuZ2xlIGJ5IHdoaWNoIHRvIHJvdGF0ZSAoaW4gcmFkaWFucykuXG4gICAgICogQHBhcmFtIGRzdCAtIG1hdHJpeCB0byBob2xkIHJlc3VsdC4gSWYgbm90IHBhc3NlZCBhIG5ldyBvbmUgaXMgY3JlYXRlZC5cbiAgICAgKiBAcmV0dXJucyBUaGUgcm90YXRlZCBtYXRyaXguXG4gICAgICovXG4gICAgZnVuY3Rpb24gcm90YXRlWChtLCBhbmdsZUluUmFkaWFucywgZHN0KSB7XG4gICAgICAgIGNvbnN0IG5ld0RzdCA9IChkc3QgPz8gbmV3IEN0b3IoMTYpKTtcbiAgICAgICAgY29uc3QgbTEwID0gbVs0XTtcbiAgICAgICAgY29uc3QgbTExID0gbVs1XTtcbiAgICAgICAgY29uc3QgbTEyID0gbVs2XTtcbiAgICAgICAgY29uc3QgbTEzID0gbVs3XTtcbiAgICAgICAgY29uc3QgbTIwID0gbVs4XTtcbiAgICAgICAgY29uc3QgbTIxID0gbVs5XTtcbiAgICAgICAgY29uc3QgbTIyID0gbVsxMF07XG4gICAgICAgIGNvbnN0IG0yMyA9IG1bMTFdO1xuICAgICAgICBjb25zdCBjID0gTWF0aC5jb3MoYW5nbGVJblJhZGlhbnMpO1xuICAgICAgICBjb25zdCBzID0gTWF0aC5zaW4oYW5nbGVJblJhZGlhbnMpO1xuICAgICAgICBuZXdEc3RbNF0gPSBjICogbTEwICsgcyAqIG0yMDtcbiAgICAgICAgbmV3RHN0WzVdID0gYyAqIG0xMSArIHMgKiBtMjE7XG4gICAgICAgIG5ld0RzdFs2XSA9IGMgKiBtMTIgKyBzICogbTIyO1xuICAgICAgICBuZXdEc3RbN10gPSBjICogbTEzICsgcyAqIG0yMztcbiAgICAgICAgbmV3RHN0WzhdID0gYyAqIG0yMCAtIHMgKiBtMTA7XG4gICAgICAgIG5ld0RzdFs5XSA9IGMgKiBtMjEgLSBzICogbTExO1xuICAgICAgICBuZXdEc3RbMTBdID0gYyAqIG0yMiAtIHMgKiBtMTI7XG4gICAgICAgIG5ld0RzdFsxMV0gPSBjICogbTIzIC0gcyAqIG0xMztcbiAgICAgICAgaWYgKG0gIT09IG5ld0RzdCkge1xuICAgICAgICAgICAgbmV3RHN0WzBdID0gbVswXTtcbiAgICAgICAgICAgIG5ld0RzdFsxXSA9IG1bMV07XG4gICAgICAgICAgICBuZXdEc3RbMl0gPSBtWzJdO1xuICAgICAgICAgICAgbmV3RHN0WzNdID0gbVszXTtcbiAgICAgICAgICAgIG5ld0RzdFsxMl0gPSBtWzEyXTtcbiAgICAgICAgICAgIG5ld0RzdFsxM10gPSBtWzEzXTtcbiAgICAgICAgICAgIG5ld0RzdFsxNF0gPSBtWzE0XTtcbiAgICAgICAgICAgIG5ld0RzdFsxNV0gPSBtWzE1XTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3RHN0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgNC1ieS00IG1hdHJpeCB3aGljaCByb3RhdGVzIGFyb3VuZCB0aGUgeS1heGlzIGJ5IHRoZSBnaXZlbiBhbmdsZS5cbiAgICAgKiBAcGFyYW0gYW5nbGVJblJhZGlhbnMgLSBUaGUgYW5nbGUgYnkgd2hpY2ggdG8gcm90YXRlIChpbiByYWRpYW5zKS5cbiAgICAgKiBAcGFyYW0gZHN0IC0gbWF0cml4IHRvIGhvbGQgcmVzdWx0LiBJZiBub3QgcGFzc2VkIGEgbmV3IG9uZSBpcyBjcmVhdGVkLlxuICAgICAqIEByZXR1cm5zIFRoZSByb3RhdGlvbiBtYXRyaXguXG4gICAgICovXG4gICAgZnVuY3Rpb24gcm90YXRpb25ZKGFuZ2xlSW5SYWRpYW5zLCBkc3QpIHtcbiAgICAgICAgY29uc3QgbmV3RHN0ID0gKGRzdCA/PyBuZXcgQ3RvcigxNikpO1xuICAgICAgICBjb25zdCBjID0gTWF0aC5jb3MoYW5nbGVJblJhZGlhbnMpO1xuICAgICAgICBjb25zdCBzID0gTWF0aC5zaW4oYW5nbGVJblJhZGlhbnMpO1xuICAgICAgICBuZXdEc3RbMF0gPSBjO1xuICAgICAgICBuZXdEc3RbMV0gPSAwO1xuICAgICAgICBuZXdEc3RbMl0gPSAtcztcbiAgICAgICAgbmV3RHN0WzNdID0gMDtcbiAgICAgICAgbmV3RHN0WzRdID0gMDtcbiAgICAgICAgbmV3RHN0WzVdID0gMTtcbiAgICAgICAgbmV3RHN0WzZdID0gMDtcbiAgICAgICAgbmV3RHN0WzddID0gMDtcbiAgICAgICAgbmV3RHN0WzhdID0gcztcbiAgICAgICAgbmV3RHN0WzldID0gMDtcbiAgICAgICAgbmV3RHN0WzEwXSA9IGM7XG4gICAgICAgIG5ld0RzdFsxMV0gPSAwO1xuICAgICAgICBuZXdEc3RbMTJdID0gMDtcbiAgICAgICAgbmV3RHN0WzEzXSA9IDA7XG4gICAgICAgIG5ld0RzdFsxNF0gPSAwO1xuICAgICAgICBuZXdEc3RbMTVdID0gMTtcbiAgICAgICAgcmV0dXJuIG5ld0RzdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUm90YXRlcyB0aGUgZ2l2ZW4gNC1ieS00IG1hdHJpeCBhcm91bmQgdGhlIHktYXhpcyBieSB0aGUgZ2l2ZW5cbiAgICAgKiBhbmdsZS5cbiAgICAgKiBAcGFyYW0gbSAtIFRoZSBtYXRyaXguXG4gICAgICogQHBhcmFtIGFuZ2xlSW5SYWRpYW5zIC0gVGhlIGFuZ2xlIGJ5IHdoaWNoIHRvIHJvdGF0ZSAoaW4gcmFkaWFucykuXG4gICAgICogQHBhcmFtIGRzdCAtIG1hdHJpeCB0byBob2xkIHJlc3VsdC4gSWYgbm90IHBhc3NlZCBhIG5ldyBvbmUgaXMgY3JlYXRlZC5cbiAgICAgKiBAcmV0dXJucyBUaGUgcm90YXRlZCBtYXRyaXguXG4gICAgICovXG4gICAgZnVuY3Rpb24gcm90YXRlWShtLCBhbmdsZUluUmFkaWFucywgZHN0KSB7XG4gICAgICAgIGNvbnN0IG5ld0RzdCA9IChkc3QgPz8gbmV3IEN0b3IoMTYpKTtcbiAgICAgICAgY29uc3QgbTAwID0gbVswICogNCArIDBdO1xuICAgICAgICBjb25zdCBtMDEgPSBtWzAgKiA0ICsgMV07XG4gICAgICAgIGNvbnN0IG0wMiA9IG1bMCAqIDQgKyAyXTtcbiAgICAgICAgY29uc3QgbTAzID0gbVswICogNCArIDNdO1xuICAgICAgICBjb25zdCBtMjAgPSBtWzIgKiA0ICsgMF07XG4gICAgICAgIGNvbnN0IG0yMSA9IG1bMiAqIDQgKyAxXTtcbiAgICAgICAgY29uc3QgbTIyID0gbVsyICogNCArIDJdO1xuICAgICAgICBjb25zdCBtMjMgPSBtWzIgKiA0ICsgM107XG4gICAgICAgIGNvbnN0IGMgPSBNYXRoLmNvcyhhbmdsZUluUmFkaWFucyk7XG4gICAgICAgIGNvbnN0IHMgPSBNYXRoLnNpbihhbmdsZUluUmFkaWFucyk7XG4gICAgICAgIG5ld0RzdFswXSA9IGMgKiBtMDAgLSBzICogbTIwO1xuICAgICAgICBuZXdEc3RbMV0gPSBjICogbTAxIC0gcyAqIG0yMTtcbiAgICAgICAgbmV3RHN0WzJdID0gYyAqIG0wMiAtIHMgKiBtMjI7XG4gICAgICAgIG5ld0RzdFszXSA9IGMgKiBtMDMgLSBzICogbTIzO1xuICAgICAgICBuZXdEc3RbOF0gPSBjICogbTIwICsgcyAqIG0wMDtcbiAgICAgICAgbmV3RHN0WzldID0gYyAqIG0yMSArIHMgKiBtMDE7XG4gICAgICAgIG5ld0RzdFsxMF0gPSBjICogbTIyICsgcyAqIG0wMjtcbiAgICAgICAgbmV3RHN0WzExXSA9IGMgKiBtMjMgKyBzICogbTAzO1xuICAgICAgICBpZiAobSAhPT0gbmV3RHN0KSB7XG4gICAgICAgICAgICBuZXdEc3RbNF0gPSBtWzRdO1xuICAgICAgICAgICAgbmV3RHN0WzVdID0gbVs1XTtcbiAgICAgICAgICAgIG5ld0RzdFs2XSA9IG1bNl07XG4gICAgICAgICAgICBuZXdEc3RbN10gPSBtWzddO1xuICAgICAgICAgICAgbmV3RHN0WzEyXSA9IG1bMTJdO1xuICAgICAgICAgICAgbmV3RHN0WzEzXSA9IG1bMTNdO1xuICAgICAgICAgICAgbmV3RHN0WzE0XSA9IG1bMTRdO1xuICAgICAgICAgICAgbmV3RHN0WzE1XSA9IG1bMTVdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXdEc3Q7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSA0LWJ5LTQgbWF0cml4IHdoaWNoIHJvdGF0ZXMgYXJvdW5kIHRoZSB6LWF4aXMgYnkgdGhlIGdpdmVuIGFuZ2xlLlxuICAgICAqIEBwYXJhbSBhbmdsZUluUmFkaWFucyAtIFRoZSBhbmdsZSBieSB3aGljaCB0byByb3RhdGUgKGluIHJhZGlhbnMpLlxuICAgICAqIEBwYXJhbSBkc3QgLSBtYXRyaXggdG8gaG9sZCByZXN1bHQuIElmIG5vdCBwYXNzZWQgYSBuZXcgb25lIGlzIGNyZWF0ZWQuXG4gICAgICogQHJldHVybnMgVGhlIHJvdGF0aW9uIG1hdHJpeC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiByb3RhdGlvblooYW5nbGVJblJhZGlhbnMsIGRzdCkge1xuICAgICAgICBjb25zdCBuZXdEc3QgPSAoZHN0ID8/IG5ldyBDdG9yKDE2KSk7XG4gICAgICAgIGNvbnN0IGMgPSBNYXRoLmNvcyhhbmdsZUluUmFkaWFucyk7XG4gICAgICAgIGNvbnN0IHMgPSBNYXRoLnNpbihhbmdsZUluUmFkaWFucyk7XG4gICAgICAgIG5ld0RzdFswXSA9IGM7XG4gICAgICAgIG5ld0RzdFsxXSA9IHM7XG4gICAgICAgIG5ld0RzdFsyXSA9IDA7XG4gICAgICAgIG5ld0RzdFszXSA9IDA7XG4gICAgICAgIG5ld0RzdFs0XSA9IC1zO1xuICAgICAgICBuZXdEc3RbNV0gPSBjO1xuICAgICAgICBuZXdEc3RbNl0gPSAwO1xuICAgICAgICBuZXdEc3RbN10gPSAwO1xuICAgICAgICBuZXdEc3RbOF0gPSAwO1xuICAgICAgICBuZXdEc3RbOV0gPSAwO1xuICAgICAgICBuZXdEc3RbMTBdID0gMTtcbiAgICAgICAgbmV3RHN0WzExXSA9IDA7XG4gICAgICAgIG5ld0RzdFsxMl0gPSAwO1xuICAgICAgICBuZXdEc3RbMTNdID0gMDtcbiAgICAgICAgbmV3RHN0WzE0XSA9IDA7XG4gICAgICAgIG5ld0RzdFsxNV0gPSAxO1xuICAgICAgICByZXR1cm4gbmV3RHN0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSb3RhdGVzIHRoZSBnaXZlbiA0LWJ5LTQgbWF0cml4IGFyb3VuZCB0aGUgei1heGlzIGJ5IHRoZSBnaXZlblxuICAgICAqIGFuZ2xlLlxuICAgICAqIEBwYXJhbSBtIC0gVGhlIG1hdHJpeC5cbiAgICAgKiBAcGFyYW0gYW5nbGVJblJhZGlhbnMgLSBUaGUgYW5nbGUgYnkgd2hpY2ggdG8gcm90YXRlIChpbiByYWRpYW5zKS5cbiAgICAgKiBAcGFyYW0gZHN0IC0gbWF0cml4IHRvIGhvbGQgcmVzdWx0LiBJZiBub3QgcGFzc2VkIGEgbmV3IG9uZSBpcyBjcmVhdGVkLlxuICAgICAqIEByZXR1cm5zIFRoZSByb3RhdGVkIG1hdHJpeC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiByb3RhdGVaKG0sIGFuZ2xlSW5SYWRpYW5zLCBkc3QpIHtcbiAgICAgICAgY29uc3QgbmV3RHN0ID0gKGRzdCA/PyBuZXcgQ3RvcigxNikpO1xuICAgICAgICBjb25zdCBtMDAgPSBtWzAgKiA0ICsgMF07XG4gICAgICAgIGNvbnN0IG0wMSA9IG1bMCAqIDQgKyAxXTtcbiAgICAgICAgY29uc3QgbTAyID0gbVswICogNCArIDJdO1xuICAgICAgICBjb25zdCBtMDMgPSBtWzAgKiA0ICsgM107XG4gICAgICAgIGNvbnN0IG0xMCA9IG1bMSAqIDQgKyAwXTtcbiAgICAgICAgY29uc3QgbTExID0gbVsxICogNCArIDFdO1xuICAgICAgICBjb25zdCBtMTIgPSBtWzEgKiA0ICsgMl07XG4gICAgICAgIGNvbnN0IG0xMyA9IG1bMSAqIDQgKyAzXTtcbiAgICAgICAgY29uc3QgYyA9IE1hdGguY29zKGFuZ2xlSW5SYWRpYW5zKTtcbiAgICAgICAgY29uc3QgcyA9IE1hdGguc2luKGFuZ2xlSW5SYWRpYW5zKTtcbiAgICAgICAgbmV3RHN0WzBdID0gYyAqIG0wMCArIHMgKiBtMTA7XG4gICAgICAgIG5ld0RzdFsxXSA9IGMgKiBtMDEgKyBzICogbTExO1xuICAgICAgICBuZXdEc3RbMl0gPSBjICogbTAyICsgcyAqIG0xMjtcbiAgICAgICAgbmV3RHN0WzNdID0gYyAqIG0wMyArIHMgKiBtMTM7XG4gICAgICAgIG5ld0RzdFs0XSA9IGMgKiBtMTAgLSBzICogbTAwO1xuICAgICAgICBuZXdEc3RbNV0gPSBjICogbTExIC0gcyAqIG0wMTtcbiAgICAgICAgbmV3RHN0WzZdID0gYyAqIG0xMiAtIHMgKiBtMDI7XG4gICAgICAgIG5ld0RzdFs3XSA9IGMgKiBtMTMgLSBzICogbTAzO1xuICAgICAgICBpZiAobSAhPT0gbmV3RHN0KSB7XG4gICAgICAgICAgICBuZXdEc3RbOF0gPSBtWzhdO1xuICAgICAgICAgICAgbmV3RHN0WzldID0gbVs5XTtcbiAgICAgICAgICAgIG5ld0RzdFsxMF0gPSBtWzEwXTtcbiAgICAgICAgICAgIG5ld0RzdFsxMV0gPSBtWzExXTtcbiAgICAgICAgICAgIG5ld0RzdFsxMl0gPSBtWzEyXTtcbiAgICAgICAgICAgIG5ld0RzdFsxM10gPSBtWzEzXTtcbiAgICAgICAgICAgIG5ld0RzdFsxNF0gPSBtWzE0XTtcbiAgICAgICAgICAgIG5ld0RzdFsxNV0gPSBtWzE1XTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3RHN0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgNC1ieS00IG1hdHJpeCB3aGljaCByb3RhdGVzIGFyb3VuZCB0aGUgZ2l2ZW4gYXhpcyBieSB0aGUgZ2l2ZW5cbiAgICAgKiBhbmdsZS5cbiAgICAgKiBAcGFyYW0gYXhpcyAtIFRoZSBheGlzXG4gICAgICogICAgIGFib3V0IHdoaWNoIHRvIHJvdGF0ZS5cbiAgICAgKiBAcGFyYW0gYW5nbGVJblJhZGlhbnMgLSBUaGUgYW5nbGUgYnkgd2hpY2ggdG8gcm90YXRlIChpbiByYWRpYW5zKS5cbiAgICAgKiBAcGFyYW0gZHN0IC0gbWF0cml4IHRvIGhvbGQgcmVzdWx0LiBJZiBub3QgcGFzc2VkIGEgbmV3IG9uZSBpcyBjcmVhdGVkLlxuICAgICAqIEByZXR1cm5zIEEgbWF0cml4IHdoaWNoIHJvdGF0ZXMgYW5nbGUgcmFkaWFuc1xuICAgICAqICAgICBhcm91bmQgdGhlIGF4aXMuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYXhpc1JvdGF0aW9uKGF4aXMsIGFuZ2xlSW5SYWRpYW5zLCBkc3QpIHtcbiAgICAgICAgY29uc3QgbmV3RHN0ID0gKGRzdCA/PyBuZXcgQ3RvcigxNikpO1xuICAgICAgICBsZXQgeCA9IGF4aXNbMF07XG4gICAgICAgIGxldCB5ID0gYXhpc1sxXTtcbiAgICAgICAgbGV0IHogPSBheGlzWzJdO1xuICAgICAgICBjb25zdCBuID0gTWF0aC5zcXJ0KHggKiB4ICsgeSAqIHkgKyB6ICogeik7XG4gICAgICAgIHggLz0gbjtcbiAgICAgICAgeSAvPSBuO1xuICAgICAgICB6IC89IG47XG4gICAgICAgIGNvbnN0IHh4ID0geCAqIHg7XG4gICAgICAgIGNvbnN0IHl5ID0geSAqIHk7XG4gICAgICAgIGNvbnN0IHp6ID0geiAqIHo7XG4gICAgICAgIGNvbnN0IGMgPSBNYXRoLmNvcyhhbmdsZUluUmFkaWFucyk7XG4gICAgICAgIGNvbnN0IHMgPSBNYXRoLnNpbihhbmdsZUluUmFkaWFucyk7XG4gICAgICAgIGNvbnN0IG9uZU1pbnVzQ29zaW5lID0gMSAtIGM7XG4gICAgICAgIG5ld0RzdFswXSA9IHh4ICsgKDEgLSB4eCkgKiBjO1xuICAgICAgICBuZXdEc3RbMV0gPSB4ICogeSAqIG9uZU1pbnVzQ29zaW5lICsgeiAqIHM7XG4gICAgICAgIG5ld0RzdFsyXSA9IHggKiB6ICogb25lTWludXNDb3NpbmUgLSB5ICogcztcbiAgICAgICAgbmV3RHN0WzNdID0gMDtcbiAgICAgICAgbmV3RHN0WzRdID0geCAqIHkgKiBvbmVNaW51c0Nvc2luZSAtIHogKiBzO1xuICAgICAgICBuZXdEc3RbNV0gPSB5eSArICgxIC0geXkpICogYztcbiAgICAgICAgbmV3RHN0WzZdID0geSAqIHogKiBvbmVNaW51c0Nvc2luZSArIHggKiBzO1xuICAgICAgICBuZXdEc3RbN10gPSAwO1xuICAgICAgICBuZXdEc3RbOF0gPSB4ICogeiAqIG9uZU1pbnVzQ29zaW5lICsgeSAqIHM7XG4gICAgICAgIG5ld0RzdFs5XSA9IHkgKiB6ICogb25lTWludXNDb3NpbmUgLSB4ICogcztcbiAgICAgICAgbmV3RHN0WzEwXSA9IHp6ICsgKDEgLSB6eikgKiBjO1xuICAgICAgICBuZXdEc3RbMTFdID0gMDtcbiAgICAgICAgbmV3RHN0WzEyXSA9IDA7XG4gICAgICAgIG5ld0RzdFsxM10gPSAwO1xuICAgICAgICBuZXdEc3RbMTRdID0gMDtcbiAgICAgICAgbmV3RHN0WzE1XSA9IDE7XG4gICAgICAgIHJldHVybiBuZXdEc3Q7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSA0LWJ5LTQgbWF0cml4IHdoaWNoIHJvdGF0ZXMgYXJvdW5kIHRoZSBnaXZlbiBheGlzIGJ5IHRoZSBnaXZlblxuICAgICAqIGFuZ2xlLiAoc2FtZSBhcyBheGlzUm90YXRpb24pXG4gICAgICogQHBhcmFtIGF4aXMgLSBUaGUgYXhpc1xuICAgICAqICAgICBhYm91dCB3aGljaCB0byByb3RhdGUuXG4gICAgICogQHBhcmFtIGFuZ2xlSW5SYWRpYW5zIC0gVGhlIGFuZ2xlIGJ5IHdoaWNoIHRvIHJvdGF0ZSAoaW4gcmFkaWFucykuXG4gICAgICogQHBhcmFtIGRzdCAtIG1hdHJpeCB0byBob2xkIHJlc3VsdC4gSWYgbm90IHBhc3NlZCBhIG5ldyBvbmUgaXMgY3JlYXRlZC5cbiAgICAgKiBAcmV0dXJucyBBIG1hdHJpeCB3aGljaCByb3RhdGVzIGFuZ2xlIHJhZGlhbnNcbiAgICAgKiAgICAgYXJvdW5kIHRoZSBheGlzLlxuICAgICAqL1xuICAgIGNvbnN0IHJvdGF0aW9uID0gYXhpc1JvdGF0aW9uO1xuICAgIC8qKlxuICAgICAqIFJvdGF0ZXMgdGhlIGdpdmVuIDQtYnktNCBtYXRyaXggYXJvdW5kIHRoZSBnaXZlbiBheGlzIGJ5IHRoZVxuICAgICAqIGdpdmVuIGFuZ2xlLlxuICAgICAqIEBwYXJhbSBtIC0gVGhlIG1hdHJpeC5cbiAgICAgKiBAcGFyYW0gYXhpcyAtIFRoZSBheGlzXG4gICAgICogICAgIGFib3V0IHdoaWNoIHRvIHJvdGF0ZS5cbiAgICAgKiBAcGFyYW0gYW5nbGVJblJhZGlhbnMgLSBUaGUgYW5nbGUgYnkgd2hpY2ggdG8gcm90YXRlIChpbiByYWRpYW5zKS5cbiAgICAgKiBAcGFyYW0gZHN0IC0gbWF0cml4IHRvIGhvbGQgcmVzdWx0LiBJZiBub3QgcGFzc2VkIGEgbmV3IG9uZSBpcyBjcmVhdGVkLlxuICAgICAqIEByZXR1cm5zIFRoZSByb3RhdGVkIG1hdHJpeC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBheGlzUm90YXRlKG0sIGF4aXMsIGFuZ2xlSW5SYWRpYW5zLCBkc3QpIHtcbiAgICAgICAgY29uc3QgbmV3RHN0ID0gKGRzdCA/PyBuZXcgQ3RvcigxNikpO1xuICAgICAgICBsZXQgeCA9IGF4aXNbMF07XG4gICAgICAgIGxldCB5ID0gYXhpc1sxXTtcbiAgICAgICAgbGV0IHogPSBheGlzWzJdO1xuICAgICAgICBjb25zdCBuID0gTWF0aC5zcXJ0KHggKiB4ICsgeSAqIHkgKyB6ICogeik7XG4gICAgICAgIHggLz0gbjtcbiAgICAgICAgeSAvPSBuO1xuICAgICAgICB6IC89IG47XG4gICAgICAgIGNvbnN0IHh4ID0geCAqIHg7XG4gICAgICAgIGNvbnN0IHl5ID0geSAqIHk7XG4gICAgICAgIGNvbnN0IHp6ID0geiAqIHo7XG4gICAgICAgIGNvbnN0IGMgPSBNYXRoLmNvcyhhbmdsZUluUmFkaWFucyk7XG4gICAgICAgIGNvbnN0IHMgPSBNYXRoLnNpbihhbmdsZUluUmFkaWFucyk7XG4gICAgICAgIGNvbnN0IG9uZU1pbnVzQ29zaW5lID0gMSAtIGM7XG4gICAgICAgIGNvbnN0IHIwMCA9IHh4ICsgKDEgLSB4eCkgKiBjO1xuICAgICAgICBjb25zdCByMDEgPSB4ICogeSAqIG9uZU1pbnVzQ29zaW5lICsgeiAqIHM7XG4gICAgICAgIGNvbnN0IHIwMiA9IHggKiB6ICogb25lTWludXNDb3NpbmUgLSB5ICogcztcbiAgICAgICAgY29uc3QgcjEwID0geCAqIHkgKiBvbmVNaW51c0Nvc2luZSAtIHogKiBzO1xuICAgICAgICBjb25zdCByMTEgPSB5eSArICgxIC0geXkpICogYztcbiAgICAgICAgY29uc3QgcjEyID0geSAqIHogKiBvbmVNaW51c0Nvc2luZSArIHggKiBzO1xuICAgICAgICBjb25zdCByMjAgPSB4ICogeiAqIG9uZU1pbnVzQ29zaW5lICsgeSAqIHM7XG4gICAgICAgIGNvbnN0IHIyMSA9IHkgKiB6ICogb25lTWludXNDb3NpbmUgLSB4ICogcztcbiAgICAgICAgY29uc3QgcjIyID0genogKyAoMSAtIHp6KSAqIGM7XG4gICAgICAgIGNvbnN0IG0wMCA9IG1bMF07XG4gICAgICAgIGNvbnN0IG0wMSA9IG1bMV07XG4gICAgICAgIGNvbnN0IG0wMiA9IG1bMl07XG4gICAgICAgIGNvbnN0IG0wMyA9IG1bM107XG4gICAgICAgIGNvbnN0IG0xMCA9IG1bNF07XG4gICAgICAgIGNvbnN0IG0xMSA9IG1bNV07XG4gICAgICAgIGNvbnN0IG0xMiA9IG1bNl07XG4gICAgICAgIGNvbnN0IG0xMyA9IG1bN107XG4gICAgICAgIGNvbnN0IG0yMCA9IG1bOF07XG4gICAgICAgIGNvbnN0IG0yMSA9IG1bOV07XG4gICAgICAgIGNvbnN0IG0yMiA9IG1bMTBdO1xuICAgICAgICBjb25zdCBtMjMgPSBtWzExXTtcbiAgICAgICAgbmV3RHN0WzBdID0gcjAwICogbTAwICsgcjAxICogbTEwICsgcjAyICogbTIwO1xuICAgICAgICBuZXdEc3RbMV0gPSByMDAgKiBtMDEgKyByMDEgKiBtMTEgKyByMDIgKiBtMjE7XG4gICAgICAgIG5ld0RzdFsyXSA9IHIwMCAqIG0wMiArIHIwMSAqIG0xMiArIHIwMiAqIG0yMjtcbiAgICAgICAgbmV3RHN0WzNdID0gcjAwICogbTAzICsgcjAxICogbTEzICsgcjAyICogbTIzO1xuICAgICAgICBuZXdEc3RbNF0gPSByMTAgKiBtMDAgKyByMTEgKiBtMTAgKyByMTIgKiBtMjA7XG4gICAgICAgIG5ld0RzdFs1XSA9IHIxMCAqIG0wMSArIHIxMSAqIG0xMSArIHIxMiAqIG0yMTtcbiAgICAgICAgbmV3RHN0WzZdID0gcjEwICogbTAyICsgcjExICogbTEyICsgcjEyICogbTIyO1xuICAgICAgICBuZXdEc3RbN10gPSByMTAgKiBtMDMgKyByMTEgKiBtMTMgKyByMTIgKiBtMjM7XG4gICAgICAgIG5ld0RzdFs4XSA9IHIyMCAqIG0wMCArIHIyMSAqIG0xMCArIHIyMiAqIG0yMDtcbiAgICAgICAgbmV3RHN0WzldID0gcjIwICogbTAxICsgcjIxICogbTExICsgcjIyICogbTIxO1xuICAgICAgICBuZXdEc3RbMTBdID0gcjIwICogbTAyICsgcjIxICogbTEyICsgcjIyICogbTIyO1xuICAgICAgICBuZXdEc3RbMTFdID0gcjIwICogbTAzICsgcjIxICogbTEzICsgcjIyICogbTIzO1xuICAgICAgICBpZiAobSAhPT0gbmV3RHN0KSB7XG4gICAgICAgICAgICBuZXdEc3RbMTJdID0gbVsxMl07XG4gICAgICAgICAgICBuZXdEc3RbMTNdID0gbVsxM107XG4gICAgICAgICAgICBuZXdEc3RbMTRdID0gbVsxNF07XG4gICAgICAgICAgICBuZXdEc3RbMTVdID0gbVsxNV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ld0RzdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUm90YXRlcyB0aGUgZ2l2ZW4gNC1ieS00IG1hdHJpeCBhcm91bmQgdGhlIGdpdmVuIGF4aXMgYnkgdGhlXG4gICAgICogZ2l2ZW4gYW5nbGUuIChzYW1lIGFzIHJvdGF0ZSlcbiAgICAgKiBAcGFyYW0gbSAtIFRoZSBtYXRyaXguXG4gICAgICogQHBhcmFtIGF4aXMgLSBUaGUgYXhpc1xuICAgICAqICAgICBhYm91dCB3aGljaCB0byByb3RhdGUuXG4gICAgICogQHBhcmFtIGFuZ2xlSW5SYWRpYW5zIC0gVGhlIGFuZ2xlIGJ5IHdoaWNoIHRvIHJvdGF0ZSAoaW4gcmFkaWFucykuXG4gICAgICogQHBhcmFtIGRzdCAtIG1hdHJpeCB0byBob2xkIHJlc3VsdC4gSWYgbm90IHBhc3NlZCBhIG5ldyBvbmUgaXMgY3JlYXRlZC5cbiAgICAgKiBAcmV0dXJucyBUaGUgcm90YXRlZCBtYXRyaXguXG4gICAgICovXG4gICAgY29uc3Qgcm90YXRlID0gYXhpc1JvdGF0ZTtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgNC1ieS00IG1hdHJpeCB3aGljaCBzY2FsZXMgaW4gZWFjaCBkaW1lbnNpb24gYnkgYW4gYW1vdW50IGdpdmVuIGJ5XG4gICAgICogdGhlIGNvcnJlc3BvbmRpbmcgZW50cnkgaW4gdGhlIGdpdmVuIHZlY3RvcjsgYXNzdW1lcyB0aGUgdmVjdG9yIGhhcyB0aHJlZVxuICAgICAqIGVudHJpZXMuXG4gICAgICogQHBhcmFtIHYgLSBBIHZlY3RvciBvZlxuICAgICAqICAgICB0aHJlZSBlbnRyaWVzIHNwZWNpZnlpbmcgdGhlIGZhY3RvciBieSB3aGljaCB0byBzY2FsZSBpbiBlYWNoIGRpbWVuc2lvbi5cbiAgICAgKiBAcGFyYW0gZHN0IC0gbWF0cml4IHRvIGhvbGQgcmVzdWx0LiBJZiBub3QgcGFzc2VkIGEgbmV3IG9uZSBpcyBjcmVhdGVkLlxuICAgICAqIEByZXR1cm5zIFRoZSBzY2FsaW5nIG1hdHJpeC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzY2FsaW5nKHYsIGRzdCkge1xuICAgICAgICBjb25zdCBuZXdEc3QgPSAoZHN0ID8/IG5ldyBDdG9yKDE2KSk7XG4gICAgICAgIG5ld0RzdFswXSA9IHZbMF07XG4gICAgICAgIG5ld0RzdFsxXSA9IDA7XG4gICAgICAgIG5ld0RzdFsyXSA9IDA7XG4gICAgICAgIG5ld0RzdFszXSA9IDA7XG4gICAgICAgIG5ld0RzdFs0XSA9IDA7XG4gICAgICAgIG5ld0RzdFs1XSA9IHZbMV07XG4gICAgICAgIG5ld0RzdFs2XSA9IDA7XG4gICAgICAgIG5ld0RzdFs3XSA9IDA7XG4gICAgICAgIG5ld0RzdFs4XSA9IDA7XG4gICAgICAgIG5ld0RzdFs5XSA9IDA7XG4gICAgICAgIG5ld0RzdFsxMF0gPSB2WzJdO1xuICAgICAgICBuZXdEc3RbMTFdID0gMDtcbiAgICAgICAgbmV3RHN0WzEyXSA9IDA7XG4gICAgICAgIG5ld0RzdFsxM10gPSAwO1xuICAgICAgICBuZXdEc3RbMTRdID0gMDtcbiAgICAgICAgbmV3RHN0WzE1XSA9IDE7XG4gICAgICAgIHJldHVybiBuZXdEc3Q7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNjYWxlcyB0aGUgZ2l2ZW4gNC1ieS00IG1hdHJpeCBpbiBlYWNoIGRpbWVuc2lvbiBieSBhbiBhbW91bnRcbiAgICAgKiBnaXZlbiBieSB0aGUgY29ycmVzcG9uZGluZyBlbnRyeSBpbiB0aGUgZ2l2ZW4gdmVjdG9yOyBhc3N1bWVzIHRoZSB2ZWN0b3IgaGFzXG4gICAgICogdGhyZWUgZW50cmllcy5cbiAgICAgKiBAcGFyYW0gbSAtIFRoZSBtYXRyaXggdG8gYmUgbW9kaWZpZWQuXG4gICAgICogQHBhcmFtIHYgLSBBIHZlY3RvciBvZiB0aHJlZSBlbnRyaWVzIHNwZWNpZnlpbmcgdGhlXG4gICAgICogICAgIGZhY3RvciBieSB3aGljaCB0byBzY2FsZSBpbiBlYWNoIGRpbWVuc2lvbi5cbiAgICAgKiBAcGFyYW0gZHN0IC0gbWF0cml4IHRvIGhvbGQgcmVzdWx0LiBJZiBub3QgcGFzc2VkIGEgbmV3IG9uZSBpcyBjcmVhdGVkLlxuICAgICAqIEByZXR1cm5zIFRoZSBzY2FsZWQgbWF0cml4LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNjYWxlKG0sIHYsIGRzdCkge1xuICAgICAgICBjb25zdCBuZXdEc3QgPSAoZHN0ID8/IG5ldyBDdG9yKDE2KSk7XG4gICAgICAgIGNvbnN0IHYwID0gdlswXTtcbiAgICAgICAgY29uc3QgdjEgPSB2WzFdO1xuICAgICAgICBjb25zdCB2MiA9IHZbMl07XG4gICAgICAgIG5ld0RzdFswXSA9IHYwICogbVswICogNCArIDBdO1xuICAgICAgICBuZXdEc3RbMV0gPSB2MCAqIG1bMCAqIDQgKyAxXTtcbiAgICAgICAgbmV3RHN0WzJdID0gdjAgKiBtWzAgKiA0ICsgMl07XG4gICAgICAgIG5ld0RzdFszXSA9IHYwICogbVswICogNCArIDNdO1xuICAgICAgICBuZXdEc3RbNF0gPSB2MSAqIG1bMSAqIDQgKyAwXTtcbiAgICAgICAgbmV3RHN0WzVdID0gdjEgKiBtWzEgKiA0ICsgMV07XG4gICAgICAgIG5ld0RzdFs2XSA9IHYxICogbVsxICogNCArIDJdO1xuICAgICAgICBuZXdEc3RbN10gPSB2MSAqIG1bMSAqIDQgKyAzXTtcbiAgICAgICAgbmV3RHN0WzhdID0gdjIgKiBtWzIgKiA0ICsgMF07XG4gICAgICAgIG5ld0RzdFs5XSA9IHYyICogbVsyICogNCArIDFdO1xuICAgICAgICBuZXdEc3RbMTBdID0gdjIgKiBtWzIgKiA0ICsgMl07XG4gICAgICAgIG5ld0RzdFsxMV0gPSB2MiAqIG1bMiAqIDQgKyAzXTtcbiAgICAgICAgaWYgKG0gIT09IG5ld0RzdCkge1xuICAgICAgICAgICAgbmV3RHN0WzEyXSA9IG1bMTJdO1xuICAgICAgICAgICAgbmV3RHN0WzEzXSA9IG1bMTNdO1xuICAgICAgICAgICAgbmV3RHN0WzE0XSA9IG1bMTRdO1xuICAgICAgICAgICAgbmV3RHN0WzE1XSA9IG1bMTVdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXdEc3Q7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSA0LWJ5LTQgbWF0cml4IHdoaWNoIHNjYWxlcyBhIHVuaWZvcm0gYW1vdW50IGluIGVhY2ggZGltZW5zaW9uLlxuICAgICAqIEBwYXJhbSBzIC0gdGhlIGFtb3VudCB0byBzY2FsZVxuICAgICAqIEBwYXJhbSBkc3QgLSBtYXRyaXggdG8gaG9sZCByZXN1bHQuIElmIG5vdCBwYXNzZWQgYSBuZXcgb25lIGlzIGNyZWF0ZWQuXG4gICAgICogQHJldHVybnMgVGhlIHNjYWxpbmcgbWF0cml4LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHVuaWZvcm1TY2FsaW5nKHMsIGRzdCkge1xuICAgICAgICBjb25zdCBuZXdEc3QgPSAoZHN0ID8/IG5ldyBDdG9yKDE2KSk7XG4gICAgICAgIG5ld0RzdFswXSA9IHM7XG4gICAgICAgIG5ld0RzdFsxXSA9IDA7XG4gICAgICAgIG5ld0RzdFsyXSA9IDA7XG4gICAgICAgIG5ld0RzdFszXSA9IDA7XG4gICAgICAgIG5ld0RzdFs0XSA9IDA7XG4gICAgICAgIG5ld0RzdFs1XSA9IHM7XG4gICAgICAgIG5ld0RzdFs2XSA9IDA7XG4gICAgICAgIG5ld0RzdFs3XSA9IDA7XG4gICAgICAgIG5ld0RzdFs4XSA9IDA7XG4gICAgICAgIG5ld0RzdFs5XSA9IDA7XG4gICAgICAgIG5ld0RzdFsxMF0gPSBzO1xuICAgICAgICBuZXdEc3RbMTFdID0gMDtcbiAgICAgICAgbmV3RHN0WzEyXSA9IDA7XG4gICAgICAgIG5ld0RzdFsxM10gPSAwO1xuICAgICAgICBuZXdEc3RbMTRdID0gMDtcbiAgICAgICAgbmV3RHN0WzE1XSA9IDE7XG4gICAgICAgIHJldHVybiBuZXdEc3Q7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNjYWxlcyB0aGUgZ2l2ZW4gNC1ieS00IG1hdHJpeCBpbiBlYWNoIGRpbWVuc2lvbiBieSBhIHVuaWZvcm0gc2NhbGUuXG4gICAgICogQHBhcmFtIG0gLSBUaGUgbWF0cml4IHRvIGJlIG1vZGlmaWVkLlxuICAgICAqIEBwYXJhbSBzIC0gVGhlIGFtb3VudCB0byBzY2FsZS5cbiAgICAgKiBAcGFyYW0gZHN0IC0gbWF0cml4IHRvIGhvbGQgcmVzdWx0LiBJZiBub3QgcGFzc2VkIGEgbmV3IG9uZSBpcyBjcmVhdGVkLlxuICAgICAqIEByZXR1cm5zIFRoZSBzY2FsZWQgbWF0cml4LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHVuaWZvcm1TY2FsZShtLCBzLCBkc3QpIHtcbiAgICAgICAgY29uc3QgbmV3RHN0ID0gKGRzdCA/PyBuZXcgQ3RvcigxNikpO1xuICAgICAgICBuZXdEc3RbMF0gPSBzICogbVswICogNCArIDBdO1xuICAgICAgICBuZXdEc3RbMV0gPSBzICogbVswICogNCArIDFdO1xuICAgICAgICBuZXdEc3RbMl0gPSBzICogbVswICogNCArIDJdO1xuICAgICAgICBuZXdEc3RbM10gPSBzICogbVswICogNCArIDNdO1xuICAgICAgICBuZXdEc3RbNF0gPSBzICogbVsxICogNCArIDBdO1xuICAgICAgICBuZXdEc3RbNV0gPSBzICogbVsxICogNCArIDFdO1xuICAgICAgICBuZXdEc3RbNl0gPSBzICogbVsxICogNCArIDJdO1xuICAgICAgICBuZXdEc3RbN10gPSBzICogbVsxICogNCArIDNdO1xuICAgICAgICBuZXdEc3RbOF0gPSBzICogbVsyICogNCArIDBdO1xuICAgICAgICBuZXdEc3RbOV0gPSBzICogbVsyICogNCArIDFdO1xuICAgICAgICBuZXdEc3RbMTBdID0gcyAqIG1bMiAqIDQgKyAyXTtcbiAgICAgICAgbmV3RHN0WzExXSA9IHMgKiBtWzIgKiA0ICsgM107XG4gICAgICAgIGlmIChtICE9PSBuZXdEc3QpIHtcbiAgICAgICAgICAgIG5ld0RzdFsxMl0gPSBtWzEyXTtcbiAgICAgICAgICAgIG5ld0RzdFsxM10gPSBtWzEzXTtcbiAgICAgICAgICAgIG5ld0RzdFsxNF0gPSBtWzE0XTtcbiAgICAgICAgICAgIG5ld0RzdFsxNV0gPSBtWzE1XTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3RHN0O1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBjcmVhdGUsXG4gICAgICAgIHNldCxcbiAgICAgICAgZnJvbU1hdDMsXG4gICAgICAgIGZyb21RdWF0LFxuICAgICAgICBuZWdhdGUsXG4gICAgICAgIGNvcHksXG4gICAgICAgIGNsb25lLFxuICAgICAgICBlcXVhbHNBcHByb3hpbWF0ZWx5LFxuICAgICAgICBlcXVhbHMsXG4gICAgICAgIGlkZW50aXR5LFxuICAgICAgICB0cmFuc3Bvc2UsXG4gICAgICAgIGludmVyc2UsXG4gICAgICAgIGRldGVybWluYW50LFxuICAgICAgICBpbnZlcnQsXG4gICAgICAgIG11bHRpcGx5LFxuICAgICAgICBtdWwsXG4gICAgICAgIHNldFRyYW5zbGF0aW9uLFxuICAgICAgICBnZXRUcmFuc2xhdGlvbixcbiAgICAgICAgZ2V0QXhpcyxcbiAgICAgICAgc2V0QXhpcyxcbiAgICAgICAgZ2V0U2NhbGluZyxcbiAgICAgICAgcGVyc3BlY3RpdmUsXG4gICAgICAgIHBlcnNwZWN0aXZlUmV2ZXJzZVosXG4gICAgICAgIG9ydGhvLFxuICAgICAgICBmcnVzdHVtLFxuICAgICAgICBmcnVzdHVtUmV2ZXJzZVosXG4gICAgICAgIGFpbSxcbiAgICAgICAgY2FtZXJhQWltLFxuICAgICAgICBsb29rQXQsXG4gICAgICAgIHRyYW5zbGF0aW9uLFxuICAgICAgICB0cmFuc2xhdGUsXG4gICAgICAgIHJvdGF0aW9uWCxcbiAgICAgICAgcm90YXRlWCxcbiAgICAgICAgcm90YXRpb25ZLFxuICAgICAgICByb3RhdGVZLFxuICAgICAgICByb3RhdGlvblosXG4gICAgICAgIHJvdGF0ZVosXG4gICAgICAgIGF4aXNSb3RhdGlvbixcbiAgICAgICAgcm90YXRpb24sXG4gICAgICAgIGF4aXNSb3RhdGUsXG4gICAgICAgIHJvdGF0ZSxcbiAgICAgICAgc2NhbGluZyxcbiAgICAgICAgc2NhbGUsXG4gICAgICAgIHVuaWZvcm1TY2FsaW5nLFxuICAgICAgICB1bmlmb3JtU2NhbGUsXG4gICAgfTtcbn1cbmNvbnN0IGNhY2hlJDIgPSBuZXcgTWFwKCk7XG5mdW5jdGlvbiBnZXRBUEkkMihDdG9yKSB7XG4gICAgbGV0IGFwaSA9IGNhY2hlJDIuZ2V0KEN0b3IpO1xuICAgIGlmICghYXBpKSB7XG4gICAgICAgIGFwaSA9IGdldEFQSUltcGwkMihDdG9yKTtcbiAgICAgICAgY2FjaGUkMi5zZXQoQ3RvciwgYXBpKTtcbiAgICB9XG4gICAgcmV0dXJuIGFwaTtcbn1cblxuLypcbiAqIENvcHlyaWdodCAyMDIyIEdyZWdnIFRhdmFyZXNcbiAqXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuICogY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLFxuICogdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvblxuICogdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsXG4gKiBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGVcbiAqIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4gKlxuICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbiAqIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuICpcbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbiAqIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gIElOIE5PIEVWRU5UIFNIQUxMXG4gKiBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuICogTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkdcbiAqIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVJcbiAqIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cbiAqL1xuLyoqXG4gKiBHZW5lcmF0ZXMgYW0gdHlwZWQgQVBJIGZvciBRdWRcbiAqICovXG5mdW5jdGlvbiBnZXRBUElJbXBsJDEoQ3Rvcikge1xuICAgIGNvbnN0IHZlYzMgPSBnZXRBUEkkMyhDdG9yKTtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgcXVhdDQ7IG1heSBiZSBjYWxsZWQgd2l0aCB4LCB5LCB6IHRvIHNldCBpbml0aWFsIHZhbHVlcy5cbiAgICAgKiBAcGFyYW0geCAtIEluaXRpYWwgeCB2YWx1ZS5cbiAgICAgKiBAcGFyYW0geSAtIEluaXRpYWwgeSB2YWx1ZS5cbiAgICAgKiBAcGFyYW0geiAtIEluaXRpYWwgeiB2YWx1ZS5cbiAgICAgKiBAcGFyYW0gdyAtIEluaXRpYWwgdyB2YWx1ZS5cbiAgICAgKiBAcmV0dXJucyB0aGUgY3JlYXRlZCB2ZWN0b3JcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGUoeCwgeSwgeiwgdykge1xuICAgICAgICBjb25zdCBuZXdEc3QgPSBuZXcgQ3Rvcig0KTtcbiAgICAgICAgaWYgKHggIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgbmV3RHN0WzBdID0geDtcbiAgICAgICAgICAgIGlmICh5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBuZXdEc3RbMV0gPSB5O1xuICAgICAgICAgICAgICAgIGlmICh6ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgbmV3RHN0WzJdID0gejtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHcgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV3RHN0WzNdID0gdztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3RHN0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgUXVhdDsgbWF5IGJlIGNhbGxlZCB3aXRoIHgsIHksIHogdG8gc2V0IGluaXRpYWwgdmFsdWVzLiAoc2FtZSBhcyBjcmVhdGUpXG4gICAgICogQHBhcmFtIHggLSBJbml0aWFsIHggdmFsdWUuXG4gICAgICogQHBhcmFtIHkgLSBJbml0aWFsIHkgdmFsdWUuXG4gICAgICogQHBhcmFtIHogLSBJbml0aWFsIHogdmFsdWUuXG4gICAgICogQHBhcmFtIHogLSBJbml0aWFsIHcgdmFsdWUuXG4gICAgICogQHJldHVybnMgdGhlIGNyZWF0ZWQgdmVjdG9yXG4gICAgICovXG4gICAgY29uc3QgZnJvbVZhbHVlcyA9IGNyZWF0ZTtcbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSB2YWx1ZXMgb2YgYSBRdWF0XG4gICAgICogQWxzbyBzZWUge0BsaW5rIHF1YXQuY3JlYXRlfSBhbmQge0BsaW5rIHF1YXQuY29weX1cbiAgICAgKlxuICAgICAqIEBwYXJhbSB4IGZpcnN0IHZhbHVlXG4gICAgICogQHBhcmFtIHkgc2Vjb25kIHZhbHVlXG4gICAgICogQHBhcmFtIHogdGhpcmQgdmFsdWVcbiAgICAgKiBAcGFyYW0gdyBmb3VydGggdmFsdWVcbiAgICAgKiBAcGFyYW0gZHN0IC0gdmVjdG9yIHRvIGhvbGQgcmVzdWx0LiBJZiBub3QgcGFzc2VkIGluIGEgbmV3IG9uZSBpcyBjcmVhdGVkLlxuICAgICAqIEByZXR1cm5zIEEgdmVjdG9yIHdpdGggaXRzIGVsZW1lbnRzIHNldC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzZXQoeCwgeSwgeiwgdywgZHN0KSB7XG4gICAgICAgIGNvbnN0IG5ld0RzdCA9IChkc3QgPz8gbmV3IEN0b3IoNCkpO1xuICAgICAgICBuZXdEc3RbMF0gPSB4O1xuICAgICAgICBuZXdEc3RbMV0gPSB5O1xuICAgICAgICBuZXdEc3RbMl0gPSB6O1xuICAgICAgICBuZXdEc3RbM10gPSB3O1xuICAgICAgICByZXR1cm4gbmV3RHN0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIGEgcXVhdGVybmlvbiBmcm9tIHRoZSBnaXZlbiBhbmdsZSBhbmQgIGF4aXMsXG4gICAgICogdGhlbiByZXR1cm5zIGl0LlxuICAgICAqXG4gICAgICogQHBhcmFtIGF4aXMgLSB0aGUgYXhpcyB0byByb3RhdGUgYXJvdW5kXG4gICAgICogQHBhcmFtIGFuZ2xlSW5SYWRpYW5zIC0gdGhlIGFuZ2xlXG4gICAgICogQHBhcmFtIGRzdCAtIHF1YXRlcm5pb24gdG8gaG9sZCByZXN1bHQuIElmIG5vdCBwYXNzZWQgaW4gYSBuZXcgb25lIGlzIGNyZWF0ZWQuXG4gICAgICogQHJldHVybnMgVGhlIHF1YXRlcm5pb24gdGhhdCByZXByZXNlbnRzIHRoZSBnaXZlbiBheGlzIGFuZCBhbmdsZVxuICAgICAqKi9cbiAgICBmdW5jdGlvbiBmcm9tQXhpc0FuZ2xlKGF4aXMsIGFuZ2xlSW5SYWRpYW5zLCBkc3QpIHtcbiAgICAgICAgY29uc3QgbmV3RHN0ID0gKGRzdCA/PyBuZXcgQ3Rvcig0KSk7XG4gICAgICAgIGNvbnN0IGhhbGZBbmdsZSA9IGFuZ2xlSW5SYWRpYW5zICogMC41O1xuICAgICAgICBjb25zdCBzID0gTWF0aC5zaW4oaGFsZkFuZ2xlKTtcbiAgICAgICAgbmV3RHN0WzBdID0gcyAqIGF4aXNbMF07XG4gICAgICAgIG5ld0RzdFsxXSA9IHMgKiBheGlzWzFdO1xuICAgICAgICBuZXdEc3RbMl0gPSBzICogYXhpc1syXTtcbiAgICAgICAgbmV3RHN0WzNdID0gTWF0aC5jb3MoaGFsZkFuZ2xlKTtcbiAgICAgICAgcmV0dXJuIG5ld0RzdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgcm90YXRpb24gYXhpcyBhbmQgYW5nbGVcbiAgICAgKiBAcGFyYW0gcSAtIHF1YXRlcm5pb24gdG8gY29tcHV0ZSBmcm9tXG4gICAgICogQHBhcmFtIGRzdCAtIFZlYzMgdG8gaG9sZCByZXN1bHQuIElmIG5vdCBwYXNzZWQgaW4gYSBuZXcgb25lIGlzIGNyZWF0ZWQuXG4gICAgICogQHJldHVybiBhbmdsZSBhbmQgYXhpc1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRvQXhpc0FuZ2xlKHEsIGRzdCkge1xuICAgICAgICBjb25zdCBuZXdEc3QgPSAoZHN0ID8/IHZlYzMuY3JlYXRlKDMpKTtcbiAgICAgICAgY29uc3QgYW5nbGUgPSBNYXRoLmFjb3MocVszXSkgKiAyO1xuICAgICAgICBjb25zdCBzID0gTWF0aC5zaW4oYW5nbGUgKiAwLjUpO1xuICAgICAgICBpZiAocyA+IEVQU0lMT04pIHtcbiAgICAgICAgICAgIG5ld0RzdFswXSA9IHFbMF0gLyBzO1xuICAgICAgICAgICAgbmV3RHN0WzFdID0gcVsxXSAvIHM7XG4gICAgICAgICAgICBuZXdEc3RbMl0gPSBxWzJdIC8gcztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG5ld0RzdFswXSA9IDE7XG4gICAgICAgICAgICBuZXdEc3RbMV0gPSAwO1xuICAgICAgICAgICAgbmV3RHN0WzJdID0gMDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBhbmdsZSwgYXhpczogbmV3RHN0IH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGFuZ2xlIGluIGRlZ3JlZXMgYmV0d2VlbiB0d28gcm90YXRpb25zIGEgYW5kIGIuXG4gICAgICogQHBhcmFtIGEgLSBxdWF0ZXJuaW9uIGFcbiAgICAgKiBAcGFyYW0gYiAtIHF1YXRlcm5pb24gYlxuICAgICAqIEByZXR1cm4gYW5nbGUgaW4gcmFkaWFucyBiZXR3ZWVuIHRoZSB0d28gcXVhdGVybmlvbnNcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBhbmdsZShhLCBiKSB7XG4gICAgICAgIGNvbnN0IGQgPSBkb3QoYSwgYik7XG4gICAgICAgIHJldHVybiBNYXRoLmFjb3MoMiAqIGQgKiBkIC0gMSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE11bHRpcGxpZXMgdHdvIHF1YXRlcm5pb25zXG4gICAgICpcbiAgICAgKiBAcGFyYW0gYSAtIHRoZSBmaXJzdCBxdWF0ZXJuaW9uXG4gICAgICogQHBhcmFtIGIgLSB0aGUgc2Vjb25kIHF1YXRlcm5pb25cbiAgICAgKiBAcGFyYW0gZHN0IC0gcXVhdGVybmlvbiB0byBob2xkIHJlc3VsdC4gSWYgbm90IHBhc3NlZCBpbiBhIG5ldyBvbmUgaXMgY3JlYXRlZC5cbiAgICAgKiBAcmV0dXJucyBBIHF1YXRlcm5pb24gdGhhdCBpcyB0aGUgcmVzdWx0IG9mIGEgKiBiXG4gICAgICovXG4gICAgZnVuY3Rpb24gbXVsdGlwbHkoYSwgYiwgZHN0KSB7XG4gICAgICAgIGNvbnN0IG5ld0RzdCA9IChkc3QgPz8gbmV3IEN0b3IoNCkpO1xuICAgICAgICBjb25zdCBheCA9IGFbMF07XG4gICAgICAgIGNvbnN0IGF5ID0gYVsxXTtcbiAgICAgICAgY29uc3QgYXogPSBhWzJdO1xuICAgICAgICBjb25zdCBhdyA9IGFbM107XG4gICAgICAgIGNvbnN0IGJ4ID0gYlswXTtcbiAgICAgICAgY29uc3QgYnkgPSBiWzFdO1xuICAgICAgICBjb25zdCBieiA9IGJbMl07XG4gICAgICAgIGNvbnN0IGJ3ID0gYlszXTtcbiAgICAgICAgbmV3RHN0WzBdID0gYXggKiBidyArIGF3ICogYnggKyBheSAqIGJ6IC0gYXogKiBieTtcbiAgICAgICAgbmV3RHN0WzFdID0gYXkgKiBidyArIGF3ICogYnkgKyBheiAqIGJ4IC0gYXggKiBiejtcbiAgICAgICAgbmV3RHN0WzJdID0gYXogKiBidyArIGF3ICogYnogKyBheCAqIGJ5IC0gYXkgKiBieDtcbiAgICAgICAgbmV3RHN0WzNdID0gYXcgKiBidyAtIGF4ICogYnggLSBheSAqIGJ5IC0gYXogKiBiejtcbiAgICAgICAgcmV0dXJuIG5ld0RzdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTXVsdGlwbGllcyB0d28gcXVhdGVybmlvbnNcbiAgICAgKlxuICAgICAqIEBwYXJhbSBhIC0gdGhlIGZpcnN0IHF1YXRlcm5pb25cbiAgICAgKiBAcGFyYW0gYiAtIHRoZSBzZWNvbmQgcXVhdGVybmlvblxuICAgICAqIEBwYXJhbSBkc3QgLSBxdWF0ZXJuaW9uIHRvIGhvbGQgcmVzdWx0LiBJZiBub3QgcGFzc2VkIGluIGEgbmV3IG9uZSBpcyBjcmVhdGVkLlxuICAgICAqIEByZXR1cm5zIEEgcXVhdGVybmlvbiB0aGF0IGlzIHRoZSByZXN1bHQgb2YgYSAqIGJcbiAgICAgKi9cbiAgICBjb25zdCBtdWwgPSBtdWx0aXBseTtcbiAgICAvKipcbiAgICAgKiBSb3RhdGVzIHRoZSBnaXZlbiBxdWF0ZXJuaW9uIGFyb3VuZCB0aGUgWCBheGlzIGJ5IHRoZSBnaXZlbiBhbmdsZS5cbiAgICAgKiBAcGFyYW0gcSAtIHF1YXRlcm5pb24gdG8gcm90YXRlXG4gICAgICogQHBhcmFtIGFuZ2xlSW5SYWRpYW5zIC0gVGhlIGFuZ2xlIGJ5IHdoaWNoIHRvIHJvdGF0ZVxuICAgICAqIEBwYXJhbSBkc3QgLSBxdWF0ZXJuaW9uIHRvIGhvbGQgcmVzdWx0LiBJZiBub3QgcGFzc2VkIGluIGEgbmV3IG9uZSBpcyBjcmVhdGVkLlxuICAgICAqIEByZXR1cm5zIEEgcXVhdGVybmlvbiB0aGF0IGlzIHRoZSByZXN1bHQgb2YgYSAqIGJcbiAgICAgKi9cbiAgICBmdW5jdGlvbiByb3RhdGVYKHEsIGFuZ2xlSW5SYWRpYW5zLCBkc3QpIHtcbiAgICAgICAgY29uc3QgbmV3RHN0ID0gKGRzdCA/PyBuZXcgQ3Rvcig0KSk7XG4gICAgICAgIGNvbnN0IGhhbGZBbmdsZSA9IGFuZ2xlSW5SYWRpYW5zICogMC41O1xuICAgICAgICBjb25zdCBxeCA9IHFbMF07XG4gICAgICAgIGNvbnN0IHF5ID0gcVsxXTtcbiAgICAgICAgY29uc3QgcXogPSBxWzJdO1xuICAgICAgICBjb25zdCBxdyA9IHFbM107XG4gICAgICAgIGNvbnN0IGJ4ID0gTWF0aC5zaW4oaGFsZkFuZ2xlKTtcbiAgICAgICAgY29uc3QgYncgPSBNYXRoLmNvcyhoYWxmQW5nbGUpO1xuICAgICAgICBuZXdEc3RbMF0gPSBxeCAqIGJ3ICsgcXcgKiBieDtcbiAgICAgICAgbmV3RHN0WzFdID0gcXkgKiBidyArIHF6ICogYng7XG4gICAgICAgIG5ld0RzdFsyXSA9IHF6ICogYncgLSBxeSAqIGJ4O1xuICAgICAgICBuZXdEc3RbM10gPSBxdyAqIGJ3IC0gcXggKiBieDtcbiAgICAgICAgcmV0dXJuIG5ld0RzdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUm90YXRlcyB0aGUgZ2l2ZW4gcXVhdGVybmlvbiBhcm91bmQgdGhlIFkgYXhpcyBieSB0aGUgZ2l2ZW4gYW5nbGUuXG4gICAgICogQHBhcmFtIHEgLSBxdWF0ZXJuaW9uIHRvIHJvdGF0ZVxuICAgICAqIEBwYXJhbSBhbmdsZUluUmFkaWFucyAtIFRoZSBhbmdsZSBieSB3aGljaCB0byByb3RhdGVcbiAgICAgKiBAcGFyYW0gZHN0IC0gcXVhdGVybmlvbiB0byBob2xkIHJlc3VsdC4gSWYgbm90IHBhc3NlZCBpbiBhIG5ldyBvbmUgaXMgY3JlYXRlZC5cbiAgICAgKiBAcmV0dXJucyBBIHF1YXRlcm5pb24gdGhhdCBpcyB0aGUgcmVzdWx0IG9mIGEgKiBiXG4gICAgICovXG4gICAgZnVuY3Rpb24gcm90YXRlWShxLCBhbmdsZUluUmFkaWFucywgZHN0KSB7XG4gICAgICAgIGNvbnN0IG5ld0RzdCA9IChkc3QgPz8gbmV3IEN0b3IoNCkpO1xuICAgICAgICBjb25zdCBoYWxmQW5nbGUgPSBhbmdsZUluUmFkaWFucyAqIDAuNTtcbiAgICAgICAgY29uc3QgcXggPSBxWzBdO1xuICAgICAgICBjb25zdCBxeSA9IHFbMV07XG4gICAgICAgIGNvbnN0IHF6ID0gcVsyXTtcbiAgICAgICAgY29uc3QgcXcgPSBxWzNdO1xuICAgICAgICBjb25zdCBieSA9IE1hdGguc2luKGhhbGZBbmdsZSk7XG4gICAgICAgIGNvbnN0IGJ3ID0gTWF0aC5jb3MoaGFsZkFuZ2xlKTtcbiAgICAgICAgbmV3RHN0WzBdID0gcXggKiBidyAtIHF6ICogYnk7XG4gICAgICAgIG5ld0RzdFsxXSA9IHF5ICogYncgKyBxdyAqIGJ5O1xuICAgICAgICBuZXdEc3RbMl0gPSBxeiAqIGJ3ICsgcXggKiBieTtcbiAgICAgICAgbmV3RHN0WzNdID0gcXcgKiBidyAtIHF5ICogYnk7XG4gICAgICAgIHJldHVybiBuZXdEc3Q7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJvdGF0ZXMgdGhlIGdpdmVuIHF1YXRlcm5pb24gYXJvdW5kIHRoZSBaIGF4aXMgYnkgdGhlIGdpdmVuIGFuZ2xlLlxuICAgICAqIEBwYXJhbSBxIC0gcXVhdGVybmlvbiB0byByb3RhdGVcbiAgICAgKiBAcGFyYW0gYW5nbGVJblJhZGlhbnMgLSBUaGUgYW5nbGUgYnkgd2hpY2ggdG8gcm90YXRlXG4gICAgICogQHBhcmFtIGRzdCAtIHF1YXRlcm5pb24gdG8gaG9sZCByZXN1bHQuIElmIG5vdCBwYXNzZWQgaW4gYSBuZXcgb25lIGlzIGNyZWF0ZWQuXG4gICAgICogQHJldHVybnMgQSBxdWF0ZXJuaW9uIHRoYXQgaXMgdGhlIHJlc3VsdCBvZiBhICogYlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHJvdGF0ZVoocSwgYW5nbGVJblJhZGlhbnMsIGRzdCkge1xuICAgICAgICBjb25zdCBuZXdEc3QgPSAoZHN0ID8/IG5ldyBDdG9yKDQpKTtcbiAgICAgICAgY29uc3QgaGFsZkFuZ2xlID0gYW5nbGVJblJhZGlhbnMgKiAwLjU7XG4gICAgICAgIGNvbnN0IHF4ID0gcVswXTtcbiAgICAgICAgY29uc3QgcXkgPSBxWzFdO1xuICAgICAgICBjb25zdCBxeiA9IHFbMl07XG4gICAgICAgIGNvbnN0IHF3ID0gcVszXTtcbiAgICAgICAgY29uc3QgYnogPSBNYXRoLnNpbihoYWxmQW5nbGUpO1xuICAgICAgICBjb25zdCBidyA9IE1hdGguY29zKGhhbGZBbmdsZSk7XG4gICAgICAgIG5ld0RzdFswXSA9IHF4ICogYncgKyBxeSAqIGJ6O1xuICAgICAgICBuZXdEc3RbMV0gPSBxeSAqIGJ3IC0gcXggKiBiejtcbiAgICAgICAgbmV3RHN0WzJdID0gcXogKiBidyArIHF3ICogYno7XG4gICAgICAgIG5ld0RzdFszXSA9IHF3ICogYncgLSBxeiAqIGJ6O1xuICAgICAgICByZXR1cm4gbmV3RHN0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTcGhlcmljYWxseSBsaW5lYXIgaW50ZXJwb2xhdGUgYmV0d2VlbiB0d28gcXVhdGVybmlvbnNcbiAgICAgKlxuICAgICAqIEBwYXJhbSBhIC0gc3RhcnRpbmcgdmFsdWVcbiAgICAgKiBAcGFyYW0gYiAtIGVuZGluZyB2YWx1ZVxuICAgICAqIEBwYXJhbSB0IC0gdmFsdWUgd2hlcmUgMCA9IGEgYW5kIDEgPSBiXG4gICAgICogQHBhcmFtIGRzdCAtIHF1YXRlcm5pb24gdG8gaG9sZCByZXN1bHQuIElmIG5vdCBwYXNzZWQgaW4gYSBuZXcgb25lIGlzIGNyZWF0ZWQuXG4gICAgICogQHJldHVybnMgQSBxdWF0ZXJuaW9uIHRoYXQgaXMgdGhlIHJlc3VsdCBvZiBhICogYlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNsZXJwKGEsIGIsIHQsIGRzdCkge1xuICAgICAgICBjb25zdCBuZXdEc3QgPSAoZHN0ID8/IG5ldyBDdG9yKDQpKTtcbiAgICAgICAgY29uc3QgYXggPSBhWzBdO1xuICAgICAgICBjb25zdCBheSA9IGFbMV07XG4gICAgICAgIGNvbnN0IGF6ID0gYVsyXTtcbiAgICAgICAgY29uc3QgYXcgPSBhWzNdO1xuICAgICAgICBsZXQgYnggPSBiWzBdO1xuICAgICAgICBsZXQgYnkgPSBiWzFdO1xuICAgICAgICBsZXQgYnogPSBiWzJdO1xuICAgICAgICBsZXQgYncgPSBiWzNdO1xuICAgICAgICBsZXQgY29zT21lZ2EgPSBheCAqIGJ4ICsgYXkgKiBieSArIGF6ICogYnogKyBhdyAqIGJ3O1xuICAgICAgICBpZiAoY29zT21lZ2EgPCAwKSB7XG4gICAgICAgICAgICBjb3NPbWVnYSA9IC1jb3NPbWVnYTtcbiAgICAgICAgICAgIGJ4ID0gLWJ4O1xuICAgICAgICAgICAgYnkgPSAtYnk7XG4gICAgICAgICAgICBieiA9IC1iejtcbiAgICAgICAgICAgIGJ3ID0gLWJ3O1xuICAgICAgICB9XG4gICAgICAgIGxldCBzY2FsZTA7XG4gICAgICAgIGxldCBzY2FsZTE7XG4gICAgICAgIGlmICgxLjAgLSBjb3NPbWVnYSA+IEVQU0lMT04pIHtcbiAgICAgICAgICAgIGNvbnN0IG9tZWdhID0gTWF0aC5hY29zKGNvc09tZWdhKTtcbiAgICAgICAgICAgIGNvbnN0IHNpbk9tZWdhID0gTWF0aC5zaW4ob21lZ2EpO1xuICAgICAgICAgICAgc2NhbGUwID0gTWF0aC5zaW4oKDEgLSB0KSAqIG9tZWdhKSAvIHNpbk9tZWdhO1xuICAgICAgICAgICAgc2NhbGUxID0gTWF0aC5zaW4odCAqIG9tZWdhKSAvIHNpbk9tZWdhO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc2NhbGUwID0gMS4wIC0gdDtcbiAgICAgICAgICAgIHNjYWxlMSA9IHQ7XG4gICAgICAgIH1cbiAgICAgICAgbmV3RHN0WzBdID0gc2NhbGUwICogYXggKyBzY2FsZTEgKiBieDtcbiAgICAgICAgbmV3RHN0WzFdID0gc2NhbGUwICogYXkgKyBzY2FsZTEgKiBieTtcbiAgICAgICAgbmV3RHN0WzJdID0gc2NhbGUwICogYXogKyBzY2FsZTEgKiBiejtcbiAgICAgICAgbmV3RHN0WzNdID0gc2NhbGUwICogYXcgKyBzY2FsZTEgKiBidztcbiAgICAgICAgcmV0dXJuIG5ld0RzdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29tcHV0ZSB0aGUgaW52ZXJzZSBvZiBhIHF1YXRlcm5pb25cbiAgICAgKlxuICAgICAqIEBwYXJhbSBxIC0gcXVhdGVybmlvbiB0byBjb21wdXRlIHRoZSBpbnZlcnNlIG9mXG4gICAgICogQHJldHVybnMgQSBxdWF0ZXJuaW9uIHRoYXQgaXMgdGhlIHJlc3VsdCBvZiBhICogYlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGludmVyc2UocSwgZHN0KSB7XG4gICAgICAgIGNvbnN0IG5ld0RzdCA9IChkc3QgPz8gbmV3IEN0b3IoNCkpO1xuICAgICAgICBjb25zdCBhMCA9IHFbMF07XG4gICAgICAgIGNvbnN0IGExID0gcVsxXTtcbiAgICAgICAgY29uc3QgYTIgPSBxWzJdO1xuICAgICAgICBjb25zdCBhMyA9IHFbM107XG4gICAgICAgIGNvbnN0IGRvdCA9IGEwICogYTAgKyBhMSAqIGExICsgYTIgKiBhMiArIGEzICogYTM7XG4gICAgICAgIGNvbnN0IGludkRvdCA9IGRvdCA/IDEgLyBkb3QgOiAwO1xuICAgICAgICBuZXdEc3RbMF0gPSAtYTAgKiBpbnZEb3Q7XG4gICAgICAgIG5ld0RzdFsxXSA9IC1hMSAqIGludkRvdDtcbiAgICAgICAgbmV3RHN0WzJdID0gLWEyICogaW52RG90O1xuICAgICAgICBuZXdEc3RbM10gPSBhMyAqIGludkRvdDtcbiAgICAgICAgcmV0dXJuIG5ld0RzdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29tcHV0ZSB0aGUgY29uanVnYXRlIG9mIGEgcXVhdGVybmlvblxuICAgICAqIEZvciBxdWF0ZXJuaW9ucyB3aXRoIGEgbWFnbml0dWRlIG9mIDEgKGEgdW5pdCBxdWF0ZXJuaW9uKVxuICAgICAqIHRoaXMgcmV0dXJucyB0aGUgc2FtZSBhcyB0aGUgaW52ZXJzZSBidXQgaXMgZmFzdGVyIHRvIGNhbGN1bGF0ZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBxIC0gcXVhdGVybmlvbiB0byBjb21wdXRlIHRoZSBjb25qdWdhdGUgb2YuXG4gICAgICogQHBhcmFtIGRzdCAtIHF1YXRlcm5pb24gdG8gaG9sZCByZXN1bHQuIElmIG5vdCBwYXNzZWQgaW4gYSBuZXcgb25lIGlzIGNyZWF0ZWQuXG4gICAgICogQHJldHVybnMgVGhlIGNvbmp1Z2F0ZSBvZiBxXG4gICAgICovXG4gICAgZnVuY3Rpb24gY29uanVnYXRlKHEsIGRzdCkge1xuICAgICAgICBjb25zdCBuZXdEc3QgPSAoZHN0ID8/IG5ldyBDdG9yKDQpKTtcbiAgICAgICAgbmV3RHN0WzBdID0gLXFbMF07XG4gICAgICAgIG5ld0RzdFsxXSA9IC1xWzFdO1xuICAgICAgICBuZXdEc3RbMl0gPSAtcVsyXTtcbiAgICAgICAgbmV3RHN0WzNdID0gcVszXTtcbiAgICAgICAgcmV0dXJuIG5ld0RzdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIHF1YXRlcm5pb24gZnJvbSB0aGUgZ2l2ZW4gcm90YXRpb24gbWF0cml4LlxuICAgICAqXG4gICAgICogVGhlIGNyZWF0ZWQgcXVhdGVybmlvbiBpcyBub3Qgbm9ybWFsaXplZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBtIC0gcm90YXRpb24gbWF0cml4XG4gICAgICogQHBhcmFtIGRzdCAtIHF1YXRlcm5pb24gdG8gaG9sZCByZXN1bHQuIElmIG5vdCBwYXNzZWQgaW4gYSBuZXcgb25lIGlzIGNyZWF0ZWQuXG4gICAgICogQHJldHVybnMgdGhlIHJlc3VsdFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZyb21NYXQobSwgZHN0KSB7XG4gICAgICAgIGNvbnN0IG5ld0RzdCA9IChkc3QgPz8gbmV3IEN0b3IoNCkpO1xuICAgICAgICAvKlxuICAgICAgICAwIDEgMlxuICAgICAgICAzIDQgNVxuICAgICAgICA2IDcgOFxuICAgICAgXG4gICAgICAgIDAgMSAyXG4gICAgICAgIDQgNSA2XG4gICAgICAgIDggOSAxMFxuICAgICAgICAgKi9cbiAgICAgICAgLy8gQWxnb3JpdGhtIGluIEtlbiBTaG9lbWFrZSdzIGFydGljbGUgaW4gMTk4NyBTSUdHUkFQSCBjb3Vyc2Ugbm90ZXNcbiAgICAgICAgLy8gYXJ0aWNsZSBcIlF1YXRlcm5pb24gQ2FsY3VsdXMgYW5kIEZhc3QgQW5pbWF0aW9uXCIuXG4gICAgICAgIGNvbnN0IHRyYWNlID0gbVswXSArIG1bNV0gKyBtWzEwXTtcbiAgICAgICAgaWYgKHRyYWNlID4gMC4wKSB7XG4gICAgICAgICAgICAvLyB8d3wgPiAxLzIsIG1heSBhcyB3ZWxsIGNob29zZSB3ID4gMS8yXG4gICAgICAgICAgICBjb25zdCByb290ID0gTWF0aC5zcXJ0KHRyYWNlICsgMSk7IC8vIDJ3XG4gICAgICAgICAgICBuZXdEc3RbM10gPSAwLjUgKiByb290O1xuICAgICAgICAgICAgY29uc3QgaW52Um9vdCA9IDAuNSAvIHJvb3Q7IC8vIDEvKDR3KVxuICAgICAgICAgICAgbmV3RHN0WzBdID0gKG1bNl0gLSBtWzldKSAqIGludlJvb3Q7XG4gICAgICAgICAgICBuZXdEc3RbMV0gPSAobVs4XSAtIG1bMl0pICogaW52Um9vdDtcbiAgICAgICAgICAgIG5ld0RzdFsyXSA9IChtWzFdIC0gbVs0XSkgKiBpbnZSb290O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gfHd8IDw9IDEvMlxuICAgICAgICAgICAgbGV0IGkgPSAwO1xuICAgICAgICAgICAgaWYgKG1bNV0gPiBtWzBdKSB7XG4gICAgICAgICAgICAgICAgaSA9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobVsxMF0gPiBtW2kgKiA0ICsgaV0pIHtcbiAgICAgICAgICAgICAgICBpID0gMjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGogPSAoaSArIDEpICUgMztcbiAgICAgICAgICAgIGNvbnN0IGsgPSAoaSArIDIpICUgMztcbiAgICAgICAgICAgIGNvbnN0IHJvb3QgPSBNYXRoLnNxcnQobVtpICogNCArIGldIC0gbVtqICogNCArIGpdIC0gbVtrICogNCArIGtdICsgMS4wKTtcbiAgICAgICAgICAgIG5ld0RzdFtpXSA9IDAuNSAqIHJvb3Q7XG4gICAgICAgICAgICBjb25zdCBpbnZSb290ID0gMC41IC8gcm9vdDtcbiAgICAgICAgICAgIG5ld0RzdFszXSA9IChtW2ogKiA0ICsga10gLSBtW2sgKiA0ICsgal0pICogaW52Um9vdDtcbiAgICAgICAgICAgIG5ld0RzdFtqXSA9IChtW2ogKiA0ICsgaV0gKyBtW2kgKiA0ICsgal0pICogaW52Um9vdDtcbiAgICAgICAgICAgIG5ld0RzdFtrXSA9IChtW2sgKiA0ICsgaV0gKyBtW2kgKiA0ICsga10pICogaW52Um9vdDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3RHN0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgcXVhdGVybmlvbiBmcm9tIHRoZSBnaXZlbiBldWxlciBhbmdsZSB4LCB5LCB6IHVzaW5nIHRoZSBwcm92aWRlZCBpbnRyaW5zaWMgb3JkZXIgZm9yIHRoZSBjb252ZXJzaW9uLlxuICAgICAqXG4gICAgICogQHBhcmFtIHhBbmdsZUluUmFkaWFucyAtIGFuZ2xlIHRvIHJvdGF0ZSBhcm91bmQgWCBheGlzIGluIHJhZGlhbnMuXG4gICAgICogQHBhcmFtIHlBbmdsZUluUmFkaWFucyAtIGFuZ2xlIHRvIHJvdGF0ZSBhcm91bmQgWSBheGlzIGluIHJhZGlhbnMuXG4gICAgICogQHBhcmFtIHpBbmdsZUluUmFkaWFucyAtIGFuZ2xlIHRvIHJvdGF0ZSBhcm91bmQgWiBheGlzIGluIHJhZGlhbnMuXG4gICAgICogQHBhcmFtIG9yZGVyIC0gb3JkZXIgdG8gYXBwbHkgZXVsZXIgYW5nbGVzXG4gICAgICogQHBhcmFtIGRzdCAtIHF1YXRlcm5pb24gdG8gaG9sZCByZXN1bHQuIElmIG5vdCBwYXNzZWQgaW4gYSBuZXcgb25lIGlzIGNyZWF0ZWQuXG4gICAgICogQHJldHVybnMgQSBxdWF0ZXJuaW9uIHJlcHJlc2VudGluZyB0aGUgc2FtZSByb3RhdGlvbiBhcyB0aGUgZXVsZXIgYW5nbGVzIGFwcGxpZWQgaW4gdGhlIGdpdmVuIG9yZGVyXG4gICAgICovXG4gICAgZnVuY3Rpb24gZnJvbUV1bGVyKHhBbmdsZUluUmFkaWFucywgeUFuZ2xlSW5SYWRpYW5zLCB6QW5nbGVJblJhZGlhbnMsIG9yZGVyLCBkc3QpIHtcbiAgICAgICAgY29uc3QgbmV3RHN0ID0gKGRzdCA/PyBuZXcgQ3Rvcig0KSk7XG4gICAgICAgIGNvbnN0IHhIYWxmQW5nbGUgPSB4QW5nbGVJblJhZGlhbnMgKiAwLjU7XG4gICAgICAgIGNvbnN0IHlIYWxmQW5nbGUgPSB5QW5nbGVJblJhZGlhbnMgKiAwLjU7XG4gICAgICAgIGNvbnN0IHpIYWxmQW5nbGUgPSB6QW5nbGVJblJhZGlhbnMgKiAwLjU7XG4gICAgICAgIGNvbnN0IHN4ID0gTWF0aC5zaW4oeEhhbGZBbmdsZSk7XG4gICAgICAgIGNvbnN0IGN4ID0gTWF0aC5jb3MoeEhhbGZBbmdsZSk7XG4gICAgICAgIGNvbnN0IHN5ID0gTWF0aC5zaW4oeUhhbGZBbmdsZSk7XG4gICAgICAgIGNvbnN0IGN5ID0gTWF0aC5jb3MoeUhhbGZBbmdsZSk7XG4gICAgICAgIGNvbnN0IHN6ID0gTWF0aC5zaW4oekhhbGZBbmdsZSk7XG4gICAgICAgIGNvbnN0IGN6ID0gTWF0aC5jb3MoekhhbGZBbmdsZSk7XG4gICAgICAgIHN3aXRjaCAob3JkZXIpIHtcbiAgICAgICAgICAgIGNhc2UgJ3h5eic6XG4gICAgICAgICAgICAgICAgbmV3RHN0WzBdID0gc3ggKiBjeSAqIGN6ICsgY3ggKiBzeSAqIHN6O1xuICAgICAgICAgICAgICAgIG5ld0RzdFsxXSA9IGN4ICogc3kgKiBjeiAtIHN4ICogY3kgKiBzejtcbiAgICAgICAgICAgICAgICBuZXdEc3RbMl0gPSBjeCAqIGN5ICogc3ogKyBzeCAqIHN5ICogY3o7XG4gICAgICAgICAgICAgICAgbmV3RHN0WzNdID0gY3ggKiBjeSAqIGN6IC0gc3ggKiBzeSAqIHN6O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAneHp5JzpcbiAgICAgICAgICAgICAgICBuZXdEc3RbMF0gPSBzeCAqIGN5ICogY3ogLSBjeCAqIHN5ICogc3o7XG4gICAgICAgICAgICAgICAgbmV3RHN0WzFdID0gY3ggKiBzeSAqIGN6IC0gc3ggKiBjeSAqIHN6O1xuICAgICAgICAgICAgICAgIG5ld0RzdFsyXSA9IGN4ICogY3kgKiBzeiArIHN4ICogc3kgKiBjejtcbiAgICAgICAgICAgICAgICBuZXdEc3RbM10gPSBjeCAqIGN5ICogY3ogKyBzeCAqIHN5ICogc3o7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICd5eHonOlxuICAgICAgICAgICAgICAgIG5ld0RzdFswXSA9IHN4ICogY3kgKiBjeiArIGN4ICogc3kgKiBzejtcbiAgICAgICAgICAgICAgICBuZXdEc3RbMV0gPSBjeCAqIHN5ICogY3ogLSBzeCAqIGN5ICogc3o7XG4gICAgICAgICAgICAgICAgbmV3RHN0WzJdID0gY3ggKiBjeSAqIHN6IC0gc3ggKiBzeSAqIGN6O1xuICAgICAgICAgICAgICAgIG5ld0RzdFszXSA9IGN4ICogY3kgKiBjeiArIHN4ICogc3kgKiBzejtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ3l6eCc6XG4gICAgICAgICAgICAgICAgbmV3RHN0WzBdID0gc3ggKiBjeSAqIGN6ICsgY3ggKiBzeSAqIHN6O1xuICAgICAgICAgICAgICAgIG5ld0RzdFsxXSA9IGN4ICogc3kgKiBjeiArIHN4ICogY3kgKiBzejtcbiAgICAgICAgICAgICAgICBuZXdEc3RbMl0gPSBjeCAqIGN5ICogc3ogLSBzeCAqIHN5ICogY3o7XG4gICAgICAgICAgICAgICAgbmV3RHN0WzNdID0gY3ggKiBjeSAqIGN6IC0gc3ggKiBzeSAqIHN6O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnenh5JzpcbiAgICAgICAgICAgICAgICBuZXdEc3RbMF0gPSBzeCAqIGN5ICogY3ogLSBjeCAqIHN5ICogc3o7XG4gICAgICAgICAgICAgICAgbmV3RHN0WzFdID0gY3ggKiBzeSAqIGN6ICsgc3ggKiBjeSAqIHN6O1xuICAgICAgICAgICAgICAgIG5ld0RzdFsyXSA9IGN4ICogY3kgKiBzeiArIHN4ICogc3kgKiBjejtcbiAgICAgICAgICAgICAgICBuZXdEc3RbM10gPSBjeCAqIGN5ICogY3ogLSBzeCAqIHN5ICogc3o7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICd6eXgnOlxuICAgICAgICAgICAgICAgIG5ld0RzdFswXSA9IHN4ICogY3kgKiBjeiAtIGN4ICogc3kgKiBzejtcbiAgICAgICAgICAgICAgICBuZXdEc3RbMV0gPSBjeCAqIHN5ICogY3ogKyBzeCAqIGN5ICogc3o7XG4gICAgICAgICAgICAgICAgbmV3RHN0WzJdID0gY3ggKiBjeSAqIHN6IC0gc3ggKiBzeSAqIGN6O1xuICAgICAgICAgICAgICAgIG5ld0RzdFszXSA9IGN4ICogY3kgKiBjeiArIHN4ICogc3kgKiBzejtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmtub3duIHJvdGF0aW9uIG9yZGVyOiAke29yZGVyfWApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXdEc3Q7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvcGllcyBhIHF1YXRlcm5pb24uIChzYW1lIGFzIHtAbGluayBxdWF0LmNsb25lfSlcbiAgICAgKiBBbHNvIHNlZSB7QGxpbmsgcXVhdC5jcmVhdGV9IGFuZCB7QGxpbmsgcXVhdC5zZXR9XG4gICAgICogQHBhcmFtIHEgLSBUaGUgcXVhdGVybmlvbi5cbiAgICAgKiBAcGFyYW0gZHN0IC0gcXVhdGVybmlvbiB0byBob2xkIHJlc3VsdC4gSWYgbm90IHBhc3NlZCBpbiBhIG5ldyBvbmUgaXMgY3JlYXRlZC5cbiAgICAgKiBAcmV0dXJucyBBIHF1YXRlcm5pb24gdGhhdCBpcyBhIGNvcHkgb2YgcVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNvcHkocSwgZHN0KSB7XG4gICAgICAgIGNvbnN0IG5ld0RzdCA9IChkc3QgPz8gbmV3IEN0b3IoNCkpO1xuICAgICAgICBuZXdEc3RbMF0gPSBxWzBdO1xuICAgICAgICBuZXdEc3RbMV0gPSBxWzFdO1xuICAgICAgICBuZXdEc3RbMl0gPSBxWzJdO1xuICAgICAgICBuZXdEc3RbM10gPSBxWzNdO1xuICAgICAgICByZXR1cm4gbmV3RHN0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDbG9uZXMgYSBxdWF0ZXJuaW9uLiAoc2FtZSBhcyB7QGxpbmsgcXVhdC5jb3B5fSlcbiAgICAgKiBBbHNvIHNlZSB7QGxpbmsgcXVhdC5jcmVhdGV9IGFuZCB7QGxpbmsgcXVhdC5zZXR9XG4gICAgICogQHBhcmFtIHEgLSBUaGUgcXVhdGVybmlvbi5cbiAgICAgKiBAcGFyYW0gZHN0IC0gcXVhdGVybmlvbiB0byBob2xkIHJlc3VsdC4gSWYgbm90IHBhc3NlZCBpbiBhIG5ldyBvbmUgaXMgY3JlYXRlZC5cbiAgICAgKiBAcmV0dXJucyBBIGNvcHkgb2YgcS5cbiAgICAgKi9cbiAgICBjb25zdCBjbG9uZSA9IGNvcHk7XG4gICAgLyoqXG4gICAgICogQWRkcyB0d28gcXVhdGVybmlvbnM7IGFzc3VtZXMgYSBhbmQgYiBoYXZlIHRoZSBzYW1lIGRpbWVuc2lvbi5cbiAgICAgKiBAcGFyYW0gYSAtIE9wZXJhbmQgcXVhdGVybmlvbi5cbiAgICAgKiBAcGFyYW0gYiAtIE9wZXJhbmQgcXVhdGVybmlvbi5cbiAgICAgKiBAcGFyYW0gZHN0IC0gcXVhdGVybmlvbiB0byBob2xkIHJlc3VsdC4gSWYgbm90IHBhc3NlZCBpbiBhIG5ldyBvbmUgaXMgY3JlYXRlZC5cbiAgICAgKiBAcmV0dXJucyBBIHF1YXRlcm5pb24gdGhhdCBpcyB0aGUgc3VtIG9mIGEgYW5kIGIuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYWRkKGEsIGIsIGRzdCkge1xuICAgICAgICBjb25zdCBuZXdEc3QgPSAoZHN0ID8/IG5ldyBDdG9yKDQpKTtcbiAgICAgICAgbmV3RHN0WzBdID0gYVswXSArIGJbMF07XG4gICAgICAgIG5ld0RzdFsxXSA9IGFbMV0gKyBiWzFdO1xuICAgICAgICBuZXdEc3RbMl0gPSBhWzJdICsgYlsyXTtcbiAgICAgICAgbmV3RHN0WzNdID0gYVszXSArIGJbM107XG4gICAgICAgIHJldHVybiBuZXdEc3Q7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFN1YnRyYWN0cyB0d28gcXVhdGVybmlvbnMuXG4gICAgICogQHBhcmFtIGEgLSBPcGVyYW5kIHF1YXRlcm5pb24uXG4gICAgICogQHBhcmFtIGIgLSBPcGVyYW5kIHF1YXRlcm5pb24uXG4gICAgICogQHBhcmFtIGRzdCAtIHF1YXRlcm5pb24gdG8gaG9sZCByZXN1bHQuIElmIG5vdCBwYXNzZWQgaW4gYSBuZXcgb25lIGlzIGNyZWF0ZWQuXG4gICAgICogQHJldHVybnMgQSBxdWF0ZXJuaW9uIHRoYXQgaXMgdGhlIGRpZmZlcmVuY2Ugb2YgYSBhbmQgYi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzdWJ0cmFjdChhLCBiLCBkc3QpIHtcbiAgICAgICAgY29uc3QgbmV3RHN0ID0gKGRzdCA/PyBuZXcgQ3Rvcig0KSk7XG4gICAgICAgIG5ld0RzdFswXSA9IGFbMF0gLSBiWzBdO1xuICAgICAgICBuZXdEc3RbMV0gPSBhWzFdIC0gYlsxXTtcbiAgICAgICAgbmV3RHN0WzJdID0gYVsyXSAtIGJbMl07XG4gICAgICAgIG5ld0RzdFszXSA9IGFbM10gLSBiWzNdO1xuICAgICAgICByZXR1cm4gbmV3RHN0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTdWJ0cmFjdHMgdHdvIHF1YXRlcm5pb25zLlxuICAgICAqIEBwYXJhbSBhIC0gT3BlcmFuZCBxdWF0ZXJuaW9uLlxuICAgICAqIEBwYXJhbSBiIC0gT3BlcmFuZCBxdWF0ZXJuaW9uLlxuICAgICAqIEBwYXJhbSBkc3QgLSBxdWF0ZXJuaW9uIHRvIGhvbGQgcmVzdWx0LiBJZiBub3QgcGFzc2VkIGluIGEgbmV3IG9uZSBpcyBjcmVhdGVkLlxuICAgICAqIEByZXR1cm5zIEEgcXVhdGVybmlvbiB0aGF0IGlzIHRoZSBkaWZmZXJlbmNlIG9mIGEgYW5kIGIuXG4gICAgICovXG4gICAgY29uc3Qgc3ViID0gc3VidHJhY3Q7XG4gICAgLyoqXG4gICAgICogTXVsdGlwbGllcyBhIHF1YXRlcm5pb24gYnkgYSBzY2FsYXIuXG4gICAgICogQHBhcmFtIHYgLSBUaGUgcXVhdGVybmlvbi5cbiAgICAgKiBAcGFyYW0gayAtIFRoZSBzY2FsYXIuXG4gICAgICogQHBhcmFtIGRzdCAtIHF1YXRlcm5pb24gdG8gaG9sZCByZXN1bHQuIElmIG5vdCBwYXNzZWQgaW4gYSBuZXcgb25lIGlzIGNyZWF0ZWQuXG4gICAgICogQHJldHVybnMgVGhlIHNjYWxlZCBxdWF0ZXJuaW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG11bFNjYWxhcih2LCBrLCBkc3QpIHtcbiAgICAgICAgY29uc3QgbmV3RHN0ID0gKGRzdCA/PyBuZXcgQ3Rvcig0KSk7XG4gICAgICAgIG5ld0RzdFswXSA9IHZbMF0gKiBrO1xuICAgICAgICBuZXdEc3RbMV0gPSB2WzFdICogaztcbiAgICAgICAgbmV3RHN0WzJdID0gdlsyXSAqIGs7XG4gICAgICAgIG5ld0RzdFszXSA9IHZbM10gKiBrO1xuICAgICAgICByZXR1cm4gbmV3RHN0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBNdWx0aXBsaWVzIGEgcXVhdGVybmlvbiBieSBhIHNjYWxhci4gKHNhbWUgYXMgbXVsU2NhbGFyKVxuICAgICAqIEBwYXJhbSB2IC0gVGhlIHF1YXRlcm5pb24uXG4gICAgICogQHBhcmFtIGsgLSBUaGUgc2NhbGFyLlxuICAgICAqIEBwYXJhbSBkc3QgLSBxdWF0ZXJuaW9uIHRvIGhvbGQgcmVzdWx0LiBJZiBub3QgcGFzc2VkIGluIGEgbmV3IG9uZSBpcyBjcmVhdGVkLlxuICAgICAqIEByZXR1cm5zIFRoZSBzY2FsZWQgcXVhdGVybmlvbi5cbiAgICAgKi9cbiAgICBjb25zdCBzY2FsZSA9IG11bFNjYWxhcjtcbiAgICAvKipcbiAgICAgKiBEaXZpZGVzIGEgdmVjdG9yIGJ5IGEgc2NhbGFyLlxuICAgICAqIEBwYXJhbSB2IC0gVGhlIHZlY3Rvci5cbiAgICAgKiBAcGFyYW0gayAtIFRoZSBzY2FsYXIuXG4gICAgICogQHBhcmFtIGRzdCAtIHF1YXRlcm5pb24gdG8gaG9sZCByZXN1bHQuIElmIG5vdCBwYXNzZWQgaW4gYSBuZXcgb25lIGlzIGNyZWF0ZWQuXG4gICAgICogQHJldHVybnMgVGhlIHNjYWxlZCBxdWF0ZXJuaW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGRpdlNjYWxhcih2LCBrLCBkc3QpIHtcbiAgICAgICAgY29uc3QgbmV3RHN0ID0gKGRzdCA/PyBuZXcgQ3Rvcig0KSk7XG4gICAgICAgIG5ld0RzdFswXSA9IHZbMF0gLyBrO1xuICAgICAgICBuZXdEc3RbMV0gPSB2WzFdIC8gaztcbiAgICAgICAgbmV3RHN0WzJdID0gdlsyXSAvIGs7XG4gICAgICAgIG5ld0RzdFszXSA9IHZbM10gLyBrO1xuICAgICAgICByZXR1cm4gbmV3RHN0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb21wdXRlcyB0aGUgZG90IHByb2R1Y3Qgb2YgdHdvIHF1YXRlcm5pb25zXG4gICAgICogQHBhcmFtIGEgLSBPcGVyYW5kIHF1YXRlcm5pb24uXG4gICAgICogQHBhcmFtIGIgLSBPcGVyYW5kIHF1YXRlcm5pb24uXG4gICAgICogQHJldHVybnMgZG90IHByb2R1Y3RcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBkb3QoYSwgYikge1xuICAgICAgICByZXR1cm4gKGFbMF0gKiBiWzBdKSArIChhWzFdICogYlsxXSkgKyAoYVsyXSAqIGJbMl0pICsgKGFbM10gKiBiWzNdKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUGVyZm9ybXMgbGluZWFyIGludGVycG9sYXRpb24gb24gdHdvIHF1YXRlcm5pb25zLlxuICAgICAqIEdpdmVuIHF1YXRlcm5pb25zIGEgYW5kIGIgYW5kIGludGVycG9sYXRpb24gY29lZmZpY2llbnQgdCwgcmV0dXJuc1xuICAgICAqIGEgKyB0ICogKGIgLSBhKS5cbiAgICAgKiBAcGFyYW0gYSAtIE9wZXJhbmQgcXVhdGVybmlvbi5cbiAgICAgKiBAcGFyYW0gYiAtIE9wZXJhbmQgcXVhdGVybmlvbi5cbiAgICAgKiBAcGFyYW0gdCAtIEludGVycG9sYXRpb24gY29lZmZpY2llbnQuXG4gICAgICogQHBhcmFtIGRzdCAtIHF1YXRlcm5pb24gdG8gaG9sZCByZXN1bHQuIElmIG5vdCBwYXNzZWQgaW4gYSBuZXcgb25lIGlzIGNyZWF0ZWQuXG4gICAgICogQHJldHVybnMgVGhlIGxpbmVhciBpbnRlcnBvbGF0ZWQgcmVzdWx0LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGxlcnAoYSwgYiwgdCwgZHN0KSB7XG4gICAgICAgIGNvbnN0IG5ld0RzdCA9IChkc3QgPz8gbmV3IEN0b3IoNCkpO1xuICAgICAgICBuZXdEc3RbMF0gPSBhWzBdICsgdCAqIChiWzBdIC0gYVswXSk7XG4gICAgICAgIG5ld0RzdFsxXSA9IGFbMV0gKyB0ICogKGJbMV0gLSBhWzFdKTtcbiAgICAgICAgbmV3RHN0WzJdID0gYVsyXSArIHQgKiAoYlsyXSAtIGFbMl0pO1xuICAgICAgICBuZXdEc3RbM10gPSBhWzNdICsgdCAqIChiWzNdIC0gYVszXSk7XG4gICAgICAgIHJldHVybiBuZXdEc3Q7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbXB1dGVzIHRoZSBsZW5ndGggb2YgcXVhdGVybmlvblxuICAgICAqIEBwYXJhbSB2IC0gcXVhdGVybmlvbi5cbiAgICAgKiBAcmV0dXJucyBsZW5ndGggb2YgcXVhdGVybmlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBsZW5ndGgodikge1xuICAgICAgICBjb25zdCB2MCA9IHZbMF07XG4gICAgICAgIGNvbnN0IHYxID0gdlsxXTtcbiAgICAgICAgY29uc3QgdjIgPSB2WzJdO1xuICAgICAgICBjb25zdCB2MyA9IHZbM107XG4gICAgICAgIHJldHVybiBNYXRoLnNxcnQodjAgKiB2MCArIHYxICogdjEgKyB2MiAqIHYyICsgdjMgKiB2Myk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbXB1dGVzIHRoZSBsZW5ndGggb2YgcXVhdGVybmlvbiAoc2FtZSBhcyBsZW5ndGgpXG4gICAgICogQHBhcmFtIHYgLSBxdWF0ZXJuaW9uLlxuICAgICAqIEByZXR1cm5zIGxlbmd0aCBvZiBxdWF0ZXJuaW9uLlxuICAgICAqL1xuICAgIGNvbnN0IGxlbiA9IGxlbmd0aDtcbiAgICAvKipcbiAgICAgKiBDb21wdXRlcyB0aGUgc3F1YXJlIG9mIHRoZSBsZW5ndGggb2YgcXVhdGVybmlvblxuICAgICAqIEBwYXJhbSB2IC0gcXVhdGVybmlvbi5cbiAgICAgKiBAcmV0dXJucyBzcXVhcmUgb2YgdGhlIGxlbmd0aCBvZiBxdWF0ZXJuaW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGxlbmd0aFNxKHYpIHtcbiAgICAgICAgY29uc3QgdjAgPSB2WzBdO1xuICAgICAgICBjb25zdCB2MSA9IHZbMV07XG4gICAgICAgIGNvbnN0IHYyID0gdlsyXTtcbiAgICAgICAgY29uc3QgdjMgPSB2WzNdO1xuICAgICAgICByZXR1cm4gdjAgKiB2MCArIHYxICogdjEgKyB2MiAqIHYyICsgdjMgKiB2MztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29tcHV0ZXMgdGhlIHNxdWFyZSBvZiB0aGUgbGVuZ3RoIG9mIHF1YXRlcm5pb24gKHNhbWUgYXMgbGVuZ3RoU3EpXG4gICAgICogQHBhcmFtIHYgLSBxdWF0ZXJuaW9uLlxuICAgICAqIEByZXR1cm5zIHNxdWFyZSBvZiB0aGUgbGVuZ3RoIG9mIHF1YXRlcm5pb24uXG4gICAgICovXG4gICAgY29uc3QgbGVuU3EgPSBsZW5ndGhTcTtcbiAgICAvKipcbiAgICAgKiBEaXZpZGVzIGEgcXVhdGVybmlvbiBieSBpdHMgRXVjbGlkZWFuIGxlbmd0aCBhbmQgcmV0dXJucyB0aGUgcXVvdGllbnQuXG4gICAgICogQHBhcmFtIHYgLSBUaGUgcXVhdGVybmlvbi5cbiAgICAgKiBAcGFyYW0gZHN0IC0gcXVhdGVybmlvbiB0byBob2xkIHJlc3VsdC4gSWYgbm90IHBhc3NlZCBpbiBhIG5ldyBvbmUgaXMgY3JlYXRlZC5cbiAgICAgKiBAcmV0dXJucyBUaGUgbm9ybWFsaXplZCBxdWF0ZXJuaW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG5vcm1hbGl6ZSh2LCBkc3QpIHtcbiAgICAgICAgY29uc3QgbmV3RHN0ID0gKGRzdCA/PyBuZXcgQ3Rvcig0KSk7XG4gICAgICAgIGNvbnN0IHYwID0gdlswXTtcbiAgICAgICAgY29uc3QgdjEgPSB2WzFdO1xuICAgICAgICBjb25zdCB2MiA9IHZbMl07XG4gICAgICAgIGNvbnN0IHYzID0gdlszXTtcbiAgICAgICAgY29uc3QgbGVuID0gTWF0aC5zcXJ0KHYwICogdjAgKyB2MSAqIHYxICsgdjIgKiB2MiArIHYzICogdjMpO1xuICAgICAgICBpZiAobGVuID4gMC4wMDAwMSkge1xuICAgICAgICAgICAgbmV3RHN0WzBdID0gdjAgLyBsZW47XG4gICAgICAgICAgICBuZXdEc3RbMV0gPSB2MSAvIGxlbjtcbiAgICAgICAgICAgIG5ld0RzdFsyXSA9IHYyIC8gbGVuO1xuICAgICAgICAgICAgbmV3RHN0WzNdID0gdjMgLyBsZW47XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBuZXdEc3RbMF0gPSAwO1xuICAgICAgICAgICAgbmV3RHN0WzFdID0gMDtcbiAgICAgICAgICAgIG5ld0RzdFsyXSA9IDA7XG4gICAgICAgICAgICBuZXdEc3RbM10gPSAwO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXdEc3Q7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENoZWNrIGlmIDIgcXVhdGVybmlvbnMgYXJlIGFwcHJveGltYXRlbHkgZXF1YWxcbiAgICAgKiBAcGFyYW0gYSAtIE9wZXJhbmQgcXVhdGVybmlvbi5cbiAgICAgKiBAcGFyYW0gYiAtIE9wZXJhbmQgcXVhdGVybmlvbi5cbiAgICAgKiBAcmV0dXJucyB0cnVlIGlmIHF1YXRlcm5pb25zIGFyZSBhcHByb3hpbWF0ZWx5IGVxdWFsXG4gICAgICovXG4gICAgZnVuY3Rpb24gZXF1YWxzQXBwcm94aW1hdGVseShhLCBiKSB7XG4gICAgICAgIHJldHVybiBNYXRoLmFicyhhWzBdIC0gYlswXSkgPCBFUFNJTE9OICYmXG4gICAgICAgICAgICBNYXRoLmFicyhhWzFdIC0gYlsxXSkgPCBFUFNJTE9OICYmXG4gICAgICAgICAgICBNYXRoLmFicyhhWzJdIC0gYlsyXSkgPCBFUFNJTE9OICYmXG4gICAgICAgICAgICBNYXRoLmFicyhhWzNdIC0gYlszXSkgPCBFUFNJTE9OO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDaGVjayBpZiAyIHF1YXRlcm5pb25zIGFyZSBleGFjdGx5IGVxdWFsXG4gICAgICogQHBhcmFtIGEgLSBPcGVyYW5kIHF1YXRlcm5pb24uXG4gICAgICogQHBhcmFtIGIgLSBPcGVyYW5kIHF1YXRlcm5pb24uXG4gICAgICogQHJldHVybnMgdHJ1ZSBpZiBxdWF0ZXJuaW9ucyBhcmUgZXhhY3RseSBlcXVhbFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGVxdWFscyhhLCBiKSB7XG4gICAgICAgIHJldHVybiBhWzBdID09PSBiWzBdICYmIGFbMV0gPT09IGJbMV0gJiYgYVsyXSA9PT0gYlsyXSAmJiBhWzNdID09PSBiWzNdO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGlkZW50aXR5IHF1YXRlcm5pb25cbiAgICAgKiBAcGFyYW0gZHN0IC0gcXVhdGVybmlvbiB0byBob2xkIHJlc3VsdC4gSWYgbm90IHBhc3NlZCBpbiBhIG5ldyBvbmUgaXMgY3JlYXRlZC5cbiAgICAgKiBAcmV0dXJucyBhbiBpZGVudGl0eSBxdWF0ZXJuaW9uXG4gICAgICovXG4gICAgZnVuY3Rpb24gaWRlbnRpdHkoZHN0KSB7XG4gICAgICAgIGNvbnN0IG5ld0RzdCA9IChkc3QgPz8gbmV3IEN0b3IoNCkpO1xuICAgICAgICBuZXdEc3RbMF0gPSAwO1xuICAgICAgICBuZXdEc3RbMV0gPSAwO1xuICAgICAgICBuZXdEc3RbMl0gPSAwO1xuICAgICAgICBuZXdEc3RbM10gPSAxO1xuICAgICAgICByZXR1cm4gbmV3RHN0O1xuICAgIH1cbiAgICBjb25zdCB0ZW1wVmVjMyA9IHZlYzMuY3JlYXRlKCk7XG4gICAgY29uc3QgeFVuaXRWZWMzID0gdmVjMy5jcmVhdGUoKTtcbiAgICBjb25zdCB5VW5pdFZlYzMgPSB2ZWMzLmNyZWF0ZSgpO1xuICAgIC8qKlxuICAgICAqIENvbXB1dGVzIGEgcXVhdGVybmlvbiB0byByZXByZXNlbnQgdGhlIHNob3J0ZXN0IHJvdGF0aW9uIGZyb20gb25lIHZlY3RvciB0byBhbm90aGVyLlxuICAgICAqXG4gICAgICogQHBhcmFtIGFVbml0IC0gdGhlIHN0YXJ0IHZlY3RvclxuICAgICAqIEBwYXJhbSBiVW5pdCAtIHRoZSBlbmQgdmVjdG9yXG4gICAgICogQHBhcmFtIGRzdCAtIHF1YXRlcm5pb24gdG8gaG9sZCByZXN1bHQuIElmIG5vdCBwYXNzZWQgaW4gYSBuZXcgb25lIGlzIGNyZWF0ZWQuXG4gICAgICogQHJldHVybnMgdGhlIHJlc3VsdFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHJvdGF0aW9uVG8oYVVuaXQsIGJVbml0LCBkc3QpIHtcbiAgICAgICAgY29uc3QgbmV3RHN0ID0gKGRzdCA/PyBuZXcgQ3Rvcig0KSk7XG4gICAgICAgIGNvbnN0IGRvdCA9IHZlYzMuZG90KGFVbml0LCBiVW5pdCk7XG4gICAgICAgIGlmIChkb3QgPCAtMC45OTk5OTkpIHtcbiAgICAgICAgICAgIHZlYzMuY3Jvc3MoeFVuaXRWZWMzLCBhVW5pdCwgdGVtcFZlYzMpO1xuICAgICAgICAgICAgaWYgKHZlYzMubGVuKHRlbXBWZWMzKSA8IDAuMDAwMDAxKSB7XG4gICAgICAgICAgICAgICAgdmVjMy5jcm9zcyh5VW5pdFZlYzMsIGFVbml0LCB0ZW1wVmVjMyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2ZWMzLm5vcm1hbGl6ZSh0ZW1wVmVjMywgdGVtcFZlYzMpO1xuICAgICAgICAgICAgZnJvbUF4aXNBbmdsZSh0ZW1wVmVjMywgTWF0aC5QSSwgbmV3RHN0KTtcbiAgICAgICAgICAgIHJldHVybiBuZXdEc3Q7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZG90ID4gMC45OTk5OTkpIHtcbiAgICAgICAgICAgIG5ld0RzdFswXSA9IDA7XG4gICAgICAgICAgICBuZXdEc3RbMV0gPSAwO1xuICAgICAgICAgICAgbmV3RHN0WzJdID0gMDtcbiAgICAgICAgICAgIG5ld0RzdFszXSA9IDE7XG4gICAgICAgICAgICByZXR1cm4gbmV3RHN0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmVjMy5jcm9zcyhhVW5pdCwgYlVuaXQsIHRlbXBWZWMzKTtcbiAgICAgICAgICAgIG5ld0RzdFswXSA9IHRlbXBWZWMzWzBdO1xuICAgICAgICAgICAgbmV3RHN0WzFdID0gdGVtcFZlYzNbMV07XG4gICAgICAgICAgICBuZXdEc3RbMl0gPSB0ZW1wVmVjM1syXTtcbiAgICAgICAgICAgIG5ld0RzdFszXSA9IDEgKyBkb3Q7XG4gICAgICAgICAgICByZXR1cm4gbm9ybWFsaXplKG5ld0RzdCwgbmV3RHN0KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb25zdCB0ZW1wUXVhdDEgPSBuZXcgQ3Rvcig0KTtcbiAgICBjb25zdCB0ZW1wUXVhdDIgPSBuZXcgQ3Rvcig0KTtcbiAgICAvKipcbiAgICAgKiBQZXJmb3JtcyBhIHNwaGVyaWNhbCBsaW5lYXIgaW50ZXJwb2xhdGlvbiB3aXRoIHR3byBjb250cm9sIHBvaW50c1xuICAgICAqXG4gICAgICogQHBhcmFtIGEgLSB0aGUgZmlyc3QgcXVhdGVybmlvblxuICAgICAqIEBwYXJhbSBiIC0gdGhlIHNlY29uZCBxdWF0ZXJuaW9uXG4gICAgICogQHBhcmFtIGMgLSB0aGUgdGhpcmQgcXVhdGVybmlvblxuICAgICAqIEBwYXJhbSBkIC0gdGhlIGZvdXJ0aCBxdWF0ZXJuaW9uXG4gICAgICogQHBhcmFtIHQgLSBJbnRlcnBvbGF0aW9uIGNvZWZmaWNpZW50IDAgdG8gMVxuICAgICAqIEByZXR1cm5zIHJlc3VsdFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNxbGVycChhLCBiLCBjLCBkLCB0LCBkc3QpIHtcbiAgICAgICAgY29uc3QgbmV3RHN0ID0gKGRzdCA/PyBuZXcgQ3Rvcig0KSk7XG4gICAgICAgIHNsZXJwKGEsIGQsIHQsIHRlbXBRdWF0MSk7XG4gICAgICAgIHNsZXJwKGIsIGMsIHQsIHRlbXBRdWF0Mik7XG4gICAgICAgIHNsZXJwKHRlbXBRdWF0MSwgdGVtcFF1YXQyLCAyICogdCAqICgxIC0gdCksIG5ld0RzdCk7XG4gICAgICAgIHJldHVybiBuZXdEc3Q7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIGNyZWF0ZSxcbiAgICAgICAgZnJvbVZhbHVlcyxcbiAgICAgICAgc2V0LFxuICAgICAgICBmcm9tQXhpc0FuZ2xlLFxuICAgICAgICB0b0F4aXNBbmdsZSxcbiAgICAgICAgYW5nbGUsXG4gICAgICAgIG11bHRpcGx5LFxuICAgICAgICBtdWwsXG4gICAgICAgIHJvdGF0ZVgsXG4gICAgICAgIHJvdGF0ZVksXG4gICAgICAgIHJvdGF0ZVosXG4gICAgICAgIHNsZXJwLFxuICAgICAgICBpbnZlcnNlLFxuICAgICAgICBjb25qdWdhdGUsXG4gICAgICAgIGZyb21NYXQsXG4gICAgICAgIGZyb21FdWxlcixcbiAgICAgICAgY29weSxcbiAgICAgICAgY2xvbmUsXG4gICAgICAgIGFkZCxcbiAgICAgICAgc3VidHJhY3QsXG4gICAgICAgIHN1YixcbiAgICAgICAgbXVsU2NhbGFyLFxuICAgICAgICBzY2FsZSxcbiAgICAgICAgZGl2U2NhbGFyLFxuICAgICAgICBkb3QsXG4gICAgICAgIGxlcnAsXG4gICAgICAgIGxlbmd0aCxcbiAgICAgICAgbGVuLFxuICAgICAgICBsZW5ndGhTcSxcbiAgICAgICAgbGVuU3EsXG4gICAgICAgIG5vcm1hbGl6ZSxcbiAgICAgICAgZXF1YWxzQXBwcm94aW1hdGVseSxcbiAgICAgICAgZXF1YWxzLFxuICAgICAgICBpZGVudGl0eSxcbiAgICAgICAgcm90YXRpb25UbyxcbiAgICAgICAgc3FsZXJwLFxuICAgIH07XG59XG5jb25zdCBjYWNoZSQxID0gbmV3IE1hcCgpO1xuLyoqXG4gKlxuICogUXVhdDQgbWF0aCBmdW5jdGlvbnMuXG4gKlxuICogQWxtb3N0IGFsbCBmdW5jdGlvbnMgdGFrZSBhbiBvcHRpb25hbCBgbmV3RHN0YCBhcmd1bWVudC4gSWYgaXQgaXMgbm90IHBhc3NlZCBpbiB0aGVcbiAqIGZ1bmN0aW9ucyB3aWxsIGNyZWF0ZSBhIG5ldyBgUXVhdDRgLiBJbiBvdGhlciB3b3JkcyB5b3UgY2FuIGRvIHRoaXNcbiAqXG4gKiAgICAgY29uc3QgdiA9IHF1YXQ0LmNyb3NzKHYxLCB2Mik7ICAvLyBDcmVhdGVzIGEgbmV3IFF1YXQ0IHdpdGggdGhlIGNyb3NzIHByb2R1Y3Qgb2YgdjEgeCB2Mi5cbiAqXG4gKiBvclxuICpcbiAqICAgICBjb25zdCB2ID0gcXVhdDQuY3JlYXRlKCk7XG4gKiAgICAgcXVhdDQuY3Jvc3ModjEsIHYyLCB2KTsgIC8vIFB1dHMgdGhlIGNyb3NzIHByb2R1Y3Qgb2YgdjEgeCB2MiBpbiB2XG4gKlxuICogVGhlIGZpcnN0IHN0eWxlIGlzIG9mdGVuIGVhc2llciBidXQgZGVwZW5kaW5nIG9uIHdoZXJlIGl0J3MgdXNlZCBpdCBnZW5lcmF0ZXMgZ2FyYmFnZSB3aGVyZVxuICogYXMgdGhlcmUgaXMgYWxtb3N0IG5ldmVyIGFsbG9jYXRpb24gd2l0aCB0aGUgc2Vjb25kIHN0eWxlLlxuICpcbiAqIEl0IGlzIGFsd2F5cyBzYWZlIHRvIHBhc3MgYW55IHZlY3RvciBhcyB0aGUgZGVzdGluYXRpb24uIFNvIGZvciBleGFtcGxlXG4gKlxuICogICAgIHF1YXQ0LmNyb3NzKHYxLCB2MiwgdjEpOyAgLy8gUHV0cyB0aGUgY3Jvc3MgcHJvZHVjdCBvZiB2MSB4IHYyIGluIHYxXG4gKlxuICovXG5mdW5jdGlvbiBnZXRBUEkkMShDdG9yKSB7XG4gICAgbGV0IGFwaSA9IGNhY2hlJDEuZ2V0KEN0b3IpO1xuICAgIGlmICghYXBpKSB7XG4gICAgICAgIGFwaSA9IGdldEFQSUltcGwkMShDdG9yKTtcbiAgICAgICAgY2FjaGUkMS5zZXQoQ3RvciwgYXBpKTtcbiAgICB9XG4gICAgcmV0dXJuIGFwaTtcbn1cblxuLypcbiAqIENvcHlyaWdodCAyMDIyIEdyZWdnIFRhdmFyZXNcbiAqXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuICogY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLFxuICogdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvblxuICogdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsXG4gKiBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGVcbiAqIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4gKlxuICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbiAqIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuICpcbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbiAqIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gIElOIE5PIEVWRU5UIFNIQUxMXG4gKiBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuICogTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkdcbiAqIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVJcbiAqIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cbiAqL1xuLyoqXG4gKiBHZW5lcmF0ZXMgYW0gdHlwZWQgQVBJIGZvciBWZWM0XG4gKiAqL1xuZnVuY3Rpb24gZ2V0QVBJSW1wbChDdG9yKSB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIHZlYzQ7IG1heSBiZSBjYWxsZWQgd2l0aCB4LCB5LCB6IHRvIHNldCBpbml0aWFsIHZhbHVlcy5cbiAgICAgKiBAcGFyYW0geCAtIEluaXRpYWwgeCB2YWx1ZS5cbiAgICAgKiBAcGFyYW0geSAtIEluaXRpYWwgeSB2YWx1ZS5cbiAgICAgKiBAcGFyYW0geiAtIEluaXRpYWwgeiB2YWx1ZS5cbiAgICAgKiBAcGFyYW0gdyAtIEluaXRpYWwgdyB2YWx1ZS5cbiAgICAgKiBAcmV0dXJucyB0aGUgY3JlYXRlZCB2ZWN0b3JcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGUoeCwgeSwgeiwgdykge1xuICAgICAgICBjb25zdCBuZXdEc3QgPSBuZXcgQ3Rvcig0KTtcbiAgICAgICAgaWYgKHggIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgbmV3RHN0WzBdID0geDtcbiAgICAgICAgICAgIGlmICh5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBuZXdEc3RbMV0gPSB5O1xuICAgICAgICAgICAgICAgIGlmICh6ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgbmV3RHN0WzJdID0gejtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHcgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV3RHN0WzNdID0gdztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3RHN0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgdmVjNDsgbWF5IGJlIGNhbGxlZCB3aXRoIHgsIHksIHogdG8gc2V0IGluaXRpYWwgdmFsdWVzLiAoc2FtZSBhcyBjcmVhdGUpXG4gICAgICogQHBhcmFtIHggLSBJbml0aWFsIHggdmFsdWUuXG4gICAgICogQHBhcmFtIHkgLSBJbml0aWFsIHkgdmFsdWUuXG4gICAgICogQHBhcmFtIHogLSBJbml0aWFsIHogdmFsdWUuXG4gICAgICogQHBhcmFtIHogLSBJbml0aWFsIHcgdmFsdWUuXG4gICAgICogQHJldHVybnMgdGhlIGNyZWF0ZWQgdmVjdG9yXG4gICAgICovXG4gICAgY29uc3QgZnJvbVZhbHVlcyA9IGNyZWF0ZTtcbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSB2YWx1ZXMgb2YgYSBWZWM0XG4gICAgICogQWxzbyBzZWUge0BsaW5rIHZlYzQuY3JlYXRlfSBhbmQge0BsaW5rIHZlYzQuY29weX1cbiAgICAgKlxuICAgICAqIEBwYXJhbSB4IGZpcnN0IHZhbHVlXG4gICAgICogQHBhcmFtIHkgc2Vjb25kIHZhbHVlXG4gICAgICogQHBhcmFtIHogdGhpcmQgdmFsdWVcbiAgICAgKiBAcGFyYW0gdyBmb3VydGggdmFsdWVcbiAgICAgKiBAcGFyYW0gZHN0IC0gdmVjdG9yIHRvIGhvbGQgcmVzdWx0LiBJZiBub3QgcGFzc2VkIGluIGEgbmV3IG9uZSBpcyBjcmVhdGVkLlxuICAgICAqIEByZXR1cm5zIEEgdmVjdG9yIHdpdGggaXRzIGVsZW1lbnRzIHNldC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzZXQoeCwgeSwgeiwgdywgZHN0KSB7XG4gICAgICAgIGNvbnN0IG5ld0RzdCA9IChkc3QgPz8gbmV3IEN0b3IoNCkpO1xuICAgICAgICBuZXdEc3RbMF0gPSB4O1xuICAgICAgICBuZXdEc3RbMV0gPSB5O1xuICAgICAgICBuZXdEc3RbMl0gPSB6O1xuICAgICAgICBuZXdEc3RbM10gPSB3O1xuICAgICAgICByZXR1cm4gbmV3RHN0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBcHBsaWVzIE1hdGguY2VpbCB0byBlYWNoIGVsZW1lbnQgb2YgdmVjdG9yXG4gICAgICogQHBhcmFtIHYgLSBPcGVyYW5kIHZlY3Rvci5cbiAgICAgKiBAcGFyYW0gZHN0IC0gdmVjdG9yIHRvIGhvbGQgcmVzdWx0LiBJZiBub3QgcGFzc2VkIGluIGEgbmV3IG9uZSBpcyBjcmVhdGVkLlxuICAgICAqIEByZXR1cm5zIEEgdmVjdG9yIHRoYXQgaXMgdGhlIGNlaWwgb2YgZWFjaCBlbGVtZW50IG9mIHYuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY2VpbCh2LCBkc3QpIHtcbiAgICAgICAgY29uc3QgbmV3RHN0ID0gKGRzdCA/PyBuZXcgQ3Rvcig0KSk7XG4gICAgICAgIG5ld0RzdFswXSA9IE1hdGguY2VpbCh2WzBdKTtcbiAgICAgICAgbmV3RHN0WzFdID0gTWF0aC5jZWlsKHZbMV0pO1xuICAgICAgICBuZXdEc3RbMl0gPSBNYXRoLmNlaWwodlsyXSk7XG4gICAgICAgIG5ld0RzdFszXSA9IE1hdGguY2VpbCh2WzNdKTtcbiAgICAgICAgcmV0dXJuIG5ld0RzdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQXBwbGllcyBNYXRoLmZsb29yIHRvIGVhY2ggZWxlbWVudCBvZiB2ZWN0b3JcbiAgICAgKiBAcGFyYW0gdiAtIE9wZXJhbmQgdmVjdG9yLlxuICAgICAqIEBwYXJhbSBkc3QgLSB2ZWN0b3IgdG8gaG9sZCByZXN1bHQuIElmIG5vdCBwYXNzZWQgaW4gYSBuZXcgb25lIGlzIGNyZWF0ZWQuXG4gICAgICogQHJldHVybnMgQSB2ZWN0b3IgdGhhdCBpcyB0aGUgZmxvb3Igb2YgZWFjaCBlbGVtZW50IG9mIHYuXG4gICAgICovXG4gICAgZnVuY3Rpb24gZmxvb3IodiwgZHN0KSB7XG4gICAgICAgIGNvbnN0IG5ld0RzdCA9IChkc3QgPz8gbmV3IEN0b3IoNCkpO1xuICAgICAgICBuZXdEc3RbMF0gPSBNYXRoLmZsb29yKHZbMF0pO1xuICAgICAgICBuZXdEc3RbMV0gPSBNYXRoLmZsb29yKHZbMV0pO1xuICAgICAgICBuZXdEc3RbMl0gPSBNYXRoLmZsb29yKHZbMl0pO1xuICAgICAgICBuZXdEc3RbM10gPSBNYXRoLmZsb29yKHZbM10pO1xuICAgICAgICByZXR1cm4gbmV3RHN0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBcHBsaWVzIE1hdGgucm91bmQgdG8gZWFjaCBlbGVtZW50IG9mIHZlY3RvclxuICAgICAqIEBwYXJhbSB2IC0gT3BlcmFuZCB2ZWN0b3IuXG4gICAgICogQHBhcmFtIGRzdCAtIHZlY3RvciB0byBob2xkIHJlc3VsdC4gSWYgbm90IHBhc3NlZCBpbiBhIG5ldyBvbmUgaXMgY3JlYXRlZC5cbiAgICAgKiBAcmV0dXJucyBBIHZlY3RvciB0aGF0IGlzIHRoZSByb3VuZCBvZiBlYWNoIGVsZW1lbnQgb2Ygdi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiByb3VuZCh2LCBkc3QpIHtcbiAgICAgICAgY29uc3QgbmV3RHN0ID0gKGRzdCA/PyBuZXcgQ3Rvcig0KSk7XG4gICAgICAgIG5ld0RzdFswXSA9IE1hdGgucm91bmQodlswXSk7XG4gICAgICAgIG5ld0RzdFsxXSA9IE1hdGgucm91bmQodlsxXSk7XG4gICAgICAgIG5ld0RzdFsyXSA9IE1hdGgucm91bmQodlsyXSk7XG4gICAgICAgIG5ld0RzdFszXSA9IE1hdGgucm91bmQodlszXSk7XG4gICAgICAgIHJldHVybiBuZXdEc3Q7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENsYW1wIGVhY2ggZWxlbWVudCBvZiB2ZWN0b3IgYmV0d2VlbiBtaW4gYW5kIG1heFxuICAgICAqIEBwYXJhbSB2IC0gT3BlcmFuZCB2ZWN0b3IuXG4gICAgICogQHBhcmFtIG1heCAtIE1pbiB2YWx1ZSwgZGVmYXVsdCAwXG4gICAgICogQHBhcmFtIG1pbiAtIE1heCB2YWx1ZSwgZGVmYXVsdCAxXG4gICAgICogQHBhcmFtIGRzdCAtIHZlY3RvciB0byBob2xkIHJlc3VsdC4gSWYgbm90IHBhc3NlZCBpbiBhIG5ldyBvbmUgaXMgY3JlYXRlZC5cbiAgICAgKiBAcmV0dXJucyBBIHZlY3RvciB0aGF0IHRoZSBjbGFtcGVkIHZhbHVlIG9mIGVhY2ggZWxlbWVudCBvZiB2LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNsYW1wKHYsIG1pbiA9IDAsIG1heCA9IDEsIGRzdCkge1xuICAgICAgICBjb25zdCBuZXdEc3QgPSAoZHN0ID8/IG5ldyBDdG9yKDQpKTtcbiAgICAgICAgbmV3RHN0WzBdID0gTWF0aC5taW4obWF4LCBNYXRoLm1heChtaW4sIHZbMF0pKTtcbiAgICAgICAgbmV3RHN0WzFdID0gTWF0aC5taW4obWF4LCBNYXRoLm1heChtaW4sIHZbMV0pKTtcbiAgICAgICAgbmV3RHN0WzJdID0gTWF0aC5taW4obWF4LCBNYXRoLm1heChtaW4sIHZbMl0pKTtcbiAgICAgICAgbmV3RHN0WzNdID0gTWF0aC5taW4obWF4LCBNYXRoLm1heChtaW4sIHZbM10pKTtcbiAgICAgICAgcmV0dXJuIG5ld0RzdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWRkcyB0d28gdmVjdG9yczsgYXNzdW1lcyBhIGFuZCBiIGhhdmUgdGhlIHNhbWUgZGltZW5zaW9uLlxuICAgICAqIEBwYXJhbSBhIC0gT3BlcmFuZCB2ZWN0b3IuXG4gICAgICogQHBhcmFtIGIgLSBPcGVyYW5kIHZlY3Rvci5cbiAgICAgKiBAcGFyYW0gZHN0IC0gdmVjdG9yIHRvIGhvbGQgcmVzdWx0LiBJZiBub3QgcGFzc2VkIGluIGEgbmV3IG9uZSBpcyBjcmVhdGVkLlxuICAgICAqIEByZXR1cm5zIEEgdmVjdG9yIHRoYXQgaXMgdGhlIHN1bSBvZiBhIGFuZCBiLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGFkZChhLCBiLCBkc3QpIHtcbiAgICAgICAgY29uc3QgbmV3RHN0ID0gKGRzdCA/PyBuZXcgQ3Rvcig0KSk7XG4gICAgICAgIG5ld0RzdFswXSA9IGFbMF0gKyBiWzBdO1xuICAgICAgICBuZXdEc3RbMV0gPSBhWzFdICsgYlsxXTtcbiAgICAgICAgbmV3RHN0WzJdID0gYVsyXSArIGJbMl07XG4gICAgICAgIG5ld0RzdFszXSA9IGFbM10gKyBiWzNdO1xuICAgICAgICByZXR1cm4gbmV3RHN0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGRzIHR3byB2ZWN0b3JzLCBzY2FsaW5nIHRoZSAybmQ7IGFzc3VtZXMgYSBhbmQgYiBoYXZlIHRoZSBzYW1lIGRpbWVuc2lvbi5cbiAgICAgKiBAcGFyYW0gYSAtIE9wZXJhbmQgdmVjdG9yLlxuICAgICAqIEBwYXJhbSBiIC0gT3BlcmFuZCB2ZWN0b3IuXG4gICAgICogQHBhcmFtIHNjYWxlIC0gQW1vdW50IHRvIHNjYWxlIGJcbiAgICAgKiBAcGFyYW0gZHN0IC0gdmVjdG9yIHRvIGhvbGQgcmVzdWx0LiBJZiBub3QgcGFzc2VkIGluIGEgbmV3IG9uZSBpcyBjcmVhdGVkLlxuICAgICAqIEByZXR1cm5zIEEgdmVjdG9yIHRoYXQgaXMgdGhlIHN1bSBvZiBhICsgYiAqIHNjYWxlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGFkZFNjYWxlZChhLCBiLCBzY2FsZSwgZHN0KSB7XG4gICAgICAgIGNvbnN0IG5ld0RzdCA9IChkc3QgPz8gbmV3IEN0b3IoNCkpO1xuICAgICAgICBuZXdEc3RbMF0gPSBhWzBdICsgYlswXSAqIHNjYWxlO1xuICAgICAgICBuZXdEc3RbMV0gPSBhWzFdICsgYlsxXSAqIHNjYWxlO1xuICAgICAgICBuZXdEc3RbMl0gPSBhWzJdICsgYlsyXSAqIHNjYWxlO1xuICAgICAgICBuZXdEc3RbM10gPSBhWzNdICsgYlszXSAqIHNjYWxlO1xuICAgICAgICByZXR1cm4gbmV3RHN0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTdWJ0cmFjdHMgdHdvIHZlY3RvcnMuXG4gICAgICogQHBhcmFtIGEgLSBPcGVyYW5kIHZlY3Rvci5cbiAgICAgKiBAcGFyYW0gYiAtIE9wZXJhbmQgdmVjdG9yLlxuICAgICAqIEBwYXJhbSBkc3QgLSB2ZWN0b3IgdG8gaG9sZCByZXN1bHQuIElmIG5vdCBwYXNzZWQgaW4gYSBuZXcgb25lIGlzIGNyZWF0ZWQuXG4gICAgICogQHJldHVybnMgQSB2ZWN0b3IgdGhhdCBpcyB0aGUgZGlmZmVyZW5jZSBvZiBhIGFuZCBiLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHN1YnRyYWN0KGEsIGIsIGRzdCkge1xuICAgICAgICBjb25zdCBuZXdEc3QgPSAoZHN0ID8/IG5ldyBDdG9yKDQpKTtcbiAgICAgICAgbmV3RHN0WzBdID0gYVswXSAtIGJbMF07XG4gICAgICAgIG5ld0RzdFsxXSA9IGFbMV0gLSBiWzFdO1xuICAgICAgICBuZXdEc3RbMl0gPSBhWzJdIC0gYlsyXTtcbiAgICAgICAgbmV3RHN0WzNdID0gYVszXSAtIGJbM107XG4gICAgICAgIHJldHVybiBuZXdEc3Q7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFN1YnRyYWN0cyB0d28gdmVjdG9ycy5cbiAgICAgKiBAcGFyYW0gYSAtIE9wZXJhbmQgdmVjdG9yLlxuICAgICAqIEBwYXJhbSBiIC0gT3BlcmFuZCB2ZWN0b3IuXG4gICAgICogQHBhcmFtIGRzdCAtIHZlY3RvciB0byBob2xkIHJlc3VsdC4gSWYgbm90IHBhc3NlZCBpbiBhIG5ldyBvbmUgaXMgY3JlYXRlZC5cbiAgICAgKiBAcmV0dXJucyBBIHZlY3RvciB0aGF0IGlzIHRoZSBkaWZmZXJlbmNlIG9mIGEgYW5kIGIuXG4gICAgICovXG4gICAgY29uc3Qgc3ViID0gc3VidHJhY3Q7XG4gICAgLyoqXG4gICAgICogQ2hlY2sgaWYgMiB2ZWN0b3JzIGFyZSBhcHByb3hpbWF0ZWx5IGVxdWFsXG4gICAgICogQHBhcmFtIGEgLSBPcGVyYW5kIHZlY3Rvci5cbiAgICAgKiBAcGFyYW0gYiAtIE9wZXJhbmQgdmVjdG9yLlxuICAgICAqIEByZXR1cm5zIHRydWUgaWYgdmVjdG9ycyBhcmUgYXBwcm94aW1hdGVseSBlcXVhbFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGVxdWFsc0FwcHJveGltYXRlbHkoYSwgYikge1xuICAgICAgICByZXR1cm4gTWF0aC5hYnMoYVswXSAtIGJbMF0pIDwgRVBTSUxPTiAmJlxuICAgICAgICAgICAgTWF0aC5hYnMoYVsxXSAtIGJbMV0pIDwgRVBTSUxPTiAmJlxuICAgICAgICAgICAgTWF0aC5hYnMoYVsyXSAtIGJbMl0pIDwgRVBTSUxPTiAmJlxuICAgICAgICAgICAgTWF0aC5hYnMoYVszXSAtIGJbM10pIDwgRVBTSUxPTjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2hlY2sgaWYgMiB2ZWN0b3JzIGFyZSBleGFjdGx5IGVxdWFsXG4gICAgICogQHBhcmFtIGEgLSBPcGVyYW5kIHZlY3Rvci5cbiAgICAgKiBAcGFyYW0gYiAtIE9wZXJhbmQgdmVjdG9yLlxuICAgICAqIEByZXR1cm5zIHRydWUgaWYgdmVjdG9ycyBhcmUgZXhhY3RseSBlcXVhbFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGVxdWFscyhhLCBiKSB7XG4gICAgICAgIHJldHVybiBhWzBdID09PSBiWzBdICYmIGFbMV0gPT09IGJbMV0gJiYgYVsyXSA9PT0gYlsyXSAmJiBhWzNdID09PSBiWzNdO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQZXJmb3JtcyBsaW5lYXIgaW50ZXJwb2xhdGlvbiBvbiB0d28gdmVjdG9ycy5cbiAgICAgKiBHaXZlbiB2ZWN0b3JzIGEgYW5kIGIgYW5kIGludGVycG9sYXRpb24gY29lZmZpY2llbnQgdCwgcmV0dXJuc1xuICAgICAqIGEgKyB0ICogKGIgLSBhKS5cbiAgICAgKiBAcGFyYW0gYSAtIE9wZXJhbmQgdmVjdG9yLlxuICAgICAqIEBwYXJhbSBiIC0gT3BlcmFuZCB2ZWN0b3IuXG4gICAgICogQHBhcmFtIHQgLSBJbnRlcnBvbGF0aW9uIGNvZWZmaWNpZW50LlxuICAgICAqIEBwYXJhbSBkc3QgLSB2ZWN0b3IgdG8gaG9sZCByZXN1bHQuIElmIG5vdCBwYXNzZWQgaW4gYSBuZXcgb25lIGlzIGNyZWF0ZWQuXG4gICAgICogQHJldHVybnMgVGhlIGxpbmVhciBpbnRlcnBvbGF0ZWQgcmVzdWx0LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGxlcnAoYSwgYiwgdCwgZHN0KSB7XG4gICAgICAgIGNvbnN0IG5ld0RzdCA9IChkc3QgPz8gbmV3IEN0b3IoNCkpO1xuICAgICAgICBuZXdEc3RbMF0gPSBhWzBdICsgdCAqIChiWzBdIC0gYVswXSk7XG4gICAgICAgIG5ld0RzdFsxXSA9IGFbMV0gKyB0ICogKGJbMV0gLSBhWzFdKTtcbiAgICAgICAgbmV3RHN0WzJdID0gYVsyXSArIHQgKiAoYlsyXSAtIGFbMl0pO1xuICAgICAgICBuZXdEc3RbM10gPSBhWzNdICsgdCAqIChiWzNdIC0gYVszXSk7XG4gICAgICAgIHJldHVybiBuZXdEc3Q7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFBlcmZvcm1zIGxpbmVhciBpbnRlcnBvbGF0aW9uIG9uIHR3byB2ZWN0b3JzLlxuICAgICAqIEdpdmVuIHZlY3RvcnMgYSBhbmQgYiBhbmQgaW50ZXJwb2xhdGlvbiBjb2VmZmljaWVudCB2ZWN0b3IgdCwgcmV0dXJuc1xuICAgICAqIGEgKyB0ICogKGIgLSBhKS5cbiAgICAgKiBAcGFyYW0gYSAtIE9wZXJhbmQgdmVjdG9yLlxuICAgICAqIEBwYXJhbSBiIC0gT3BlcmFuZCB2ZWN0b3IuXG4gICAgICogQHBhcmFtIHQgLSBJbnRlcnBvbGF0aW9uIGNvZWZmaWNpZW50cyB2ZWN0b3IuXG4gICAgICogQHBhcmFtIGRzdCAtIHZlY3RvciB0byBob2xkIHJlc3VsdC4gSWYgbm90IHBhc3NlZCBpbiBhIG5ldyBvbmUgaXMgY3JlYXRlZC5cbiAgICAgKiBAcmV0dXJucyB0aGUgbGluZWFyIGludGVycG9sYXRlZCByZXN1bHQuXG4gICAgICovXG4gICAgZnVuY3Rpb24gbGVycFYoYSwgYiwgdCwgZHN0KSB7XG4gICAgICAgIGNvbnN0IG5ld0RzdCA9IChkc3QgPz8gbmV3IEN0b3IoNCkpO1xuICAgICAgICBuZXdEc3RbMF0gPSBhWzBdICsgdFswXSAqIChiWzBdIC0gYVswXSk7XG4gICAgICAgIG5ld0RzdFsxXSA9IGFbMV0gKyB0WzFdICogKGJbMV0gLSBhWzFdKTtcbiAgICAgICAgbmV3RHN0WzJdID0gYVsyXSArIHRbMl0gKiAoYlsyXSAtIGFbMl0pO1xuICAgICAgICBuZXdEc3RbM10gPSBhWzNdICsgdFszXSAqIChiWzNdIC0gYVszXSk7XG4gICAgICAgIHJldHVybiBuZXdEc3Q7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybiBtYXggdmFsdWVzIG9mIHR3byB2ZWN0b3JzLlxuICAgICAqIEdpdmVuIHZlY3RvcnMgYSBhbmQgYiByZXR1cm5zXG4gICAgICogW21heChhWzBdLCBiWzBdKSwgbWF4KGFbMV0sIGJbMV0pLCBtYXgoYVsyXSwgYlsyXSldLlxuICAgICAqIEBwYXJhbSBhIC0gT3BlcmFuZCB2ZWN0b3IuXG4gICAgICogQHBhcmFtIGIgLSBPcGVyYW5kIHZlY3Rvci5cbiAgICAgKiBAcGFyYW0gZHN0IC0gdmVjdG9yIHRvIGhvbGQgcmVzdWx0LiBJZiBub3QgcGFzc2VkIGluIGEgbmV3IG9uZSBpcyBjcmVhdGVkLlxuICAgICAqIEByZXR1cm5zIFRoZSBtYXggY29tcG9uZW50cyB2ZWN0b3IuXG4gICAgICovXG4gICAgZnVuY3Rpb24gbWF4KGEsIGIsIGRzdCkge1xuICAgICAgICBjb25zdCBuZXdEc3QgPSAoZHN0ID8/IG5ldyBDdG9yKDQpKTtcbiAgICAgICAgbmV3RHN0WzBdID0gTWF0aC5tYXgoYVswXSwgYlswXSk7XG4gICAgICAgIG5ld0RzdFsxXSA9IE1hdGgubWF4KGFbMV0sIGJbMV0pO1xuICAgICAgICBuZXdEc3RbMl0gPSBNYXRoLm1heChhWzJdLCBiWzJdKTtcbiAgICAgICAgbmV3RHN0WzNdID0gTWF0aC5tYXgoYVszXSwgYlszXSk7XG4gICAgICAgIHJldHVybiBuZXdEc3Q7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybiBtaW4gdmFsdWVzIG9mIHR3byB2ZWN0b3JzLlxuICAgICAqIEdpdmVuIHZlY3RvcnMgYSBhbmQgYiByZXR1cm5zXG4gICAgICogW21pbihhWzBdLCBiWzBdKSwgbWluKGFbMV0sIGJbMV0pLCBtaW4oYVsyXSwgYlsyXSldLlxuICAgICAqIEBwYXJhbSBhIC0gT3BlcmFuZCB2ZWN0b3IuXG4gICAgICogQHBhcmFtIGIgLSBPcGVyYW5kIHZlY3Rvci5cbiAgICAgKiBAcGFyYW0gZHN0IC0gdmVjdG9yIHRvIGhvbGQgcmVzdWx0LiBJZiBub3QgcGFzc2VkIGluIGEgbmV3IG9uZSBpcyBjcmVhdGVkLlxuICAgICAqIEByZXR1cm5zIFRoZSBtaW4gY29tcG9uZW50cyB2ZWN0b3IuXG4gICAgICovXG4gICAgZnVuY3Rpb24gbWluKGEsIGIsIGRzdCkge1xuICAgICAgICBjb25zdCBuZXdEc3QgPSAoZHN0ID8/IG5ldyBDdG9yKDQpKTtcbiAgICAgICAgbmV3RHN0WzBdID0gTWF0aC5taW4oYVswXSwgYlswXSk7XG4gICAgICAgIG5ld0RzdFsxXSA9IE1hdGgubWluKGFbMV0sIGJbMV0pO1xuICAgICAgICBuZXdEc3RbMl0gPSBNYXRoLm1pbihhWzJdLCBiWzJdKTtcbiAgICAgICAgbmV3RHN0WzNdID0gTWF0aC5taW4oYVszXSwgYlszXSk7XG4gICAgICAgIHJldHVybiBuZXdEc3Q7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE11bHRpcGxpZXMgYSB2ZWN0b3IgYnkgYSBzY2FsYXIuXG4gICAgICogQHBhcmFtIHYgLSBUaGUgdmVjdG9yLlxuICAgICAqIEBwYXJhbSBrIC0gVGhlIHNjYWxhci5cbiAgICAgKiBAcGFyYW0gZHN0IC0gdmVjdG9yIHRvIGhvbGQgcmVzdWx0LiBJZiBub3QgcGFzc2VkIGluIGEgbmV3IG9uZSBpcyBjcmVhdGVkLlxuICAgICAqIEByZXR1cm5zIFRoZSBzY2FsZWQgdmVjdG9yLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG11bFNjYWxhcih2LCBrLCBkc3QpIHtcbiAgICAgICAgY29uc3QgbmV3RHN0ID0gKGRzdCA/PyBuZXcgQ3Rvcig0KSk7XG4gICAgICAgIG5ld0RzdFswXSA9IHZbMF0gKiBrO1xuICAgICAgICBuZXdEc3RbMV0gPSB2WzFdICogaztcbiAgICAgICAgbmV3RHN0WzJdID0gdlsyXSAqIGs7XG4gICAgICAgIG5ld0RzdFszXSA9IHZbM10gKiBrO1xuICAgICAgICByZXR1cm4gbmV3RHN0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBNdWx0aXBsaWVzIGEgdmVjdG9yIGJ5IGEgc2NhbGFyLiAoc2FtZSBhcyBtdWxTY2FsYXIpXG4gICAgICogQHBhcmFtIHYgLSBUaGUgdmVjdG9yLlxuICAgICAqIEBwYXJhbSBrIC0gVGhlIHNjYWxhci5cbiAgICAgKiBAcGFyYW0gZHN0IC0gdmVjdG9yIHRvIGhvbGQgcmVzdWx0LiBJZiBub3QgcGFzc2VkIGluIGEgbmV3IG9uZSBpcyBjcmVhdGVkLlxuICAgICAqIEByZXR1cm5zIFRoZSBzY2FsZWQgdmVjdG9yLlxuICAgICAqL1xuICAgIGNvbnN0IHNjYWxlID0gbXVsU2NhbGFyO1xuICAgIC8qKlxuICAgICAqIERpdmlkZXMgYSB2ZWN0b3IgYnkgYSBzY2FsYXIuXG4gICAgICogQHBhcmFtIHYgLSBUaGUgdmVjdG9yLlxuICAgICAqIEBwYXJhbSBrIC0gVGhlIHNjYWxhci5cbiAgICAgKiBAcGFyYW0gZHN0IC0gdmVjdG9yIHRvIGhvbGQgcmVzdWx0LiBJZiBub3QgcGFzc2VkIGluIGEgbmV3IG9uZSBpcyBjcmVhdGVkLlxuICAgICAqIEByZXR1cm5zIFRoZSBzY2FsZWQgdmVjdG9yLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGRpdlNjYWxhcih2LCBrLCBkc3QpIHtcbiAgICAgICAgY29uc3QgbmV3RHN0ID0gKGRzdCA/PyBuZXcgQ3Rvcig0KSk7XG4gICAgICAgIG5ld0RzdFswXSA9IHZbMF0gLyBrO1xuICAgICAgICBuZXdEc3RbMV0gPSB2WzFdIC8gaztcbiAgICAgICAgbmV3RHN0WzJdID0gdlsyXSAvIGs7XG4gICAgICAgIG5ld0RzdFszXSA9IHZbM10gLyBrO1xuICAgICAgICByZXR1cm4gbmV3RHN0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJbnZlcnNlIGEgdmVjdG9yLlxuICAgICAqIEBwYXJhbSB2IC0gVGhlIHZlY3Rvci5cbiAgICAgKiBAcGFyYW0gZHN0IC0gdmVjdG9yIHRvIGhvbGQgcmVzdWx0LiBJZiBub3QgcGFzc2VkIGluIGEgbmV3IG9uZSBpcyBjcmVhdGVkLlxuICAgICAqIEByZXR1cm5zIFRoZSBpbnZlcnRlZCB2ZWN0b3IuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaW52ZXJzZSh2LCBkc3QpIHtcbiAgICAgICAgY29uc3QgbmV3RHN0ID0gKGRzdCA/PyBuZXcgQ3Rvcig0KSk7XG4gICAgICAgIG5ld0RzdFswXSA9IDEgLyB2WzBdO1xuICAgICAgICBuZXdEc3RbMV0gPSAxIC8gdlsxXTtcbiAgICAgICAgbmV3RHN0WzJdID0gMSAvIHZbMl07XG4gICAgICAgIG5ld0RzdFszXSA9IDEgLyB2WzNdO1xuICAgICAgICByZXR1cm4gbmV3RHN0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJbnZlcnQgYSB2ZWN0b3IuIChzYW1lIGFzIGludmVyc2UpXG4gICAgICogQHBhcmFtIHYgLSBUaGUgdmVjdG9yLlxuICAgICAqIEBwYXJhbSBkc3QgLSB2ZWN0b3IgdG8gaG9sZCByZXN1bHQuIElmIG5vdCBwYXNzZWQgaW4gYSBuZXcgb25lIGlzIGNyZWF0ZWQuXG4gICAgICogQHJldHVybnMgVGhlIGludmVydGVkIHZlY3Rvci5cbiAgICAgKi9cbiAgICBjb25zdCBpbnZlcnQgPSBpbnZlcnNlO1xuICAgIC8qKlxuICAgICAqIENvbXB1dGVzIHRoZSBkb3QgcHJvZHVjdCBvZiB0d28gdmVjdG9yc1xuICAgICAqIEBwYXJhbSBhIC0gT3BlcmFuZCB2ZWN0b3IuXG4gICAgICogQHBhcmFtIGIgLSBPcGVyYW5kIHZlY3Rvci5cbiAgICAgKiBAcmV0dXJucyBkb3QgcHJvZHVjdFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGRvdChhLCBiKSB7XG4gICAgICAgIHJldHVybiAoYVswXSAqIGJbMF0pICsgKGFbMV0gKiBiWzFdKSArIChhWzJdICogYlsyXSkgKyAoYVszXSAqIGJbM10pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb21wdXRlcyB0aGUgbGVuZ3RoIG9mIHZlY3RvclxuICAgICAqIEBwYXJhbSB2IC0gdmVjdG9yLlxuICAgICAqIEByZXR1cm5zIGxlbmd0aCBvZiB2ZWN0b3IuXG4gICAgICovXG4gICAgZnVuY3Rpb24gbGVuZ3RoKHYpIHtcbiAgICAgICAgY29uc3QgdjAgPSB2WzBdO1xuICAgICAgICBjb25zdCB2MSA9IHZbMV07XG4gICAgICAgIGNvbnN0IHYyID0gdlsyXTtcbiAgICAgICAgY29uc3QgdjMgPSB2WzNdO1xuICAgICAgICByZXR1cm4gTWF0aC5zcXJ0KHYwICogdjAgKyB2MSAqIHYxICsgdjIgKiB2MiArIHYzICogdjMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb21wdXRlcyB0aGUgbGVuZ3RoIG9mIHZlY3RvciAoc2FtZSBhcyBsZW5ndGgpXG4gICAgICogQHBhcmFtIHYgLSB2ZWN0b3IuXG4gICAgICogQHJldHVybnMgbGVuZ3RoIG9mIHZlY3Rvci5cbiAgICAgKi9cbiAgICBjb25zdCBsZW4gPSBsZW5ndGg7XG4gICAgLyoqXG4gICAgICogQ29tcHV0ZXMgdGhlIHNxdWFyZSBvZiB0aGUgbGVuZ3RoIG9mIHZlY3RvclxuICAgICAqIEBwYXJhbSB2IC0gdmVjdG9yLlxuICAgICAqIEByZXR1cm5zIHNxdWFyZSBvZiB0aGUgbGVuZ3RoIG9mIHZlY3Rvci5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBsZW5ndGhTcSh2KSB7XG4gICAgICAgIGNvbnN0IHYwID0gdlswXTtcbiAgICAgICAgY29uc3QgdjEgPSB2WzFdO1xuICAgICAgICBjb25zdCB2MiA9IHZbMl07XG4gICAgICAgIGNvbnN0IHYzID0gdlszXTtcbiAgICAgICAgcmV0dXJuIHYwICogdjAgKyB2MSAqIHYxICsgdjIgKiB2MiArIHYzICogdjM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbXB1dGVzIHRoZSBzcXVhcmUgb2YgdGhlIGxlbmd0aCBvZiB2ZWN0b3IgKHNhbWUgYXMgbGVuZ3RoU3EpXG4gICAgICogQHBhcmFtIHYgLSB2ZWN0b3IuXG4gICAgICogQHJldHVybnMgc3F1YXJlIG9mIHRoZSBsZW5ndGggb2YgdmVjdG9yLlxuICAgICAqL1xuICAgIGNvbnN0IGxlblNxID0gbGVuZ3RoU3E7XG4gICAgLyoqXG4gICAgICogQ29tcHV0ZXMgdGhlIGRpc3RhbmNlIGJldHdlZW4gMiBwb2ludHNcbiAgICAgKiBAcGFyYW0gYSAtIHZlY3Rvci5cbiAgICAgKiBAcGFyYW0gYiAtIHZlY3Rvci5cbiAgICAgKiBAcmV0dXJucyBkaXN0YW5jZSBiZXR3ZWVuIGEgYW5kIGJcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBkaXN0YW5jZShhLCBiKSB7XG4gICAgICAgIGNvbnN0IGR4ID0gYVswXSAtIGJbMF07XG4gICAgICAgIGNvbnN0IGR5ID0gYVsxXSAtIGJbMV07XG4gICAgICAgIGNvbnN0IGR6ID0gYVsyXSAtIGJbMl07XG4gICAgICAgIGNvbnN0IGR3ID0gYVszXSAtIGJbM107XG4gICAgICAgIHJldHVybiBNYXRoLnNxcnQoZHggKiBkeCArIGR5ICogZHkgKyBkeiAqIGR6ICsgZHcgKiBkdyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbXB1dGVzIHRoZSBkaXN0YW5jZSBiZXR3ZWVuIDIgcG9pbnRzIChzYW1lIGFzIGRpc3RhbmNlKVxuICAgICAqIEBwYXJhbSBhIC0gdmVjdG9yLlxuICAgICAqIEBwYXJhbSBiIC0gdmVjdG9yLlxuICAgICAqIEByZXR1cm5zIGRpc3RhbmNlIGJldHdlZW4gYSBhbmQgYlxuICAgICAqL1xuICAgIGNvbnN0IGRpc3QgPSBkaXN0YW5jZTtcbiAgICAvKipcbiAgICAgKiBDb21wdXRlcyB0aGUgc3F1YXJlIG9mIHRoZSBkaXN0YW5jZSBiZXR3ZWVuIDIgcG9pbnRzXG4gICAgICogQHBhcmFtIGEgLSB2ZWN0b3IuXG4gICAgICogQHBhcmFtIGIgLSB2ZWN0b3IuXG4gICAgICogQHJldHVybnMgc3F1YXJlIG9mIHRoZSBkaXN0YW5jZSBiZXR3ZWVuIGEgYW5kIGJcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBkaXN0YW5jZVNxKGEsIGIpIHtcbiAgICAgICAgY29uc3QgZHggPSBhWzBdIC0gYlswXTtcbiAgICAgICAgY29uc3QgZHkgPSBhWzFdIC0gYlsxXTtcbiAgICAgICAgY29uc3QgZHogPSBhWzJdIC0gYlsyXTtcbiAgICAgICAgY29uc3QgZHcgPSBhWzNdIC0gYlszXTtcbiAgICAgICAgcmV0dXJuIGR4ICogZHggKyBkeSAqIGR5ICsgZHogKiBkeiArIGR3ICogZHc7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbXB1dGVzIHRoZSBzcXVhcmUgb2YgdGhlIGRpc3RhbmNlIGJldHdlZW4gMiBwb2ludHMgKHNhbWUgYXMgZGlzdGFuY2VTcSlcbiAgICAgKiBAcGFyYW0gYSAtIHZlY3Rvci5cbiAgICAgKiBAcGFyYW0gYiAtIHZlY3Rvci5cbiAgICAgKiBAcmV0dXJucyBzcXVhcmUgb2YgdGhlIGRpc3RhbmNlIGJldHdlZW4gYSBhbmQgYlxuICAgICAqL1xuICAgIGNvbnN0IGRpc3RTcSA9IGRpc3RhbmNlU3E7XG4gICAgLyoqXG4gICAgICogRGl2aWRlcyBhIHZlY3RvciBieSBpdHMgRXVjbGlkZWFuIGxlbmd0aCBhbmQgcmV0dXJucyB0aGUgcXVvdGllbnQuXG4gICAgICogQHBhcmFtIHYgLSBUaGUgdmVjdG9yLlxuICAgICAqIEBwYXJhbSBkc3QgLSB2ZWN0b3IgdG8gaG9sZCByZXN1bHQuIElmIG5vdCBwYXNzZWQgaW4gYSBuZXcgb25lIGlzIGNyZWF0ZWQuXG4gICAgICogQHJldHVybnMgVGhlIG5vcm1hbGl6ZWQgdmVjdG9yLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG5vcm1hbGl6ZSh2LCBkc3QpIHtcbiAgICAgICAgY29uc3QgbmV3RHN0ID0gKGRzdCA/PyBuZXcgQ3Rvcig0KSk7XG4gICAgICAgIGNvbnN0IHYwID0gdlswXTtcbiAgICAgICAgY29uc3QgdjEgPSB2WzFdO1xuICAgICAgICBjb25zdCB2MiA9IHZbMl07XG4gICAgICAgIGNvbnN0IHYzID0gdlszXTtcbiAgICAgICAgY29uc3QgbGVuID0gTWF0aC5zcXJ0KHYwICogdjAgKyB2MSAqIHYxICsgdjIgKiB2MiArIHYzICogdjMpO1xuICAgICAgICBpZiAobGVuID4gMC4wMDAwMSkge1xuICAgICAgICAgICAgbmV3RHN0WzBdID0gdjAgLyBsZW47XG4gICAgICAgICAgICBuZXdEc3RbMV0gPSB2MSAvIGxlbjtcbiAgICAgICAgICAgIG5ld0RzdFsyXSA9IHYyIC8gbGVuO1xuICAgICAgICAgICAgbmV3RHN0WzNdID0gdjMgLyBsZW47XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBuZXdEc3RbMF0gPSAwO1xuICAgICAgICAgICAgbmV3RHN0WzFdID0gMDtcbiAgICAgICAgICAgIG5ld0RzdFsyXSA9IDA7XG4gICAgICAgICAgICBuZXdEc3RbM10gPSAwO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXdEc3Q7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE5lZ2F0ZXMgYSB2ZWN0b3IuXG4gICAgICogQHBhcmFtIHYgLSBUaGUgdmVjdG9yLlxuICAgICAqIEBwYXJhbSBkc3QgLSB2ZWN0b3IgdG8gaG9sZCByZXN1bHQuIElmIG5vdCBwYXNzZWQgaW4gYSBuZXcgb25lIGlzIGNyZWF0ZWQuXG4gICAgICogQHJldHVybnMgLXYuXG4gICAgICovXG4gICAgZnVuY3Rpb24gbmVnYXRlKHYsIGRzdCkge1xuICAgICAgICBjb25zdCBuZXdEc3QgPSAoZHN0ID8/IG5ldyBDdG9yKDQpKTtcbiAgICAgICAgbmV3RHN0WzBdID0gLXZbMF07XG4gICAgICAgIG5ld0RzdFsxXSA9IC12WzFdO1xuICAgICAgICBuZXdEc3RbMl0gPSAtdlsyXTtcbiAgICAgICAgbmV3RHN0WzNdID0gLXZbM107XG4gICAgICAgIHJldHVybiBuZXdEc3Q7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvcGllcyBhIHZlY3Rvci4gKHNhbWUgYXMge0BsaW5rIHZlYzQuY2xvbmV9KVxuICAgICAqIEFsc28gc2VlIHtAbGluayB2ZWM0LmNyZWF0ZX0gYW5kIHtAbGluayB2ZWM0LnNldH1cbiAgICAgKiBAcGFyYW0gdiAtIFRoZSB2ZWN0b3IuXG4gICAgICogQHBhcmFtIGRzdCAtIHZlY3RvciB0byBob2xkIHJlc3VsdC4gSWYgbm90IHBhc3NlZCBpbiBhIG5ldyBvbmUgaXMgY3JlYXRlZC5cbiAgICAgKiBAcmV0dXJucyBBIGNvcHkgb2Ygdi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjb3B5KHYsIGRzdCkge1xuICAgICAgICBjb25zdCBuZXdEc3QgPSAoZHN0ID8/IG5ldyBDdG9yKDQpKTtcbiAgICAgICAgbmV3RHN0WzBdID0gdlswXTtcbiAgICAgICAgbmV3RHN0WzFdID0gdlsxXTtcbiAgICAgICAgbmV3RHN0WzJdID0gdlsyXTtcbiAgICAgICAgbmV3RHN0WzNdID0gdlszXTtcbiAgICAgICAgcmV0dXJuIG5ld0RzdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2xvbmVzIGEgdmVjdG9yLiAoc2FtZSBhcyB7QGxpbmsgdmVjNC5jb3B5fSlcbiAgICAgKiBBbHNvIHNlZSB7QGxpbmsgdmVjNC5jcmVhdGV9IGFuZCB7QGxpbmsgdmVjNC5zZXR9XG4gICAgICogQHBhcmFtIHYgLSBUaGUgdmVjdG9yLlxuICAgICAqIEBwYXJhbSBkc3QgLSB2ZWN0b3IgdG8gaG9sZCByZXN1bHQuIElmIG5vdCBwYXNzZWQgaW4gYSBuZXcgb25lIGlzIGNyZWF0ZWQuXG4gICAgICogQHJldHVybnMgQSBjb3B5IG9mIHYuXG4gICAgICovXG4gICAgY29uc3QgY2xvbmUgPSBjb3B5O1xuICAgIC8qKlxuICAgICAqIE11bHRpcGxpZXMgYSB2ZWN0b3IgYnkgYW5vdGhlciB2ZWN0b3IgKGNvbXBvbmVudC13aXNlKTsgYXNzdW1lcyBhIGFuZFxuICAgICAqIGIgaGF2ZSB0aGUgc2FtZSBsZW5ndGguXG4gICAgICogQHBhcmFtIGEgLSBPcGVyYW5kIHZlY3Rvci5cbiAgICAgKiBAcGFyYW0gYiAtIE9wZXJhbmQgdmVjdG9yLlxuICAgICAqIEBwYXJhbSBkc3QgLSB2ZWN0b3IgdG8gaG9sZCByZXN1bHQuIElmIG5vdCBwYXNzZWQgaW4gYSBuZXcgb25lIGlzIGNyZWF0ZWQuXG4gICAgICogQHJldHVybnMgVGhlIHZlY3RvciBvZiBwcm9kdWN0cyBvZiBlbnRyaWVzIG9mIGEgYW5kIGIuXG4gICAgICovXG4gICAgZnVuY3Rpb24gbXVsdGlwbHkoYSwgYiwgZHN0KSB7XG4gICAgICAgIGNvbnN0IG5ld0RzdCA9IChkc3QgPz8gbmV3IEN0b3IoNCkpO1xuICAgICAgICBuZXdEc3RbMF0gPSBhWzBdICogYlswXTtcbiAgICAgICAgbmV3RHN0WzFdID0gYVsxXSAqIGJbMV07XG4gICAgICAgIG5ld0RzdFsyXSA9IGFbMl0gKiBiWzJdO1xuICAgICAgICBuZXdEc3RbM10gPSBhWzNdICogYlszXTtcbiAgICAgICAgcmV0dXJuIG5ld0RzdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTXVsdGlwbGllcyBhIHZlY3RvciBieSBhbm90aGVyIHZlY3RvciAoY29tcG9uZW50LXdpc2UpOyBhc3N1bWVzIGEgYW5kXG4gICAgICogYiBoYXZlIHRoZSBzYW1lIGxlbmd0aC4gKHNhbWUgYXMgbXVsKVxuICAgICAqIEBwYXJhbSBhIC0gT3BlcmFuZCB2ZWN0b3IuXG4gICAgICogQHBhcmFtIGIgLSBPcGVyYW5kIHZlY3Rvci5cbiAgICAgKiBAcGFyYW0gZHN0IC0gdmVjdG9yIHRvIGhvbGQgcmVzdWx0LiBJZiBub3QgcGFzc2VkIGluIGEgbmV3IG9uZSBpcyBjcmVhdGVkLlxuICAgICAqIEByZXR1cm5zIFRoZSB2ZWN0b3Igb2YgcHJvZHVjdHMgb2YgZW50cmllcyBvZiBhIGFuZCBiLlxuICAgICAqL1xuICAgIGNvbnN0IG11bCA9IG11bHRpcGx5O1xuICAgIC8qKlxuICAgICAqIERpdmlkZXMgYSB2ZWN0b3IgYnkgYW5vdGhlciB2ZWN0b3IgKGNvbXBvbmVudC13aXNlKTsgYXNzdW1lcyBhIGFuZFxuICAgICAqIGIgaGF2ZSB0aGUgc2FtZSBsZW5ndGguXG4gICAgICogQHBhcmFtIGEgLSBPcGVyYW5kIHZlY3Rvci5cbiAgICAgKiBAcGFyYW0gYiAtIE9wZXJhbmQgdmVjdG9yLlxuICAgICAqIEBwYXJhbSBkc3QgLSB2ZWN0b3IgdG8gaG9sZCByZXN1bHQuIElmIG5vdCBwYXNzZWQgaW4gYSBuZXcgb25lIGlzIGNyZWF0ZWQuXG4gICAgICogQHJldHVybnMgVGhlIHZlY3RvciBvZiBxdW90aWVudHMgb2YgZW50cmllcyBvZiBhIGFuZCBiLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGRpdmlkZShhLCBiLCBkc3QpIHtcbiAgICAgICAgY29uc3QgbmV3RHN0ID0gKGRzdCA/PyBuZXcgQ3Rvcig0KSk7XG4gICAgICAgIG5ld0RzdFswXSA9IGFbMF0gLyBiWzBdO1xuICAgICAgICBuZXdEc3RbMV0gPSBhWzFdIC8gYlsxXTtcbiAgICAgICAgbmV3RHN0WzJdID0gYVsyXSAvIGJbMl07XG4gICAgICAgIG5ld0RzdFszXSA9IGFbM10gLyBiWzNdO1xuICAgICAgICByZXR1cm4gbmV3RHN0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEaXZpZGVzIGEgdmVjdG9yIGJ5IGFub3RoZXIgdmVjdG9yIChjb21wb25lbnQtd2lzZSk7IGFzc3VtZXMgYSBhbmRcbiAgICAgKiBiIGhhdmUgdGhlIHNhbWUgbGVuZ3RoLiAoc2FtZSBhcyBkaXZpZGUpXG4gICAgICogQHBhcmFtIGEgLSBPcGVyYW5kIHZlY3Rvci5cbiAgICAgKiBAcGFyYW0gYiAtIE9wZXJhbmQgdmVjdG9yLlxuICAgICAqIEBwYXJhbSBkc3QgLSB2ZWN0b3IgdG8gaG9sZCByZXN1bHQuIElmIG5vdCBwYXNzZWQgaW4gYSBuZXcgb25lIGlzIGNyZWF0ZWQuXG4gICAgICogQHJldHVybnMgVGhlIHZlY3RvciBvZiBxdW90aWVudHMgb2YgZW50cmllcyBvZiBhIGFuZCBiLlxuICAgICAqL1xuICAgIGNvbnN0IGRpdiA9IGRpdmlkZTtcbiAgICAvKipcbiAgICAgKiBaZXJvJ3MgYSB2ZWN0b3JcbiAgICAgKiBAcGFyYW0gZHN0IC0gdmVjdG9yIHRvIGhvbGQgcmVzdWx0LiBJZiBub3QgcGFzc2VkIGluIGEgbmV3IG9uZSBpcyBjcmVhdGVkLlxuICAgICAqIEByZXR1cm5zIFRoZSB6ZXJvZWQgdmVjdG9yLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHplcm8oZHN0KSB7XG4gICAgICAgIGNvbnN0IG5ld0RzdCA9IChkc3QgPz8gbmV3IEN0b3IoNCkpO1xuICAgICAgICBuZXdEc3RbMF0gPSAwO1xuICAgICAgICBuZXdEc3RbMV0gPSAwO1xuICAgICAgICBuZXdEc3RbMl0gPSAwO1xuICAgICAgICBuZXdEc3RbM10gPSAwO1xuICAgICAgICByZXR1cm4gbmV3RHN0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiB0cmFuc2Zvcm0gdmVjNCBieSA0eDQgbWF0cml4XG4gICAgICogQHBhcmFtIHYgLSB0aGUgdmVjdG9yXG4gICAgICogQHBhcmFtIG0gLSBUaGUgbWF0cml4LlxuICAgICAqIEBwYXJhbSBkc3QgLSBvcHRpb25hbCB2ZWM0IHRvIHN0b3JlIHJlc3VsdC4gSWYgbm90IHBhc3NlZCBhIG5ldyBvbmUgaXMgY3JlYXRlZC5cbiAgICAgKiBAcmV0dXJucyB0aGUgdHJhbnNmb3JtZWQgdmVjdG9yXG4gICAgICovXG4gICAgZnVuY3Rpb24gdHJhbnNmb3JtTWF0NCh2LCBtLCBkc3QpIHtcbiAgICAgICAgY29uc3QgbmV3RHN0ID0gKGRzdCA/PyBuZXcgQ3Rvcig0KSk7XG4gICAgICAgIGNvbnN0IHggPSB2WzBdO1xuICAgICAgICBjb25zdCB5ID0gdlsxXTtcbiAgICAgICAgY29uc3QgeiA9IHZbMl07XG4gICAgICAgIGNvbnN0IHcgPSB2WzNdO1xuICAgICAgICBuZXdEc3RbMF0gPSBtWzBdICogeCArIG1bNF0gKiB5ICsgbVs4XSAqIHogKyBtWzEyXSAqIHc7XG4gICAgICAgIG5ld0RzdFsxXSA9IG1bMV0gKiB4ICsgbVs1XSAqIHkgKyBtWzldICogeiArIG1bMTNdICogdztcbiAgICAgICAgbmV3RHN0WzJdID0gbVsyXSAqIHggKyBtWzZdICogeSArIG1bMTBdICogeiArIG1bMTRdICogdztcbiAgICAgICAgbmV3RHN0WzNdID0gbVszXSAqIHggKyBtWzddICogeSArIG1bMTFdICogeiArIG1bMTVdICogdztcbiAgICAgICAgcmV0dXJuIG5ld0RzdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVHJlYXQgYSA0RCB2ZWN0b3IgYXMgYSBkaXJlY3Rpb24gYW5kIHNldCBpdCdzIGxlbmd0aFxuICAgICAqXG4gICAgICogQHBhcmFtIGEgVGhlIHZlYzQgdG8gbGVuZ3RoZW5cbiAgICAgKiBAcGFyYW0gbGVuIFRoZSBsZW5ndGggb2YgdGhlIHJlc3VsdGluZyB2ZWN0b3JcbiAgICAgKiBAcmV0dXJucyBUaGUgbGVuZ3RoZW5lZCB2ZWN0b3JcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzZXRMZW5ndGgoYSwgbGVuLCBkc3QpIHtcbiAgICAgICAgY29uc3QgbmV3RHN0ID0gKGRzdCA/PyBuZXcgQ3Rvcig0KSk7XG4gICAgICAgIG5vcm1hbGl6ZShhLCBuZXdEc3QpO1xuICAgICAgICByZXR1cm4gbXVsU2NhbGFyKG5ld0RzdCwgbGVuLCBuZXdEc3QpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBFbnN1cmUgYSB2ZWN0b3IgaXMgbm90IGxvbmdlciB0aGFuIGEgbWF4IGxlbmd0aFxuICAgICAqXG4gICAgICogQHBhcmFtIGEgVGhlIHZlYzQgdG8gbGltaXRcbiAgICAgKiBAcGFyYW0gbWF4TGVuIFRoZSBsb25nZXN0IGxlbmd0aCBvZiB0aGUgcmVzdWx0aW5nIHZlY3RvclxuICAgICAqIEByZXR1cm5zIFRoZSB2ZWN0b3IsIHNob3J0ZW5lZCB0byBtYXhMZW4gaWYgaXQncyB0b28gbG9uZ1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRydW5jYXRlKGEsIG1heExlbiwgZHN0KSB7XG4gICAgICAgIGNvbnN0IG5ld0RzdCA9IChkc3QgPz8gbmV3IEN0b3IoNCkpO1xuICAgICAgICBpZiAobGVuZ3RoKGEpID4gbWF4TGVuKSB7XG4gICAgICAgICAgICByZXR1cm4gc2V0TGVuZ3RoKGEsIG1heExlbiwgbmV3RHN0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY29weShhLCBuZXdEc3QpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gdGhlIHZlY3RvciBleGFjdGx5IGJldHdlZW4gMiBlbmRwb2ludCB2ZWN0b3JzXG4gICAgICpcbiAgICAgKiBAcGFyYW0gYSBFbmRwb2ludCAxXG4gICAgICogQHBhcmFtIGIgRW5kcG9pbnQgMlxuICAgICAqIEByZXR1cm5zIFRoZSB2ZWN0b3IgZXhhY3RseSByZXNpZGluZyBiZXR3ZWVuIGVuZHBvaW50cyAxIGFuZCAyXG4gICAgICovXG4gICAgZnVuY3Rpb24gbWlkcG9pbnQoYSwgYiwgZHN0KSB7XG4gICAgICAgIGNvbnN0IG5ld0RzdCA9IChkc3QgPz8gbmV3IEN0b3IoNCkpO1xuICAgICAgICByZXR1cm4gbGVycChhLCBiLCAwLjUsIG5ld0RzdCk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIGNyZWF0ZSxcbiAgICAgICAgZnJvbVZhbHVlcyxcbiAgICAgICAgc2V0LFxuICAgICAgICBjZWlsLFxuICAgICAgICBmbG9vcixcbiAgICAgICAgcm91bmQsXG4gICAgICAgIGNsYW1wLFxuICAgICAgICBhZGQsXG4gICAgICAgIGFkZFNjYWxlZCxcbiAgICAgICAgc3VidHJhY3QsXG4gICAgICAgIHN1YixcbiAgICAgICAgZXF1YWxzQXBwcm94aW1hdGVseSxcbiAgICAgICAgZXF1YWxzLFxuICAgICAgICBsZXJwLFxuICAgICAgICBsZXJwVixcbiAgICAgICAgbWF4LFxuICAgICAgICBtaW4sXG4gICAgICAgIG11bFNjYWxhcixcbiAgICAgICAgc2NhbGUsXG4gICAgICAgIGRpdlNjYWxhcixcbiAgICAgICAgaW52ZXJzZSxcbiAgICAgICAgaW52ZXJ0LFxuICAgICAgICBkb3QsXG4gICAgICAgIGxlbmd0aCxcbiAgICAgICAgbGVuLFxuICAgICAgICBsZW5ndGhTcSxcbiAgICAgICAgbGVuU3EsXG4gICAgICAgIGRpc3RhbmNlLFxuICAgICAgICBkaXN0LFxuICAgICAgICBkaXN0YW5jZVNxLFxuICAgICAgICBkaXN0U3EsXG4gICAgICAgIG5vcm1hbGl6ZSxcbiAgICAgICAgbmVnYXRlLFxuICAgICAgICBjb3B5LFxuICAgICAgICBjbG9uZSxcbiAgICAgICAgbXVsdGlwbHksXG4gICAgICAgIG11bCxcbiAgICAgICAgZGl2aWRlLFxuICAgICAgICBkaXYsXG4gICAgICAgIHplcm8sXG4gICAgICAgIHRyYW5zZm9ybU1hdDQsXG4gICAgICAgIHNldExlbmd0aCxcbiAgICAgICAgdHJ1bmNhdGUsXG4gICAgICAgIG1pZHBvaW50LFxuICAgIH07XG59XG5jb25zdCBjYWNoZSA9IG5ldyBNYXAoKTtcbi8qKlxuICpcbiAqIFZlYzQgbWF0aCBmdW5jdGlvbnMuXG4gKlxuICogQWxtb3N0IGFsbCBmdW5jdGlvbnMgdGFrZSBhbiBvcHRpb25hbCBgbmV3RHN0YCBhcmd1bWVudC4gSWYgaXQgaXMgbm90IHBhc3NlZCBpbiB0aGVcbiAqIGZ1bmN0aW9ucyB3aWxsIGNyZWF0ZSBhIG5ldyBgVmVjNGAuIEluIG90aGVyIHdvcmRzIHlvdSBjYW4gZG8gdGhpc1xuICpcbiAqICAgICBjb25zdCB2ID0gdmVjNC5jcm9zcyh2MSwgdjIpOyAgLy8gQ3JlYXRlcyBhIG5ldyBWZWM0IHdpdGggdGhlIGNyb3NzIHByb2R1Y3Qgb2YgdjEgeCB2Mi5cbiAqXG4gKiBvclxuICpcbiAqICAgICBjb25zdCB2ID0gdmVjNC5jcmVhdGUoKTtcbiAqICAgICB2ZWM0LmNyb3NzKHYxLCB2Miwgdik7ICAvLyBQdXRzIHRoZSBjcm9zcyBwcm9kdWN0IG9mIHYxIHggdjIgaW4gdlxuICpcbiAqIFRoZSBmaXJzdCBzdHlsZSBpcyBvZnRlbiBlYXNpZXIgYnV0IGRlcGVuZGluZyBvbiB3aGVyZSBpdCdzIHVzZWQgaXQgZ2VuZXJhdGVzIGdhcmJhZ2Ugd2hlcmVcbiAqIGFzIHRoZXJlIGlzIGFsbW9zdCBuZXZlciBhbGxvY2F0aW9uIHdpdGggdGhlIHNlY29uZCBzdHlsZS5cbiAqXG4gKiBJdCBpcyBhbHdheXMgc2FmZSB0byBwYXNzIGFueSB2ZWN0b3IgYXMgdGhlIGRlc3RpbmF0aW9uLiBTbyBmb3IgZXhhbXBsZVxuICpcbiAqICAgICB2ZWM0LmNyb3NzKHYxLCB2MiwgdjEpOyAgLy8gUHV0cyB0aGUgY3Jvc3MgcHJvZHVjdCBvZiB2MSB4IHYyIGluIHYxXG4gKlxuICovXG5mdW5jdGlvbiBnZXRBUEkoQ3Rvcikge1xuICAgIGxldCBhcGkgPSBjYWNoZS5nZXQoQ3Rvcik7XG4gICAgaWYgKCFhcGkpIHtcbiAgICAgICAgYXBpID0gZ2V0QVBJSW1wbChDdG9yKTtcbiAgICAgICAgY2FjaGUuc2V0KEN0b3IsIGFwaSk7XG4gICAgfVxuICAgIHJldHVybiBhcGk7XG59XG5cbi8qKlxuICogR2VuZXJhdGUgd2dwdS1tYXRyaXggQVBJIGZvciB0eXBlXG4gKi9cbmZ1bmN0aW9uIHdncHVNYXRyaXhBUEkoTWF0M0N0b3IsIE1hdDRDdG9yLCBRdWF0Q3RvciwgVmVjMkN0b3IsIFZlYzNDdG9yLCBWZWM0Q3Rvcikge1xuICAgIHJldHVybiB7XG4gICAgICAgIC8qKiBAbmFtZXNwYWNlIG1hdDQgKi9cbiAgICAgICAgbWF0NDogZ2V0QVBJJDIoTWF0M0N0b3IpLFxuICAgICAgICAvKiogQG5hbWVzcGFjZSBtYXQzICovXG4gICAgICAgIG1hdDM6IGdldEFQSSQ0KE1hdDRDdG9yKSxcbiAgICAgICAgLyoqIEBuYW1lc3BhY2UgcXVhdCAqL1xuICAgICAgICBxdWF0OiBnZXRBUEkkMShRdWF0Q3RvciksXG4gICAgICAgIC8qKiBAbmFtZXNwYWNlIHZlYzIgKi9cbiAgICAgICAgdmVjMjogZ2V0QVBJJDUoVmVjMkN0b3IpLFxuICAgICAgICAvKiogQG5hbWVzcGFjZSB2ZWMzICovXG4gICAgICAgIHZlYzM6IGdldEFQSSQzKFZlYzNDdG9yKSxcbiAgICAgICAgLyoqIEBuYW1lc3BhY2UgdmVjNCAqL1xuICAgICAgICB2ZWM0OiBnZXRBUEkoVmVjNEN0b3IpLFxuICAgIH07XG59XG5jb25zdCB7IFxuLyoqIEBuYW1lc3BhY2UgKi9cbm1hdDQsIFxuLyoqIEBuYW1lc3BhY2UgKi9cbm1hdDMsIFxuLyoqIEBuYW1lc3BhY2UgKi9cbnF1YXQsIFxuLyoqIEBuYW1lc3BhY2UgKi9cbnZlYzIsIFxuLyoqIEBuYW1lc3BhY2UgKi9cbnZlYzMsIFxuLyoqIEBuYW1lc3BhY2UgKi9cbnZlYzQsIH0gPSB3Z3B1TWF0cml4QVBJKEZsb2F0MzJBcnJheSwgRmxvYXQzMkFycmF5LCBGbG9hdDMyQXJyYXksIEZsb2F0MzJBcnJheSwgRmxvYXQzMkFycmF5LCBGbG9hdDMyQXJyYXkpO1xuY29uc3QgeyBcbi8qKiBAbmFtZXNwYWNlICovXG5tYXQ0OiBtYXQ0ZCwgXG4vKiogQG5hbWVzcGFjZSAqL1xubWF0MzogbWF0M2QsIFxuLyoqIEBuYW1lc3BhY2UgKi9cbnF1YXQ6IHF1YXRkLCBcbi8qKiBAbmFtZXNwYWNlICovXG52ZWMyOiB2ZWMyZCwgXG4vKiogQG5hbWVzcGFjZSAqL1xudmVjMzogdmVjM2QsIFxuLyoqIEBuYW1lc3BhY2UgKi9cbnZlYzQ6IHZlYzRkLCB9ID0gd2dwdU1hdHJpeEFQSShGbG9hdDY0QXJyYXksIEZsb2F0NjRBcnJheSwgRmxvYXQ2NEFycmF5LCBGbG9hdDY0QXJyYXksIEZsb2F0NjRBcnJheSwgRmxvYXQ2NEFycmF5KTtcbmNvbnN0IHsgXG4vKiogQG5hbWVzcGFjZSAqL1xubWF0NDogbWF0NG4sIFxuLyoqIEBuYW1lc3BhY2UgKi9cbm1hdDM6IG1hdDNuLCBcbi8qKiBAbmFtZXNwYWNlICovXG5xdWF0OiBxdWF0biwgXG4vKiogQG5hbWVzcGFjZSAqL1xudmVjMjogdmVjMm4sIFxuLyoqIEBuYW1lc3BhY2UgKi9cbnZlYzM6IHZlYzNuLCBcbi8qKiBAbmFtZXNwYWNlICovXG52ZWM0OiB2ZWM0biwgfSA9IHdncHVNYXRyaXhBUEkoWmVyb0FycmF5LCBBcnJheSwgQXJyYXksIEFycmF5LCBBcnJheSwgQXJyYXkpO1xuXG5leHBvcnQgeyBtYXQzLCBtYXQzZCwgbWF0M24sIG1hdDQsIG1hdDRkLCBtYXQ0biwgcXVhdCwgcXVhdGQsIHF1YXRuLCB1dGlscywgdmVjMiwgdmVjMmQsIHZlYzJuLCB2ZWMzLCB2ZWMzZCwgdmVjM24sIHZlYzQsIHZlYzRkLCB2ZWM0biB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9d2dwdS1tYXRyaXgubW9kdWxlLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9