"use strict";
(self["webpackChunk_wheezy_demos"] = self["webpackChunk_wheezy_demos"] || []).push([["index"],{

/***/ "./index.ts":
/*!******************!*\
  !*** ./index.ts ***!
  \******************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _wheezy_engine__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @wheezy/engine */ "../engine/index.ts");
/* harmony import */ var _src_Demo0__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./src/Demo0 */ "./src/Demo0.ts");
/* harmony import */ var _src_Demo1__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./src/Demo1 */ "./src/Demo1.ts");



const canvas = document.getElementById('webgpu-canvas');
const initDebugControls = (engine) => {
    const defaultOutputSource = 0;
    const defaultRenderingMode = 1;
    const defaultScene = 1;
    const debugContainer = document.getElementById('debug-container');
    const sceneSelector = document.getElementById('scene-selector');
    const sceneOptions = [
        { label: 'Scene 1', value: 0 },
        { label: 'Scene 2', value: 1 },
    ];
    sceneOptions.forEach((item) => {
        const option = document.createElement('option');
        if (item.value === defaultScene) {
            option.selected = true;
        }
        option.textContent = item.label;
        option.value = String(item.value);
        sceneSelector.appendChild(option);
    });
    sceneSelector.addEventListener('change', (event) => {
        setScene(engine, Number(event.target.value));
    });
    const outputSourceDropDown = document.createElement('select');
    outputSourceDropDown.addEventListener('change', (event) => {
        engine.renderer.outputSource = Number(event.target.value);
    });
    const renderingModeDropDown = document.createElement('select');
    renderingModeDropDown.addEventListener('change', (event) => {
        engine.renderer.renderingMode = Number(event.target.value);
    });
    const outputOptions = [
        { label: 'Color', value: 0 },
        { label: 'Ambient color', value: 2 },
        { label: 'Diffuse color', value: 3 },
        { label: 'Metallic component', value: 4 },
        { label: 'Roughness component', value: 5 },
        { label: 'Occlusion component', value: 8 },
        { label: 'Surface normal', value: 1 },
        { label: 'Fragment normal', value: 6 },
        { label: 'Vertex tangent', value: 7 },
    ];
    outputOptions.forEach((item) => {
        const option = document.createElement('option');
        if (item.value === defaultOutputSource) {
            option.selected = true;
        }
        option.textContent = item.label;
        option.value = String(item.value);
        outputSourceDropDown.appendChild(option);
    });
    const renderModes = [
        { label: 'Blinn-Phong (No bump mapping)', value: 0 },
        { label: 'Blinn-Phong (With bump mapping)', value: 1 },
        { label: 'Terrence-Cook (No mipmapping)', value: 2 },
    ];
    renderModes.forEach((item) => {
        const option = document.createElement('option');
        if (item.value === defaultRenderingMode) {
            option.selected = true;
        }
        option.textContent = item.label;
        option.value = String(item.value);
        renderingModeDropDown.appendChild(option);
    });
    engine.renderer.outputSource = defaultOutputSource;
    engine.renderer.renderingMode = defaultRenderingMode;
    setScene(engine, defaultScene);
    debugContainer.appendChild(outputSourceDropDown);
    debugContainer.appendChild(renderingModeDropDown);
};
const setScene = async (engine, index) => {
    const loader = document.getElementById('loader');
    switch (index) {
        case 0: {
            loader.style.display = 'block';
            engine.scene = undefined;
            const scene = new _src_Demo0__WEBPACK_IMPORTED_MODULE_1__.Demo0();
            await scene.init();
            engine.scene = scene;
            loader.style.display = 'none';
            engine.render();
            break;
        }
        case 1: {
            loader.style.display = 'block';
            engine.scene = undefined;
            const scene = new _src_Demo1__WEBPACK_IMPORTED_MODULE_2__.Demo1();
            await scene.init();
            engine.scene = scene;
            loader.style.display = 'none';
            engine.render();
            break;
        }
    }
};
const run = async () => {
    const engine = (await _wheezy_engine__WEBPACK_IMPORTED_MODULE_0__.Engine.getOrInit({ canvas }));
    initDebugControls(engine);
};
run();


/***/ }),

/***/ "./src/Demo0.ts":
/*!**********************!*\
  !*** ./src/Demo0.ts ***!
  \**********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Demo0: () => (/* binding */ Demo0)
/* harmony export */ });
/* harmony import */ var wgpu_matrix__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! wgpu-matrix */ "../../node_modules/wgpu-matrix/dist/3.x/wgpu-matrix.module.js");
/* harmony import */ var _wheezy_engine__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @wheezy/engine */ "../engine/index.ts");
/* harmony import */ var _wheezy_engine_src_engine_core_cameras_ArcBallCamera__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @wheezy/engine/src/engine/core/cameras/ArcBallCamera */ "../engine/src/engine/core/cameras/ArcBallCamera/index.ts");
/* harmony import */ var _wheezy_engine_src_utils_ArcBallController__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @wheezy/engine/src/utils/ArcBallController */ "../engine/src/utils/ArcBallController/index.ts");




//This is supposed to demonstrate basic workflow
class Demo0 extends _wheezy_engine__WEBPACK_IMPORTED_MODULE_0__.Scene {
    constructor() {
        super();
        this.mercuryHook = this._createTransformObject();
        this.venusHook = this._createTransformObject();
        this.earthHook = this._createTransformObject();
        this.marsHook = this._createTransformObject();
        this.jupiterHook = this._createTransformObject();
        this.saturnHook = this._createTransformObject();
        this.uranusHook = this._createTransformObject();
        this.neptuneHook = this._createTransformObject();
        this.yearsPerMinute = 1;
        this.camera = new _wheezy_engine_src_engine_core_cameras_ArcBallCamera__WEBPACK_IMPORTED_MODULE_1__.ArcBallCamera({
            zFar: 1000,
            zNear: 0.1,
            canvasWidth: this._engine.renderer.context.canvas.width,
            canvasHeight: this._engine.renderer.context.canvas.height,
            position: wgpu_matrix__WEBPACK_IMPORTED_MODULE_3__.vec3.create(0, 4, 5),
        });
        this.controller = new _wheezy_engine_src_utils_ArcBallController__WEBPACK_IMPORTED_MODULE_2__.ArcBallController({
            camera: this.camera,
            canvas: this._engine?.renderer.context.canvas,
        });
        this.light = new _wheezy_engine__WEBPACK_IMPORTED_MODULE_0__.DirectionalLight({
            parent: this.root,
            position: wgpu_matrix__WEBPACK_IMPORTED_MODULE_3__.vec3.create(0, 0, 0),
        });
        this._setupSkyBox();
    }
    async _setupSkyBox() {
        const imgSrcs = [
            'static/cubemaps/space/posx.png',
            'static/cubemaps/space/negx.png',
            'static/cubemaps/space/posy.png',
            'static/cubemaps/space/negy.png',
            'static/cubemaps/space/posz.png',
            'static/cubemaps/space/negz.png',
        ];
        const promises = imgSrcs.map(async (source) => {
            const response = await fetch(source);
            return createImageBitmap(await response.blob());
        });
        const imageBitmaps = (await Promise.all(promises));
        this._engine?.renderer.setSkyBoxTexture(imageBitmaps);
    }
    _createTransformObject() {
        const gameObject = new _wheezy_engine__WEBPACK_IMPORTED_MODULE_0__.GameObject();
        this.objectManager.addObject(gameObject, this.root);
        new _wheezy_engine__WEBPACK_IMPORTED_MODULE_0__.Transform(gameObject);
        return gameObject;
    }
    async _setupSun() {
        const planetMD = await _wheezy_engine__WEBPACK_IMPORTED_MODULE_0__.WheezyGLBLoader.loadFromUrl('static/models/planets/sun.glb');
        this.sun = await this.uploadModel({
            modelData: planetMD,
        });
        this.sun.transform.scale(wgpu_matrix__WEBPACK_IMPORTED_MODULE_3__.vec3.create(0.12, 0.12, 0.12));
    }
    async _setupMercury() {
        const planetMD = await _wheezy_engine__WEBPACK_IMPORTED_MODULE_0__.WheezyGLBLoader.loadFromUrl('static/models/planets/mercury.glb');
        this.mercury = await this.uploadModel({
            modelData: planetMD,
        });
        this.objectManager.reparentObject(this.mercury, this.mercuryHook);
        this.mercuryHook.transform.rotateDegreesEuler({ y: 80 });
        this.mercury.transform.scale(wgpu_matrix__WEBPACK_IMPORTED_MODULE_3__.vec3.create(0.08, 0.08, 0.08));
        this.mercury.transform.translate(wgpu_matrix__WEBPACK_IMPORTED_MODULE_3__.vec3.create(1.4));
    }
    async _setupVenus() {
        const planetMD = await _wheezy_engine__WEBPACK_IMPORTED_MODULE_0__.WheezyGLBLoader.loadFromUrl('static/models/planets/venus.glb');
        this.venus = await this.uploadModel({
            modelData: planetMD,
        });
        this.objectManager.reparentObject(this.venus, this.venusHook);
        this.venusHook.transform.rotateDegreesEuler({ y: 160 });
        this.venus.transform.scale(wgpu_matrix__WEBPACK_IMPORTED_MODULE_3__.vec3.create(0.12, 0.12, 0.12));
        this.venus.transform.translate(wgpu_matrix__WEBPACK_IMPORTED_MODULE_3__.vec3.create(1.7, 0, 0));
    }
    async _setupEarth() {
        const planetMD = await _wheezy_engine__WEBPACK_IMPORTED_MODULE_0__.WheezyGLBLoader.loadFromUrl('static/models/planets/earth.glb');
        this.earth = await this.uploadModel({
            modelData: planetMD,
        });
        this.objectManager.reparentObject(this.earth, this.earthHook);
        this.earthHook.transform.rotateDegreesEuler({ y: 10 });
        this.earth.transform.rotateDegreesEuler({ x: -90 });
        this.earth.transform.scale(wgpu_matrix__WEBPACK_IMPORTED_MODULE_3__.vec3.create(0.16, 0.16, 0.16));
        this.earth.transform.translate(wgpu_matrix__WEBPACK_IMPORTED_MODULE_3__.vec3.create(2.2, 0, 0));
    }
    async _setupMars() {
        const planetMD = await _wheezy_engine__WEBPACK_IMPORTED_MODULE_0__.WheezyGLBLoader.loadFromUrl('static/models/planets/mars.glb');
        this.mars = await this.uploadModel({
            modelData: planetMD,
        });
        this.objectManager.reparentObject(this.mars, this.marsHook);
        this.marsHook.transform.rotateDegreesEuler({ y: 50 });
        this.mars.transform.scale(wgpu_matrix__WEBPACK_IMPORTED_MODULE_3__.vec3.create(0.14, 0.14, 0.14));
        this.mars.transform.translate(wgpu_matrix__WEBPACK_IMPORTED_MODULE_3__.vec3.create(2.7, 0, 0));
    }
    async _setupJupiter() {
        const planetMD = await _wheezy_engine__WEBPACK_IMPORTED_MODULE_0__.WheezyGLBLoader.loadFromUrl('static/models/planets/jupiter.glb');
        this.jupiter = await this.uploadModel({
            modelData: planetMD,
        });
        this.objectManager.reparentObject(this.jupiter, this.jupiterHook);
        this.jupiterHook.transform.rotateDegreesEuler({ y: 150 });
        this.jupiter.transform.scale(wgpu_matrix__WEBPACK_IMPORTED_MODULE_3__.vec3.create(0.15, 0.15, 0.15));
        this.jupiter.transform.rotateDegreesEuler({ x: 90 });
        this.jupiter.transform.translate(wgpu_matrix__WEBPACK_IMPORTED_MODULE_3__.vec3.create(3.4, 0, 0));
    }
    async _setupSaturn() {
        const planetMD = await _wheezy_engine__WEBPACK_IMPORTED_MODULE_0__.WheezyGLBLoader.loadFromUrl('static/models/planets/saturn.glb');
        this.saturn = await this.uploadModel({
            modelData: planetMD,
        });
        this.objectManager.reparentObject(this.saturn, this.saturnHook);
        this.saturnHook.transform.rotateDegreesEuler({ y: 210 });
        this.saturn.transform.scale(wgpu_matrix__WEBPACK_IMPORTED_MODULE_3__.vec3.create(0.0012, 0.0012, 0.0012));
        this.saturn.transform.rotateDegreesEuler({ x: 76 });
        this.saturn.transform.translate(wgpu_matrix__WEBPACK_IMPORTED_MODULE_3__.vec3.create(4.3, 0, 0));
    }
    async _setupUranus() {
        const planetMD = await _wheezy_engine__WEBPACK_IMPORTED_MODULE_0__.WheezyGLBLoader.loadFromUrl('static/models/planets/uranus.glb');
        this.uranus = await this.uploadModel({
            modelData: planetMD,
        });
        this.objectManager.reparentObject(this.uranus, this.uranusHook);
        this.uranusHook.transform.rotateDegreesEuler({ y: 270 });
        this.uranus.transform.scale(wgpu_matrix__WEBPACK_IMPORTED_MODULE_3__.vec3.create(0.2, 0.2, 0.2));
        this.uranus.transform.rotateDegreesEuler({ x: 90 });
        this.uranus.transform.translate(wgpu_matrix__WEBPACK_IMPORTED_MODULE_3__.vec3.create(5.2, 0, 0));
    }
    async _setupNeptune() {
        const planetMD = await _wheezy_engine__WEBPACK_IMPORTED_MODULE_0__.WheezyGLBLoader.loadFromUrl('static/models/planets/neptune.glb');
        this.neptune = await this.uploadModel({
            modelData: planetMD,
        });
        this.objectManager.reparentObject(this.neptune, this.neptuneHook);
        this.neptuneHook.transform.rotateDegreesEuler({ y: 100 });
        this.neptune.transform.scale(wgpu_matrix__WEBPACK_IMPORTED_MODULE_3__.vec3.create(0.2, 0.2, 0.2));
        this.neptune.transform.rotateDegreesEuler({ x: 90 });
        this.neptune.transform.translate(wgpu_matrix__WEBPACK_IMPORTED_MODULE_3__.vec3.create(5.8, 0, 0));
    }
    async init() {
        await super.init();
        await this._setupSun();
        await this._setupMercury();
        await this._setupVenus();
        await this._setupEarth();
        await this._setupMars();
        await this._setupJupiter();
        await this._setupSaturn();
        await this._setupUranus();
        await this._setupNeptune();
        const wrapper = document.createElement('div');
        wrapper.style.position = 'absolute';
        wrapper.style.top = '0';
        wrapper.style.zIndex = '10';
        wrapper.style.padding = '10px';
        const button0 = document.createElement('button');
        button0.textContent = '1 год в минуту';
        button0.addEventListener('click', () => {
            this.yearsPerMinute = 1;
        });
        const button1 = document.createElement('button');
        button1.textContent = '100 лет в минуту';
        button1.addEventListener('click', () => {
            this.yearsPerMinute = 100;
        });
        wrapper.appendChild(button0);
        wrapper.appendChild(button1);
        document.body.appendChild(wrapper);
    }
    getOrbitRotationPerFrame(name) {
        const commonDivider = 3600 / this.yearsPerMinute;
        switch (name) {
            case 'mercury':
                return (360 * 4.17) / commonDivider;
            case 'venus':
                return (360 * 1.63) / commonDivider;
            case 'earth':
                return (360 * 1) / commonDivider;
            case 'mars':
                return (360 * 0.53) / commonDivider;
            case 'jupiter':
                return (360 * 0.084) / commonDivider;
            case 'saturn':
                return (360 * 0.034) / commonDivider;
            case 'uranus':
                return (360 * 0.012) / commonDivider;
            case 'neptune':
                return (360 * 0.006) / commonDivider;
            default:
                return 0;
        }
    }
    getSelfRotationPerFrame(name) {
        const commonDivider = 3600 / this.yearsPerMinute;
        switch (name) {
            case 'sun':
                return (360 * 0.04 * 365) / commonDivider;
            case 'mercury':
                return (360 * 1.5 * 365) / commonDivider;
            case 'venus':
                return (360 * 1.502 * 365) / commonDivider;
            case 'earth':
                return (360 * 1 * 365) / commonDivider;
            case 'mars':
                return (360 * 1.03 * 365) / commonDivider;
            case 'jupiter':
                return (360 * 0.41 * 365) / commonDivider;
            case 'saturn':
                return (360 * 0.45 * 365) / commonDivider;
            case 'uranus':
                return (360 * 0.666 * 365) / commonDivider;
            case 'neptune':
                return (360 * 0.708 * 365) / commonDivider;
            default:
                return 0;
        }
    }
    onRender(deltaTime) {
        this.controller.update(deltaTime);
        //FYI: Always remember to reset orientation in blender :/
        this.sun.transform.rotateDegreesEuler({
            y: this.getSelfRotationPerFrame('sun'),
        });
        this.mercury.transform.rotateDegreesEuler({
            y: this.getSelfRotationPerFrame('mercury'),
        });
        this.mercuryHook.transform.rotateDegreesEuler({
            y: this.getOrbitRotationPerFrame('mercury'),
        });
        this.venus.transform.rotateDegreesEuler({
            y: this.getSelfRotationPerFrame('venus'),
        });
        this.venusHook.transform.rotateDegreesEuler({
            y: this.getOrbitRotationPerFrame('venus'),
        });
        this.earth.transform.rotateDegreesEuler({
            z: this.getSelfRotationPerFrame('earth'),
        });
        this.earthHook.transform.rotateDegreesEuler({
            y: this.getOrbitRotationPerFrame('earth'),
        });
        this.mars.transform.rotateDegreesEuler({
            y: this.getSelfRotationPerFrame('mars'),
        });
        this.marsHook.transform.rotateDegreesEuler({
            y: this.getOrbitRotationPerFrame('mars'),
        });
        this.jupiter.transform.rotateDegreesEuler({
            z: -this.getSelfRotationPerFrame('jupiter'),
        });
        this.jupiterHook.transform.rotateDegreesEuler({
            y: this.getOrbitRotationPerFrame('jupiter'),
        });
        this.saturn.transform.rotateDegreesEuler({
            z: -this.getSelfRotationPerFrame('saturn'),
        });
        this.saturnHook.transform.rotateDegreesEuler({
            y: this.getOrbitRotationPerFrame('saturn'),
        });
        this.uranus.transform.rotateDegreesEuler({
            z: -this.getSelfRotationPerFrame('uranus'),
        });
        this.uranusHook.transform.rotateDegreesEuler({
            y: this.getOrbitRotationPerFrame('uranus'),
        });
        this.neptune.transform.rotateDegreesEuler({
            z: -this.getSelfRotationPerFrame('neptune'),
        });
        this.neptuneHook.transform.rotateDegreesEuler({
            y: this.getOrbitRotationPerFrame('neptune'),
        });
    }
}


/***/ }),

/***/ "./src/Demo1.ts":
/*!**********************!*\
  !*** ./src/Demo1.ts ***!
  \**********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Demo1: () => (/* binding */ Demo1)
/* harmony export */ });
/* harmony import */ var _wheezy_engine__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @wheezy/engine */ "../engine/index.ts");
/* harmony import */ var _wheezy_engine_src_engine_core_cameras_ArcBallCamera__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @wheezy/engine/src/engine/core/cameras/ArcBallCamera */ "../engine/src/engine/core/cameras/ArcBallCamera/index.ts");
/* harmony import */ var _wheezy_engine_src_utils_ArcBallController__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @wheezy/engine/src/utils/ArcBallController */ "../engine/src/utils/ArcBallController/index.ts");
/* harmony import */ var wgpu_matrix__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! wgpu-matrix */ "../../node_modules/wgpu-matrix/dist/3.x/wgpu-matrix.module.js");




class Demo1 extends _wheezy_engine__WEBPACK_IMPORTED_MODULE_0__.Scene {
    constructor() {
        super();
        this.camera = new _wheezy_engine_src_engine_core_cameras_ArcBallCamera__WEBPACK_IMPORTED_MODULE_1__.ArcBallCamera({
            canvasHeight: this.engine.renderer.context.canvas.height,
            canvasWidth: this.engine.renderer.context.canvas.width,
            position: wgpu_matrix__WEBPACK_IMPORTED_MODULE_3__.vec3.create(7, 0, -7),
        });
        this._controller = new _wheezy_engine_src_utils_ArcBallController__WEBPACK_IMPORTED_MODULE_2__.ArcBallController({
            camera: this.camera,
            canvas: this.engine.renderer.context.canvas,
        });
    }
    async init() {
        await super.init();
        await this._setupSkyBox();
        const modelData = await _wheezy_engine__WEBPACK_IMPORTED_MODULE_0__.WheezyGLBLoader.loadFromUrl('static/models/DamagedHelmet.glb');
        //FIXME: when the model is at origin, lighting shits itself
        const modelGO0 = await this.uploadModel({
            modelData: modelData,
        });
        const modelGO1 = await this.uploadModel({
            modelData: modelData,
        });
        this._testHook = new _wheezy_engine__WEBPACK_IMPORTED_MODULE_0__.GameObject();
        this.objectManager.addObject(this._testHook, this.root);
        this.objectManager.reparentObject(modelGO0, this._testHook);
        this.objectManager.reparentObject(modelGO1, this._testHook);
        new _wheezy_engine__WEBPACK_IMPORTED_MODULE_0__.Transform(this._testHook);
        this.light = new _wheezy_engine__WEBPACK_IMPORTED_MODULE_0__.DirectionalLight({
            parent: this.root,
            position: wgpu_matrix__WEBPACK_IMPORTED_MODULE_3__.vec3.create(10, 0, -10),
        });
        modelGO0.transform.rotateDegreesEuler({ x: 90 });
        modelGO0.transform.translate(wgpu_matrix__WEBPACK_IMPORTED_MODULE_3__.vec3.create(0, 0, -4));
        modelGO0.transform.scale(wgpu_matrix__WEBPACK_IMPORTED_MODULE_3__.vec3.create(1.5, 1.5, 1.5));
        modelGO1.transform.rotateDegreesEuler({ x: 90, z: 130 });
        modelGO1.transform.scale(wgpu_matrix__WEBPACK_IMPORTED_MODULE_3__.vec3.create(3, 3, 3));
        modelGO1.transform.translate(wgpu_matrix__WEBPACK_IMPORTED_MODULE_3__.vec3.create(-1, 0, 7));
        this._helmet = modelGO0.transform;
        this._helmet1 = modelGO1.transform;
        this._testHook.transform.rotateDegreesEuler({ y: -40 });
    }
    async _setupSkyBox() {
        const imgSrcs = [
            'static/cubemaps/bridge/posx.jpg',
            'static/cubemaps/bridge/negx.jpg',
            'static/cubemaps/bridge/posy.jpg',
            'static/cubemaps/bridge/negy.jpg',
            'static/cubemaps/bridge/posz.jpg',
            'static/cubemaps/bridge/negz.jpg',
        ];
        const promises = imgSrcs.map(async (source) => {
            const response = await fetch(source);
            return createImageBitmap(await response.blob());
        });
        const imageBitmaps = (await Promise.all(promises));
        this._engine?.renderer.setSkyBoxTexture(imageBitmaps);
    }
    onRender(dt) {
        this._controller.update(dt);
        this._helmet.rotateDegreesEuler({ z: -5 * dt });
        // this._helmet1.rotateDegreesEuler({ z: 5 * dt })
    }
}


/***/ }),

/***/ "../engine/index.ts":
/*!**************************!*\
  !*** ../engine/index.ts ***!
  \**************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   BufferStorage: () => (/* reexport safe */ _src_engine_core__WEBPACK_IMPORTED_MODULE_0__.BufferStorage),
/* harmony export */   Camera: () => (/* reexport safe */ _src_engine_core__WEBPACK_IMPORTED_MODULE_0__.Camera),
/* harmony export */   Collider: () => (/* reexport safe */ _src_physics__WEBPACK_IMPORTED_MODULE_2__.Collider),
/* harmony export */   Component: () => (/* reexport safe */ _src_engine_core__WEBPACK_IMPORTED_MODULE_0__.Component),
/* harmony export */   DEFAULT_DEPTH_FORMAT: () => (/* reexport safe */ _src_engine_core__WEBPACK_IMPORTED_MODULE_0__.DEFAULT_DEPTH_FORMAT),
/* harmony export */   DEFAULT_IMAGE_IDS: () => (/* reexport safe */ _src_engine_types__WEBPACK_IMPORTED_MODULE_1__.DEFAULT_IMAGE_IDS),
/* harmony export */   DEFAULT_SAMPLER_IDS: () => (/* reexport safe */ _src_engine_types__WEBPACK_IMPORTED_MODULE_1__.DEFAULT_SAMPLER_IDS),
/* harmony export */   DEFAULT_SHADOW_DEPTH_FORMAT: () => (/* reexport safe */ _src_engine_core__WEBPACK_IMPORTED_MODULE_0__.DEFAULT_SHADOW_DEPTH_FORMAT),
/* harmony export */   DEFAULT_SWAP_CHAIN_FORMAT: () => (/* reexport safe */ _src_engine_core__WEBPACK_IMPORTED_MODULE_0__.DEFAULT_SWAP_CHAIN_FORMAT),
/* harmony export */   DEFULT_SHADOW_TEXTURE_SIZE: () => (/* reexport safe */ _src_engine_core__WEBPACK_IMPORTED_MODULE_0__.DEFULT_SHADOW_TEXTURE_SIZE),
/* harmony export */   DirectionalLight: () => (/* reexport safe */ _src_engine_core__WEBPACK_IMPORTED_MODULE_0__.DirectionalLight),
/* harmony export */   Engine: () => (/* reexport safe */ _src_engine_core__WEBPACK_IMPORTED_MODULE_0__.Engine),
/* harmony export */   Entity: () => (/* reexport safe */ _src_engine_core__WEBPACK_IMPORTED_MODULE_0__.Entity),
/* harmony export */   EntityTypes: () => (/* reexport safe */ _src_engine_types__WEBPACK_IMPORTED_MODULE_1__.EntityTypes),
/* harmony export */   GLTFTextureFilter: () => (/* reexport safe */ _src_engine_types__WEBPACK_IMPORTED_MODULE_1__.GLTFTextureFilter),
/* harmony export */   GLTFTextureWrap: () => (/* reexport safe */ _src_engine_types__WEBPACK_IMPORTED_MODULE_1__.GLTFTextureWrap),
/* harmony export */   GameObject: () => (/* reexport safe */ _src_engine_core__WEBPACK_IMPORTED_MODULE_0__.GameObject),
/* harmony export */   ImageStorage: () => (/* reexport safe */ _src_engine_core__WEBPACK_IMPORTED_MODULE_0__.ImageStorage),
/* harmony export */   LIGHT_SOURCE_TYPES: () => (/* reexport safe */ _src_engine_types__WEBPACK_IMPORTED_MODULE_1__.LIGHT_SOURCE_TYPES),
/* harmony export */   MSAA_SAMPLE_COUNT: () => (/* reexport safe */ _src_engine_core__WEBPACK_IMPORTED_MODULE_0__.MSAA_SAMPLE_COUNT),
/* harmony export */   MaterialStorage: () => (/* reexport safe */ _src_engine_core__WEBPACK_IMPORTED_MODULE_0__.MaterialStorage),
/* harmony export */   Mesh: () => (/* reexport safe */ _src_engine_core__WEBPACK_IMPORTED_MODULE_0__.Mesh),
/* harmony export */   ObjectManager: () => (/* reexport safe */ _src_engine_core__WEBPACK_IMPORTED_MODULE_0__.ObjectManager),
/* harmony export */   PerspectiveCamera: () => (/* reexport safe */ _src_engine_core__WEBPACK_IMPORTED_MODULE_0__.PerspectiveCamera),
/* harmony export */   PhysicsObject: () => (/* reexport safe */ _src_physics__WEBPACK_IMPORTED_MODULE_2__.PhysicsObject),
/* harmony export */   RENDER_MODES: () => (/* reexport safe */ _src_engine_types__WEBPACK_IMPORTED_MODULE_1__.RENDER_MODES),
/* harmony export */   RENDER_OUTPUT_SOURCES: () => (/* reexport safe */ _src_engine_types__WEBPACK_IMPORTED_MODULE_1__.RENDER_OUTPUT_SOURCES),
/* harmony export */   Renderer: () => (/* reexport safe */ _src_engine_core__WEBPACK_IMPORTED_MODULE_0__.Renderer),
/* harmony export */   SamplerStorage: () => (/* reexport safe */ _src_engine_core__WEBPACK_IMPORTED_MODULE_0__.SamplerStorage),
/* harmony export */   Scene: () => (/* reexport safe */ _src_engine_core__WEBPACK_IMPORTED_MODULE_0__.Scene),
/* harmony export */   SceneTree: () => (/* reexport safe */ _src_engine_core__WEBPACK_IMPORTED_MODULE_0__.SceneTree),
/* harmony export */   TextureStorage: () => (/* reexport safe */ _src_engine_core__WEBPACK_IMPORTED_MODULE_0__.TextureStorage),
/* harmony export */   Transform: () => (/* reexport safe */ _src_engine_core__WEBPACK_IMPORTED_MODULE_0__.Transform),
/* harmony export */   VIEW_PARAMS_BUFFER_SIZE: () => (/* reexport safe */ _src_engine_core__WEBPACK_IMPORTED_MODULE_0__.VIEW_PARAMS_BUFFER_SIZE),
/* harmony export */   WheezyGLBLoader: () => (/* reexport safe */ _src_utils__WEBPACK_IMPORTED_MODULE_3__.WheezyGLBLoader),
/* harmony export */   alignTo: () => (/* reexport safe */ _src_engine_core__WEBPACK_IMPORTED_MODULE_0__.alignTo)
/* harmony export */ });
/* harmony import */ var _src_engine_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./src/engine/core */ "../engine/src/engine/core/index.ts");
/* harmony import */ var _src_engine_types__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./src/engine/types */ "../engine/src/engine/types/index.ts");
/* harmony import */ var _src_physics__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./src/physics */ "../engine/src/physics/index.ts");
/* harmony import */ var _src_utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./src/utils */ "../engine/src/utils/index.ts");






/***/ }),

/***/ "../engine/src/engine/core/BufferStorage/BufferStorage.ts":
/*!****************************************************************!*\
  !*** ../engine/src/engine/core/BufferStorage/BufferStorage.ts ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   BufferStorage: () => (/* binding */ BufferStorage)
/* harmony export */ });
class BufferStorage {
    constructor() {
        this._buffers = new Map();
    }
    get buffers() {
        return this._buffers;
    }
}


/***/ }),

/***/ "../engine/src/engine/core/BufferStorage/index.ts":
/*!********************************************************!*\
  !*** ../engine/src/engine/core/BufferStorage/index.ts ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   BufferStorage: () => (/* reexport safe */ _BufferStorage__WEBPACK_IMPORTED_MODULE_0__.BufferStorage)
/* harmony export */ });
/* harmony import */ var _BufferStorage__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./BufferStorage */ "../engine/src/engine/core/BufferStorage/BufferStorage.ts");



/***/ }),

/***/ "../engine/src/engine/core/Component/Component.ts":
/*!********************************************************!*\
  !*** ../engine/src/engine/core/Component/Component.ts ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Component: () => (/* binding */ Component)
/* harmony export */ });
/* harmony import */ var _Entity__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Entity */ "../engine/src/engine/core/Entity/index.ts");

class Component extends _Entity__WEBPACK_IMPORTED_MODULE_0__.Entity {
    constructor(parent, componentType) {
        super(componentType);
        this._parent = parent;
        this._parent.addComponent(this);
    }
    get parent() {
        return this._parent;
    }
}


/***/ }),

/***/ "../engine/src/engine/core/Component/index.ts":
/*!****************************************************!*\
  !*** ../engine/src/engine/core/Component/index.ts ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Component: () => (/* reexport safe */ _Component__WEBPACK_IMPORTED_MODULE_0__.Component)
/* harmony export */ });
/* harmony import */ var _Component__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Component */ "../engine/src/engine/core/Component/Component.ts");



/***/ }),

/***/ "../engine/src/engine/core/Engine/Engine.ts":
/*!**************************************************!*\
  !*** ../engine/src/engine/core/Engine/Engine.ts ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Engine: () => (/* binding */ Engine)
/* harmony export */ });
/* harmony import */ var _Renderer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Renderer */ "../engine/src/engine/core/Renderer/index.ts");

class Engine {
    constructor() {
        this._prevFrameTime = 0;
    }
    async initRenderer(canvas) {
        this._renderer = new _Renderer__WEBPACK_IMPORTED_MODULE_0__.Renderer({ canvas });
        await this._renderer.init();
    }
    static async getOrInit({ canvas, }) {
        //FIXME: types
        try {
            if (window.WheezyEngine) {
                console.warn('Engine has already been instanced');
                return window.WheezyEngine;
            }
            const engineInstance = new Engine();
            await engineInstance.initRenderer(canvas);
            window.WheezyEngine = engineInstance;
            return engineInstance;
        }
        catch (err) {
            alert(err);
        }
    }
    get renderer() {
        return this._renderer;
    }
    get scene() {
        return this._scene;
    }
    set scene(scene) {
        this._scene = scene;
    }
    render(time = 0) {
        if (!this.scene)
            return;
        const dt = (time - this._prevFrameTime) / 100;
        this._prevFrameTime = time;
        this._renderer.render(dt, this.scene);
        requestAnimationFrame((time) => this.render(time));
    }
}


/***/ }),

/***/ "../engine/src/engine/core/Engine/index.ts":
/*!*************************************************!*\
  !*** ../engine/src/engine/core/Engine/index.ts ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   DEFAULT_DEPTH_FORMAT: () => (/* reexport safe */ _Renderer_constants__WEBPACK_IMPORTED_MODULE_1__.DEFAULT_DEPTH_FORMAT),
/* harmony export */   DEFAULT_SHADOW_DEPTH_FORMAT: () => (/* reexport safe */ _Renderer_constants__WEBPACK_IMPORTED_MODULE_1__.DEFAULT_SHADOW_DEPTH_FORMAT),
/* harmony export */   DEFAULT_SWAP_CHAIN_FORMAT: () => (/* reexport safe */ _Renderer_constants__WEBPACK_IMPORTED_MODULE_1__.DEFAULT_SWAP_CHAIN_FORMAT),
/* harmony export */   DEFULT_SHADOW_TEXTURE_SIZE: () => (/* reexport safe */ _Renderer_constants__WEBPACK_IMPORTED_MODULE_1__.DEFULT_SHADOW_TEXTURE_SIZE),
/* harmony export */   Engine: () => (/* reexport safe */ _Engine__WEBPACK_IMPORTED_MODULE_0__.Engine),
/* harmony export */   MSAA_SAMPLE_COUNT: () => (/* reexport safe */ _Renderer_constants__WEBPACK_IMPORTED_MODULE_1__.MSAA_SAMPLE_COUNT),
/* harmony export */   VIEW_PARAMS_BUFFER_SIZE: () => (/* reexport safe */ _Renderer_constants__WEBPACK_IMPORTED_MODULE_1__.VIEW_PARAMS_BUFFER_SIZE)
/* harmony export */ });
/* harmony import */ var _Engine__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Engine */ "../engine/src/engine/core/Engine/Engine.ts");
/* harmony import */ var _Renderer_constants__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Renderer/constants */ "../engine/src/engine/core/Renderer/constants.ts");




/***/ }),

/***/ "../engine/src/engine/core/Entity/Entity.ts":
/*!**************************************************!*\
  !*** ../engine/src/engine/core/Entity/Entity.ts ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Entity: () => (/* binding */ Entity)
/* harmony export */ });
class Entity {
    constructor(type) {
        this._id = this._generateId();
        this._type = type;
    }
    _generateId() {
        return String(Math.random());
    }
    get id() {
        return this._id;
    }
    get type() {
        return this._type;
    }
}


/***/ }),

/***/ "../engine/src/engine/core/Entity/index.ts":
/*!*************************************************!*\
  !*** ../engine/src/engine/core/Entity/index.ts ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Entity: () => (/* reexport safe */ _Entity__WEBPACK_IMPORTED_MODULE_0__.Entity)
/* harmony export */ });
/* harmony import */ var _Entity__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Entity */ "../engine/src/engine/core/Entity/Entity.ts");



/***/ }),

/***/ "../engine/src/engine/core/GameObject/GameObject.ts":
/*!**********************************************************!*\
  !*** ../engine/src/engine/core/GameObject/GameObject.ts ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   GameObject: () => (/* binding */ GameObject)
/* harmony export */ });
/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../types */ "../engine/src/engine/types/index.ts");
/* harmony import */ var _Entity__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Entity */ "../engine/src/engine/core/Entity/index.ts");


class GameObject extends _Entity__WEBPACK_IMPORTED_MODULE_1__.Entity {
    constructor() {
        super(_types__WEBPACK_IMPORTED_MODULE_0__.EntityTypes.gameObject);
        this._components = new Map();
        this._name = `GameObject ${super.id}`;
    }
    get name() {
        return this._name;
    }
    set name(value) {
        this._name = value;
    }
    get components() {
        return this._components;
    }
    get transform() {
        //FIXME: find a less dumb way to do it
        if (this._transform) {
            return this._transform;
        }
        return [...this.components.values()].find((component) => component.type === _types__WEBPACK_IMPORTED_MODULE_0__.EntityTypes.transform);
    }
    addComponent(component) {
        this._components.set(component.id, component);
    }
    removeComponent(id) {
        this._components.delete(id);
    }
}


/***/ }),

/***/ "../engine/src/engine/core/GameObject/index.ts":
/*!*****************************************************!*\
  !*** ../engine/src/engine/core/GameObject/index.ts ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   GameObject: () => (/* reexport safe */ _GameObject__WEBPACK_IMPORTED_MODULE_0__.GameObject)
/* harmony export */ });
/* harmony import */ var _GameObject__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./GameObject */ "../engine/src/engine/core/GameObject/GameObject.ts");



/***/ }),

/***/ "../engine/src/engine/core/ImageStorage/ImageStorage.ts":
/*!**************************************************************!*\
  !*** ../engine/src/engine/core/ImageStorage/ImageStorage.ts ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ImageStorage: () => (/* binding */ ImageStorage)
/* harmony export */ });
/* harmony import */ var _types_core_ImageStorage__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../types/core/ImageStorage */ "../engine/src/engine/types/core/ImageStorage/index.ts");

class ImageStorage {
    constructor() {
        this._images = new Map();
    }
    async createDefaults() {
        const whiteBitmap = await createImageBitmap(new ImageData(new Uint8ClampedArray([255, 255, 255, 255]), 1, 1));
        const greyBitmap = await createImageBitmap(new ImageData(new Uint8ClampedArray([255, 252, 235, 255]), 1, 1));
        const blackBitmap = await createImageBitmap(new ImageData(new Uint8ClampedArray([0, 0, 0, 255]), 1, 1));
        const normalBitmap = await createImageBitmap(new ImageData(new Uint8ClampedArray([128, 128, 255, 255]), 1, 1));
        this._images.set(_types_core_ImageStorage__WEBPACK_IMPORTED_MODULE_0__.DEFAULT_IMAGE_IDS.metallicRoughness, whiteBitmap);
        this._images.set(_types_core_ImageStorage__WEBPACK_IMPORTED_MODULE_0__.DEFAULT_IMAGE_IDS.occlusion, whiteBitmap);
        this._images.set(_types_core_ImageStorage__WEBPACK_IMPORTED_MODULE_0__.DEFAULT_IMAGE_IDS.baseColor, greyBitmap);
        this._images.set(_types_core_ImageStorage__WEBPACK_IMPORTED_MODULE_0__.DEFAULT_IMAGE_IDS.emission, blackBitmap);
        this._images.set(_types_core_ImageStorage__WEBPACK_IMPORTED_MODULE_0__.DEFAULT_IMAGE_IDS.normal, normalBitmap);
    }
    get images() {
        return this._images;
    }
}


/***/ }),

/***/ "../engine/src/engine/core/ImageStorage/index.ts":
/*!*******************************************************!*\
  !*** ../engine/src/engine/core/ImageStorage/index.ts ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ImageStorage: () => (/* reexport safe */ _ImageStorage__WEBPACK_IMPORTED_MODULE_0__.ImageStorage)
/* harmony export */ });
/* harmony import */ var _ImageStorage__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ImageStorage */ "../engine/src/engine/core/ImageStorage/ImageStorage.ts");



/***/ }),

/***/ "../engine/src/engine/core/MaterialStorage/MaterialStorage.ts":
/*!********************************************************************!*\
  !*** ../engine/src/engine/core/MaterialStorage/MaterialStorage.ts ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   MaterialStorage: () => (/* binding */ MaterialStorage)
/* harmony export */ });
class MaterialStorage {
    constructor() {
        this._materials = new Map();
    }
    get materials() {
        return this._materials;
    }
}


/***/ }),

/***/ "../engine/src/engine/core/MaterialStorage/index.ts":
/*!**********************************************************!*\
  !*** ../engine/src/engine/core/MaterialStorage/index.ts ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   MaterialStorage: () => (/* reexport safe */ _MaterialStorage__WEBPACK_IMPORTED_MODULE_0__.MaterialStorage)
/* harmony export */ });
/* harmony import */ var _MaterialStorage__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./MaterialStorage */ "../engine/src/engine/core/MaterialStorage/MaterialStorage.ts");



/***/ }),

/***/ "../engine/src/engine/core/Mesh/Mesh.ts":
/*!**********************************************!*\
  !*** ../engine/src/engine/core/Mesh/Mesh.ts ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Mesh: () => (/* binding */ Mesh)
/* harmony export */ });
/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../types */ "../engine/src/engine/types/index.ts");
/* harmony import */ var _Component__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Component */ "../engine/src/engine/core/Component/index.ts");


class Mesh extends _Component__WEBPACK_IMPORTED_MODULE_1__.Component {
    constructor(parent, positions, indices, normals, textureCoordinates, tangents, material) {
        super(parent, _types__WEBPACK_IMPORTED_MODULE_0__.EntityTypes.mesh);
        this.mode = 4; // GPU topology mode
        this.isPipelineBuilt = false;
        this.positions = positions;
        this.indices = indices;
        this.textureCoordinates = textureCoordinates;
        this.material = material;
        this.normals = normals;
        this.tangents = tangents;
    }
}


/***/ }),

/***/ "../engine/src/engine/core/Mesh/index.ts":
/*!***********************************************!*\
  !*** ../engine/src/engine/core/Mesh/index.ts ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Mesh: () => (/* reexport safe */ _Mesh__WEBPACK_IMPORTED_MODULE_0__.Mesh)
/* harmony export */ });
/* harmony import */ var _Mesh__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Mesh */ "../engine/src/engine/core/Mesh/Mesh.ts");



/***/ }),

/***/ "../engine/src/engine/core/MeshRenderDataStorage/MeshRenderDataStorage.ts":
/*!********************************************************************************!*\
  !*** ../engine/src/engine/core/MeshRenderDataStorage/MeshRenderDataStorage.ts ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   MeshRenderDataStorage: () => (/* binding */ MeshRenderDataStorage)
/* harmony export */ });
class MeshRenderDataStorage {
    constructor() {
        this._data = new Map();
    }
    get data() {
        return this._data;
    }
}


/***/ }),

/***/ "../engine/src/engine/core/MeshRenderDataStorage/index.ts":
/*!****************************************************************!*\
  !*** ../engine/src/engine/core/MeshRenderDataStorage/index.ts ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   MeshRenderDataStorage: () => (/* reexport safe */ _MeshRenderDataStorage__WEBPACK_IMPORTED_MODULE_0__.MeshRenderDataStorage)
/* harmony export */ });
/* harmony import */ var _MeshRenderDataStorage__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./MeshRenderDataStorage */ "../engine/src/engine/core/MeshRenderDataStorage/MeshRenderDataStorage.ts");



/***/ }),

/***/ "../engine/src/engine/core/ModelUploader/ModelUploader.ts":
/*!****************************************************************!*\
  !*** ../engine/src/engine/core/ModelUploader/ModelUploader.ts ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ModelUploader: () => (/* binding */ ModelUploader)
/* harmony export */ });
/* harmony import */ var wgpu_matrix__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! wgpu-matrix */ "../../node_modules/wgpu-matrix/dist/3.x/wgpu-matrix.module.js");
/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../types */ "../engine/src/engine/types/index.ts");
/* harmony import */ var _GameObject__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../GameObject */ "../engine/src/engine/core/GameObject/index.ts");
/* harmony import */ var _Mesh__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../Mesh */ "../engine/src/engine/core/Mesh/index.ts");
/* harmony import */ var _Transform__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../Transform */ "../engine/src/engine/core/Transform/index.ts");





class ModelUploader {
    static getTextureFilterMode(filter) {
        switch (filter) {
            case _types__WEBPACK_IMPORTED_MODULE_0__.GLTFTextureFilter.NEAREST_MIPMAP_NEAREST:
            case _types__WEBPACK_IMPORTED_MODULE_0__.GLTFTextureFilter.NEAREST_MIPMAP_LINEAR:
            case _types__WEBPACK_IMPORTED_MODULE_0__.GLTFTextureFilter.NEAREST:
                return 'nearest';
            case _types__WEBPACK_IMPORTED_MODULE_0__.GLTFTextureFilter.LINEAR_MIPMAP_NEAREST:
            case _types__WEBPACK_IMPORTED_MODULE_0__.GLTFTextureFilter.LINEAR_MIPMAP_LINEAR:
            case _types__WEBPACK_IMPORTED_MODULE_0__.GLTFTextureFilter.LINEAR:
                return 'linear';
            default:
                return 'linear';
        }
    }
    static getTextureMipMapMode(filter) {
        switch (filter) {
            case _types__WEBPACK_IMPORTED_MODULE_0__.GLTFTextureFilter.NEAREST_MIPMAP_NEAREST:
            case _types__WEBPACK_IMPORTED_MODULE_0__.GLTFTextureFilter.LINEAR_MIPMAP_NEAREST:
            case _types__WEBPACK_IMPORTED_MODULE_0__.GLTFTextureFilter.NEAREST:
                return 'nearest';
            case _types__WEBPACK_IMPORTED_MODULE_0__.GLTFTextureFilter.LINEAR_MIPMAP_LINEAR:
            case _types__WEBPACK_IMPORTED_MODULE_0__.GLTFTextureFilter.NEAREST_MIPMAP_LINEAR:
            case _types__WEBPACK_IMPORTED_MODULE_0__.GLTFTextureFilter.LINEAR:
                return 'linear';
        }
    }
    static getTextureAddressMode(mode) {
        switch (mode) {
            case _types__WEBPACK_IMPORTED_MODULE_0__.GLTFTextureWrap.REPEAT:
                return 'repeat';
            case _types__WEBPACK_IMPORTED_MODULE_0__.GLTFTextureWrap.CLAMP_TO_EDGE:
                return 'clamp-to-edge';
            case _types__WEBPACK_IMPORTED_MODULE_0__.GLTFTextureWrap.MIRRORED_REPEAT:
                return 'mirror-repeat';
            default:
                return 'repeat';
        }
    }
    static async uploadImages(modelData, bufferStorage, imageStorage) {
        for (let [key, value] of modelData.images.entries()) {
            const { bufferView: { buffer, byteLength, byteOffset }, mimeType, } = value;
            const imageView = new Uint8Array(bufferStorage.buffers.get(buffer), byteOffset, byteLength);
            const blob = new Blob([imageView], { type: mimeType });
            const bitmap = await createImageBitmap(blob);
            imageStorage.images.set(key, bitmap);
        }
    }
    static uploadBuffers(modelData, bufferStorage) {
        modelData.buffers.forEach((value, key) => {
            bufferStorage.buffers.set(key, value);
        });
    }
    static uploadSamplers(modelData, samplerStorage, device) {
        modelData.samplers.forEach((value, key) => {
            const gpuSampler = device.createSampler({
                magFilter: this.getTextureFilterMode(value?.magFilter),
                minFilter: this.getTextureFilterMode(value?.minFilter),
                addressModeU: this.getTextureAddressMode(value?.wrapS),
                addressModeV: this.getTextureAddressMode(value?.wrapT),
                //FIXME: use mipmap filtration
                mipmapFilter: 'nearest',
            });
            samplerStorage.samplers.set(key, gpuSampler);
        });
    }
    static uploadTextures(modelData, textureStorage) {
        modelData.textures.forEach((value, key) => {
            textureStorage.textures.set(key, value);
        });
    }
    static createGPUTexture(device, format, samplerStorage, imageStorage, texturePreloadData) {
        let textureView;
        let textureSampler;
        if (!texturePreloadData) {
            throw new Error('No texture data');
        }
        if (!texturePreloadData.imageId) {
            throw new Error('No image view for this texture');
        }
        if (!texturePreloadData.samplerId) {
            throw new Error('No sampler for this texture');
        }
        textureSampler = samplerStorage.samplers.get(texturePreloadData.samplerId);
        const imageBitmap = imageStorage.images.get(texturePreloadData.imageId);
        const imageSize = [imageBitmap.width, imageBitmap.height, 1];
        const imageTexture = device.createTexture({
            size: imageSize,
            format: format,
            usage: GPUTextureUsage.TEXTURE_BINDING |
                GPUTextureUsage.COPY_DST |
                GPUTextureUsage.RENDER_ATTACHMENT,
        });
        device.queue.copyExternalImageToTexture({ source: imageBitmap }, { texture: imageTexture }, imageSize);
        textureView = imageTexture.createView();
        return { view: textureView, sampler: textureSampler };
    }
    static uploadMaterials(modelData, textureStorage, samplerStorage, imageStorage, materialStorage, device) {
        let defaultMaterial = materialStorage.materials.get('default');
        if (!defaultMaterial) {
            defaultMaterial = {
                name: 'Default wheezy material',
                emissiveFactor: wgpu_matrix__WEBPACK_IMPORTED_MODULE_4__.vec3.create(1, 1, 1),
                metallicFactor: 1,
                roughnessFactor: 1,
                baseColorFactor: wgpu_matrix__WEBPACK_IMPORTED_MODULE_4__.vec4.create(1, 1, 1, 1),
                baseColorTexture: this.createGPUTexture(device, 'rgba8unorm-srgb', samplerStorage, imageStorage, textureStorage.defaultBaseColor),
                metallicRoughnessTexture: this.createGPUTexture(device, 'rgba8unorm', samplerStorage, imageStorage, textureStorage.defaultMetallicRoughness),
                normalTexture: this.createGPUTexture(device, 'rgba8unorm', samplerStorage, imageStorage, textureStorage.defaultNormal),
                occlusionTexture: this.createGPUTexture(device, 'rgba8unorm', samplerStorage, imageStorage, textureStorage.defaultOcclusion),
                emissiveTexture: this.createGPUTexture(device, 'rgba8unorm', samplerStorage, imageStorage, textureStorage.defaultEmission),
            };
            materialStorage.materials.set('default', defaultMaterial);
        }
        modelData.materials.forEach((value, key) => {
            const material = {
                name: value.name,
                emissiveFactor: value?.emissiveFactor ?? defaultMaterial.emissiveFactor,
                metallicFactor: value?.metallicFactor ?? defaultMaterial.metallicFactor,
                roughnessFactor: value.roughnessFactor ?? defaultMaterial.roughnessFactor,
                baseColorFactor: value?.baseColorFactor ?? defaultMaterial.baseColorFactor,
                baseColorTexture: value.baseColorTextureId
                    ? this.createGPUTexture(device, 'rgba8unorm-srgb', samplerStorage, imageStorage, textureStorage.textures.get(value.baseColorTextureId))
                    : defaultMaterial.baseColorTexture,
                metallicRoughnessTexture: value.metallicRoughnessTextureId
                    ? this.createGPUTexture(device, 'rgba8unorm', samplerStorage, imageStorage, textureStorage.textures.get(value.metallicRoughnessTextureId))
                    : defaultMaterial.metallicRoughnessTexture,
                normalTexture: value.normalTextureId
                    ? this.createGPUTexture(device, 'rgba8unorm', samplerStorage, imageStorage, textureStorage.textures.get(value.normalTextureId))
                    : defaultMaterial.normalTexture,
                occlusionTexture: value.occlusionTextureId
                    ? this.createGPUTexture(device, 'rgba8unorm', samplerStorage, imageStorage, textureStorage.textures.get(value.occlusionTextureId))
                    : defaultMaterial.occlusionTexture,
                emissiveTexture: value.emissiveTextureId
                    ? this.createGPUTexture(device, 'rgba8unorm', samplerStorage, imageStorage, textureStorage.textures.get(value.emissiveTextureId))
                    : defaultMaterial.emissiveTexture,
            };
            materialStorage.materials.set(key, material);
        });
    }
    static traversePreloadNode(node, parentGameObject, objectManager, bufferStorage, materialStorage, device) {
        const { trsMatrix, meshes, children } = node;
        const gameObject = new _GameObject__WEBPACK_IMPORTED_MODULE_1__.GameObject();
        objectManager.addObject(gameObject, parentGameObject);
        new _Transform__WEBPACK_IMPORTED_MODULE_3__.Transform(gameObject, trsMatrix);
        meshes.forEach((meshData) => {
            new _Mesh__WEBPACK_IMPORTED_MODULE_2__.Mesh(gameObject, meshData.positions, meshData.indices, meshData.normals, meshData.textureCoordinates, meshData.tangents, materialStorage.materials.get(meshData.materialId));
        });
        children.forEach((child) => {
            this.traversePreloadNode(child, gameObject, objectManager, bufferStorage, materialStorage, device);
        });
    }
    static async uploadModel(modelData, objectManager, bufferStorage, imageStorage, samplerStorage, materialStorage, textureStorage, sceneObject, device) {
        this.uploadBuffers(modelData, bufferStorage);
        await this.uploadImages(modelData, bufferStorage, imageStorage);
        this.uploadSamplers(modelData, samplerStorage, device);
        this.uploadTextures(modelData, textureStorage);
        this.uploadMaterials(modelData, textureStorage, samplerStorage, imageStorage, materialStorage, device);
        const { trsMatrix, meshes, children } = modelData.model;
        const meshObject = new _GameObject__WEBPACK_IMPORTED_MODULE_1__.GameObject();
        objectManager.addObject(meshObject, sceneObject);
        new _Transform__WEBPACK_IMPORTED_MODULE_3__.Transform(meshObject, trsMatrix);
        meshes.forEach((meshData) => {
            new _Mesh__WEBPACK_IMPORTED_MODULE_2__.Mesh(meshObject, meshData.positions, meshData.indices, meshData.normals, meshData.textureCoordinates, meshData.tangents, materialStorage.materials.get(meshData.materialId));
        });
        children.forEach((child) => {
            this.traversePreloadNode(child, meshObject, objectManager, bufferStorage, materialStorage, device);
        });
        return meshObject;
    }
}


/***/ }),

/***/ "../engine/src/engine/core/ModelUploader/index.ts":
/*!********************************************************!*\
  !*** ../engine/src/engine/core/ModelUploader/index.ts ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ModelUploader: () => (/* reexport safe */ _ModelUploader__WEBPACK_IMPORTED_MODULE_0__.ModelUploader)
/* harmony export */ });
/* harmony import */ var _ModelUploader__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ModelUploader */ "../engine/src/engine/core/ModelUploader/ModelUploader.ts");



/***/ }),

/***/ "../engine/src/engine/core/ObjectManager/ObjectManager.ts":
/*!****************************************************************!*\
  !*** ../engine/src/engine/core/ObjectManager/ObjectManager.ts ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ObjectManager: () => (/* binding */ ObjectManager)
/* harmony export */ });
/* harmony import */ var _SceneTree__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../SceneTree */ "../engine/src/engine/core/SceneTree/index.ts");

class ObjectManager {
    constructor() {
        this._objectPositions = new Map();
        this._sceneTree = new _SceneTree__WEBPACK_IMPORTED_MODULE_0__.SceneTree();
    }
    get sceneTree() {
        return this._sceneTree;
    }
    getObjectPosition(gameObject) {
        return gameObject
            ? this._objectPositions.get(gameObject.id) ?? null
            : null;
    }
    addObject(child, target) {
        const position = this._sceneTree.addNodeAt(this.getObjectPosition(target), {
            gameObject: child,
            children: new Map(),
        });
        this._objectPositions.set(child.id, position);
    }
    reparentObject(child, target) {
        const childPosition = this._objectPositions.get(child.id);
        if (!childPosition) {
            throw new Error(`Position record not found for ${child.id}`);
        }
        const newPosition = this._sceneTree.reparentNode(this.getObjectPosition(target), childPosition);
        this._objectPositions.set(child.id, newPosition);
    }
    destroyObject(gameObject) {
        const childPosition = this._objectPositions.get(gameObject.id);
        if (!childPosition) {
            throw new Error(`Position record not found for ${gameObject.id}`);
        }
        const idsToRemove = this._sceneTree.removeNode(childPosition);
        idsToRemove.forEach((id) => {
            this._objectPositions.delete(id);
        });
    }
}


/***/ }),

/***/ "../engine/src/engine/core/ObjectManager/index.ts":
/*!********************************************************!*\
  !*** ../engine/src/engine/core/ObjectManager/index.ts ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ObjectManager: () => (/* reexport safe */ _ObjectManager__WEBPACK_IMPORTED_MODULE_0__.ObjectManager)
/* harmony export */ });
/* harmony import */ var _ObjectManager__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ObjectManager */ "../engine/src/engine/core/ObjectManager/ObjectManager.ts");



/***/ }),

/***/ "../engine/src/engine/core/Renderer/Renderer.ts":
/*!******************************************************!*\
  !*** ../engine/src/engine/core/Renderer/Renderer.ts ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Renderer: () => (/* binding */ Renderer),
/* harmony export */   alignTo: () => (/* binding */ alignTo)
/* harmony export */ });
/* harmony import */ var wgpu_matrix__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! wgpu-matrix */ "../../node_modules/wgpu-matrix/dist/3.x/wgpu-matrix.module.js");
/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../types */ "../engine/src/engine/types/index.ts");
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./constants */ "../engine/src/engine/core/Renderer/constants.ts");
/* harmony import */ var _shaders_testShader_wgsl__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../shaders/testShader.wgsl */ "../engine/src/engine/shaders/testShader.wgsl");
/* harmony import */ var _shaders_vertexShadow_wgsl__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../shaders/vertexShadow.wgsl */ "../engine/src/engine/shaders/vertexShadow.wgsl");
/* harmony import */ var _shaders_skybox_wgsl__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../shaders/skybox.wgsl */ "../engine/src/engine/shaders/skybox.wgsl");
/* harmony import */ var _primitives_cube__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../primitives/cube */ "../engine/src/engine/primitives/cube.ts");







const alignTo = (val, align) => {
    return Math.floor((val + align - 1) / align) * align;
};
const skyBoxUniformBufferSize = 4 * 16 + 4 * 16 + 4 * 16 + 4 * 4;
class Renderer {
    constructor({ canvas }) {
        this._swapChainFormat = _constants__WEBPACK_IMPORTED_MODULE_1__.DEFAULT_SWAP_CHAIN_FORMAT;
        this._depthTextureFormat = _constants__WEBPACK_IMPORTED_MODULE_1__.DEFAULT_DEPTH_FORMAT;
        this._shadowDepthTextureSize = _constants__WEBPACK_IMPORTED_MODULE_1__.DEFULT_SHADOW_TEXTURE_SIZE;
        this._skyBoxUniformBufferSize = 16 * 4 * 3 + 4 * 4;
        this._skyBoxModelMatrix = wgpu_matrix__WEBPACK_IMPORTED_MODULE_6__.mat4.scaling(wgpu_matrix__WEBPACK_IMPORTED_MODULE_6__.vec3.fromValues(100, 100, 100));
        this._viewParamsBufferSize = _constants__WEBPACK_IMPORTED_MODULE_1__.VIEW_PARAMS_BUFFER_SIZE;
        this._msaaSampleCount = _constants__WEBPACK_IMPORTED_MODULE_1__.MSAA_SAMPLE_COUNT;
        this.ambientLightColor = wgpu_matrix__WEBPACK_IMPORTED_MODULE_6__.vec3.create(1, 1, 1);
        this.ambientLightIntensity = 0.03;
        this.outputSource = _types__WEBPACK_IMPORTED_MODULE_0__.RENDER_OUTPUT_SOURCES.DEFAULT;
        this.renderingMode = _types__WEBPACK_IMPORTED_MODULE_0__.RENDER_MODES.USE_F_NORMAL;
        this._canvas = canvas;
    }
    async init() {
        await this._initializeContext(this._canvas);
        this._context.configure({
            device: this._device,
            usage: GPUTextureUsage.RENDER_ATTACHMENT,
            format: this._swapChainFormat,
        });
        this._depthTexture = this._device.createTexture({
            label: 'depthTexture',
            size: {
                width: this._context.canvas.width,
                height: this._context.canvas.height,
            },
            sampleCount: this._msaaSampleCount,
            format: this._depthTextureFormat,
            usage: GPUTextureUsage.RENDER_ATTACHMENT,
        });
        this._shadowDepthTexture = this._device.createTexture({
            label: 'shadowDepthTexture',
            size: [
                this._shadowDepthTextureSize,
                this._shadowDepthTextureSize,
                1,
            ],
            usage: GPUTextureUsage.RENDER_ATTACHMENT |
                GPUTextureUsage.TEXTURE_BINDING,
            format: _constants__WEBPACK_IMPORTED_MODULE_1__.DEFAULT_SHADOW_DEPTH_FORMAT,
        });
        this._shadowDepthSampler = this.device.createSampler({
            compare: 'less',
            label: 'shadow depth sampler',
        });
        this._shadowDepthTextureView = this._shadowDepthTexture.createView();
        this._shaderModule = this.device.createShaderModule({
            label: 'main shader',
            code: _shaders_testShader_wgsl__WEBPACK_IMPORTED_MODULE_2__,
        });
        this._initializeBindGroupLayouts();
        this._initializeViewParams();
        if (this._msaaSampleCount !== 1) {
            this._multisampleTextureView = this.device
                .createTexture({
                size: [this._canvas.width, this._canvas.height],
                sampleCount: this._msaaSampleCount,
                format: this.swapChainFormat,
                usage: GPUTextureUsage.RENDER_ATTACHMENT,
            })
                .createView();
        }
        else {
            this._multisampleTextureView = undefined;
        }
        this._renderPassDescriptor = {
            label: 'main render pass descriptor',
            colorAttachments: [
                {
                    view: null,
                    resolveTarget: (this._msaaSampleCount === 1
                        ? undefined
                        : null),
                    loadOp: 'load',
                    clearValue: [0.0, 0.0, 0.0, 0.0],
                    storeOp: 'store',
                },
            ],
            depthStencilAttachment: {
                view: this._depthTexture.createView(),
                depthLoadOp: 'clear',
                depthClearValue: 1.0,
                depthStoreOp: 'store',
                stencilLoadOp: 'clear',
                stencilClearValue: 0,
                stencilStoreOp: 'store',
            },
        };
        this._shadowPassDescriptor = {
            colorAttachments: [],
            depthStencilAttachment: {
                view: this._shadowDepthTextureView,
                depthClearValue: 1.0,
                depthLoadOp: 'clear',
                depthStoreOp: 'store',
            },
        };
        this._skyBoxVerticesBuffer = this._device.createBuffer({
            size: _primitives_cube__WEBPACK_IMPORTED_MODULE_5__.cubeVertexArray.byteLength,
            usage: GPUBufferUsage.VERTEX,
            mappedAtCreation: true,
        });
        new Float32Array(this._skyBoxVerticesBuffer.getMappedRange()).set(_primitives_cube__WEBPACK_IMPORTED_MODULE_5__.cubeVertexArray);
        this._skyBoxVerticesBuffer.unmap();
        this._skyBoxPipeline = this._device.createRenderPipeline({
            layout: 'auto',
            vertex: {
                module: this._device.createShaderModule({
                    code: _shaders_skybox_wgsl__WEBPACK_IMPORTED_MODULE_4__,
                }),
                buffers: [
                    {
                        arrayStride: _primitives_cube__WEBPACK_IMPORTED_MODULE_5__.cubeVertexSize,
                        attributes: [
                            {
                                shaderLocation: 0,
                                offset: _primitives_cube__WEBPACK_IMPORTED_MODULE_5__.cubePositionOffset,
                                format: 'float32x4',
                            },
                            {
                                shaderLocation: 1,
                                offset: _primitives_cube__WEBPACK_IMPORTED_MODULE_5__.cubeUVOffset,
                                format: 'float32x2',
                            },
                        ],
                    },
                ],
            },
            fragment: {
                module: this._device.createShaderModule({
                    code: _shaders_skybox_wgsl__WEBPACK_IMPORTED_MODULE_4__,
                }),
                targets: [
                    {
                        format: this._swapChainFormat,
                    },
                ],
            },
            primitive: {
                topology: 'triangle-list',
                cullMode: 'front',
            },
            depthStencil: {
                depthWriteEnabled: true,
                depthCompare: 'less',
                format: this._depthTextureFormat,
            },
            multisample: {
                count: this._msaaSampleCount,
            },
        });
        this._skyboxSampler = this._device.createSampler({
            magFilter: 'linear',
            minFilter: 'linear',
        });
        this._skyBoxUniformBuffer = this._device.createBuffer({
            size: skyBoxUniformBufferSize,
            usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,
        });
        this._skyBoxRenderPassDescriptor = {
            label: 'skybox render pass',
            colorAttachments: [
                {
                    view: null, // Assigned later
                    loadOp: 'clear',
                    storeOp: 'store',
                },
            ],
            depthStencilAttachment: {
                view: this._depthTexture.createView(),
                depthLoadOp: 'clear',
                depthClearValue: 1.0,
                depthStoreOp: 'store',
                stencilLoadOp: 'clear',
                stencilClearValue: 0,
                stencilStoreOp: 'store',
            },
        };
        await this.setDefaultSkyBoxTexture();
    }
    async setDefaultSkyBoxTexture() {
        const images = new Array(6).fill(new ImageData(new Uint8ClampedArray([75, 76, 76, 255]), 1, 1));
        const promises = images.map(async (image) => {
            return createImageBitmap(image);
        });
        const imageBitmaps = (await Promise.all(promises));
        this.setSkyBoxTexture(imageBitmaps);
    }
    setSkyBoxTexture(bitmaps) {
        this._skyboxTexture = this._device.createTexture({
            dimension: '2d',
            size: [bitmaps[0].width, bitmaps[0].height, 6],
            format: 'rgba8unorm',
            usage: GPUTextureUsage.TEXTURE_BINDING |
                GPUTextureUsage.COPY_DST |
                GPUTextureUsage.RENDER_ATTACHMENT,
        });
        for (let i = 0; i < bitmaps.length; i++) {
            const imageBitmap = bitmaps[i];
            this._device.queue.copyExternalImageToTexture({ source: imageBitmap }, { texture: this._skyboxTexture, origin: [0, 0, i] }, [imageBitmap.width, imageBitmap.height]);
        }
        this._skyBoxUniformBindGroup = this._device.createBindGroup({
            label: 'skybox uniform bindgroup',
            layout: this._skyBoxPipeline.getBindGroupLayout(0),
            entries: [
                {
                    binding: 0,
                    resource: {
                        buffer: this._skyBoxUniformBuffer,
                        offset: 0,
                        size: skyBoxUniformBufferSize,
                    },
                },
                {
                    binding: 1,
                    resource: this._skyboxSampler,
                },
                {
                    binding: 2,
                    resource: this._skyboxTexture.createView({
                        dimension: 'cube',
                    }),
                },
            ],
        });
    }
    get device() {
        return this._device;
    }
    get adapter() {
        return this._adapter;
    }
    get context() {
        return this._context;
    }
    get swapChainFormat() {
        return this._swapChainFormat;
    }
    get depthTextureFormat() {
        return this._depthTextureFormat;
    }
    _initializeViewParams() {
        this._viewParamsBuffer = this.device.createBuffer({
            size: this._viewParamsBufferSize,
            usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,
        });
        this._debugParamsBuffer = this.device.createBuffer({
            size: 4 + 4,
            usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,
        });
        this._viewParamsBindGroup = this.device.createBindGroup({
            layout: this._uniformsBGLayout,
            entries: [
                { binding: 0, resource: { buffer: this._viewParamsBuffer } },
                { binding: 1, resource: { buffer: this._debugParamsBuffer } },
            ],
        });
    }
    _initializeBindGroupLayouts() {
        this._uniformsBGLayout = this.device.createBindGroupLayout({
            entries: [
                {
                    binding: 0,
                    visibility: GPUShaderStage.VERTEX | GPUShaderStage.FRAGMENT,
                    buffer: { type: 'uniform' },
                },
                {
                    binding: 1,
                    visibility: GPUShaderStage.VERTEX | GPUShaderStage.FRAGMENT,
                    buffer: { type: 'uniform' },
                },
            ],
        });
        this._nodeParamsBGLayout = this.device.createBindGroupLayout({
            entries: [
                {
                    binding: 0,
                    visibility: GPUShaderStage.VERTEX | GPUShaderStage.FRAGMENT,
                    buffer: { type: 'uniform' },
                },
            ],
        });
    }
    async _initializeContext(canvas) {
        const adapter = await navigator.gpu.requestAdapter();
        if (!adapter) {
            throw new Error('GPU Adapter Unavailable');
        }
        const device = await adapter.requestDevice();
        this._device = device;
        this._adapter = adapter;
        canvas.width = document.body.clientWidth * window.devicePixelRatio;
        canvas.height = document.body.clientHeight * window.devicePixelRatio;
        this._context = canvas.getContext('webgpu');
        if (!this._context) {
            throw new Error('Failed to acquire GpuCanvasContext');
        }
    }
    // public buildRenderPipeline() {}
    _createMeshBuffer(accessor, scene) {
        const view = new Uint8Array(scene.bufferStorage.buffers.get(accessor.bufferId), accessor.byteOffset, accessor.byteLength);
        const buffer = this.device.createBuffer({
            size: alignTo(accessor.byteLength, 4),
            usage: accessor.usage,
            mappedAtCreation: true,
        });
        new Uint8Array(buffer.getMappedRange()).set(view);
        buffer.unmap();
        return buffer;
    }
    buildRenderPipeline(mesh, scene) {
        const meshDataEntry = {};
        //FIXME: REFACTOR THIS SHIT
        meshDataEntry.materialParamsBuffer = this.device.createBuffer({
            size: 8 * 4,
            usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.UNIFORM,
            mappedAtCreation: true,
        });
        const params = new Float32Array(meshDataEntry.materialParamsBuffer.getMappedRange());
        params.set(mesh.material.baseColorFactor, 0);
        params.set([mesh.material.metallicFactor, mesh.material.roughnessFactor], 4);
        meshDataEntry.materialParamsBuffer.unmap();
        const sampleType = 'float';
        const vertexState = {
            module: this._shaderModule,
            entryPoint: 'vertex_main',
            buffers: [
                {
                    //TODO: figure out a way to make bytestrides constant
                    arrayStride: mesh.positions.byteStride,
                    attributes: [
                        {
                            format: mesh.positions.elementType,
                            offset: 0,
                            shaderLocation: 0,
                        },
                    ],
                },
                {
                    arrayStride: mesh.textureCoordinates.byteStride,
                    attributes: [
                        {
                            format: mesh.textureCoordinates.elementType,
                            offset: 0,
                            shaderLocation: 1,
                        },
                    ],
                },
                {
                    arrayStride: mesh.normals.byteStride,
                    attributes: [
                        {
                            format: mesh.normals.elementType,
                            offset: 0,
                            shaderLocation: 2,
                        },
                    ],
                },
                {
                    arrayStride: mesh.tangents.byteStride,
                    attributes: [
                        {
                            format: mesh.tangents.elementType,
                            offset: 0,
                            shaderLocation: 3,
                        },
                    ],
                },
            ],
        };
        const fragmentState = {
            module: this._shaderModule,
            entryPoint: 'fragment_main',
            targets: [{ format: this._swapChainFormat }],
        };
        const primitive = {
            topology: 'triangle-list',
            stripIndexFormat: undefined,
            cullMode: 'back',
        };
        //REFACTOR: this is constant now
        const materialBindGroupLayout = this.device.createBindGroupLayout({
            label: 'materialBindGroupLayout',
            entries: [
                {
                    binding: 0,
                    visibility: GPUShaderStage.FRAGMENT,
                    buffer: {
                        type: 'uniform',
                    },
                },
                {
                    binding: 1,
                    visibility: GPUShaderStage.FRAGMENT,
                    texture: {
                        sampleType,
                    },
                },
                {
                    binding: 2,
                    visibility: GPUShaderStage.FRAGMENT,
                    texture: {
                        sampleType,
                    },
                },
                {
                    binding: 3,
                    visibility: GPUShaderStage.FRAGMENT,
                    texture: {
                        sampleType,
                    },
                },
                {
                    binding: 4,
                    visibility: GPUShaderStage.FRAGMENT,
                    texture: {
                        sampleType,
                    },
                },
                {
                    binding: 5,
                    visibility: GPUShaderStage.FRAGMENT,
                    texture: {
                        sampleType: 'depth',
                    },
                },
                {
                    binding: 6,
                    visibility: GPUShaderStage.FRAGMENT,
                    texture: {
                        sampleType,
                        viewDimension: 'cube',
                    },
                },
                {
                    binding: 7,
                    visibility: GPUShaderStage.FRAGMENT,
                    texture: {
                        sampleType,
                    },
                },
            ],
        });
        const samplerBindGroupLayout = this.device.createBindGroupLayout({
            label: 'samplerBindGroupLayout',
            entries: [
                {
                    binding: 1,
                    visibility: GPUShaderStage.FRAGMENT,
                    sampler: {},
                },
                {
                    binding: 2,
                    visibility: GPUShaderStage.FRAGMENT,
                    sampler: {},
                },
                {
                    binding: 3,
                    visibility: GPUShaderStage.FRAGMENT,
                    sampler: {},
                },
                {
                    binding: 4,
                    visibility: GPUShaderStage.FRAGMENT,
                    sampler: {},
                },
                {
                    binding: 5,
                    visibility: GPUShaderStage.FRAGMENT,
                    sampler: {
                        type: 'comparison',
                    },
                },
                {
                    binding: 6,
                    visibility: GPUShaderStage.FRAGMENT,
                    sampler: {},
                },
                {
                    binding: 7,
                    visibility: GPUShaderStage.FRAGMENT,
                    sampler: {},
                },
            ],
        });
        meshDataEntry.samplerBindGroup = this.device.createBindGroup({
            label: 'sampler bindgroup',
            layout: samplerBindGroupLayout,
            entries: [
                {
                    binding: 1,
                    resource: mesh.material.baseColorTexture.sampler,
                },
                {
                    binding: 2,
                    resource: mesh.material.metallicRoughnessTexture.sampler,
                },
                {
                    binding: 3,
                    resource: mesh.material.normalTexture.sampler,
                },
                {
                    binding: 4,
                    resource: mesh.material.occlusionTexture.sampler,
                },
                {
                    binding: 5,
                    resource: this._shadowDepthSampler,
                },
                {
                    binding: 6,
                    resource: this._skyboxSampler,
                },
                {
                    binding: 7,
                    resource: mesh.material?.emissiveTexture.sampler,
                },
            ],
        });
        meshDataEntry.materialBindGroup = this.device.createBindGroup({
            label: 'material bindgroup',
            layout: materialBindGroupLayout,
            entries: [
                {
                    binding: 0,
                    resource: {
                        buffer: meshDataEntry.materialParamsBuffer,
                        size: 8 * 4,
                    },
                },
                {
                    binding: 1,
                    resource: mesh.material.baseColorTexture.view,
                },
                {
                    binding: 2,
                    resource: mesh.material?.metallicRoughnessTexture.view,
                },
                {
                    binding: 3,
                    resource: mesh.material?.normalTexture.view,
                },
                {
                    binding: 4,
                    resource: mesh.material?.occlusionTexture.view,
                },
                {
                    binding: 5,
                    resource: this._shadowDepthTextureView,
                },
                {
                    binding: 6,
                    resource: this._skyboxTexture.createView({
                        dimension: 'cube',
                    }),
                },
                {
                    binding: 7,
                    resource: mesh.material?.emissiveTexture.view,
                },
            ],
        });
        const layout = this.device.createPipelineLayout({
            bindGroupLayouts: [
                this._uniformsBGLayout,
                this._nodeParamsBGLayout,
                materialBindGroupLayout,
                samplerBindGroupLayout,
            ],
        });
        //FIXME: this should not be created per mesh when all stuff is stubbed
        meshDataEntry.shadowRenderPipeline = this.device.createRenderPipeline({
            label: 'shadow render pipeline',
            layout: this.device.createPipelineLayout({
                label: 'shadow render pipeline layout',
                bindGroupLayouts: [
                    this._uniformsBGLayout,
                    this._nodeParamsBGLayout,
                ],
            }),
            vertex: {
                module: this.device.createShaderModule({
                    label: 'shadow shader module',
                    code: _shaders_vertexShadow_wgsl__WEBPACK_IMPORTED_MODULE_3__,
                }),
                buffers: [
                    {
                        arrayStride: mesh.positions.byteStride,
                        attributes: [
                            {
                                format: mesh.positions.elementType,
                                offset: 0,
                                shaderLocation: 0,
                            },
                        ],
                    },
                ],
            },
            depthStencil: {
                depthWriteEnabled: true,
                depthCompare: 'less',
                format: 'depth32float',
            },
            primitive,
        });
        meshDataEntry.renderPipeline = this.device.createRenderPipeline({
            label: 'main render pipeline',
            layout: layout,
            vertex: vertexState,
            fragment: fragmentState,
            primitive: primitive,
            depthStencil: {
                format: this._depthTextureFormat,
                depthWriteEnabled: true,
                depthCompare: 'less',
            },
            multisample: {
                count: this._msaaSampleCount,
            },
        });
        meshDataEntry.positionsBuffer = this._createMeshBuffer(mesh.positions, scene);
        meshDataEntry.textureCoordinatesBuffer = this._createMeshBuffer(mesh.textureCoordinates, scene);
        meshDataEntry.normalsBuffer = this._createMeshBuffer(mesh.normals, scene);
        meshDataEntry.tangentsBuffer = this._createMeshBuffer(mesh.tangents, scene);
        meshDataEntry.indicesBuffer = this._createMeshBuffer(mesh.indices, scene);
        scene.meshRenderDataStorage.data.set(mesh.id, meshDataEntry);
        mesh.isPipelineBuilt = true;
    }
    renderMesh(mesh, scene, renderPassEncoder) {
        const { renderPipeline, materialBindGroup, samplerBindGroup, positionsBuffer, textureCoordinatesBuffer, tangentsBuffer, normalsBuffer, indicesBuffer, nodeParamsBindGroup, } = scene.meshRenderDataStorage.data.get(mesh.id);
        renderPassEncoder.setBindGroup(1, nodeParamsBindGroup);
        renderPassEncoder.setPipeline(renderPipeline);
        renderPassEncoder.setBindGroup(2, materialBindGroup);
        renderPassEncoder.setBindGroup(3, samplerBindGroup);
        renderPassEncoder.setVertexBuffer(0, positionsBuffer, 0, mesh.positions.byteLength);
        renderPassEncoder.setVertexBuffer(1, textureCoordinatesBuffer, 0, mesh.textureCoordinates.byteLength);
        renderPassEncoder.setVertexBuffer(2, normalsBuffer, 0, mesh.normals.byteLength);
        renderPassEncoder.setVertexBuffer(3, tangentsBuffer, 0, mesh.tangents.byteLength);
        renderPassEncoder.setIndexBuffer(indicesBuffer, mesh.indices.elementType, 0, mesh.indices.byteLength);
        renderPassEncoder.drawIndexed(mesh.indices.count);
    }
    renderMeshShadows(mesh, scene, renderPassEncoder) {
        const { shadowRenderPipeline, positionsBuffer, indicesBuffer, nodeParamsBindGroup, } = scene.meshRenderDataStorage.data.get(mesh.id);
        renderPassEncoder.setBindGroup(1, nodeParamsBindGroup);
        renderPassEncoder.setPipeline(shadowRenderPipeline);
        renderPassEncoder.setVertexBuffer(0, positionsBuffer, 0, mesh.positions.byteLength);
        renderPassEncoder.setIndexBuffer(indicesBuffer, mesh.indices.elementType, 0, mesh.indices.byteLength);
        renderPassEncoder.drawIndexed(mesh.indices.count);
    }
    render(deltaTime, scene) {
        scene.onRender(deltaTime);
        const meshesToRender = [];
        const debugInfoArray = new ArrayBuffer(4 + 4);
        const debugInfoView = new DataView(debugInfoArray, 0, debugInfoArray.byteLength);
        debugInfoView.setUint32(0, this.outputSource, true);
        debugInfoView.setUint32(4, this.renderingMode, true);
        const viewParamsUploadBuffer = this.device.createBuffer({
            size: this._viewParamsBufferSize,
            usage: GPUBufferUsage.COPY_SRC,
            mappedAtCreation: true,
        });
        const viewMap = new Float32Array(viewParamsUploadBuffer.getMappedRange());
        viewMap.set(scene.camera.projectionMatrix);
        viewMap.set(scene.camera.view, 16);
        viewMap.set(scene.camera.position, 32);
        //FIXME: this will be an array of lights in the scene
        viewMap.set(scene.light.projectionMatrix, 36);
        viewMap.set(scene.light.viewMatrix, 52);
        viewMap.set(scene.light.position, 68);
        viewMap.set(wgpu_matrix__WEBPACK_IMPORTED_MODULE_6__.vec4.create(...this.ambientLightColor, this.ambientLightIntensity), 72);
        viewParamsUploadBuffer.unmap();
        const skyBoxViewParamsUploadBuffer = this.device.createBuffer({
            size: this._skyBoxUniformBufferSize,
            usage: GPUBufferUsage.COPY_SRC,
            mappedAtCreation: true,
        });
        const skyboxViewMap = new Float32Array(skyBoxViewParamsUploadBuffer.getMappedRange());
        skyboxViewMap.set(this._skyBoxModelMatrix);
        skyboxViewMap.set(scene.camera.projectionMatrix, 16);
        skyboxViewMap.set(scene.camera.view, 32);
        skyboxViewMap.set(scene.camera.position, 48);
        skyBoxViewParamsUploadBuffer.unmap();
        const debugParamsArray = new ArrayBuffer(this._debugParamsBuffer.size);
        const debugParamsView = new DataView(debugParamsArray, 0, debugParamsArray.byteLength);
        debugParamsView.setUint32(0, 0);
        debugParamsView.setUint32(4, 0);
        this.device.queue.writeBuffer(this._debugParamsBuffer, 0, debugInfoArray);
        const iterateNode = (node, worldMatrix) => {
            const nodeTransform = node.gameObject.transform;
            const meshMatrix = nodeTransform
                ? wgpu_matrix__WEBPACK_IMPORTED_MODULE_6__.mat4.mul(worldMatrix, nodeTransform.matrix)
                : worldMatrix;
            const nodeParamsUploadBuffer = this.device.createBuffer({
                size: 16 * 4,
                usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,
                mappedAtCreation: true,
            });
            const nodeParamsMap = new Float32Array(nodeParamsUploadBuffer.getMappedRange());
            nodeParamsMap.set(meshMatrix);
            nodeParamsUploadBuffer.unmap();
            const nodeParamsBindGroup = this.device.createBindGroup({
                layout: this._nodeParamsBGLayout,
                entries: [
                    {
                        binding: 0,
                        resource: {
                            buffer: nodeParamsUploadBuffer,
                        },
                    },
                ],
            });
            node?.gameObject?.components?.forEach((component) => {
                if (component.type === _types__WEBPACK_IMPORTED_MODULE_0__.EntityTypes.mesh) {
                    //FIXME: transform calculations are not performed for the light transform as of now
                    meshesToRender.push(component);
                    if (!component.isPipelineBuilt) {
                        this.buildRenderPipeline(component, scene);
                    }
                    scene.meshRenderDataStorage.data.get(component.id).nodeParamsBindGroup = nodeParamsBindGroup;
                }
            });
            node?.children?.forEach((child) => {
                iterateNode(child, meshMatrix);
            });
        };
        scene.objectManager.sceneTree.nodes.forEach((node) => {
            iterateNode(node, wgpu_matrix__WEBPACK_IMPORTED_MODULE_6__.mat4.identity());
        });
        const commandEncoder = this.device.createCommandEncoder();
        commandEncoder.copyBufferToBuffer(viewParamsUploadBuffer, 0, this._viewParamsBuffer, 0, this._viewParamsBufferSize);
        commandEncoder.copyBufferToBuffer(skyBoxViewParamsUploadBuffer, 0, this._skyBoxUniformBuffer, 0, this._skyBoxUniformBufferSize);
        this._renderPassDescriptor.colorAttachments[0].view =
            this.context.getCurrentTexture().createView();
        if (this._msaaSampleCount !== 1) {
            ;
            this._renderPassDescriptor.colorAttachments[0].view =
                this._multisampleTextureView;
            this._renderPassDescriptor.colorAttachments[0].resolveTarget = this.context
                .getCurrentTexture()
                .createView();
        }
        ;
        this._skyBoxRenderPassDescriptor.colorAttachments[0].view =
            this.context.getCurrentTexture().createView();
        if (this._msaaSampleCount !== 1) {
            ;
            this._skyBoxRenderPassDescriptor.colorAttachments[0].view = this._multisampleTextureView;
            this._renderPassDescriptor.colorAttachments[0].resolveTarget = this.context
                .getCurrentTexture()
                .createView();
        }
        const skyBoxPass = commandEncoder.beginRenderPass(this._skyBoxRenderPassDescriptor);
        skyBoxPass.setPipeline(this._skyBoxPipeline);
        skyBoxPass.setVertexBuffer(0, this._skyBoxVerticesBuffer);
        skyBoxPass.setBindGroup(0, this._skyBoxUniformBindGroup);
        skyBoxPass.draw(_primitives_cube__WEBPACK_IMPORTED_MODULE_5__.cubeVertexCount);
        skyBoxPass.end();
        const shadowPass = commandEncoder.beginRenderPass(this._shadowPassDescriptor);
        shadowPass.setBindGroup(0, this._viewParamsBindGroup);
        meshesToRender.forEach((mesh) => {
            this.renderMeshShadows(mesh, scene, shadowPass);
        });
        shadowPass.end();
        const renderPass = commandEncoder.beginRenderPass(this._renderPassDescriptor);
        renderPass.setBindGroup(0, this._viewParamsBindGroup);
        //FIXME: move samplers and textures back to the same bindgroup
        meshesToRender.forEach((mesh) => {
            this.renderMesh(mesh, scene, renderPass);
        });
        renderPass.end();
        this.device.queue.submit([commandEncoder.finish()]);
        viewParamsUploadBuffer.destroy();
        skyBoxViewParamsUploadBuffer.destroy();
    }
}


/***/ }),

/***/ "../engine/src/engine/core/Renderer/constants.ts":
/*!*******************************************************!*\
  !*** ../engine/src/engine/core/Renderer/constants.ts ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   DEFAULT_DEPTH_FORMAT: () => (/* binding */ DEFAULT_DEPTH_FORMAT),
/* harmony export */   DEFAULT_SHADOW_DEPTH_FORMAT: () => (/* binding */ DEFAULT_SHADOW_DEPTH_FORMAT),
/* harmony export */   DEFAULT_SWAP_CHAIN_FORMAT: () => (/* binding */ DEFAULT_SWAP_CHAIN_FORMAT),
/* harmony export */   DEFULT_SHADOW_TEXTURE_SIZE: () => (/* binding */ DEFULT_SHADOW_TEXTURE_SIZE),
/* harmony export */   MSAA_SAMPLE_COUNT: () => (/* binding */ MSAA_SAMPLE_COUNT),
/* harmony export */   VIEW_PARAMS_BUFFER_SIZE: () => (/* binding */ VIEW_PARAMS_BUFFER_SIZE)
/* harmony export */ });
const DEFAULT_SWAP_CHAIN_FORMAT = 'rgba8unorm';
const DEFAULT_DEPTH_FORMAT = 'depth24plus-stencil8';
const DEFAULT_SHADOW_DEPTH_FORMAT = 'depth32float';
const DEFULT_SHADOW_TEXTURE_SIZE = 1024;
const VIEW_PARAMS_BUFFER_SIZE = 16 * 4 + 16 * 4 + 4 * 4 + 4 * 4 + 16 * 4 + 16 * 4 + 16 + 16 * 3 + 4 + 4;
const MSAA_SAMPLE_COUNT = 4;


/***/ }),

/***/ "../engine/src/engine/core/Renderer/index.ts":
/*!***************************************************!*\
  !*** ../engine/src/engine/core/Renderer/index.ts ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Renderer: () => (/* reexport safe */ _Renderer__WEBPACK_IMPORTED_MODULE_0__.Renderer),
/* harmony export */   alignTo: () => (/* reexport safe */ _Renderer__WEBPACK_IMPORTED_MODULE_0__.alignTo)
/* harmony export */ });
/* harmony import */ var _Renderer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Renderer */ "../engine/src/engine/core/Renderer/Renderer.ts");



/***/ }),

/***/ "../engine/src/engine/core/SamplerStorage/SamplerStorage.ts":
/*!******************************************************************!*\
  !*** ../engine/src/engine/core/SamplerStorage/SamplerStorage.ts ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   SamplerStorage: () => (/* binding */ SamplerStorage)
/* harmony export */ });
/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../types */ "../engine/src/engine/types/index.ts");

class SamplerStorage {
    constructor(device) {
        this._samplers = new Map();
        const sampler = device.createSampler({
            magFilter: 'linear',
            minFilter: 'linear',
            addressModeU: 'repeat',
            addressModeV: 'repeat',
            mipmapFilter: 'nearest',
        });
        this.samplers.set(_types__WEBPACK_IMPORTED_MODULE_0__.DEFAULT_SAMPLER_IDS.baseColor, sampler);
        this.samplers.set(_types__WEBPACK_IMPORTED_MODULE_0__.DEFAULT_SAMPLER_IDS.emission, sampler);
        this.samplers.set(_types__WEBPACK_IMPORTED_MODULE_0__.DEFAULT_SAMPLER_IDS.metallicRoughness, sampler);
        this.samplers.set(_types__WEBPACK_IMPORTED_MODULE_0__.DEFAULT_SAMPLER_IDS.normal, sampler);
        this.samplers.set(_types__WEBPACK_IMPORTED_MODULE_0__.DEFAULT_SAMPLER_IDS.occlusion, sampler);
    }
    get samplers() {
        return this._samplers;
    }
}


/***/ }),

/***/ "../engine/src/engine/core/SamplerStorage/index.ts":
/*!*********************************************************!*\
  !*** ../engine/src/engine/core/SamplerStorage/index.ts ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   SamplerStorage: () => (/* reexport safe */ _SamplerStorage__WEBPACK_IMPORTED_MODULE_0__.SamplerStorage)
/* harmony export */ });
/* harmony import */ var _SamplerStorage__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./SamplerStorage */ "../engine/src/engine/core/SamplerStorage/SamplerStorage.ts");



/***/ }),

/***/ "../engine/src/engine/core/Scene/Scene.ts":
/*!************************************************!*\
  !*** ../engine/src/engine/core/Scene/Scene.ts ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Scene: () => (/* binding */ Scene)
/* harmony export */ });
/* harmony import */ var wgpu_matrix__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! wgpu-matrix */ "../../node_modules/wgpu-matrix/dist/3.x/wgpu-matrix.module.js");
/* harmony import */ var _BufferStorage__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../BufferStorage */ "../engine/src/engine/core/BufferStorage/index.ts");
/* harmony import */ var _cameras_ArcBallCamera__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../cameras/ArcBallCamera */ "../engine/src/engine/core/cameras/ArcBallCamera/index.ts");
/* harmony import */ var _ImageStorage__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../ImageStorage */ "../engine/src/engine/core/ImageStorage/index.ts");
/* harmony import */ var _MaterialStorage__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../MaterialStorage */ "../engine/src/engine/core/MaterialStorage/index.ts");
/* harmony import */ var _ModelUploader__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../ModelUploader */ "../engine/src/engine/core/ModelUploader/index.ts");
/* harmony import */ var _ObjectManager__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../ObjectManager */ "../engine/src/engine/core/ObjectManager/index.ts");
/* harmony import */ var _SamplerStorage__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../SamplerStorage */ "../engine/src/engine/core/SamplerStorage/index.ts");
/* harmony import */ var _TextureStorage__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../TextureStorage */ "../engine/src/engine/core/TextureStorage/index.ts");
/* harmony import */ var _GameObject__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../GameObject */ "../engine/src/engine/core/GameObject/index.ts");
/* harmony import */ var _MeshRenderDataStorage__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../MeshRenderDataStorage */ "../engine/src/engine/core/MeshRenderDataStorage/index.ts");











class Scene {
    constructor(props) {
        this._objectManager = new _ObjectManager__WEBPACK_IMPORTED_MODULE_5__.ObjectManager();
        this._bufferStorage = new _BufferStorage__WEBPACK_IMPORTED_MODULE_0__.BufferStorage();
        this._imageStorage = new _ImageStorage__WEBPACK_IMPORTED_MODULE_2__.ImageStorage();
        this._textureStorage = new _TextureStorage__WEBPACK_IMPORTED_MODULE_7__.TextureStorage();
        this._materialStorage = new _MaterialStorage__WEBPACK_IMPORTED_MODULE_3__.MaterialStorage();
        this._meshRenderDataStorage = new _MeshRenderDataStorage__WEBPACK_IMPORTED_MODULE_9__.MeshRenderDataStorage();
        const { camera } = props ?? {};
        //FIXME: types
        this._engine = window.WheezyEngine;
        if (!this._engine) {
            throw new Error('Failed to initialize scene as no instance of Wheezy Engine is found');
        }
        this._samplerStorage = new _SamplerStorage__WEBPACK_IMPORTED_MODULE_6__.SamplerStorage(this._engine.renderer.device);
        this._root = new _GameObject__WEBPACK_IMPORTED_MODULE_8__.GameObject();
        this._objectManager.addObject(this._root);
        this.camera =
            camera ??
                new _cameras_ArcBallCamera__WEBPACK_IMPORTED_MODULE_1__.ArcBallCamera({
                    zFar: 1000,
                    zNear: 0.1,
                    canvasWidth: this._engine.renderer.context.canvas.width,
                    canvasHeight: this._engine.renderer.context.canvas.height,
                    position: wgpu_matrix__WEBPACK_IMPORTED_MODULE_10__.vec3.create(0, 0, 5),
                });
    }
    async init() {
        await this.imageStorage.createDefaults();
    }
    get objectManager() {
        return this._objectManager;
    }
    get root() {
        return this._root;
    }
    get textureStorage() {
        return this._textureStorage;
    }
    get meshRenderDataStorage() {
        return this._meshRenderDataStorage;
    }
    get materialStorage() {
        return this._materialStorage;
    }
    get bufferStorage() {
        return this._bufferStorage;
    }
    get imageStorage() {
        return this._imageStorage;
    }
    get samplerStorage() {
        return this._samplerStorage;
    }
    get camera() {
        return this._camera;
    }
    set camera(value) {
        this._camera = value;
    }
    get engine() {
        return this._engine;
    }
    async uploadModel(props) {
        if (!this._engine) {
            throw new Error('Failed to upload model as no instance of Wheezy Engine is found');
        }
        return _ModelUploader__WEBPACK_IMPORTED_MODULE_4__.ModelUploader.uploadModel(props.modelData, this._objectManager, this._bufferStorage, this._imageStorage, this._samplerStorage, this._materialStorage, this._textureStorage, this._root, this._engine.renderer.device);
    }
    onRender(_) {
        throw new Error('onRender method should be redefined in extending class');
    }
}


/***/ }),

/***/ "../engine/src/engine/core/Scene/index.ts":
/*!************************************************!*\
  !*** ../engine/src/engine/core/Scene/index.ts ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Scene: () => (/* reexport safe */ _Scene__WEBPACK_IMPORTED_MODULE_0__.Scene)
/* harmony export */ });
/* harmony import */ var _Scene__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Scene */ "../engine/src/engine/core/Scene/Scene.ts");



/***/ }),

/***/ "../engine/src/engine/core/SceneTree/SceneTree.ts":
/*!********************************************************!*\
  !*** ../engine/src/engine/core/SceneTree/SceneTree.ts ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   SceneTree: () => (/* binding */ SceneTree)
/* harmony export */ });
class SceneTree {
    constructor() {
        this._nodes = new Map();
    }
    getNodeContentAt(position) {
        let currentTreeNode = this._nodes.get(position[0]);
        for (let i = 1; i < position.length; i++) {
            currentTreeNode = currentTreeNode?.children?.get(position[i]);
        }
        return currentTreeNode ?? null;
    }
    addNodeAt(position, nodeContent) {
        if (!position) {
            this._nodes.set(nodeContent.gameObject.id, nodeContent);
            return [nodeContent.gameObject.id];
        }
        let currentTreeNode = this.getNodeContentAt(position);
        currentTreeNode?.children?.set(nodeContent.gameObject.id, nodeContent);
        return [...position, nodeContent.gameObject.id];
    }
    reparentNode(target, child) {
        const nodeContent = this.getNodeContentAt(child);
        if (!nodeContent) {
            throw new Error(`No node found at position ${child.join()}`);
        }
        const newPosition = this.addNodeAt(target, nodeContent);
        this.removeNode(child);
        return newPosition;
    }
    removeNode(targetPosition) {
        const parentPosition = targetPosition.slice(0, targetPosition.length - 1);
        const parentNode = this.getNodeContentAt(parentPosition);
        const childrenIds = [];
        this.traverseNode(parentNode?.children, (nodeId) => {
            childrenIds.push(nodeId);
        });
        parentNode?.children?.delete(targetPosition[targetPosition.length - 1]);
        return childrenIds;
    }
    traverseNode(node, callback) {
        const iterate = (sceneNode) => {
            if (!sceneNode)
                return;
            sceneNode.forEach((value, key) => {
                callback(key, value);
                iterate(value.children);
            });
        };
        iterate(node);
    }
    get nodes() {
        return this._nodes;
    }
}


/***/ }),

/***/ "../engine/src/engine/core/SceneTree/index.ts":
/*!****************************************************!*\
  !*** ../engine/src/engine/core/SceneTree/index.ts ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   SceneTree: () => (/* reexport safe */ _SceneTree__WEBPACK_IMPORTED_MODULE_0__.SceneTree)
/* harmony export */ });
/* harmony import */ var _SceneTree__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./SceneTree */ "../engine/src/engine/core/SceneTree/SceneTree.ts");



/***/ }),

/***/ "../engine/src/engine/core/TextureStorage/TextureStorage.ts":
/*!******************************************************************!*\
  !*** ../engine/src/engine/core/TextureStorage/TextureStorage.ts ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   TextureStorage: () => (/* binding */ TextureStorage)
/* harmony export */ });
/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../types */ "../engine/src/engine/types/index.ts");

class TextureStorage {
    constructor() {
        this._textures = new Map();
    }
    get textures() {
        return this._textures;
    }
    get defaultBaseColor() {
        return {
            samplerId: _types__WEBPACK_IMPORTED_MODULE_0__.DEFAULT_SAMPLER_IDS.baseColor,
            imageId: _types__WEBPACK_IMPORTED_MODULE_0__.DEFAULT_IMAGE_IDS.baseColor,
        };
    }
    get defaultMetallicRoughness() {
        return {
            samplerId: _types__WEBPACK_IMPORTED_MODULE_0__.DEFAULT_SAMPLER_IDS.metallicRoughness,
            imageId: _types__WEBPACK_IMPORTED_MODULE_0__.DEFAULT_IMAGE_IDS.metallicRoughness,
        };
    }
    get defaultEmission() {
        return {
            samplerId: _types__WEBPACK_IMPORTED_MODULE_0__.DEFAULT_SAMPLER_IDS.emission,
            imageId: _types__WEBPACK_IMPORTED_MODULE_0__.DEFAULT_IMAGE_IDS.emission,
        };
    }
    get defaultNormal() {
        return {
            samplerId: _types__WEBPACK_IMPORTED_MODULE_0__.DEFAULT_SAMPLER_IDS.normal,
            imageId: _types__WEBPACK_IMPORTED_MODULE_0__.DEFAULT_IMAGE_IDS.normal,
        };
    }
    get defaultOcclusion() {
        return {
            samplerId: _types__WEBPACK_IMPORTED_MODULE_0__.DEFAULT_SAMPLER_IDS.occlusion,
            imageId: _types__WEBPACK_IMPORTED_MODULE_0__.DEFAULT_IMAGE_IDS.baseColor,
        };
    }
}


/***/ }),

/***/ "../engine/src/engine/core/TextureStorage/index.ts":
/*!*********************************************************!*\
  !*** ../engine/src/engine/core/TextureStorage/index.ts ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   TextureStorage: () => (/* reexport safe */ _TextureStorage__WEBPACK_IMPORTED_MODULE_0__.TextureStorage)
/* harmony export */ });
/* harmony import */ var _TextureStorage__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./TextureStorage */ "../engine/src/engine/core/TextureStorage/TextureStorage.ts");



/***/ }),

/***/ "../engine/src/engine/core/Transform/Transform.ts":
/*!********************************************************!*\
  !*** ../engine/src/engine/core/Transform/Transform.ts ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Transform: () => (/* binding */ Transform)
/* harmony export */ });
/* harmony import */ var wgpu_matrix__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! wgpu-matrix */ "../../node_modules/wgpu-matrix/dist/3.x/wgpu-matrix.module.js");
/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../types */ "../engine/src/engine/types/index.ts");
/* harmony import */ var _Component__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Component */ "../engine/src/engine/core/Component/index.ts");



class Transform extends _Component__WEBPACK_IMPORTED_MODULE_1__.Component {
    constructor(parent, matrix) {
        super(parent, _types__WEBPACK_IMPORTED_MODULE_0__.EntityTypes.transform);
        this.matrix = matrix ? wgpu_matrix__WEBPACK_IMPORTED_MODULE_2__.mat4.copy(matrix) : wgpu_matrix__WEBPACK_IMPORTED_MODULE_2__.mat4.identity();
        this._position = new Float32Array(this.matrix.buffer, 4 * 12, 4);
    }
    get position() {
        return this._position;
    }
    set position(value) {
        wgpu_matrix__WEBPACK_IMPORTED_MODULE_2__.vec4.copy(value, this._position);
    }
    scale(value) {
        wgpu_matrix__WEBPACK_IMPORTED_MODULE_2__.mat4.scale(this.matrix, value, this.matrix);
    }
    translate(value) {
        this._position = wgpu_matrix__WEBPACK_IMPORTED_MODULE_2__.vec3.copy(value, this._position);
    }
    rotateRadians({ x, y, z }) {
        const newMatrix = wgpu_matrix__WEBPACK_IMPORTED_MODULE_2__.mat4.copy(this.matrix);
        x && wgpu_matrix__WEBPACK_IMPORTED_MODULE_2__.mat4.rotateX(newMatrix, x, newMatrix);
        y && wgpu_matrix__WEBPACK_IMPORTED_MODULE_2__.mat4.rotateY(newMatrix, y, newMatrix);
        z && wgpu_matrix__WEBPACK_IMPORTED_MODULE_2__.mat4.rotateZ(newMatrix, z, newMatrix);
        wgpu_matrix__WEBPACK_IMPORTED_MODULE_2__.mat4.copy(newMatrix, this.matrix);
    }
    rotateDegreesEuler({ x, y, z }) {
        const degreeToRad = 0.01745329252;
        this.rotateRadians({
            x: (x ?? 0) * degreeToRad,
            y: (y ?? 0) * degreeToRad,
            z: (z ?? 0) * degreeToRad,
        });
    }
}


/***/ }),

/***/ "../engine/src/engine/core/Transform/index.ts":
/*!****************************************************!*\
  !*** ../engine/src/engine/core/Transform/index.ts ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Transform: () => (/* reexport safe */ _Transform__WEBPACK_IMPORTED_MODULE_0__.Transform)
/* harmony export */ });
/* harmony import */ var _Transform__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Transform */ "../engine/src/engine/core/Transform/Transform.ts");



/***/ }),

/***/ "../engine/src/engine/core/cameras/ArcBallCamera/ArcBallCamera.ts":
/*!************************************************************************!*\
  !*** ../engine/src/engine/core/cameras/ArcBallCamera/ArcBallCamera.ts ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ArcBallCamera: () => (/* binding */ ArcBallCamera)
/* harmony export */ });
/* harmony import */ var wgpu_matrix__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! wgpu-matrix */ "../../node_modules/wgpu-matrix/dist/3.x/wgpu-matrix.module.js");
/* harmony import */ var _Camera__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Camera */ "../engine/src/engine/core/cameras/Camera/index.ts");


class ArcBallCamera extends _Camera__WEBPACK_IMPORTED_MODULE_0__.Camera {
    constructor(props) {
        super(props);
        this._distance = 0;
        this._axis = wgpu_matrix__WEBPACK_IMPORTED_MODULE_1__.vec3.create();
        const positionVec = props?.position ?? wgpu_matrix__WEBPACK_IMPORTED_MODULE_1__.vec3.create(0, 0, 0);
        super.position = positionVec;
        this._distance = wgpu_matrix__WEBPACK_IMPORTED_MODULE_1__.vec3.len(super.position);
        super.back = wgpu_matrix__WEBPACK_IMPORTED_MODULE_1__.vec3.normalize(super.position);
        this.recalculateRight();
        this.recalculateUp();
        super.view = wgpu_matrix__WEBPACK_IMPORTED_MODULE_1__.mat4.invert(super.matrix);
    }
    get axis() {
        return this._axis;
    }
    set axis(vec) {
        wgpu_matrix__WEBPACK_IMPORTED_MODULE_1__.vec3.copy(vec, this._axis);
    }
    get distance() {
        return this._distance;
    }
    set distance(value) {
        this._distance = value;
    }
    get matrix() {
        return super.matrix;
    }
    set matrix(mat) {
        super.matrix = mat;
        this._distance = wgpu_matrix__WEBPACK_IMPORTED_MODULE_1__.vec3.len(super.position);
    }
    recalculateRight() {
        super.right = wgpu_matrix__WEBPACK_IMPORTED_MODULE_1__.vec3.normalize(wgpu_matrix__WEBPACK_IMPORTED_MODULE_1__.vec3.cross(super.up, super.back));
    }
    recalculateUp() {
        super.up = wgpu_matrix__WEBPACK_IMPORTED_MODULE_1__.vec3.normalize(wgpu_matrix__WEBPACK_IMPORTED_MODULE_1__.vec3.cross(super.back, super.right));
    }
}


/***/ }),

/***/ "../engine/src/engine/core/cameras/ArcBallCamera/index.ts":
/*!****************************************************************!*\
  !*** ../engine/src/engine/core/cameras/ArcBallCamera/index.ts ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ArcBallCamera: () => (/* reexport safe */ _ArcBallCamera__WEBPACK_IMPORTED_MODULE_0__.ArcBallCamera)
/* harmony export */ });
/* harmony import */ var _ArcBallCamera__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ArcBallCamera */ "../engine/src/engine/core/cameras/ArcBallCamera/ArcBallCamera.ts");



/***/ }),

/***/ "../engine/src/engine/core/cameras/Camera/Camera.ts":
/*!**********************************************************!*\
  !*** ../engine/src/engine/core/cameras/Camera/Camera.ts ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Camera: () => (/* binding */ Camera)
/* harmony export */ });
/* harmony import */ var wgpu_matrix__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! wgpu-matrix */ "../../node_modules/wgpu-matrix/dist/3.x/wgpu-matrix.module.js");
/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../types */ "../engine/src/engine/types/index.ts");
/* harmony import */ var _Entity__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../Entity */ "../engine/src/engine/core/Entity/index.ts");



class Camera extends _Entity__WEBPACK_IMPORTED_MODULE_1__.Entity {
    constructor(props) {
        super(_types__WEBPACK_IMPORTED_MODULE_0__.EntityTypes.camera);
        this._view = wgpu_matrix__WEBPACK_IMPORTED_MODULE_2__.mat4.create();
        this._matrix = new Float32Array([
            1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1,
        ]);
        this._right = new Float32Array(this._matrix.buffer, 4 * 0, 4);
        this._up = new Float32Array(this._matrix.buffer, 4 * 4, 4);
        this._back = new Float32Array(this._matrix.buffer, 4 * 8, 4);
        this._position = new Float32Array(this._matrix.buffer, 4 * 12, 4);
        this._zFar = props?.zFar ?? 1000;
        this._zNear = props?.zNear ?? 0.1;
        this._aspectRatio = props.canvasWidth / props.canvasHeight;
        this._projectionMatrix = wgpu_matrix__WEBPACK_IMPORTED_MODULE_2__.mat4.perspective((2 * Math.PI) / 5, this._aspectRatio, this._zNear, this._zFar);
    }
    get aspectRatio() {
        return this._aspectRatio;
    }
    get zFar() {
        return this._zFar;
    }
    get zNear() {
        return this._zNear;
    }
    get projectionMatrix() {
        return this._projectionMatrix;
    }
    get view() {
        return this._view;
    }
    set view(mat) {
        wgpu_matrix__WEBPACK_IMPORTED_MODULE_2__.mat4.copy(mat, this._view);
    }
    get right() {
        return this._right;
    }
    set right(vec) {
        wgpu_matrix__WEBPACK_IMPORTED_MODULE_2__.vec3.copy(vec, this._right);
    }
    get up() {
        return this._up;
    }
    set up(vec) {
        wgpu_matrix__WEBPACK_IMPORTED_MODULE_2__.vec3.copy(vec, this._up);
    }
    get back() {
        return this._back;
    }
    set back(vec) {
        wgpu_matrix__WEBPACK_IMPORTED_MODULE_2__.vec3.copy(vec, this._back);
    }
    get matrix() {
        return this._matrix;
    }
    set matrix(value) {
        this._matrix = wgpu_matrix__WEBPACK_IMPORTED_MODULE_2__.mat4.copy(value, this._matrix);
    }
    get position() {
        return this._position;
    }
    set position(value) {
        wgpu_matrix__WEBPACK_IMPORTED_MODULE_2__.vec3.copy(value, this._position);
    }
}


/***/ }),

/***/ "../engine/src/engine/core/cameras/Camera/index.ts":
/*!*********************************************************!*\
  !*** ../engine/src/engine/core/cameras/Camera/index.ts ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Camera: () => (/* reexport safe */ _Camera__WEBPACK_IMPORTED_MODULE_0__.Camera)
/* harmony export */ });
/* harmony import */ var _Camera__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Camera */ "../engine/src/engine/core/cameras/Camera/Camera.ts");



/***/ }),

/***/ "../engine/src/engine/core/cameras/PerspectiveCamera/PerspectiveCamera.ts":
/*!********************************************************************************!*\
  !*** ../engine/src/engine/core/cameras/PerspectiveCamera/PerspectiveCamera.ts ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   PerspectiveCamera: () => (/* binding */ PerspectiveCamera)
/* harmony export */ });
/* harmony import */ var wgpu_matrix__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! wgpu-matrix */ "../../node_modules/wgpu-matrix/dist/3.x/wgpu-matrix.module.js");
/* harmony import */ var _utils_Stuff__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../../utils/Stuff */ "../engine/src/utils/Stuff.ts");
/* harmony import */ var _Camera_Camera__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Camera/Camera */ "../engine/src/engine/core/cameras/Camera/Camera.ts");



class PerspectiveCamera extends _Camera_Camera__WEBPACK_IMPORTED_MODULE_1__.Camera {
    constructor(props) {
        super(props);
        this.pitch = 0;
        this.yaw = 0;
        const positionVec = props?.position ?? wgpu_matrix__WEBPACK_IMPORTED_MODULE_2__.vec3.create(0, 0, 0);
        const targetVec = props?.target ?? wgpu_matrix__WEBPACK_IMPORTED_MODULE_2__.vec3.copy(positionVec);
        const back = wgpu_matrix__WEBPACK_IMPORTED_MODULE_2__.vec3.normalize(wgpu_matrix__WEBPACK_IMPORTED_MODULE_2__.vec3.sub(positionVec, targetVec));
        this._recalculateAngles(back);
        super.position = positionVec;
    }
    _recalculateAngles(direction) {
        this.yaw = Math.atan2(direction[0], direction[2]);
        this.pitch = -Math.asin(direction[1]);
    }
    update() {
        this.yaw = _utils_Stuff__WEBPACK_IMPORTED_MODULE_0__.Stuff.mod(this.yaw, Math.PI * 2);
        this.pitch = _utils_Stuff__WEBPACK_IMPORTED_MODULE_0__.Stuff.clamp(this.pitch, -Math.PI / 2, Math.PI / 2);
        const position = wgpu_matrix__WEBPACK_IMPORTED_MODULE_2__.vec3.copy(super.position);
        super.matrix = wgpu_matrix__WEBPACK_IMPORTED_MODULE_2__.mat4.rotateX(wgpu_matrix__WEBPACK_IMPORTED_MODULE_2__.mat4.rotationY(this.yaw), this.pitch);
        super.position = position;
        super.view = wgpu_matrix__WEBPACK_IMPORTED_MODULE_2__.mat4.invert(super.matrix);
        return super.view;
    }
}


/***/ }),

/***/ "../engine/src/engine/core/cameras/PerspectiveCamera/index.ts":
/*!********************************************************************!*\
  !*** ../engine/src/engine/core/cameras/PerspectiveCamera/index.ts ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   PerspectiveCamera: () => (/* reexport safe */ _PerspectiveCamera__WEBPACK_IMPORTED_MODULE_0__.PerspectiveCamera)
/* harmony export */ });
/* harmony import */ var _PerspectiveCamera__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./PerspectiveCamera */ "../engine/src/engine/core/cameras/PerspectiveCamera/PerspectiveCamera.ts");



/***/ }),

/***/ "../engine/src/engine/core/index.ts":
/*!******************************************!*\
  !*** ../engine/src/engine/core/index.ts ***!
  \******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   BufferStorage: () => (/* reexport safe */ _BufferStorage__WEBPACK_IMPORTED_MODULE_7__.BufferStorage),
/* harmony export */   Camera: () => (/* reexport safe */ _cameras_Camera__WEBPACK_IMPORTED_MODULE_12__.Camera),
/* harmony export */   Component: () => (/* reexport safe */ _Component__WEBPACK_IMPORTED_MODULE_0__.Component),
/* harmony export */   DEFAULT_DEPTH_FORMAT: () => (/* reexport safe */ _Engine__WEBPACK_IMPORTED_MODULE_14__.DEFAULT_DEPTH_FORMAT),
/* harmony export */   DEFAULT_SHADOW_DEPTH_FORMAT: () => (/* reexport safe */ _Engine__WEBPACK_IMPORTED_MODULE_14__.DEFAULT_SHADOW_DEPTH_FORMAT),
/* harmony export */   DEFAULT_SWAP_CHAIN_FORMAT: () => (/* reexport safe */ _Engine__WEBPACK_IMPORTED_MODULE_14__.DEFAULT_SWAP_CHAIN_FORMAT),
/* harmony export */   DEFULT_SHADOW_TEXTURE_SIZE: () => (/* reexport safe */ _Engine__WEBPACK_IMPORTED_MODULE_14__.DEFULT_SHADOW_TEXTURE_SIZE),
/* harmony export */   DirectionalLight: () => (/* reexport safe */ _lights__WEBPACK_IMPORTED_MODULE_17__.DirectionalLight),
/* harmony export */   Engine: () => (/* reexport safe */ _Engine__WEBPACK_IMPORTED_MODULE_14__.Engine),
/* harmony export */   Entity: () => (/* reexport safe */ _Entity__WEBPACK_IMPORTED_MODULE_1__.Entity),
/* harmony export */   GameObject: () => (/* reexport safe */ _GameObject__WEBPACK_IMPORTED_MODULE_2__.GameObject),
/* harmony export */   ImageStorage: () => (/* reexport safe */ _ImageStorage__WEBPACK_IMPORTED_MODULE_8__.ImageStorage),
/* harmony export */   MSAA_SAMPLE_COUNT: () => (/* reexport safe */ _Engine__WEBPACK_IMPORTED_MODULE_14__.MSAA_SAMPLE_COUNT),
/* harmony export */   MaterialStorage: () => (/* reexport safe */ _MaterialStorage__WEBPACK_IMPORTED_MODULE_11__.MaterialStorage),
/* harmony export */   Mesh: () => (/* reexport safe */ _Mesh__WEBPACK_IMPORTED_MODULE_6__.Mesh),
/* harmony export */   ObjectManager: () => (/* reexport safe */ _ObjectManager__WEBPACK_IMPORTED_MODULE_3__.ObjectManager),
/* harmony export */   PerspectiveCamera: () => (/* reexport safe */ _cameras_PerspectiveCamera__WEBPACK_IMPORTED_MODULE_13__.PerspectiveCamera),
/* harmony export */   Renderer: () => (/* reexport safe */ _Renderer__WEBPACK_IMPORTED_MODULE_16__.Renderer),
/* harmony export */   SamplerStorage: () => (/* reexport safe */ _SamplerStorage__WEBPACK_IMPORTED_MODULE_9__.SamplerStorage),
/* harmony export */   Scene: () => (/* reexport safe */ _Scene__WEBPACK_IMPORTED_MODULE_15__.Scene),
/* harmony export */   SceneTree: () => (/* reexport safe */ _SceneTree__WEBPACK_IMPORTED_MODULE_4__.SceneTree),
/* harmony export */   TextureStorage: () => (/* reexport safe */ _TextureStorage__WEBPACK_IMPORTED_MODULE_10__.TextureStorage),
/* harmony export */   Transform: () => (/* reexport safe */ _Transform__WEBPACK_IMPORTED_MODULE_5__.Transform),
/* harmony export */   VIEW_PARAMS_BUFFER_SIZE: () => (/* reexport safe */ _Engine__WEBPACK_IMPORTED_MODULE_14__.VIEW_PARAMS_BUFFER_SIZE),
/* harmony export */   alignTo: () => (/* reexport safe */ _Renderer__WEBPACK_IMPORTED_MODULE_16__.alignTo)
/* harmony export */ });
/* harmony import */ var _Component__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Component */ "../engine/src/engine/core/Component/index.ts");
/* harmony import */ var _Entity__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Entity */ "../engine/src/engine/core/Entity/index.ts");
/* harmony import */ var _GameObject__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./GameObject */ "../engine/src/engine/core/GameObject/index.ts");
/* harmony import */ var _ObjectManager__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./ObjectManager */ "../engine/src/engine/core/ObjectManager/index.ts");
/* harmony import */ var _SceneTree__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./SceneTree */ "../engine/src/engine/core/SceneTree/index.ts");
/* harmony import */ var _Transform__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./Transform */ "../engine/src/engine/core/Transform/index.ts");
/* harmony import */ var _Mesh__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./Mesh */ "../engine/src/engine/core/Mesh/index.ts");
/* harmony import */ var _BufferStorage__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./BufferStorage */ "../engine/src/engine/core/BufferStorage/index.ts");
/* harmony import */ var _ImageStorage__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./ImageStorage */ "../engine/src/engine/core/ImageStorage/index.ts");
/* harmony import */ var _SamplerStorage__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./SamplerStorage */ "../engine/src/engine/core/SamplerStorage/index.ts");
/* harmony import */ var _TextureStorage__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./TextureStorage */ "../engine/src/engine/core/TextureStorage/index.ts");
/* harmony import */ var _MaterialStorage__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./MaterialStorage */ "../engine/src/engine/core/MaterialStorage/index.ts");
/* harmony import */ var _cameras_Camera__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./cameras/Camera */ "../engine/src/engine/core/cameras/Camera/index.ts");
/* harmony import */ var _cameras_PerspectiveCamera__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./cameras/PerspectiveCamera */ "../engine/src/engine/core/cameras/PerspectiveCamera/index.ts");
/* harmony import */ var _Engine__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./Engine */ "../engine/src/engine/core/Engine/index.ts");
/* harmony import */ var _Scene__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./Scene */ "../engine/src/engine/core/Scene/index.ts");
/* harmony import */ var _Renderer__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./Renderer */ "../engine/src/engine/core/Renderer/index.ts");
/* harmony import */ var _lights__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./lights */ "../engine/src/engine/core/lights/index.ts");




















/***/ }),

/***/ "../engine/src/engine/core/lights/BaseLight/BaseLight.ts":
/*!***************************************************************!*\
  !*** ../engine/src/engine/core/lights/BaseLight/BaseLight.ts ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   BaseLight: () => (/* binding */ BaseLight)
/* harmony export */ });
/* harmony import */ var wgpu_matrix__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! wgpu-matrix */ "../../node_modules/wgpu-matrix/dist/3.x/wgpu-matrix.module.js");
/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../types */ "../engine/src/engine/types/index.ts");
/* harmony import */ var _Component__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../Component */ "../engine/src/engine/core/Component/index.ts");
/* harmony import */ var _Transform__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../Transform */ "../engine/src/engine/core/Transform/index.ts");




const left = -2;
const right = 2;
const bottom = -2;
const top = 2;
const near = 0.1;
const far = 50;
class BaseLight extends _Component__WEBPACK_IMPORTED_MODULE_1__.Component {
    constructor(props) {
        super(props.parent, _types__WEBPACK_IMPORTED_MODULE_0__.EntityTypes.light);
        this.color = wgpu_matrix__WEBPACK_IMPORTED_MODULE_3__.vec3.create(1, 1, 1);
        this._viewMatrix = wgpu_matrix__WEBPACK_IMPORTED_MODULE_3__.mat4.identity();
        this._projectionMatrix = wgpu_matrix__WEBPACK_IMPORTED_MODULE_3__.mat4.ortho(left, right, bottom, top, near, far);
        this._lightSourceType = props.lightSourceType;
        this._transform = new _Transform__WEBPACK_IMPORTED_MODULE_2__.Transform(props.parent);
        this._right = new Float32Array(this._viewMatrix.buffer, 4 * 0, 4);
        this._up = new Float32Array(this._viewMatrix.buffer, 4 * 4, 4);
        this._back = new Float32Array(this._viewMatrix.buffer, 4 * 8, 4);
        this._position = new Float32Array(this._viewMatrix.buffer, 4 * 12, 4);
        this._target = props?.target ?? wgpu_matrix__WEBPACK_IMPORTED_MODULE_3__.vec3.copy(this.position);
        this._back = wgpu_matrix__WEBPACK_IMPORTED_MODULE_3__.vec3.normalize(wgpu_matrix__WEBPACK_IMPORTED_MODULE_3__.vec3.sub(this.position, this.target));
        wgpu_matrix__WEBPACK_IMPORTED_MODULE_3__.vec4.copy(props?.position ?? wgpu_matrix__WEBPACK_IMPORTED_MODULE_3__.vec4.create(0, 0, 10, 1), this.position);
        this._viewMatrix = wgpu_matrix__WEBPACK_IMPORTED_MODULE_3__.mat4.lookAt(this.position, this.target, this.up);
    }
    _recalculateRight() {
        this._right = wgpu_matrix__WEBPACK_IMPORTED_MODULE_3__.vec3.normalize(wgpu_matrix__WEBPACK_IMPORTED_MODULE_3__.vec3.cross(this.up, this.back));
    }
    _recalculateUp() {
        this._up = wgpu_matrix__WEBPACK_IMPORTED_MODULE_3__.vec3.normalize(wgpu_matrix__WEBPACK_IMPORTED_MODULE_3__.vec3.cross(this.back, this.right));
    }
    _recalculateBack() {
        this._back = wgpu_matrix__WEBPACK_IMPORTED_MODULE_3__.vec3.normalize(wgpu_matrix__WEBPACK_IMPORTED_MODULE_3__.vec3.sub(this.position, this.target));
    }
    get transform() {
        return this._transform;
    }
    get target() {
        return this._target;
    }
    set target(value) {
        wgpu_matrix__WEBPACK_IMPORTED_MODULE_3__.vec3.copy(value, this._target);
        this._recalculateBack();
    }
    get position() {
        return this._position;
    }
    set position(value) {
        //FIXME: that doesnt work
        this._transform.position = value;
        this._recalculateBack();
    }
    get right() {
        return this._right;
    }
    get back() {
        return this._back;
    }
    get up() {
        return this._up;
    }
    get lightSourceType() {
        return this._lightSourceType;
    }
    get viewMatrix() {
        return wgpu_matrix__WEBPACK_IMPORTED_MODULE_3__.mat4.multiply(this._transform.matrix, this._viewMatrix);
    }
    get projectionMatrix() {
        return this._projectionMatrix;
    }
}


/***/ }),

/***/ "../engine/src/engine/core/lights/BaseLight/index.ts":
/*!***********************************************************!*\
  !*** ../engine/src/engine/core/lights/BaseLight/index.ts ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   BaseLight: () => (/* reexport safe */ _BaseLight__WEBPACK_IMPORTED_MODULE_0__.BaseLight)
/* harmony export */ });
/* harmony import */ var _BaseLight__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./BaseLight */ "../engine/src/engine/core/lights/BaseLight/BaseLight.ts");



/***/ }),

/***/ "../engine/src/engine/core/lights/DirectionalLight/DirectionalLight.ts":
/*!*****************************************************************************!*\
  !*** ../engine/src/engine/core/lights/DirectionalLight/DirectionalLight.ts ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   DirectionalLight: () => (/* binding */ DirectionalLight)
/* harmony export */ });
/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../types */ "../engine/src/engine/types/index.ts");
/* harmony import */ var _BaseLight__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../BaseLight */ "../engine/src/engine/core/lights/BaseLight/index.ts");


class DirectionalLight extends _BaseLight__WEBPACK_IMPORTED_MODULE_1__.BaseLight {
    constructor(props) {
        super({ ...props, lightSourceType: _types__WEBPACK_IMPORTED_MODULE_0__.LIGHT_SOURCE_TYPES.directional });
    }
}


/***/ }),

/***/ "../engine/src/engine/core/lights/DirectionalLight/index.ts":
/*!******************************************************************!*\
  !*** ../engine/src/engine/core/lights/DirectionalLight/index.ts ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   DirectionalLight: () => (/* reexport safe */ _DirectionalLight__WEBPACK_IMPORTED_MODULE_0__.DirectionalLight)
/* harmony export */ });
/* harmony import */ var _DirectionalLight__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./DirectionalLight */ "../engine/src/engine/core/lights/DirectionalLight/DirectionalLight.ts");



/***/ }),

/***/ "../engine/src/engine/core/lights/index.ts":
/*!*************************************************!*\
  !*** ../engine/src/engine/core/lights/index.ts ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   DirectionalLight: () => (/* reexport safe */ _DirectionalLight__WEBPACK_IMPORTED_MODULE_0__.DirectionalLight)
/* harmony export */ });
/* harmony import */ var _DirectionalLight__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./DirectionalLight */ "../engine/src/engine/core/lights/DirectionalLight/index.ts");



/***/ }),

/***/ "../engine/src/engine/primitives/cube.ts":
/*!***********************************************!*\
  !*** ../engine/src/engine/primitives/cube.ts ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   cubeColorOffset: () => (/* binding */ cubeColorOffset),
/* harmony export */   cubePositionOffset: () => (/* binding */ cubePositionOffset),
/* harmony export */   cubeUVOffset: () => (/* binding */ cubeUVOffset),
/* harmony export */   cubeVertexArray: () => (/* binding */ cubeVertexArray),
/* harmony export */   cubeVertexCount: () => (/* binding */ cubeVertexCount),
/* harmony export */   cubeVertexSize: () => (/* binding */ cubeVertexSize)
/* harmony export */ });
const cubeVertexSize = 4 * 10; // Byte size of one cube vertex.
const cubePositionOffset = 0;
const cubeColorOffset = 4 * 4; // Byte offset of cube vertex color attribute.
const cubeUVOffset = 4 * 8;
const cubeVertexCount = 36;
// prettier-ignore
const cubeVertexArray = new Float32Array([
    // float4 position, float4 color, float2 uv,
    1, -1, 1, 1, 1, 0, 1, 1, 0, 1,
    -1, -1, 1, 1, 0, 0, 1, 1, 1, 1,
    -1, -1, -1, 1, 0, 0, 0, 1, 1, 0,
    1, -1, -1, 1, 1, 0, 0, 1, 0, 0,
    1, -1, 1, 1, 1, 0, 1, 1, 0, 1,
    -1, -1, -1, 1, 0, 0, 0, 1, 1, 0,
    1, 1, 1, 1, 1, 1, 1, 1, 0, 1,
    1, -1, 1, 1, 1, 0, 1, 1, 1, 1,
    1, -1, -1, 1, 1, 0, 0, 1, 1, 0,
    1, 1, -1, 1, 1, 1, 0, 1, 0, 0,
    1, 1, 1, 1, 1, 1, 1, 1, 0, 1,
    1, -1, -1, 1, 1, 0, 0, 1, 1, 0,
    -1, 1, 1, 1, 0, 1, 1, 1, 0, 1,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    1, 1, -1, 1, 1, 1, 0, 1, 1, 0,
    -1, 1, -1, 1, 0, 1, 0, 1, 0, 0,
    -1, 1, 1, 1, 0, 1, 1, 1, 0, 1,
    1, 1, -1, 1, 1, 1, 0, 1, 1, 0,
    -1, -1, 1, 1, 0, 0, 1, 1, 0, 1,
    -1, 1, 1, 1, 0, 1, 1, 1, 1, 1,
    -1, 1, -1, 1, 0, 1, 0, 1, 1, 0,
    -1, -1, -1, 1, 0, 0, 0, 1, 0, 0,
    -1, -1, 1, 1, 0, 0, 1, 1, 0, 1,
    -1, 1, -1, 1, 0, 1, 0, 1, 1, 0,
    1, 1, 1, 1, 1, 1, 1, 1, 0, 1,
    -1, 1, 1, 1, 0, 1, 1, 1, 1, 1,
    -1, -1, 1, 1, 0, 0, 1, 1, 1, 0,
    -1, -1, 1, 1, 0, 0, 1, 1, 1, 0,
    1, -1, 1, 1, 1, 0, 1, 1, 0, 0,
    1, 1, 1, 1, 1, 1, 1, 1, 0, 1,
    1, -1, -1, 1, 1, 0, 0, 1, 0, 1,
    -1, -1, -1, 1, 0, 0, 0, 1, 1, 1,
    -1, 1, -1, 1, 0, 1, 0, 1, 1, 0,
    1, 1, -1, 1, 1, 1, 0, 1, 0, 0,
    1, -1, -1, 1, 1, 0, 0, 1, 0, 1,
    -1, 1, -1, 1, 0, 1, 0, 1, 1, 0,
]);


/***/ }),

/***/ "../engine/src/engine/types/core/BufferStorage/index.ts":
/*!**************************************************************!*\
  !*** ../engine/src/engine/types/core/BufferStorage/index.ts ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);



/***/ }),

/***/ "../engine/src/engine/types/core/Component/index.ts":
/*!**********************************************************!*\
  !*** ../engine/src/engine/types/core/Component/index.ts ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);



/***/ }),

/***/ "../engine/src/engine/types/core/Engine/index.ts":
/*!*******************************************************!*\
  !*** ../engine/src/engine/types/core/Engine/index.ts ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);



/***/ }),

/***/ "../engine/src/engine/types/core/Entity/index.ts":
/*!*******************************************************!*\
  !*** ../engine/src/engine/types/core/Entity/index.ts ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   EntityTypes: () => (/* binding */ EntityTypes)
/* harmony export */ });
var EntityTypes;
(function (EntityTypes) {
    EntityTypes["gameObject"] = "gameObject";
    EntityTypes["mesh"] = "mesh";
    EntityTypes["material"] = "material";
    EntityTypes["transform"] = "transform";
    EntityTypes["camera"] = "camera";
    EntityTypes["collider"] = "collider";
    EntityTypes["physicsObject"] = "physicsObject";
    EntityTypes["light"] = "light";
})(EntityTypes || (EntityTypes = {}));


/***/ }),

/***/ "../engine/src/engine/types/core/GameObject/index.ts":
/*!***********************************************************!*\
  !*** ../engine/src/engine/types/core/GameObject/index.ts ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);



/***/ }),

/***/ "../engine/src/engine/types/core/ImageStorage/index.ts":
/*!*************************************************************!*\
  !*** ../engine/src/engine/types/core/ImageStorage/index.ts ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   DEFAULT_IMAGE_IDS: () => (/* binding */ DEFAULT_IMAGE_IDS)
/* harmony export */ });
var DEFAULT_IMAGE_IDS;
(function (DEFAULT_IMAGE_IDS) {
    DEFAULT_IMAGE_IDS["baseColor"] = "defaultBaseColor";
    DEFAULT_IMAGE_IDS["metallicRoughness"] = "defaultMetallicRoughness";
    DEFAULT_IMAGE_IDS["emission"] = "defaultEmission";
    DEFAULT_IMAGE_IDS["normal"] = "defaultNormal";
    DEFAULT_IMAGE_IDS["occlusion"] = "defaultOcclusion";
})(DEFAULT_IMAGE_IDS || (DEFAULT_IMAGE_IDS = {}));


/***/ }),

/***/ "../engine/src/engine/types/core/LightSource/index.ts":
/*!************************************************************!*\
  !*** ../engine/src/engine/types/core/LightSource/index.ts ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   LIGHT_SOURCE_TYPES: () => (/* binding */ LIGHT_SOURCE_TYPES)
/* harmony export */ });
var LIGHT_SOURCE_TYPES;
(function (LIGHT_SOURCE_TYPES) {
    LIGHT_SOURCE_TYPES["directional"] = "directional";
    LIGHT_SOURCE_TYPES["point"] = "point";
    LIGHT_SOURCE_TYPES["spot"] = "spot";
})(LIGHT_SOURCE_TYPES || (LIGHT_SOURCE_TYPES = {}));


/***/ }),

/***/ "../engine/src/engine/types/core/Mesh/index.ts":
/*!*****************************************************!*\
  !*** ../engine/src/engine/types/core/Mesh/index.ts ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);



/***/ }),

/***/ "../engine/src/engine/types/core/ObjectManager/index.ts":
/*!**************************************************************!*\
  !*** ../engine/src/engine/types/core/ObjectManager/index.ts ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);



/***/ }),

/***/ "../engine/src/engine/types/core/Renderer/index.ts":
/*!*********************************************************!*\
  !*** ../engine/src/engine/types/core/Renderer/index.ts ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   RENDER_MODES: () => (/* binding */ RENDER_MODES),
/* harmony export */   RENDER_OUTPUT_SOURCES: () => (/* binding */ RENDER_OUTPUT_SOURCES)
/* harmony export */ });
var RENDER_OUTPUT_SOURCES;
(function (RENDER_OUTPUT_SOURCES) {
    RENDER_OUTPUT_SOURCES[RENDER_OUTPUT_SOURCES["DEFAULT"] = 0] = "DEFAULT";
    RENDER_OUTPUT_SOURCES[RENDER_OUTPUT_SOURCES["V_NORMAL"] = 1] = "V_NORMAL";
    RENDER_OUTPUT_SOURCES[RENDER_OUTPUT_SOURCES["AMBIENT"] = 2] = "AMBIENT";
    RENDER_OUTPUT_SOURCES[RENDER_OUTPUT_SOURCES["DIFFUSE"] = 3] = "DIFFUSE";
    RENDER_OUTPUT_SOURCES[RENDER_OUTPUT_SOURCES["METALLIC"] = 4] = "METALLIC";
    RENDER_OUTPUT_SOURCES[RENDER_OUTPUT_SOURCES["ROUGHNESS"] = 5] = "ROUGHNESS";
    RENDER_OUTPUT_SOURCES[RENDER_OUTPUT_SOURCES["F_NORMAL"] = 6] = "F_NORMAL";
    RENDER_OUTPUT_SOURCES[RENDER_OUTPUT_SOURCES["V_TANGENT"] = 7] = "V_TANGENT";
})(RENDER_OUTPUT_SOURCES || (RENDER_OUTPUT_SOURCES = {}));
var RENDER_MODES;
(function (RENDER_MODES) {
    RENDER_MODES[RENDER_MODES["USE_V_NORMAL"] = 0] = "USE_V_NORMAL";
    RENDER_MODES[RENDER_MODES["USE_F_NORMAL"] = 1] = "USE_F_NORMAL";
})(RENDER_MODES || (RENDER_MODES = {}));


/***/ }),

/***/ "../engine/src/engine/types/core/SamplerStorage/index.ts":
/*!***************************************************************!*\
  !*** ../engine/src/engine/types/core/SamplerStorage/index.ts ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   DEFAULT_SAMPLER_IDS: () => (/* binding */ DEFAULT_SAMPLER_IDS)
/* harmony export */ });
var DEFAULT_SAMPLER_IDS;
(function (DEFAULT_SAMPLER_IDS) {
    DEFAULT_SAMPLER_IDS["baseColor"] = "defaultBaseColor";
    DEFAULT_SAMPLER_IDS["metallicRoughness"] = "defaultMetallicRoughness";
    DEFAULT_SAMPLER_IDS["emission"] = "defaultEmission";
    DEFAULT_SAMPLER_IDS["normal"] = "defaultNormal";
    DEFAULT_SAMPLER_IDS["occlusion"] = "defaultOcclusion";
})(DEFAULT_SAMPLER_IDS || (DEFAULT_SAMPLER_IDS = {}));


/***/ }),

/***/ "../engine/src/engine/types/core/Scene/Scene.ts":
/*!******************************************************!*\
  !*** ../engine/src/engine/types/core/Scene/Scene.ts ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);



/***/ }),

/***/ "../engine/src/engine/types/core/Scene/index.ts":
/*!******************************************************!*\
  !*** ../engine/src/engine/types/core/Scene/index.ts ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _Scene__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Scene */ "../engine/src/engine/types/core/Scene/Scene.ts");



/***/ }),

/***/ "../engine/src/engine/types/core/SceneTree/index.ts":
/*!**********************************************************!*\
  !*** ../engine/src/engine/types/core/SceneTree/index.ts ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);



/***/ }),

/***/ "../engine/src/engine/types/core/TextureStorage/index.ts":
/*!***************************************************************!*\
  !*** ../engine/src/engine/types/core/TextureStorage/index.ts ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);



/***/ }),

/***/ "../engine/src/engine/types/core/Transform/index.ts":
/*!**********************************************************!*\
  !*** ../engine/src/engine/types/core/Transform/index.ts ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);



/***/ }),

/***/ "../engine/src/engine/types/index.ts":
/*!*******************************************!*\
  !*** ../engine/src/engine/types/index.ts ***!
  \*******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   DEFAULT_IMAGE_IDS: () => (/* reexport safe */ _core_ImageStorage__WEBPACK_IMPORTED_MODULE_8__.DEFAULT_IMAGE_IDS),
/* harmony export */   DEFAULT_SAMPLER_IDS: () => (/* reexport safe */ _core_SamplerStorage__WEBPACK_IMPORTED_MODULE_9__.DEFAULT_SAMPLER_IDS),
/* harmony export */   EntityTypes: () => (/* reexport safe */ _core_Entity__WEBPACK_IMPORTED_MODULE_0__.EntityTypes),
/* harmony export */   GLTFTextureFilter: () => (/* binding */ GLTFTextureFilter),
/* harmony export */   GLTFTextureWrap: () => (/* binding */ GLTFTextureWrap),
/* harmony export */   LIGHT_SOURCE_TYPES: () => (/* reexport safe */ _core_LightSource__WEBPACK_IMPORTED_MODULE_14__.LIGHT_SOURCE_TYPES),
/* harmony export */   RENDER_MODES: () => (/* reexport safe */ _core_Renderer__WEBPACK_IMPORTED_MODULE_13__.RENDER_MODES),
/* harmony export */   RENDER_OUTPUT_SOURCES: () => (/* reexport safe */ _core_Renderer__WEBPACK_IMPORTED_MODULE_13__.RENDER_OUTPUT_SOURCES)
/* harmony export */ });
/* harmony import */ var _core_Entity__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./core/Entity */ "../engine/src/engine/types/core/Entity/index.ts");
/* harmony import */ var _core_GameObject__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./core/GameObject */ "../engine/src/engine/types/core/GameObject/index.ts");
/* harmony import */ var _core_Component__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./core/Component */ "../engine/src/engine/types/core/Component/index.ts");
/* harmony import */ var _core_SceneTree__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./core/SceneTree */ "../engine/src/engine/types/core/SceneTree/index.ts");
/* harmony import */ var _core_ObjectManager__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./core/ObjectManager */ "../engine/src/engine/types/core/ObjectManager/index.ts");
/* harmony import */ var _core_Mesh__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./core/Mesh */ "../engine/src/engine/types/core/Mesh/index.ts");
/* harmony import */ var _core_Transform__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./core/Transform */ "../engine/src/engine/types/core/Transform/index.ts");
/* harmony import */ var _core_BufferStorage__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./core/BufferStorage */ "../engine/src/engine/types/core/BufferStorage/index.ts");
/* harmony import */ var _core_ImageStorage__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./core/ImageStorage */ "../engine/src/engine/types/core/ImageStorage/index.ts");
/* harmony import */ var _core_SamplerStorage__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./core/SamplerStorage */ "../engine/src/engine/types/core/SamplerStorage/index.ts");
/* harmony import */ var _core_TextureStorage__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./core/TextureStorage */ "../engine/src/engine/types/core/TextureStorage/index.ts");
/* harmony import */ var _core_Scene__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./core/Scene */ "../engine/src/engine/types/core/Scene/index.ts");
/* harmony import */ var _core_Engine__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./core/Engine */ "../engine/src/engine/types/core/Engine/index.ts");
/* harmony import */ var _core_Renderer__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./core/Renderer */ "../engine/src/engine/types/core/Renderer/index.ts");
/* harmony import */ var _core_LightSource__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./core/LightSource */ "../engine/src/engine/types/core/LightSource/index.ts");















var GLTFTextureFilter;
(function (GLTFTextureFilter) {
    GLTFTextureFilter[GLTFTextureFilter["NEAREST"] = 9728] = "NEAREST";
    GLTFTextureFilter[GLTFTextureFilter["LINEAR"] = 9729] = "LINEAR";
    GLTFTextureFilter[GLTFTextureFilter["NEAREST_MIPMAP_NEAREST"] = 9984] = "NEAREST_MIPMAP_NEAREST";
    GLTFTextureFilter[GLTFTextureFilter["LINEAR_MIPMAP_NEAREST"] = 9985] = "LINEAR_MIPMAP_NEAREST";
    GLTFTextureFilter[GLTFTextureFilter["NEAREST_MIPMAP_LINEAR"] = 9986] = "NEAREST_MIPMAP_LINEAR";
    GLTFTextureFilter[GLTFTextureFilter["LINEAR_MIPMAP_LINEAR"] = 9987] = "LINEAR_MIPMAP_LINEAR";
})(GLTFTextureFilter || (GLTFTextureFilter = {}));
var GLTFTextureWrap;
(function (GLTFTextureWrap) {
    GLTFTextureWrap[GLTFTextureWrap["REPEAT"] = 10497] = "REPEAT";
    GLTFTextureWrap[GLTFTextureWrap["CLAMP_TO_EDGE"] = 33071] = "CLAMP_TO_EDGE";
    GLTFTextureWrap[GLTFTextureWrap["MIRRORED_REPEAT"] = 33648] = "MIRRORED_REPEAT";
})(GLTFTextureWrap || (GLTFTextureWrap = {}));


/***/ }),

/***/ "../engine/src/physics/Collider/index.ts":
/*!***********************************************!*\
  !*** ../engine/src/physics/Collider/index.ts ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Collider: () => (/* binding */ Collider)
/* harmony export */ });
/* harmony import */ var _engine_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../engine/core */ "../engine/src/engine/core/index.ts");
/* harmony import */ var _engine_types__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../engine/types */ "../engine/src/engine/types/index.ts");


class Collider extends _engine_core__WEBPACK_IMPORTED_MODULE_0__.Component {
    constructor(parent) {
        super(parent, _engine_types__WEBPACK_IMPORTED_MODULE_1__.EntityTypes.collider);
    }
}


/***/ }),

/***/ "../engine/src/physics/PhysicsObject/index.ts":
/*!****************************************************!*\
  !*** ../engine/src/physics/PhysicsObject/index.ts ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   PhysicsObject: () => (/* binding */ PhysicsObject)
/* harmony export */ });
/* harmony import */ var wgpu_matrix__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! wgpu-matrix */ "../../node_modules/wgpu-matrix/dist/3.x/wgpu-matrix.module.js");
/* harmony import */ var _engine_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../engine/core */ "../engine/src/engine/core/index.ts");
/* harmony import */ var _engine_types__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../engine/types */ "../engine/src/engine/types/index.ts");



class PhysicsObject extends _engine_core__WEBPACK_IMPORTED_MODULE_0__.Component {
    constructor(parent) {
        super(parent, _engine_types__WEBPACK_IMPORTED_MODULE_1__.EntityTypes.physicsObject);
        this.velocity = wgpu_matrix__WEBPACK_IMPORTED_MODULE_2__.vec3.create(0);
    }
}


/***/ }),

/***/ "../engine/src/physics/index.ts":
/*!**************************************!*\
  !*** ../engine/src/physics/index.ts ***!
  \**************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Collider: () => (/* reexport safe */ _Collider__WEBPACK_IMPORTED_MODULE_0__.Collider),
/* harmony export */   PhysicsObject: () => (/* reexport safe */ _PhysicsObject__WEBPACK_IMPORTED_MODULE_1__.PhysicsObject)
/* harmony export */ });
/* harmony import */ var _Collider__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Collider */ "../engine/src/physics/Collider/index.ts");
/* harmony import */ var _PhysicsObject__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./PhysicsObject */ "../engine/src/physics/PhysicsObject/index.ts");




/***/ }),

/***/ "../engine/src/utils/ArcBallController/ArcBallController.ts":
/*!******************************************************************!*\
  !*** ../engine/src/utils/ArcBallController/ArcBallController.ts ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ArcBallController: () => (/* binding */ ArcBallController)
/* harmony export */ });
/* harmony import */ var wgpu_matrix__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! wgpu-matrix */ "../../node_modules/wgpu-matrix/dist/3.x/wgpu-matrix.module.js");
/* harmony import */ var _Stuff__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Stuff */ "../engine/src/utils/Stuff.ts");


class ArcBallController {
    constructor({ camera, canvas }) {
        this.rotationSpeed = 0.3;
        this.zoomSpeed = 0.1;
        this.frictionCoefficient = 0.999;
        this._angularVelocity = 0;
        this._isTouching = false;
        this.analogX = 0;
        this.analogY = 0;
        this.touchX = 0;
        this.touchY = 0;
        this.camera = camera;
        this.canvas = canvas;
        this.canvas.addEventListener('pointerdown', () => {
            this._isTouching = true;
        });
        this.canvas.addEventListener('pointerup', () => {
            this._isTouching = false;
            // this.touchX = 0
            // this.touchY = 0
        });
        this.canvas.addEventListener('pointermove', (evt) => {
            const mouseDown = evt.pointerType == 'mouse' ? (evt.buttons & 1) !== 0 : true;
            if (mouseDown) {
                this.analogX += evt.movementX;
                this.analogY += evt.movementY;
            }
        });
        this.canvas.addEventListener('touchstart', (evt) => {
            this.touchX = evt.changedTouches[0].clientX;
            this.touchY = evt.changedTouches[0].clientY;
        });
        this.canvas.addEventListener('touchmove', (evt) => {
            this.analogX += evt.changedTouches[0].clientX - this.touchX;
            this.analogY += evt.changedTouches[0].clientY - this.touchY;
            this.touchX = evt.changedTouches[0].clientX;
            this.touchY = evt.changedTouches[0].clientY;
        });
    }
    update(deltaTime) {
        const epsilon = 0.0000001;
        if (this._isTouching) {
            this._angularVelocity = 0;
        }
        else {
            this._angularVelocity *= Math.pow(1 - this.frictionCoefficient, deltaTime);
        }
        const movement = wgpu_matrix__WEBPACK_IMPORTED_MODULE_1__.vec3.create();
        wgpu_matrix__WEBPACK_IMPORTED_MODULE_1__.vec3.addScaled(movement, this.camera.right, this.analogX, movement);
        wgpu_matrix__WEBPACK_IMPORTED_MODULE_1__.vec3.addScaled(movement, this.camera.up, -this.analogY, movement);
        this.analogX = 0;
        this.analogY = 0;
        const crossProduct = wgpu_matrix__WEBPACK_IMPORTED_MODULE_1__.vec3.cross(movement, this.camera.back);
        const magnitude = wgpu_matrix__WEBPACK_IMPORTED_MODULE_1__.vec3.len(crossProduct);
        if (magnitude > epsilon) {
            this.camera.axis = wgpu_matrix__WEBPACK_IMPORTED_MODULE_1__.vec3.scale(crossProduct, 1 / magnitude);
            this._angularVelocity = magnitude * this.rotationSpeed;
        }
        const rotationAngle = this._angularVelocity * deltaTime;
        if (rotationAngle > epsilon) {
            this.camera.back = wgpu_matrix__WEBPACK_IMPORTED_MODULE_1__.vec3.normalize(_Stuff__WEBPACK_IMPORTED_MODULE_0__.Stuff.rotate(this.camera.back, this.camera.axis, rotationAngle));
            this.camera.recalculateRight();
            this.camera.recalculateUp();
        }
        //TODO
        // if (this.analogZoom !== 0) {
        //     this.distance *= 1 + analogZoom * this.zoomSpeed
        // }
        this.camera.position = wgpu_matrix__WEBPACK_IMPORTED_MODULE_1__.vec3.scale(this.camera.back, this.camera.distance);
        this.camera.view = wgpu_matrix__WEBPACK_IMPORTED_MODULE_1__.mat4.invert(this.camera.matrix);
    }
}


/***/ }),

/***/ "../engine/src/utils/ArcBallController/index.ts":
/*!******************************************************!*\
  !*** ../engine/src/utils/ArcBallController/index.ts ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ArcBallController: () => (/* reexport safe */ _ArcBallController__WEBPACK_IMPORTED_MODULE_0__.ArcBallController)
/* harmony export */ });
/* harmony import */ var _ArcBallController__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ArcBallController */ "../engine/src/utils/ArcBallController/ArcBallController.ts");



/***/ }),

/***/ "../engine/src/utils/Stuff.ts":
/*!************************************!*\
  !*** ../engine/src/utils/Stuff.ts ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Stuff: () => (/* binding */ Stuff)
/* harmony export */ });
/* harmony import */ var wgpu_matrix__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! wgpu-matrix */ "../../node_modules/wgpu-matrix/dist/3.x/wgpu-matrix.module.js");

class Stuff {
    static clamp(x, min, max) {
        return Math.min(Math.max(x, min), max);
    }
    static mod(x, div) {
        return x - Math.floor(Math.abs(x) / div) * div * Math.sign(x);
    }
    static lerp(a, b, s) {
        return wgpu_matrix__WEBPACK_IMPORTED_MODULE_0__.vec3.addScaled(a, wgpu_matrix__WEBPACK_IMPORTED_MODULE_0__.vec3.sub(b, a), s);
    }
    static rotate(vec, axis, angle) {
        return wgpu_matrix__WEBPACK_IMPORTED_MODULE_0__.vec3.transformMat4Upper3x3(vec, wgpu_matrix__WEBPACK_IMPORTED_MODULE_0__.mat4.rotation(axis, angle));
    }
    static extractEulerRotation(mat) {
        // [
        //     x1, x2, x3, x4,  // <- column 0
        //     y1, y2, y3, y4,  // <- column 1
        //     z1, z2, z3, z4,  // <- column 2
        //     w1, w2, w3, w4,  // <- column 3
        //   ]
        const rotXangle = Math.atan2(-mat[9], mat[10]);
        const cosYangle = Math.sqrt(Math.pow(mat[0], 2) + Math.pow(mat[4], 2));
        const rotYangle = Math.atan2(mat[8], cosYangle);
        const sinXangle = Math.sin(rotXangle);
        const cosXangle = Math.cos(rotXangle);
        const rotZangle = Math.atan2(cosXangle * mat[1] + sinXangle * mat[2], cosXangle * mat[5] + sinXangle * mat[6]);
        return wgpu_matrix__WEBPACK_IMPORTED_MODULE_0__.vec3.create(rotXangle, rotYangle, rotZangle);
    }
}


/***/ }),

/***/ "../engine/src/utils/WheezyGLBLoader/WheezyGLBLoader.ts":
/*!**************************************************************!*\
  !*** ../engine/src/utils/WheezyGLBLoader/WheezyGLBLoader.ts ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   WheezyGLBLoader: () => (/* binding */ WheezyGLBLoader)
/* harmony export */ });
/* harmony import */ var _loaders_gl_core__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @loaders.gl/core */ "../../node_modules/@loaders.gl/core/dist/lib/api/load.js");
/* harmony import */ var _loaders_gl_gltf__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @loaders.gl/gltf */ "../../node_modules/@loaders.gl/gltf/dist/glb-loader.js");
/* harmony import */ var _engine_types__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../engine/types */ "../engine/src/engine/types/index.ts");
/* harmony import */ var _helpers__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./helpers */ "../engine/src/utils/WheezyGLBLoader/helpers.ts");
/* harmony import */ var wgpu_matrix__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! wgpu-matrix */ "../../node_modules/wgpu-matrix/dist/3.x/wgpu-matrix.module.js");





const generateId = () => {
    return String(Math.random());
};
class WheezyGLBLoader {
    static loadImages(modelData, bufferIndexMap) {
        const imagesIndexMap = new Map();
        const imagesMap = new Map();
        modelData.json?.images?.forEach(({ bufferView, mimeType, }, index) => {
            const bufferViewData = modelData.json.bufferViews[bufferView];
            const bufferId = bufferIndexMap.get(bufferViewData.buffer);
            if (!bufferViewData.byteOffset) {
                bufferViewData.byteOffset = 0;
            }
            const bufferOffset = modelData.binChunks[bufferViewData.buffer].byteOffset ?? 0;
            bufferViewData.buffer = bufferId;
            bufferViewData.byteOffset += bufferOffset;
            const id = generateId();
            imagesIndexMap.set(index, id);
            imagesMap.set(id, { bufferView: bufferViewData, mimeType });
        });
        return { imagesIndexMap, imagesMap };
    }
    static async loadFromUrl(url) {
        const modelData = await (0,_loaders_gl_core__WEBPACK_IMPORTED_MODULE_2__.load)(url, _loaders_gl_gltf__WEBPACK_IMPORTED_MODULE_3__.GLBLoader);
        console.log(modelData);
        const { bufferIndexMap, bufferMap } = this.loadBuffers(modelData);
        const { imagesIndexMap, imagesMap } = this.loadImages(modelData, bufferIndexMap);
        const { samplersIndexMap, samplersMap } = this.loadSamplers(modelData);
        const { texturesIndexMap, texturesMap } = this.loadTextures(modelData, samplersIndexMap, imagesIndexMap);
        const { materialsIndexMap, materialsMap } = this.loadMaterials(modelData, texturesIndexMap);
        const modelPreload = {
            trsMatrix: wgpu_matrix__WEBPACK_IMPORTED_MODULE_4__.mat4.identity(),
            meshes: [],
            children: [],
        };
        modelData?.json?.scenes?.forEach((scene) => {
            scene?.nodes?.forEach((nodeIndex) => {
                modelPreload.children.push(this.loadNode(nodeIndex, modelData, bufferIndexMap, materialsIndexMap, bufferMap));
            });
        });
        return {
            model: modelPreload,
            buffers: bufferMap,
            images: imagesMap,
            samplers: samplersMap,
            textures: texturesMap,
            materials: materialsMap,
        };
    }
    static loadNode(nodeIndex, modelData, bufferIndexMap, materialsIndexMap, bufferMap) {
        const nodeJsonData = modelData?.json?.nodes[nodeIndex];
        const dataStructEntry = {
            trsMatrix: nodeJsonData.matrix ?? wgpu_matrix__WEBPACK_IMPORTED_MODULE_4__.mat4.identity(),
            meshes: [],
            children: [],
        };
        if (nodeJsonData.mesh !== undefined) {
            const meshJsonData = modelData.json.meshes[nodeJsonData.mesh];
            meshJsonData.primitives.forEach((primitive) => {
                //FIXME: generate all of it
                const meshData = {
                    positions: WheezyGLBLoader.parseAccessor(modelData, primitive.attributes.POSITION, GPUBufferUsage.VERTEX, bufferIndexMap),
                    indices: WheezyGLBLoader.parseAccessor(modelData, primitive.indices, GPUBufferUsage.INDEX, bufferIndexMap),
                    normals: WheezyGLBLoader.parseAccessor(modelData, primitive.attributes.NORMAL, GPUBufferUsage.VERTEX, bufferIndexMap),
                    textureCoordinates: WheezyGLBLoader.parseAccessor(modelData, primitive.attributes.TEXCOORD_0, GPUBufferUsage.VERTEX, bufferIndexMap),
                    materialId: primitive.material !== undefined
                        ? materialsIndexMap.get(primitive.material)
                        : 'default',
                    mode: primitive.mode ?? 4,
                };
                if (!meshData.normals) {
                    meshData.normals = this.createNormalsBuffer(meshData, bufferIndexMap, bufferMap);
                }
                if (!meshData.textureCoordinates) {
                    meshData.textureCoordinates =
                        this.createTextureCoordinatesBuffer(bufferIndexMap, bufferMap);
                }
                meshData.tangents = this.createTangentsBuffer(meshData, bufferIndexMap, bufferMap);
                dataStructEntry.meshes.push(meshData);
            });
        }
        nodeJsonData?.children?.forEach((childIndex) => {
            dataStructEntry.children.push(this.loadNode(childIndex, modelData, bufferIndexMap, materialsIndexMap, bufferMap));
        });
        return dataStructEntry;
    }
}
WheezyGLBLoader.loadSamplers = (modelData) => {
    const samplersIndexMap = new Map();
    const samplersMap = new Map();
    modelData.json?.samplers?.forEach((sampler, index) => {
        const id = generateId();
        samplersIndexMap.set(index, id);
        samplersMap.set(id, sampler);
    });
    return { samplersIndexMap, samplersMap };
};
WheezyGLBLoader.loadTextures = (modelData, samplersIndexMap, imagesIndexMap) => {
    const texturesIndexMap = new Map();
    const texturesMap = new Map();
    modelData.json?.textures?.forEach((textureData, index) => {
        const id = generateId();
        const texture = {
            samplerId: samplersIndexMap.get(textureData.sampler) ??
                _engine_types__WEBPACK_IMPORTED_MODULE_0__.DEFAULT_SAMPLER_IDS.baseColor,
            imageId: imagesIndexMap.get(textureData.source),
        };
        texturesIndexMap.set(index, id);
        texturesMap.set(id, texture);
    });
    return { texturesIndexMap, texturesMap };
};
WheezyGLBLoader.loadMaterials = (modelData, texturesIndexMap) => {
    const materialsIndexMap = new Map();
    const materialsMap = new Map();
    modelData.json?.materials?.forEach((
    //FIXME: check types
    materialData, index) => {
        const material = {
            name: materialData.name,
            baseColorFactor: materialData?.pbrMetallicRoughness?.baseColorFactor,
            emissiveFactor: materialData.emissiveFactor,
            metallicFactor: materialData?.pbrMetallicRoughness?.metallicFactor,
            roughnessFactor: materialData?.pbrMetallicRoughness?.roughnessFactor,
            baseColorTextureId: materialData?.pbrMetallicRoughness?.baseColorTexture
                ?.index !== undefined
                ? texturesIndexMap.get(materialData?.pbrMetallicRoughness
                    ?.baseColorTexture?.index)
                : undefined,
            metallicRoughnessTextureId: materialData?.pbrMetallicRoughness
                ?.metallicRoughnessTexture?.index !== undefined
                ? texturesIndexMap.get(materialData?.pbrMetallicRoughness
                    ?.metallicRoughnessTexture?.index)
                : undefined,
            normalTextureId: materialData?.normalTexture?.index !== undefined
                ? texturesIndexMap.get(materialData?.normalTexture?.index)
                : undefined,
            occlusionTextureId: materialData?.occlusionTexture?.index !== undefined
                ? texturesIndexMap.get(materialData?.occlusionTexture?.index)
                : undefined,
            emissiveTextureId: materialData?.emissiveTexture?.index !== undefined
                ? texturesIndexMap.get(materialData?.emissiveTexture?.index)
                : undefined,
        };
        const id = generateId();
        materialsIndexMap.set(index, id);
        materialsMap.set(id, material);
    });
    return { materialsIndexMap, materialsMap };
};
WheezyGLBLoader.loadBuffers = (modelData) => {
    const bufferIndexMap = new Map();
    const bufferMap = new Map();
    modelData.binChunks.forEach((chunk, index) => {
        if (chunk.arrayBuffer) {
            const id = generateId();
            bufferIndexMap.set(index, id);
            bufferMap.set(id, chunk.arrayBuffer);
        }
    });
    return { bufferIndexMap, bufferMap };
};
WheezyGLBLoader.createNormalsBuffer = (meshData, bufferIndexMap, bufferMap) => {
    const positionsBuffer = bufferMap.get(meshData.positions.bufferId);
    const indexBuffer = bufferMap.get(meshData.indices.bufferId);
    const vertices = new Float32Array(positionsBuffer, meshData.positions?.byteOffset, meshData.positions?.byteLength / 4);
    const indices = new Uint16Array(indexBuffer, meshData.indices?.byteOffset, meshData.indices?.byteLength / 2);
    const normals = new Float32Array(vertices.length);
    for (let i = 0; i < indices.length; i += 3) {
        const vert0 = wgpu_matrix__WEBPACK_IMPORTED_MODULE_4__.vec3.create(vertices[indices[i] * 3], vertices[indices[i] * 3 + 1], vertices[indices[i] * 3 + 2]);
        const vert1 = wgpu_matrix__WEBPACK_IMPORTED_MODULE_4__.vec3.create(vertices[indices[i + 1] * 3], vertices[indices[i + 1] * 3 + 1], vertices[indices[i + 1] * 3 + 2]);
        const vert2 = wgpu_matrix__WEBPACK_IMPORTED_MODULE_4__.vec3.create(vertices[indices[i + 2] * 3], vertices[indices[i + 2] * 3 + 1], vertices[indices[i + 2] * 3 + 2]);
        // p = cross(B-A, C-A)
        const normal = wgpu_matrix__WEBPACK_IMPORTED_MODULE_4__.vec3.cross(wgpu_matrix__WEBPACK_IMPORTED_MODULE_4__.vec3.subtract(vert1, vert0), wgpu_matrix__WEBPACK_IMPORTED_MODULE_4__.vec3.subtract(vert2, vert0));
        normals[indices[i] * 3] += normal[0];
        normals[indices[i] * 3 + 1] += normal[1];
        normals[indices[i] * 3 + 2] += normal[2];
        normals[indices[i + 1] * 3] += normal[0];
        normals[indices[i + 1] * 3 + 1] += normal[1];
        normals[indices[i + 1] * 3 + 2] += normal[2];
        normals[indices[i + 2] * 3] += normal[0];
        normals[indices[i + 2] * 3 + 1] += normal[1];
        normals[indices[i + 2] * 3 + 2] += normal[2];
    }
    for (let i = 0; i < indices.length; i += 3) {
        const normalizedNormal = wgpu_matrix__WEBPACK_IMPORTED_MODULE_4__.vec3.normalize(wgpu_matrix__WEBPACK_IMPORTED_MODULE_4__.vec3.create(normals[indices[i] * 3], normals[indices[i] * 3 + 1], normals[indices[i] * 3 + 2]));
        normals[indices[i] * 3] = normalizedNormal[0];
        normals[indices[i] * 3 + 1] = normalizedNormal[1];
        normals[indices[i] * 3 + 2] = normalizedNormal[2];
    }
    const id = generateId();
    bufferIndexMap.set(Math.random(), id);
    bufferMap.set(id, normals.buffer);
    return {
        bufferId: id,
        byteStride: 12,
        byteLength: normals.byteLength,
        byteOffset: 0,
        count: normals.byteLength / (4 * 3),
        componentType: _helpers__WEBPACK_IMPORTED_MODULE_1__.GLTFComponentType.FLOAT,
        elementType: 'float32x3',
        usage: GPUBufferUsage.VERTEX,
    };
};
WheezyGLBLoader.createTextureCoordinatesBuffer = (bufferIndexMap, bufferMap) => {
    const texCoords = new Uint32Array();
    const id = generateId();
    bufferIndexMap.set(Math.random(), id);
    bufferMap.set(id, texCoords.buffer);
    return {
        bufferId: id,
        byteStride: 8,
        byteLength: texCoords.byteLength,
        byteOffset: 0,
        count: texCoords.byteLength / (4 * 2),
        componentType: _helpers__WEBPACK_IMPORTED_MODULE_1__.GLTFComponentType.FLOAT,
        elementType: 'float32x2',
        usage: 32,
    };
};
WheezyGLBLoader.createTangentsBuffer = (meshData, bufferIndexMap, bufferMap) => {
    const positionsBuffer = bufferMap.get(meshData.positions.bufferId);
    const textureCoordinatesBuffer = bufferMap.get(meshData.textureCoordinates.bufferId);
    const indexBuffer = bufferMap.get(meshData.indices.bufferId);
    const vertices = new Float32Array(positionsBuffer, meshData.positions?.byteOffset, meshData.positions?.byteLength / 4);
    const textureCoordinates = new Uint32Array(textureCoordinatesBuffer, meshData.textureCoordinates?.byteOffset, meshData.textureCoordinates?.byteLength / 4);
    const indices = 
    //FIXME: this could be something other than Uint16
    new Uint16Array(indexBuffer, meshData.indices?.byteOffset, meshData.indices?.byteLength / 2);
    const tangents = new Float32Array(vertices.length);
    for (let i = 0; i < indices.length; i += 9) {
        const vert0 = wgpu_matrix__WEBPACK_IMPORTED_MODULE_4__.vec3.create(vertices[indices[i]], vertices[indices[i + 1]], vertices[indices[i + 2]]);
        const vert1 = wgpu_matrix__WEBPACK_IMPORTED_MODULE_4__.vec3.create(vertices[indices[i + 3]], vertices[indices[i + 4]], vertices[indices[i + 5]]);
        const vert2 = wgpu_matrix__WEBPACK_IMPORTED_MODULE_4__.vec3.create(vertices[indices[i + 6]], vertices[indices[i + 7]], vertices[indices[i + 8]]);
        const uv0 = wgpu_matrix__WEBPACK_IMPORTED_MODULE_4__.vec2.create(textureCoordinates[indices[i]], textureCoordinates[indices[i + 1]]);
        const uv1 = wgpu_matrix__WEBPACK_IMPORTED_MODULE_4__.vec2.create(textureCoordinates[indices[i + 2]], textureCoordinates[indices[i + 3]]);
        const uv2 = wgpu_matrix__WEBPACK_IMPORTED_MODULE_4__.vec2.create(textureCoordinates[indices[i + 4]], textureCoordinates[indices[i + 5]]);
        const edge1 = wgpu_matrix__WEBPACK_IMPORTED_MODULE_4__.vec3.subtract(vert1, vert0);
        const edge2 = wgpu_matrix__WEBPACK_IMPORTED_MODULE_4__.vec3.subtract(vert2, vert0);
        const deltaU1 = uv1[0] - uv0[0];
        const deltaV1 = uv1[1] - uv0[1];
        const deltaU2 = uv2[0] - uv0[0];
        const deltaV2 = uv2[1] - uv0[1];
        let f = 1 / (deltaU1 * deltaV2 - deltaU2 * deltaV1);
        //FIXME: im not sure it should be that
        if (!isFinite(f)) {
            f = 0.0;
        }
        const tangent = wgpu_matrix__WEBPACK_IMPORTED_MODULE_4__.vec3.create(f * (deltaV2 * edge1[0] - deltaV1 * edge2[0]), f * (deltaV2 * edge1[1] - deltaV1 * edge2[1]), f * (deltaV2 * edge1[2] - deltaV1 * edge2[2]));
        tangents[indices[i]] += tangent[0];
        tangents[indices[i + 1]] += tangent[1];
        tangents[indices[i + 2]] += tangent[2];
        tangents[indices[i + 3]] += tangent[0];
        tangents[indices[i + 4]] += tangent[1];
        tangents[indices[i + 5]] += tangent[2];
        tangents[indices[i + 6]] += tangent[0];
        tangents[indices[i + 7]] += tangent[1];
        tangents[indices[i + 8]] += tangent[2];
    }
    const id = generateId();
    bufferIndexMap.set(Math.random(), id);
    bufferMap.set(id, tangents.buffer);
    return {
        bufferId: id,
        byteStride: 12,
        byteLength: tangents.byteLength,
        byteOffset: 0,
        count: tangents.byteLength / (4 * 3),
        componentType: _helpers__WEBPACK_IMPORTED_MODULE_1__.GLTFComponentType.FLOAT,
        elementType: 'float32x3',
        usage: 32,
    };
};
WheezyGLBLoader.parseAccessor = (modelData, accessorId, usage, bufferIndexMap) => {
    if (accessorId !== 0 && !accessorId) {
        return undefined;
    }
    const rawAccessor = modelData.json.accessors[accessorId];
    const rawBufferView = modelData.json.bufferViews[rawAccessor.bufferView];
    const buffer = modelData.binChunks[rawBufferView.buffer];
    const elementSize = (0,_helpers__WEBPACK_IMPORTED_MODULE_1__.getTypeSize)(rawAccessor.componentType, rawAccessor.type);
    const byteStride = Math.max(elementSize, rawBufferView.byteStride ?? 0);
    return {
        bufferId: bufferIndexMap.get(rawBufferView.buffer),
        byteStride: byteStride,
        byteLength: rawAccessor.count * (byteStride ?? 1),
        byteOffset: (rawAccessor?.byteOffset ?? 0) +
            (rawBufferView?.byteOffset ?? 0) +
            (buffer?.byteOffset ?? 0),
        count: rawAccessor.count,
        componentType: rawAccessor.componentType,
        elementType: (0,_helpers__WEBPACK_IMPORTED_MODULE_1__.getVertexType)(rawAccessor.componentType, rawAccessor.type),
        min: rawAccessor.min,
        max: rawAccessor.max,
        usage: usage,
    };
};


/***/ }),

/***/ "../engine/src/utils/WheezyGLBLoader/helpers.ts":
/*!******************************************************!*\
  !*** ../engine/src/utils/WheezyGLBLoader/helpers.ts ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   GLTFComponentType: () => (/* binding */ GLTFComponentType),
/* harmony export */   ImageUsage: () => (/* binding */ ImageUsage),
/* harmony export */   getTypeComponentsAmount: () => (/* binding */ getTypeComponentsAmount),
/* harmony export */   getTypeSize: () => (/* binding */ getTypeSize),
/* harmony export */   getVertexType: () => (/* binding */ getVertexType)
/* harmony export */ });
var GLTFComponentType;
(function (GLTFComponentType) {
    GLTFComponentType[GLTFComponentType["BYTE"] = 5120] = "BYTE";
    GLTFComponentType[GLTFComponentType["UNSIGNED_BYTE"] = 5121] = "UNSIGNED_BYTE";
    GLTFComponentType[GLTFComponentType["SHORT"] = 5122] = "SHORT";
    GLTFComponentType[GLTFComponentType["UNSIGNED_SHORT"] = 5123] = "UNSIGNED_SHORT";
    GLTFComponentType[GLTFComponentType["INT"] = 5124] = "INT";
    GLTFComponentType[GLTFComponentType["UNSIGNED_INT"] = 5125] = "UNSIGNED_INT";
    GLTFComponentType[GLTFComponentType["FLOAT"] = 5126] = "FLOAT";
    GLTFComponentType[GLTFComponentType["DOUBLE"] = 5130] = "DOUBLE";
})(GLTFComponentType || (GLTFComponentType = {}));
const getTypeComponentsAmount = (type) => {
    switch (type) {
        case 'SCALAR':
            return 1;
        case 'VEC2':
            return 2;
        case 'VEC3':
            return 3;
        case 'VEC4':
            return 4;
        case 'MAT2':
            return 4;
        case 'MAT3':
            return 9;
        case 'MAT4':
            return 16;
        default:
            throw Error(`Invalid gltf type ${type}`);
    }
};
const getVertexType = (componentType, type) => {
    let typeStr = null;
    switch (componentType) {
        case GLTFComponentType.BYTE:
            typeStr = 'sint8';
            break;
        case GLTFComponentType.UNSIGNED_BYTE:
            typeStr = 'uint8';
            break;
        case GLTFComponentType.SHORT:
            typeStr = 'sint16';
            break;
        case GLTFComponentType.UNSIGNED_SHORT:
            typeStr = 'uint16';
            break;
        case GLTFComponentType.INT:
            typeStr = 'int32';
            break;
        case GLTFComponentType.UNSIGNED_INT:
            typeStr = 'uint32';
            break;
        case GLTFComponentType.FLOAT:
            typeStr = 'float32';
            break;
        default:
            throw Error(`Unrecognized or unsupported gltf type ${componentType}`);
    }
    switch (getTypeComponentsAmount(type)) {
        case 1:
            break;
        case 2:
            typeStr += 'x2';
            break;
        case 3:
            typeStr += 'x3';
            break;
        case 4:
            typeStr += 'x4';
            break;
        default:
            throw Error(`Invalid number of components for gltf type: ${type}`);
    }
    return typeStr;
};
const getTypeSize = (componentType, type) => {
    let componentSize = 0;
    switch (componentType) {
        case GLTFComponentType.BYTE:
            componentSize = 1;
            break;
        case GLTFComponentType.UNSIGNED_BYTE:
            componentSize = 1;
            break;
        case GLTFComponentType.SHORT:
            componentSize = 2;
            break;
        case GLTFComponentType.UNSIGNED_SHORT:
            componentSize = 2;
            break;
        case GLTFComponentType.INT:
            componentSize = 4;
            break;
        case GLTFComponentType.UNSIGNED_INT:
            componentSize = 4;
            break;
        case GLTFComponentType.FLOAT:
            componentSize = 4;
            break;
        case GLTFComponentType.DOUBLE:
            componentSize = 8;
            break;
        default:
            throw Error('Unrecognized GLTF Component Type?');
    }
    return getTypeComponentsAmount(type) * componentSize;
};
var ImageUsage;
(function (ImageUsage) {
    ImageUsage[ImageUsage["BASE_COLOR"] = 0] = "BASE_COLOR";
    ImageUsage[ImageUsage["METALLIC_ROUGHNESS"] = 1] = "METALLIC_ROUGHNESS";
    ImageUsage[ImageUsage["NORMAL"] = 2] = "NORMAL";
    ImageUsage[ImageUsage["OCCLUSION"] = 3] = "OCCLUSION";
    ImageUsage[ImageUsage["EMISSION"] = 4] = "EMISSION";
})(ImageUsage || (ImageUsage = {}));


/***/ }),

/***/ "../engine/src/utils/index.ts":
/*!************************************!*\
  !*** ../engine/src/utils/index.ts ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   WheezyGLBLoader: () => (/* reexport safe */ _WheezyGLBLoader_WheezyGLBLoader__WEBPACK_IMPORTED_MODULE_0__.WheezyGLBLoader)
/* harmony export */ });
/* harmony import */ var _WheezyGLBLoader_WheezyGLBLoader__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./WheezyGLBLoader/WheezyGLBLoader */ "../engine/src/utils/WheezyGLBLoader/WheezyGLBLoader.ts");



/***/ }),

/***/ "../engine/src/engine/shaders/skybox.wgsl":
/*!************************************************!*\
  !*** ../engine/src/engine/shaders/skybox.wgsl ***!
  \************************************************/
/***/ ((module) => {

module.exports = "struct Uniforms {\n    transform : mat4x4f,\n    camera_projection_matrix: mat4x4<f32>,\n    camera_view_matrix: mat4x4<f32>,\n    camera_position: vec4f,\n}\n\n@group(0) @binding(0) var<uniform> uniforms : Uniforms;\n@group(0) @binding(1) var skybox_sampler: sampler;\n@group(0) @binding(2) var skybox_texture: texture_cube<f32>;\n\nstruct VertexOutput {\n    @builtin(position) Position : vec4f,\n    @location(0) texture_coordinates : vec2f,\n    @location(1) world_position: vec4f,\n}\n\n@vertex\nfn vertex_main(\n    @location(0) position : vec4f,\n    @location(1) uv : vec2f\n) -> VertexOutput {\n    var output : VertexOutput;\n    let camera_view_projection_matrix = uniforms.camera_projection_matrix * uniforms.camera_view_matrix;\n\n    output.Position = camera_view_projection_matrix * uniforms.transform * position;\n    output.texture_coordinates = uv;\n    output.world_position = 0.5 * (position + vec4(1.0, 1.0, 1.0, 1.0));\n    return output;\n}\n\n@fragment\nfn fragment_main(\n    @location(0) texture_coordinates: vec2f,\n    @location(1) world_position: vec4f\n) -> @location(0) vec4f {\n    var sample_vector = world_position.xyz - vec3(0.5);\n    sample_vector.z *= -1;\n    return textureSample(skybox_texture, skybox_sampler, sample_vector);\n}\n";

/***/ }),

/***/ "../engine/src/engine/shaders/testShader.wgsl":
/*!****************************************************!*\
  !*** ../engine/src/engine/shaders/testShader.wgsl ***!
  \****************************************************/
/***/ ((module) => {

module.exports = "alias float4 = vec4<f32>;\nalias float3 = vec3<f32>;\nalias float2 = vec2<f32>;\n\nconst OUT_DEFAULT = 0;\nconst OUT_V_NORMAL = 1;\nconst OUT_AMBIENT = 2;\nconst OUT_DIFFUSE = 3;\nconst OUT_METALLIC = 4;\nconst OUT_ROUGHNESS = 5;\nconst OUT_F_NORMAL = 6;\nconst OUT_V_TANGENT = 7;\nconst OUT_OCCLUSION = 8;\n\nconst USE_V_NORMAL = 0;\nconst USE_F_NORMAL = 1;\nconst USE_PBR = 2;\n\nconst PI = 3.14159265359;\n\nstruct VertexInput {\n    @location(0) position: float3,\n    @location(1) texcoords: float2,\n    @location(2) vertex_normal: float3,\n    @location(3) vertex_tangent: float3\n};\n\nstruct VertexOutput {\n    @builtin(position) position: float4,\n    @location(0) world_position: float3,\n    @location(1) texcoords: float2,\n    @location(2) vertex_normal: float3,\n    @location(3) vertex_tangent: float3,\n    @location(4) camera_position: float3,\n    @location(5) shadow_position: vec3f\n};\n\nstruct ViewParams {\n    camera_projection_matrix: mat4x4<f32>,\n    camera_view_matrix: mat4x4<f32>,\n    camera_position: vec4f,\n    light_projection_matrix: mat4x4<f32>,\n    light_view_matrix: mat4x4<f32>,\n    light_position: vec4f,\n    ambient_light_color: vec4f\n};\n\nstruct NodeParams {\n    transform: mat4x4<f32>,\n};\n\nstruct DebugParams {\n    output_type: u32,\n    normal_type: u32\n}\n\nstruct MaterialParams {\n    base_color_factor: float4,\n    metallic_factor: f32,\n    roughness_factor: f32,\n};\n\n@group(0) @binding(0)\nvar<uniform> view_params: ViewParams;\n\n@group(0) @binding(1)\nvar<uniform> debug_params: DebugParams;\n\n@group(1) @binding(0)\nvar<uniform> node_params: NodeParams;\n\n@group(2) @binding(0)\nvar<uniform> material_params: MaterialParams;\n\n@group(3) @binding(1)\nvar base_color_sampler: sampler;\n\n@group(2) @binding(1)\nvar base_color_texture: texture_2d<f32>;\n\n@group(3) @binding(2)\nvar metallic_roughness_sampler: sampler;\n\n@group(2) @binding(2)\nvar metallic_roughness_texture: texture_2d<f32>;\n\n@group(3) @binding(3)\nvar fragment_normal_sampler: sampler;\n\n@group(2) @binding(3)\nvar fragment_normal_texture: texture_2d<f32>;\n\n@group(3) @binding(4)\nvar occlusion_sampler: sampler;\n\n@group(2) @binding(4)\nvar occlusion_texture: texture_2d<f32>;\n\n@group(3) @binding(5)\nvar shadow_sampler: sampler_comparison;\n\n@group(2) @binding(5)\nvar shadow_texture: texture_depth_2d;\n\n@group(3) @binding(6)\nvar skybox_sampler: sampler;\n\n@group(2) @binding(6)\nvar skybox_texture: texture_cube<f32>;\n\n@group(3) @binding(7)\nvar emission_sampler: sampler;\n\n@group(2) @binding(7)\nvar emission_texture: texture_2d<f32>;\n\n@vertex\nfn vertex_main(vert: VertexInput) -> VertexOutput {\n    var out: VertexOutput;\n\n    let light_view_projection_matrix = view_params.light_projection_matrix * view_params.light_view_matrix;\n    let camera_view_projection_matrix = view_params.camera_projection_matrix * view_params.camera_view_matrix;\n    let light_space_position = light_view_projection_matrix * node_params.transform * float4(vert.position, 1.0);\n\n    out.shadow_position = vec3(light_space_position.xy * vec2(0.5, -0.5) + vec2(0.5, 0.5), light_space_position.z);\n\n    out.position = camera_view_projection_matrix * node_params.transform * float4(vert.position, 1.0);\n    out.world_position = (node_params.transform * float4(vert.position, 1.0)).xyz;\n    out.texcoords = vert.texcoords;\n    out.vertex_normal = normalize(node_params.transform * float4(vert.vertex_normal, 0.0)).xyz;\n    //FIXME: w component is tangent handedness 1 or -1, google more on that\n    out.vertex_tangent = normalize(node_params.transform * float4(vert.vertex_tangent, 1.0)).xyz;\n    out.camera_position = view_params.camera_position.xyz;\n\n    return out;\n};\n\nfn linear_to_srgb(x: f32) -> f32 {\n    if (x <= 0.0031308) {\n        return 12.92 * x;\n    }\n    return 1.055 * pow(x, 1.0 / 2.4) - 0.055;\n}\n\nfn decode_color(color: vec4f) -> vec4f {\n    return vec4f(linear_to_srgb(color.x), linear_to_srgb(color.y), linear_to_srgb(color.z), 1.0);\n}\n\nfn get_visibility(shadow_position: float3) -> f32 {\n    var visibility = 0.0;\n    let shadow_texel_size = 1.0 / f32(textureDimensions(shadow_texture).x);\n    for (var y = -1; y <= 1; y++) {\n        for (var x = -1; x <= 1; x++) {\n            let offset = vec2f(vec2(x, y)) * shadow_texel_size;\n\n            visibility += textureSampleCompare(\n                shadow_texture, shadow_sampler,\n                shadow_position.xy + offset, shadow_position.z - 0.005\n            );\n        }\n    }\n    \n    return visibility / 9.0;\n}\n\nfn get_lambert_factor(light_position: float3, world_position: float3, normal: float3) -> f32 {\n    return max(dot(normalize(light_position - world_position), normalize(normal)), 0.0);\n}\n\nfn get_lighting_factor(ambient_intensity: f32, visibility: f32, lambert_factor: f32) -> f32 {\n    return min(ambient_intensity + max(0.2, visibility) * lambert_factor, 1.0);\n}\n\nconst LIGHT_COLOR = vec4f(1.0, 1.0, 1.0, 0.0);\nconst LIGHT_DIFFUSE_INTENSITY = 1.0;\n\n//FIXME: this is not a constant\nconst SPECULAR_POWER = 32.0;\n\nfn calculateBumpedNormal(in: VertexOutput) -> float3 {\n    let normal = normalize(in.vertex_normal);\n    var tangent = normalize(in.vertex_tangent);\n    //gram-schmidt orthogonalization\n    tangent = normalize(tangent - dot(tangent, normal) * normal);\n    let bitangent = cross(tangent, normal);\n    let bump_map_normal = normalize(textureSample(fragment_normal_texture, fragment_normal_sampler, in.texcoords).rgb * 2.0 - 1.0);\n    let tbn_matrix = mat3x3f(tangent, bitangent, normal);\n\n    return normalize(tbn_matrix * bump_map_normal);\n}\n\nfn DistributionGGX( N: float3, H: float3, roughness: f32) -> f32 {\n    let a = roughness*roughness;\n    let a2 = a * a;\n    let NdotH  = max(dot(N, H), 0.0);\n    let NdotH2 = NdotH*NdotH;\n\t\n    let num = a2;\n    var denom = (NdotH2 * (a2 - 1.0) + 1.0);\n    denom = PI * denom * denom;\n\t\n    return num / denom;\n}\n\nfn GeometrySchlickGGX(NdotV: f32, roughness: f32) -> f32 {\n    let r = (roughness + 1.0);\n    let k = (r*r) / 8.0;\n\n    let num = NdotV;\n    let denom = NdotV * (1.0 - k) + k;\n\t\n    return num / denom;\n}\n\nfn GeometrySmith( N: float3, V: float3, L: float3, roughness: f32) -> f32 {\n    let NdotV = max(dot(N, V), 0.0);\n    let NdotL = max(dot(N, L), 0.0);\n    let ggx2  = GeometrySchlickGGX(NdotV, roughness);\n    let ggx1  = GeometrySchlickGGX(NdotL, roughness);\n\t\n    return ggx1 * ggx2;\n}\n\nfn fresnelSchlick(cosTheta: f32, F0: float3, roughness: f32) -> float3 {\n    return F0 + (max(vec3(1.0 - roughness), F0) - F0) * pow(clamp(1.0 - cosTheta, 0.0, 1.0), 5.0);\n}\n\n@fragment\nfn fragment_main(in: VertexOutput) -> @location(0) float4 {\n    var albedo_color = textureSample(base_color_texture, base_color_sampler, in.texcoords) \n            * material_params.base_color_factor;\n    let metallic_roughness = textureSample(metallic_roughness_texture, metallic_roughness_sampler, in.texcoords);\n    let roughness = metallic_roughness.g;\n    let metallic = metallic_roughness.b;\n    let occlusion = textureSample(occlusion_texture, occlusion_sampler, in.texcoords).r;\n    let emission = textureSample(emission_texture, emission_sampler, in.texcoords);\n\n    var fragment_normal: float3;\n    switch(debug_params.normal_type) {\n        case(USE_V_NORMAL): {\n            fragment_normal = in.vertex_normal;\n            break;\n        }\n        case(USE_PBR): {\n            albedo_color = pow(albedo_color, vec4f(2.2));\n            let N = calculateBumpedNormal(in);\n            let V = normalize(in.camera_position - in.world_position);\n            let R = reflect(-V, N);\n\n            var F0 = vec3(0.04); \n            F0 = mix(F0, albedo_color.rgb, vec3(metallic));\n                    \n            // reflectance equation\n            var Lo = vec3(0.0);\n            \n            // calculate per-light radiance\n            let L = normalize(view_params.light_position.xyz - in.world_position);\n            let H = normalize(V + L);\n            let distance = length(view_params.light_position.xyz - in.world_position);\n            let attenuation = 1.0; //not applicable to directional light\n            //1.0 / (distance * distance);\n            let radiance = LIGHT_COLOR.rgb * attenuation;        \n            \n            // cook-torrance brdf\n            let NDF = DistributionGGX(N, H, roughness);        \n            let G = GeometrySmith(N, V, L, roughness);      \n            let F = fresnelSchlick(max(dot(H, V), 0.0), F0, roughness);       \n            \n            let numerator = NDF * G * F;\n            let denominator = 4.0 * max(dot(N, V), 0.0) * max(dot(N, L), 0.0) + 0.0001;\n            let specular = numerator / denominator;  \n \n            let kS = F;\n            var kD = vec3(1.0) - kS;\n            kD *= 1.0 - vec3(metallic);\t  \n\n            // add to outgoing radiance Lo\n            let NdotL = max(dot(N, L), 0.0);            \n            Lo += (kD * albedo_color.rgb / PI + specular) * radiance * NdotL;\n  \n            let kSl = fresnelSchlick(max(dot(N, V), 0.0), F0, roughness);\n            var kDl = 1.0 - kSl;\n            kDl *= 1.0 - metallic; \n            let reflection_color = textureSample(skybox_texture, skybox_sampler, R).xyz;\n            //FIXME: this should be sampled from cubemap\n            let irradiance = vec3f(1, 1, 1); \n            let diffuse = irradiance * albedo_color.rgb;\n\n            let ambient_color = (kDl * diffuse) * occlusion * vec3(0.03);\n           \n            var color = ambient_color.rgb + Lo + (F * reflection_color) + emission.rgb;\n\n            color = color / (color + vec3(1.0));\n            color = pow(color, vec3(1.0/2.2));\n        \n            return vec4(color, 1.0);\n        }\n        default: {\n            fragment_normal = calculateBumpedNormal(in);\n        }\n    }\n\n    albedo_color *= occlusion;\n    let ambient_color = vec4(view_params.ambient_light_color.xyz * view_params.ambient_light_color.w, 1.0f);\n\n    let visibility = get_visibility(in.shadow_position);\n    let diffuse_factor = get_lambert_factor(view_params.light_position.xyz, in.world_position, fragment_normal);\n    var specular_color = vec4(0.0, 0.0, 0.0, 0.0);\n\n    var diffuse_color = vec4f();\n\n    if (diffuse_factor > 0) {\n        diffuse_color = vec4f(LIGHT_COLOR.xyz * LIGHT_DIFFUSE_INTENSITY * diffuse_factor, 1.0);\n    }\n    else {\n        diffuse_color = vec4f(0, 0, 0, 0);\n    }\n\n    if (visibility > 0.0) {\n        let vertex_to_eye_vec = normalize(in.camera_position - in.world_position);\n\n        let light_reflection = normalize(reflect(in.shadow_position, fragment_normal));\n\n        var specular_factor = dot(vertex_to_eye_vec, light_reflection);\n\n        if (specular_factor > 0.0) {\n            specular_factor = pow(specular_factor, SPECULAR_POWER);\n            specular_color = vec4f(LIGHT_COLOR.xyz * metallic * specular_factor, 1.0f);\n        }\n    }\n\n    let lighting_factor = get_lighting_factor(view_params.ambient_light_color.w, visibility, diffuse_factor);\n\n    switch(debug_params.output_type) {\n        case(OUT_V_NORMAL): {\n            return vec4(in.vertex_normal, 1.0);\n        }\n        case(OUT_AMBIENT): {\n            return ambient_color;\n        }\n        case(OUT_DIFFUSE): {\n            return diffuse_color;\n        }\n        case(OUT_METALLIC): {\n            return vec4(metallic);\n        }\n        case(OUT_ROUGHNESS): {\n            return vec4(roughness);\n        }\n        case(OUT_F_NORMAL): {\n            return vec4(fragment_normal, 1.0);\n        }\n        case(OUT_V_TANGENT): {\n            return vec4(in.vertex_tangent, 1.0);\n        }\n        case(OUT_OCCLUSION) : {\n            return vec4(occlusion);\n        }\n        default: {\n            return decode_color(vec4(\n                (ambient_color.xyz + lighting_factor *\n                (specular_color.xyz + diffuse_color.xyz)) * albedo_color.xyz + emission.xyz,\n                1.0\n            ));\n        }\n    }\n};\n";

/***/ }),

/***/ "../engine/src/engine/shaders/vertexShadow.wgsl":
/*!******************************************************!*\
  !*** ../engine/src/engine/shaders/vertexShadow.wgsl ***!
  \******************************************************/
/***/ ((module) => {

module.exports = "alias float4 = vec4<f32>;\nalias float3 = vec3<f32>;\nalias float2 = vec2<f32>;\n\nstruct VertexInput {\n    @location(0) position: float3,\n};\n\nstruct ViewParams {\n    camera_projection_matrix: mat4x4<f32>,\n    camera_view_matrix: mat4x4<f32>,\n    camera_position: vec4f,\n    light_projection_matrix: mat4x4<f32>,\n    light_view_matrix: mat4x4<f32>,\n    light_position: vec4f,\n    ambient_light_color: vec4f,\n};\n\nstruct NodeParams {\n    transform: mat4x4<f32>,\n};\n\n@group(0) @binding(0)\nvar<uniform> view_params: ViewParams;\n\n@group(1) @binding(0)\nvar<uniform> node_params: NodeParams;\n\n@vertex\nfn vertex_main(vert: VertexInput) -> @builtin(position) vec4f {\n    let light_view_projection_matrix = view_params.light_projection_matrix * view_params.light_view_matrix;\n\n    return light_view_projection_matrix * node_params.transform * float4(vert.position, 1.0);\n};\n";

/***/ }),

/***/ "../../node_modules/@loaders.gl/core/dist/iterators/make-iterator/make-array-buffer-iterator.js":
/*!******************************************************************************************************!*\
  !*** ../../node_modules/@loaders.gl/core/dist/iterators/make-iterator/make-array-buffer-iterator.js ***!
  \******************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   makeArrayBufferIterator: () => (/* binding */ makeArrayBufferIterator)
/* harmony export */ });
const DEFAULT_CHUNK_SIZE = 256 * 1024;
function makeArrayBufferIterator(arrayBuffer) {
  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  return function* () {
    const {
      chunkSize = DEFAULT_CHUNK_SIZE
    } = options;
    let byteOffset = 0;
    while (byteOffset < arrayBuffer.byteLength) {
      const chunkByteLength = Math.min(arrayBuffer.byteLength - byteOffset, chunkSize);
      const chunk = new ArrayBuffer(chunkByteLength);
      const sourceArray = new Uint8Array(arrayBuffer, byteOffset, chunkByteLength);
      const chunkArray = new Uint8Array(chunk);
      chunkArray.set(sourceArray);
      byteOffset += chunkByteLength;
      yield chunk;
    }
  }();
}
//# sourceMappingURL=make-array-buffer-iterator.js.map

/***/ }),

/***/ "../../node_modules/@loaders.gl/core/dist/iterators/make-iterator/make-blob-iterator.js":
/*!**********************************************************************************************!*\
  !*** ../../node_modules/@loaders.gl/core/dist/iterators/make-iterator/make-blob-iterator.js ***!
  \**********************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   makeBlobIterator: () => (/* binding */ makeBlobIterator)
/* harmony export */ });
const DEFAULT_CHUNK_SIZE = 1024 * 1024;
async function* makeBlobIterator(blob, options) {
  const chunkSize = (options === null || options === void 0 ? void 0 : options.chunkSize) || DEFAULT_CHUNK_SIZE;
  let offset = 0;
  while (offset < blob.size) {
    const end = offset + chunkSize;
    const chunk = await blob.slice(offset, end).arrayBuffer();
    offset = end;
    yield chunk;
  }
}
//# sourceMappingURL=make-blob-iterator.js.map

/***/ }),

/***/ "../../node_modules/@loaders.gl/core/dist/iterators/make-iterator/make-iterator.js":
/*!*****************************************************************************************!*\
  !*** ../../node_modules/@loaders.gl/core/dist/iterators/make-iterator/make-iterator.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   makeIterator: () => (/* binding */ makeIterator)
/* harmony export */ });
/* harmony import */ var _make_string_iterator_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./make-string-iterator.js */ "../../node_modules/@loaders.gl/core/dist/iterators/make-iterator/make-string-iterator.js");
/* harmony import */ var _make_array_buffer_iterator_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./make-array-buffer-iterator.js */ "../../node_modules/@loaders.gl/core/dist/iterators/make-iterator/make-array-buffer-iterator.js");
/* harmony import */ var _make_blob_iterator_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./make-blob-iterator.js */ "../../node_modules/@loaders.gl/core/dist/iterators/make-iterator/make-blob-iterator.js");
/* harmony import */ var _make_stream_iterator_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./make-stream-iterator.js */ "../../node_modules/@loaders.gl/core/dist/iterators/make-iterator/make-stream-iterator.js");
/* harmony import */ var _javascript_utils_is_type_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../javascript-utils/is-type.js */ "../../node_modules/@loaders.gl/core/dist/javascript-utils/is-type.js");





function makeIterator(data, options) {
  if (typeof data === 'string') {
    return (0,_make_string_iterator_js__WEBPACK_IMPORTED_MODULE_0__.makeStringIterator)(data, options);
  }
  if (data instanceof ArrayBuffer) {
    return (0,_make_array_buffer_iterator_js__WEBPACK_IMPORTED_MODULE_1__.makeArrayBufferIterator)(data, options);
  }
  if ((0,_javascript_utils_is_type_js__WEBPACK_IMPORTED_MODULE_2__.isBlob)(data)) {
    return (0,_make_blob_iterator_js__WEBPACK_IMPORTED_MODULE_3__.makeBlobIterator)(data, options);
  }
  if ((0,_javascript_utils_is_type_js__WEBPACK_IMPORTED_MODULE_2__.isReadableStream)(data)) {
    return (0,_make_stream_iterator_js__WEBPACK_IMPORTED_MODULE_4__.makeStreamIterator)(data, options);
  }
  if ((0,_javascript_utils_is_type_js__WEBPACK_IMPORTED_MODULE_2__.isResponse)(data)) {
    const response = data;
    return (0,_make_stream_iterator_js__WEBPACK_IMPORTED_MODULE_4__.makeStreamIterator)(response.body, options);
  }
  throw new Error('makeIterator');
}
//# sourceMappingURL=make-iterator.js.map

/***/ }),

/***/ "../../node_modules/@loaders.gl/core/dist/iterators/make-iterator/make-stream-iterator.js":
/*!************************************************************************************************!*\
  !*** ../../node_modules/@loaders.gl/core/dist/iterators/make-iterator/make-stream-iterator.js ***!
  \************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   makeStreamIterator: () => (/* binding */ makeStreamIterator)
/* harmony export */ });
/* harmony import */ var _loaders_gl_loader_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @loaders.gl/loader-utils */ "../../node_modules/@loaders.gl/loader-utils/dist/lib/env-utils/globals.js");
/* harmony import */ var _loaders_gl_loader_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @loaders.gl/loader-utils */ "../../node_modules/@loaders.gl/loader-utils/dist/lib/binary-utils/memory-conversion-utils.js");

function makeStreamIterator(stream, options) {
  return _loaders_gl_loader_utils__WEBPACK_IMPORTED_MODULE_0__.isBrowser ? makeBrowserStreamIterator(stream, options) : makeNodeStreamIterator(stream, options);
}
async function* makeBrowserStreamIterator(stream, options) {
  const reader = stream.getReader();
  let nextBatchPromise;
  try {
    while (true) {
      const currentBatchPromise = nextBatchPromise || reader.read();
      if (options !== null && options !== void 0 && options._streamReadAhead) {
        nextBatchPromise = reader.read();
      }
      const {
        done,
        value
      } = await currentBatchPromise;
      if (done) {
        return;
      }
      yield (0,_loaders_gl_loader_utils__WEBPACK_IMPORTED_MODULE_1__.toArrayBuffer)(value);
    }
  } catch (error) {
    reader.releaseLock();
  }
}
async function* makeNodeStreamIterator(stream, options) {
  for await (const chunk of stream) {
    yield (0,_loaders_gl_loader_utils__WEBPACK_IMPORTED_MODULE_1__.toArrayBuffer)(chunk);
  }
}
//# sourceMappingURL=make-stream-iterator.js.map

/***/ }),

/***/ "../../node_modules/@loaders.gl/core/dist/iterators/make-iterator/make-string-iterator.js":
/*!************************************************************************************************!*\
  !*** ../../node_modules/@loaders.gl/core/dist/iterators/make-iterator/make-string-iterator.js ***!
  \************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   makeStringIterator: () => (/* binding */ makeStringIterator)
/* harmony export */ });
const DEFAULT_CHUNK_SIZE = 256 * 1024;
function* makeStringIterator(string, options) {
  const chunkSize = (options === null || options === void 0 ? void 0 : options.chunkSize) || DEFAULT_CHUNK_SIZE;
  let offset = 0;
  const textEncoder = new TextEncoder();
  while (offset < string.length) {
    const chunkLength = Math.min(string.length - offset, chunkSize);
    const chunk = string.slice(offset, offset + chunkLength);
    offset += chunkLength;
    yield textEncoder.encode(chunk);
  }
}
//# sourceMappingURL=make-string-iterator.js.map

/***/ }),

/***/ "../../node_modules/@loaders.gl/core/dist/javascript-utils/is-type.js":
/*!****************************************************************************!*\
  !*** ../../node_modules/@loaders.gl/core/dist/javascript-utils/is-type.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   isAsyncIterable: () => (/* binding */ isAsyncIterable),
/* harmony export */   isBlob: () => (/* binding */ isBlob),
/* harmony export */   isBuffer: () => (/* binding */ isBuffer),
/* harmony export */   isFile: () => (/* binding */ isFile),
/* harmony export */   isIterable: () => (/* binding */ isIterable),
/* harmony export */   isIterator: () => (/* binding */ isIterator),
/* harmony export */   isObject: () => (/* binding */ isObject),
/* harmony export */   isPromise: () => (/* binding */ isPromise),
/* harmony export */   isPureObject: () => (/* binding */ isPureObject),
/* harmony export */   isReadableDOMStream: () => (/* binding */ isReadableDOMStream),
/* harmony export */   isReadableNodeStream: () => (/* binding */ isReadableNodeStream),
/* harmony export */   isReadableStream: () => (/* binding */ isReadableStream),
/* harmony export */   isResponse: () => (/* binding */ isResponse),
/* harmony export */   isWritableDOMStream: () => (/* binding */ isWritableDOMStream),
/* harmony export */   isWritableNodeStream: () => (/* binding */ isWritableNodeStream),
/* harmony export */   isWritableStream: () => (/* binding */ isWritableStream)
/* harmony export */ });
const isBoolean = x => typeof x === 'boolean';
const isFunction = x => typeof x === 'function';
const isObject = x => x !== null && typeof x === 'object';
const isPureObject = x => isObject(x) && x.constructor === {}.constructor;
const isPromise = x => isObject(x) && isFunction(x.then);
const isIterable = x => Boolean(x) && typeof x[Symbol.iterator] === 'function';
const isAsyncIterable = x => x && typeof x[Symbol.asyncIterator] === 'function';
const isIterator = x => x && isFunction(x.next);
const isResponse = x => typeof Response !== 'undefined' && x instanceof Response || x && x.arrayBuffer && x.text && x.json;
const isFile = x => typeof File !== 'undefined' && x instanceof File;
const isBlob = x => typeof Blob !== 'undefined' && x instanceof Blob;
const isBuffer = x => x && typeof x === 'object' && x.isBuffer;
const isWritableDOMStream = x => isObject(x) && isFunction(x.abort) && isFunction(x.getWriter);
const isReadableDOMStream = x => typeof ReadableStream !== 'undefined' && x instanceof ReadableStream || isObject(x) && isFunction(x.tee) && isFunction(x.cancel) && isFunction(x.getReader);
const isWritableNodeStream = x => isObject(x) && isFunction(x.end) && isFunction(x.write) && isBoolean(x.writable);
const isReadableNodeStream = x => isObject(x) && isFunction(x.read) && isFunction(x.pipe) && isBoolean(x.readable);
const isReadableStream = x => isReadableDOMStream(x) || isReadableNodeStream(x);
const isWritableStream = x => isWritableDOMStream(x) || isWritableNodeStream(x);
//# sourceMappingURL=is-type.js.map

/***/ }),

/***/ "../../node_modules/@loaders.gl/core/dist/lib/api/load.js":
/*!****************************************************************!*\
  !*** ../../node_modules/@loaders.gl/core/dist/lib/api/load.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   load: () => (/* binding */ load)
/* harmony export */ });
/* harmony import */ var _javascript_utils_is_type_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../javascript-utils/is-type.js */ "../../node_modules/@loaders.gl/core/dist/javascript-utils/is-type.js");
/* harmony import */ var _loader_utils_normalize_loader_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../loader-utils/normalize-loader.js */ "../../node_modules/@loaders.gl/core/dist/lib/loader-utils/normalize-loader.js");
/* harmony import */ var _loader_utils_get_fetch_function_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../loader-utils/get-fetch-function.js */ "../../node_modules/@loaders.gl/core/dist/lib/loader-utils/get-fetch-function.js");
/* harmony import */ var _parse_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./parse.js */ "../../node_modules/@loaders.gl/core/dist/lib/api/parse.js");




async function load(url, loaders, options, context) {
  let resolvedLoaders;
  let resolvedOptions;
  if (!Array.isArray(loaders) && !(0,_loader_utils_normalize_loader_js__WEBPACK_IMPORTED_MODULE_0__.isLoaderObject)(loaders)) {
    resolvedLoaders = [];
    resolvedOptions = loaders;
    context = undefined;
  } else {
    resolvedLoaders = loaders;
    resolvedOptions = options;
  }
  const fetch = (0,_loader_utils_get_fetch_function_js__WEBPACK_IMPORTED_MODULE_1__.getFetchFunction)(resolvedOptions);
  let data = url;
  if (typeof url === 'string') {
    data = await fetch(url);
  }
  if ((0,_javascript_utils_is_type_js__WEBPACK_IMPORTED_MODULE_2__.isBlob)(url)) {
    data = await fetch(url);
  }
  return Array.isArray(resolvedLoaders) ? await (0,_parse_js__WEBPACK_IMPORTED_MODULE_3__.parse)(data, resolvedLoaders, resolvedOptions) : await (0,_parse_js__WEBPACK_IMPORTED_MODULE_3__.parse)(data, resolvedLoaders, resolvedOptions);
}
//# sourceMappingURL=load.js.map

/***/ }),

/***/ "../../node_modules/@loaders.gl/core/dist/lib/api/parse.js":
/*!*****************************************************************!*\
  !*** ../../node_modules/@loaders.gl/core/dist/lib/api/parse.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   parse: () => (/* binding */ parse)
/* harmony export */ });
/* harmony import */ var _loaders_gl_loader_utils__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! @loaders.gl/loader-utils */ "../../node_modules/@loaders.gl/loader-utils/dist/lib/worker-loader-utils/parse-with-worker.js");
/* harmony import */ var _loaders_gl_worker_utils__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @loaders.gl/worker-utils */ "../../node_modules/@loaders.gl/worker-utils/dist/lib/worker-api/validate-worker-version.js");
/* harmony import */ var _loaders_gl_worker_utils__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! @loaders.gl/worker-utils */ "../../node_modules/@loaders.gl/worker-utils/dist/lib/env-utils/assert.js");
/* harmony import */ var _loader_utils_normalize_loader_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../loader-utils/normalize-loader.js */ "../../node_modules/@loaders.gl/core/dist/lib/loader-utils/normalize-loader.js");
/* harmony import */ var _javascript_utils_is_type_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../javascript-utils/is-type.js */ "../../node_modules/@loaders.gl/core/dist/javascript-utils/is-type.js");
/* harmony import */ var _loader_utils_option_utils_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../loader-utils/option-utils.js */ "../../node_modules/@loaders.gl/core/dist/lib/loader-utils/option-utils.js");
/* harmony import */ var _loaders_gl_loader_utils__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @loaders.gl/loader-utils */ "../../node_modules/@loaders.gl/loader-utils/dist/lib/option-utils/merge-loader-options.js");
/* harmony import */ var _loader_utils_get_data_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../loader-utils/get-data.js */ "../../node_modules/@loaders.gl/core/dist/lib/loader-utils/get-data.js");
/* harmony import */ var _loader_utils_loader_context_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../loader-utils/loader-context.js */ "../../node_modules/@loaders.gl/core/dist/lib/loader-utils/loader-context.js");
/* harmony import */ var _utils_resource_utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/resource-utils.js */ "../../node_modules/@loaders.gl/core/dist/lib/utils/resource-utils.js");
/* harmony import */ var _select_loader_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./select-loader.js */ "../../node_modules/@loaders.gl/core/dist/lib/api/select-loader.js");










async function parse(data, loaders, options, context) {
  if (loaders && !Array.isArray(loaders) && !(0,_loader_utils_normalize_loader_js__WEBPACK_IMPORTED_MODULE_0__.isLoaderObject)(loaders)) {
    context = undefined;
    options = loaders;
    loaders = undefined;
  }
  data = await data;
  options = options || {};
  const url = (0,_utils_resource_utils_js__WEBPACK_IMPORTED_MODULE_1__.getResourceUrl)(data);
  const typedLoaders = loaders;
  const candidateLoaders = (0,_loader_utils_loader_context_js__WEBPACK_IMPORTED_MODULE_2__.getLoadersFromContext)(typedLoaders, context);
  const loader = await (0,_select_loader_js__WEBPACK_IMPORTED_MODULE_3__.selectLoader)(data, candidateLoaders, options);
  if (!loader) {
    return null;
  }
  options = (0,_loader_utils_option_utils_js__WEBPACK_IMPORTED_MODULE_4__.normalizeOptions)(options, loader, candidateLoaders, url);
  context = (0,_loader_utils_loader_context_js__WEBPACK_IMPORTED_MODULE_2__.getLoaderContext)({
    url,
    _parse: parse,
    loaders: candidateLoaders
  }, options, context || null);
  return await parseWithLoader(loader, data, options, context);
}
async function parseWithLoader(loader, data, options, context) {
  (0,_loaders_gl_worker_utils__WEBPACK_IMPORTED_MODULE_5__.validateWorkerVersion)(loader);
  options = (0,_loaders_gl_loader_utils__WEBPACK_IMPORTED_MODULE_6__.mergeLoaderOptions)(loader.options, options);
  if ((0,_javascript_utils_is_type_js__WEBPACK_IMPORTED_MODULE_7__.isResponse)(data)) {
    const response = data;
    const {
      ok,
      redirected,
      status,
      statusText,
      type,
      url
    } = response;
    const headers = Object.fromEntries(response.headers.entries());
    context.response = {
      headers,
      ok,
      redirected,
      status,
      statusText,
      type,
      url
    };
  }
  data = await (0,_loader_utils_get_data_js__WEBPACK_IMPORTED_MODULE_8__.getArrayBufferOrStringFromData)(data, loader, options);
  const loaderWithParser = loader;
  if (loaderWithParser.parseTextSync && typeof data === 'string') {
    return loaderWithParser.parseTextSync(data, options, context);
  }
  if ((0,_loaders_gl_loader_utils__WEBPACK_IMPORTED_MODULE_9__.canParseWithWorker)(loader, options)) {
    return await (0,_loaders_gl_loader_utils__WEBPACK_IMPORTED_MODULE_9__.parseWithWorker)(loader, data, options, context, parse);
  }
  if (loaderWithParser.parseText && typeof data === 'string') {
    return await loaderWithParser.parseText(data, options, context);
  }
  if (loaderWithParser.parse) {
    return await loaderWithParser.parse(data, options, context);
  }
  (0,_loaders_gl_worker_utils__WEBPACK_IMPORTED_MODULE_10__.assert)(!loaderWithParser.parseSync);
  throw new Error(`${loader.id} loader - no parser found and worker is disabled`);
}
//# sourceMappingURL=parse.js.map

/***/ }),

/***/ "../../node_modules/@loaders.gl/core/dist/lib/api/register-loaders.js":
/*!****************************************************************************!*\
  !*** ../../node_modules/@loaders.gl/core/dist/lib/api/register-loaders.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   _unregisterLoaders: () => (/* binding */ _unregisterLoaders),
/* harmony export */   getRegisteredLoaders: () => (/* binding */ getRegisteredLoaders),
/* harmony export */   registerLoaders: () => (/* binding */ registerLoaders)
/* harmony export */ });
/* harmony import */ var _loader_utils_normalize_loader_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../loader-utils/normalize-loader.js */ "../../node_modules/@loaders.gl/core/dist/lib/loader-utils/normalize-loader.js");
/* harmony import */ var _loader_utils_option_utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../loader-utils/option-utils.js */ "../../node_modules/@loaders.gl/core/dist/lib/loader-utils/option-utils.js");


const getGlobalLoaderRegistry = () => {
  const state = (0,_loader_utils_option_utils_js__WEBPACK_IMPORTED_MODULE_0__.getGlobalLoaderState)();
  state.loaderRegistry = state.loaderRegistry || [];
  return state.loaderRegistry;
};
function registerLoaders(loaders) {
  const loaderRegistry = getGlobalLoaderRegistry();
  loaders = Array.isArray(loaders) ? loaders : [loaders];
  for (const loader of loaders) {
    const normalizedLoader = (0,_loader_utils_normalize_loader_js__WEBPACK_IMPORTED_MODULE_1__.normalizeLoader)(loader);
    if (!loaderRegistry.find(registeredLoader => normalizedLoader === registeredLoader)) {
      loaderRegistry.unshift(normalizedLoader);
    }
  }
}
function getRegisteredLoaders() {
  return getGlobalLoaderRegistry();
}
function _unregisterLoaders() {
  const state = (0,_loader_utils_option_utils_js__WEBPACK_IMPORTED_MODULE_0__.getGlobalLoaderState)();
  state.loaderRegistry = [];
}
//# sourceMappingURL=register-loaders.js.map

/***/ }),

/***/ "../../node_modules/@loaders.gl/core/dist/lib/api/select-loader.js":
/*!*************************************************************************!*\
  !*** ../../node_modules/@loaders.gl/core/dist/lib/api/select-loader.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   selectLoader: () => (/* binding */ selectLoader),
/* harmony export */   selectLoaderSync: () => (/* binding */ selectLoaderSync)
/* harmony export */ });
/* harmony import */ var _loaders_gl_loader_utils__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @loaders.gl/loader-utils */ "../../node_modules/@loaders.gl/loader-utils/dist/lib/path-utils/path.js");
/* harmony import */ var _loaders_gl_loader_utils__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @loaders.gl/loader-utils */ "../../node_modules/@loaders.gl/loader-utils/dist/lib/binary-utils/array-buffer-utils.js");
/* harmony import */ var _loader_utils_normalize_loader_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../loader-utils/normalize-loader.js */ "../../node_modules/@loaders.gl/core/dist/lib/loader-utils/normalize-loader.js");
/* harmony import */ var _utils_log_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../utils/log.js */ "../../node_modules/@loaders.gl/core/dist/lib/utils/log.js");
/* harmony import */ var _utils_resource_utils_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utils/resource-utils.js */ "../../node_modules/@loaders.gl/core/dist/lib/utils/resource-utils.js");
/* harmony import */ var _register_loaders_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./register-loaders.js */ "../../node_modules/@loaders.gl/core/dist/lib/api/register-loaders.js");
/* harmony import */ var _javascript_utils_is_type_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../javascript-utils/is-type.js */ "../../node_modules/@loaders.gl/core/dist/javascript-utils/is-type.js");
/* harmony import */ var _utils_url_utils_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../utils/url-utils.js */ "../../node_modules/@loaders.gl/core/dist/lib/utils/url-utils.js");







const EXT_PATTERN = /\.([^.]+)$/;
async function selectLoader(data) {
  let loaders = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
  let options = arguments.length > 2 ? arguments[2] : undefined;
  let context = arguments.length > 3 ? arguments[3] : undefined;
  if (!validHTTPResponse(data)) {
    return null;
  }
  let loader = selectLoaderSync(data, loaders, {
    ...options,
    nothrow: true
  }, context);
  if (loader) {
    return loader;
  }
  if ((0,_javascript_utils_is_type_js__WEBPACK_IMPORTED_MODULE_0__.isBlob)(data)) {
    data = await data.slice(0, 10).arrayBuffer();
    loader = selectLoaderSync(data, loaders, options, context);
  }
  if (!loader && !(options !== null && options !== void 0 && options.nothrow)) {
    throw new Error(getNoValidLoaderMessage(data));
  }
  return loader;
}
function selectLoaderSync(data) {
  let loaders = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
  let options = arguments.length > 2 ? arguments[2] : undefined;
  let context = arguments.length > 3 ? arguments[3] : undefined;
  if (!validHTTPResponse(data)) {
    return null;
  }
  if (loaders && !Array.isArray(loaders)) {
    return (0,_loader_utils_normalize_loader_js__WEBPACK_IMPORTED_MODULE_1__.normalizeLoader)(loaders);
  }
  let candidateLoaders = [];
  if (loaders) {
    candidateLoaders = candidateLoaders.concat(loaders);
  }
  if (!(options !== null && options !== void 0 && options.ignoreRegisteredLoaders)) {
    candidateLoaders.push(...(0,_register_loaders_js__WEBPACK_IMPORTED_MODULE_2__.getRegisteredLoaders)());
  }
  normalizeLoaders(candidateLoaders);
  const loader = selectLoaderInternal(data, candidateLoaders, options, context);
  if (!loader && !(options !== null && options !== void 0 && options.nothrow)) {
    throw new Error(getNoValidLoaderMessage(data));
  }
  return loader;
}
function selectLoaderInternal(data, loaders, options, context) {
  const url = (0,_utils_resource_utils_js__WEBPACK_IMPORTED_MODULE_3__.getResourceUrl)(data);
  const type = (0,_utils_resource_utils_js__WEBPACK_IMPORTED_MODULE_3__.getResourceMIMEType)(data);
  const testUrl = (0,_utils_url_utils_js__WEBPACK_IMPORTED_MODULE_4__.stripQueryString)(url) || (context === null || context === void 0 ? void 0 : context.url);
  let loader = null;
  let reason = '';
  if (options !== null && options !== void 0 && options.mimeType) {
    loader = findLoaderByMIMEType(loaders, options === null || options === void 0 ? void 0 : options.mimeType);
    reason = `match forced by supplied MIME type ${options === null || options === void 0 ? void 0 : options.mimeType}`;
  }
  loader = loader || findLoaderByUrl(loaders, testUrl);
  reason = reason || (loader ? `matched url ${testUrl}` : '');
  loader = loader || findLoaderByMIMEType(loaders, type);
  reason = reason || (loader ? `matched MIME type ${type}` : '');
  loader = loader || findLoaderByInitialBytes(loaders, data);
  reason = reason || (loader ? `matched initial data ${getFirstCharacters(data)}` : '');
  if (options !== null && options !== void 0 && options.fallbackMimeType) {
    loader = loader || findLoaderByMIMEType(loaders, options === null || options === void 0 ? void 0 : options.fallbackMimeType);
    reason = reason || (loader ? `matched fallback MIME type ${type}` : '');
  }
  if (reason) {
    var _loader;
    _utils_log_js__WEBPACK_IMPORTED_MODULE_5__.log.log(1, `selectLoader selected ${(_loader = loader) === null || _loader === void 0 ? void 0 : _loader.name}: ${reason}.`);
  }
  return loader;
}
function validHTTPResponse(data) {
  if (data instanceof Response) {
    if (data.status === 204) {
      return false;
    }
  }
  return true;
}
function getNoValidLoaderMessage(data) {
  const url = (0,_utils_resource_utils_js__WEBPACK_IMPORTED_MODULE_3__.getResourceUrl)(data);
  const type = (0,_utils_resource_utils_js__WEBPACK_IMPORTED_MODULE_3__.getResourceMIMEType)(data);
  let message = 'No valid loader found (';
  message += url ? `${_loaders_gl_loader_utils__WEBPACK_IMPORTED_MODULE_6__.filename(url)}, ` : 'no url provided, ';
  message += `MIME type: ${type ? `"${type}"` : 'not provided'}, `;
  const firstCharacters = data ? getFirstCharacters(data) : '';
  message += firstCharacters ? ` first bytes: "${firstCharacters}"` : 'first bytes: not available';
  message += ')';
  return message;
}
function normalizeLoaders(loaders) {
  for (const loader of loaders) {
    (0,_loader_utils_normalize_loader_js__WEBPACK_IMPORTED_MODULE_1__.normalizeLoader)(loader);
  }
}
function findLoaderByUrl(loaders, url) {
  const match = url && EXT_PATTERN.exec(url);
  const extension = match && match[1];
  return extension ? findLoaderByExtension(loaders, extension) : null;
}
function findLoaderByExtension(loaders, extension) {
  extension = extension.toLowerCase();
  for (const loader of loaders) {
    for (const loaderExtension of loader.extensions) {
      if (loaderExtension.toLowerCase() === extension) {
        return loader;
      }
    }
  }
  return null;
}
function findLoaderByMIMEType(loaders, mimeType) {
  for (const loader of loaders) {
    if (loader.mimeTypes && loader.mimeTypes.includes(mimeType)) {
      return loader;
    }
    if (mimeType === `application/x.${loader.id}`) {
      return loader;
    }
  }
  return null;
}
function findLoaderByInitialBytes(loaders, data) {
  if (!data) {
    return null;
  }
  for (const loader of loaders) {
    if (typeof data === 'string') {
      if (testDataAgainstText(data, loader)) {
        return loader;
      }
    } else if (ArrayBuffer.isView(data)) {
      if (testDataAgainstBinary(data.buffer, data.byteOffset, loader)) {
        return loader;
      }
    } else if (data instanceof ArrayBuffer) {
      const byteOffset = 0;
      if (testDataAgainstBinary(data, byteOffset, loader)) {
        return loader;
      }
    }
  }
  return null;
}
function testDataAgainstText(data, loader) {
  if (loader.testText) {
    return loader.testText(data);
  }
  const tests = Array.isArray(loader.tests) ? loader.tests : [loader.tests];
  return tests.some(test => data.startsWith(test));
}
function testDataAgainstBinary(data, byteOffset, loader) {
  const tests = Array.isArray(loader.tests) ? loader.tests : [loader.tests];
  return tests.some(test => testBinary(data, byteOffset, loader, test));
}
function testBinary(data, byteOffset, loader, test) {
  if (test instanceof ArrayBuffer) {
    return (0,_loaders_gl_loader_utils__WEBPACK_IMPORTED_MODULE_7__.compareArrayBuffers)(test, data, test.byteLength);
  }
  switch (typeof test) {
    case 'function':
      return test(data);
    case 'string':
      const magic = getMagicString(data, byteOffset, test.length);
      return test === magic;
    default:
      return false;
  }
}
function getFirstCharacters(data) {
  let length = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 5;
  if (typeof data === 'string') {
    return data.slice(0, length);
  } else if (ArrayBuffer.isView(data)) {
    return getMagicString(data.buffer, data.byteOffset, length);
  } else if (data instanceof ArrayBuffer) {
    const byteOffset = 0;
    return getMagicString(data, byteOffset, length);
  }
  return '';
}
function getMagicString(arrayBuffer, byteOffset, length) {
  if (arrayBuffer.byteLength < byteOffset + length) {
    return '';
  }
  const dataView = new DataView(arrayBuffer);
  let magic = '';
  for (let i = 0; i < length; i++) {
    magic += String.fromCharCode(dataView.getUint8(byteOffset + i));
  }
  return magic;
}
//# sourceMappingURL=select-loader.js.map

/***/ }),

/***/ "../../node_modules/@loaders.gl/core/dist/lib/fetch/fetch-file.js":
/*!************************************************************************!*\
  !*** ../../node_modules/@loaders.gl/core/dist/lib/fetch/fetch-file.js ***!
  \************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   fetchFile: () => (/* binding */ fetchFile),
/* harmony export */   isDataURL: () => (/* binding */ isDataURL),
/* harmony export */   isNodePath: () => (/* binding */ isNodePath),
/* harmony export */   isRequestURL: () => (/* binding */ isRequestURL)
/* harmony export */ });
/* harmony import */ var _loaders_gl_loader_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @loaders.gl/loader-utils */ "../../node_modules/@loaders.gl/loader-utils/dist/lib/path-utils/file-aliases.js");
/* harmony import */ var _utils_response_utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/response-utils.js */ "../../node_modules/@loaders.gl/core/dist/lib/utils/response-utils.js");


function isNodePath(url) {
  return !isRequestURL(url) && !isDataURL(url);
}
function isRequestURL(url) {
  return url.startsWith('http:') || url.startsWith('https:');
}
function isDataURL(url) {
  return url.startsWith('data:');
}
async function fetchFile(urlOrData, fetchOptions) {
  if (typeof urlOrData === 'string') {
    const url = (0,_loaders_gl_loader_utils__WEBPACK_IMPORTED_MODULE_0__.resolvePath)(urlOrData);
    if (isNodePath(url)) {
      var _globalThis$loaders;
      if ((_globalThis$loaders = globalThis.loaders) !== null && _globalThis$loaders !== void 0 && _globalThis$loaders.fetchNode) {
        var _globalThis$loaders2;
        return (_globalThis$loaders2 = globalThis.loaders) === null || _globalThis$loaders2 === void 0 ? void 0 : _globalThis$loaders2.fetchNode(url, fetchOptions);
      }
    }
    return await fetch(url, fetchOptions);
  }
  return await (0,_utils_response_utils_js__WEBPACK_IMPORTED_MODULE_1__.makeResponse)(urlOrData);
}
//# sourceMappingURL=fetch-file.js.map

/***/ }),

/***/ "../../node_modules/@loaders.gl/core/dist/lib/loader-utils/get-data.js":
/*!*****************************************************************************!*\
  !*** ../../node_modules/@loaders.gl/core/dist/lib/loader-utils/get-data.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   getArrayBufferOrStringFromData: () => (/* binding */ getArrayBufferOrStringFromData),
/* harmony export */   getArrayBufferOrStringFromDataSync: () => (/* binding */ getArrayBufferOrStringFromDataSync),
/* harmony export */   getAsyncIterableFromData: () => (/* binding */ getAsyncIterableFromData),
/* harmony export */   getReadableStream: () => (/* binding */ getReadableStream)
/* harmony export */ });
/* harmony import */ var _loaders_gl_loader_utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @loaders.gl/loader-utils */ "../../node_modules/@loaders.gl/loader-utils/dist/lib/iterators/async-iteration.js");
/* harmony import */ var _javascript_utils_is_type_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../javascript-utils/is-type.js */ "../../node_modules/@loaders.gl/core/dist/javascript-utils/is-type.js");
/* harmony import */ var _iterators_make_iterator_make_iterator_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../iterators/make-iterator/make-iterator.js */ "../../node_modules/@loaders.gl/core/dist/iterators/make-iterator/make-iterator.js");
/* harmony import */ var _utils_response_utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/response-utils.js */ "../../node_modules/@loaders.gl/core/dist/lib/utils/response-utils.js");




const ERR_DATA = 'Cannot convert supplied data type';
function getArrayBufferOrStringFromDataSync(data, loader, options) {
  if (loader.text && typeof data === 'string') {
    return data;
  }
  if ((0,_javascript_utils_is_type_js__WEBPACK_IMPORTED_MODULE_0__.isBuffer)(data)) {
    data = data.buffer;
  }
  if (data instanceof ArrayBuffer) {
    const arrayBuffer = data;
    if (loader.text && !loader.binary) {
      const textDecoder = new TextDecoder('utf8');
      return textDecoder.decode(arrayBuffer);
    }
    return arrayBuffer;
  }
  if (ArrayBuffer.isView(data)) {
    if (loader.text && !loader.binary) {
      const textDecoder = new TextDecoder('utf8');
      return textDecoder.decode(data);
    }
    let arrayBuffer = data.buffer;
    const byteLength = data.byteLength || data.length;
    if (data.byteOffset !== 0 || byteLength !== arrayBuffer.byteLength) {
      arrayBuffer = arrayBuffer.slice(data.byteOffset, data.byteOffset + byteLength);
    }
    return arrayBuffer;
  }
  throw new Error(ERR_DATA);
}
async function getArrayBufferOrStringFromData(data, loader, options) {
  const isArrayBuffer = data instanceof ArrayBuffer || ArrayBuffer.isView(data);
  if (typeof data === 'string' || isArrayBuffer) {
    return getArrayBufferOrStringFromDataSync(data, loader, options);
  }
  if ((0,_javascript_utils_is_type_js__WEBPACK_IMPORTED_MODULE_0__.isBlob)(data)) {
    data = await (0,_utils_response_utils_js__WEBPACK_IMPORTED_MODULE_1__.makeResponse)(data);
  }
  if ((0,_javascript_utils_is_type_js__WEBPACK_IMPORTED_MODULE_0__.isResponse)(data)) {
    const response = data;
    await (0,_utils_response_utils_js__WEBPACK_IMPORTED_MODULE_1__.checkResponse)(response);
    return loader.binary ? await response.arrayBuffer() : await response.text();
  }
  if ((0,_javascript_utils_is_type_js__WEBPACK_IMPORTED_MODULE_0__.isReadableStream)(data)) {
    data = (0,_iterators_make_iterator_make_iterator_js__WEBPACK_IMPORTED_MODULE_2__.makeIterator)(data, options);
  }
  if ((0,_javascript_utils_is_type_js__WEBPACK_IMPORTED_MODULE_0__.isIterable)(data) || (0,_javascript_utils_is_type_js__WEBPACK_IMPORTED_MODULE_0__.isAsyncIterable)(data)) {
    return (0,_loaders_gl_loader_utils__WEBPACK_IMPORTED_MODULE_3__.concatenateArrayBuffersAsync)(data);
  }
  throw new Error(ERR_DATA);
}
async function getAsyncIterableFromData(data, options) {
  if ((0,_javascript_utils_is_type_js__WEBPACK_IMPORTED_MODULE_0__.isIterator)(data)) {
    return data;
  }
  if ((0,_javascript_utils_is_type_js__WEBPACK_IMPORTED_MODULE_0__.isResponse)(data)) {
    const response = data;
    await (0,_utils_response_utils_js__WEBPACK_IMPORTED_MODULE_1__.checkResponse)(response);
    const body = await response.body;
    return (0,_iterators_make_iterator_make_iterator_js__WEBPACK_IMPORTED_MODULE_2__.makeIterator)(body, options);
  }
  if ((0,_javascript_utils_is_type_js__WEBPACK_IMPORTED_MODULE_0__.isBlob)(data) || (0,_javascript_utils_is_type_js__WEBPACK_IMPORTED_MODULE_0__.isReadableStream)(data)) {
    return (0,_iterators_make_iterator_make_iterator_js__WEBPACK_IMPORTED_MODULE_2__.makeIterator)(data, options);
  }
  if ((0,_javascript_utils_is_type_js__WEBPACK_IMPORTED_MODULE_0__.isAsyncIterable)(data)) {
    return data;
  }
  return getIterableFromData(data);
}
async function getReadableStream(data) {
  if ((0,_javascript_utils_is_type_js__WEBPACK_IMPORTED_MODULE_0__.isReadableStream)(data)) {
    return data;
  }
  if ((0,_javascript_utils_is_type_js__WEBPACK_IMPORTED_MODULE_0__.isResponse)(data)) {
    return data.body;
  }
  const response = await (0,_utils_response_utils_js__WEBPACK_IMPORTED_MODULE_1__.makeResponse)(data);
  return response.body;
}
function getIterableFromData(data) {
  if (ArrayBuffer.isView(data)) {
    return function* oneChunk() {
      yield data.buffer;
    }();
  }
  if (data instanceof ArrayBuffer) {
    return function* oneChunk() {
      yield data;
    }();
  }
  if ((0,_javascript_utils_is_type_js__WEBPACK_IMPORTED_MODULE_0__.isIterator)(data)) {
    return data;
  }
  if ((0,_javascript_utils_is_type_js__WEBPACK_IMPORTED_MODULE_0__.isIterable)(data)) {
    return data[Symbol.iterator]();
  }
  throw new Error(ERR_DATA);
}
//# sourceMappingURL=get-data.js.map

/***/ }),

/***/ "../../node_modules/@loaders.gl/core/dist/lib/loader-utils/get-fetch-function.js":
/*!***************************************************************************************!*\
  !*** ../../node_modules/@loaders.gl/core/dist/lib/loader-utils/get-fetch-function.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   getFetchFunction: () => (/* binding */ getFetchFunction)
/* harmony export */ });
/* harmony import */ var _javascript_utils_is_type_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../javascript-utils/is-type.js */ "../../node_modules/@loaders.gl/core/dist/javascript-utils/is-type.js");
/* harmony import */ var _fetch_fetch_file_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../fetch/fetch-file.js */ "../../node_modules/@loaders.gl/core/dist/lib/fetch/fetch-file.js");
/* harmony import */ var _option_utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./option-utils.js */ "../../node_modules/@loaders.gl/core/dist/lib/loader-utils/option-utils.js");



function getFetchFunction(options, context) {
  const globalOptions = (0,_option_utils_js__WEBPACK_IMPORTED_MODULE_0__.getGlobalLoaderOptions)();
  const loaderOptions = options || globalOptions;
  if (typeof loaderOptions.fetch === 'function') {
    return loaderOptions.fetch;
  }
  if ((0,_javascript_utils_is_type_js__WEBPACK_IMPORTED_MODULE_1__.isObject)(loaderOptions.fetch)) {
    return url => (0,_fetch_fetch_file_js__WEBPACK_IMPORTED_MODULE_2__.fetchFile)(url, loaderOptions.fetch);
  }
  if (context !== null && context !== void 0 && context.fetch) {
    return context === null || context === void 0 ? void 0 : context.fetch;
  }
  return _fetch_fetch_file_js__WEBPACK_IMPORTED_MODULE_2__.fetchFile;
}
//# sourceMappingURL=get-fetch-function.js.map

/***/ }),

/***/ "../../node_modules/@loaders.gl/core/dist/lib/loader-utils/loader-context.js":
/*!***********************************************************************************!*\
  !*** ../../node_modules/@loaders.gl/core/dist/lib/loader-utils/loader-context.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   getLoaderContext: () => (/* binding */ getLoaderContext),
/* harmony export */   getLoadersFromContext: () => (/* binding */ getLoadersFromContext)
/* harmony export */ });
/* harmony import */ var _get_fetch_function_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./get-fetch-function.js */ "../../node_modules/@loaders.gl/core/dist/lib/loader-utils/get-fetch-function.js");
/* harmony import */ var _utils_url_utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/url-utils.js */ "../../node_modules/@loaders.gl/core/dist/lib/utils/url-utils.js");
/* harmony import */ var _loaders_gl_loader_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @loaders.gl/loader-utils */ "../../node_modules/@loaders.gl/loader-utils/dist/lib/path-utils/path.js");



function getLoaderContext(context, options, parentContext) {
  if (parentContext) {
    return parentContext;
  }
  const newContext = {
    fetch: (0,_get_fetch_function_js__WEBPACK_IMPORTED_MODULE_0__.getFetchFunction)(options, context),
    ...context
  };
  if (newContext.url) {
    const baseUrl = (0,_utils_url_utils_js__WEBPACK_IMPORTED_MODULE_1__.stripQueryString)(newContext.url);
    newContext.baseUrl = baseUrl;
    newContext.queryString = (0,_utils_url_utils_js__WEBPACK_IMPORTED_MODULE_1__.extractQueryString)(newContext.url);
    newContext.filename = _loaders_gl_loader_utils__WEBPACK_IMPORTED_MODULE_2__.filename(baseUrl);
    newContext.baseUrl = _loaders_gl_loader_utils__WEBPACK_IMPORTED_MODULE_2__.dirname(baseUrl);
  }
  if (!Array.isArray(newContext.loaders)) {
    newContext.loaders = null;
  }
  return newContext;
}
function getLoadersFromContext(loaders, context) {
  if (loaders && !Array.isArray(loaders)) {
    return loaders;
  }
  let candidateLoaders;
  if (loaders) {
    candidateLoaders = Array.isArray(loaders) ? loaders : [loaders];
  }
  if (context && context.loaders) {
    const contextLoaders = Array.isArray(context.loaders) ? context.loaders : [context.loaders];
    candidateLoaders = candidateLoaders ? [...candidateLoaders, ...contextLoaders] : contextLoaders;
  }
  return candidateLoaders && candidateLoaders.length ? candidateLoaders : undefined;
}
//# sourceMappingURL=loader-context.js.map

/***/ }),

/***/ "../../node_modules/@loaders.gl/core/dist/lib/loader-utils/loggers.js":
/*!****************************************************************************!*\
  !*** ../../node_modules/@loaders.gl/core/dist/lib/loader-utils/loggers.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ConsoleLog: () => (/* binding */ ConsoleLog),
/* harmony export */   NullLog: () => (/* binding */ NullLog),
/* harmony export */   probeLog: () => (/* binding */ probeLog)
/* harmony export */ });
/* harmony import */ var _probe_gl_log__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @probe.gl/log */ "../../node_modules/@probe.gl/log/dist/log.js");

const probeLog = new _probe_gl_log__WEBPACK_IMPORTED_MODULE_0__.Log({
  id: 'loaders.gl'
});
class NullLog {
  log() {
    return () => {};
  }
  info() {
    return () => {};
  }
  warn() {
    return () => {};
  }
  error() {
    return () => {};
  }
}
class ConsoleLog {
  constructor() {
    this.console = void 0;
    this.console = console;
  }
  log() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    return this.console.log.bind(this.console, ...args);
  }
  info() {
    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      args[_key2] = arguments[_key2];
    }
    return this.console.info.bind(this.console, ...args);
  }
  warn() {
    for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
      args[_key3] = arguments[_key3];
    }
    return this.console.warn.bind(this.console, ...args);
  }
  error() {
    for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
      args[_key4] = arguments[_key4];
    }
    return this.console.error.bind(this.console, ...args);
  }
}
//# sourceMappingURL=loggers.js.map

/***/ }),

/***/ "../../node_modules/@loaders.gl/core/dist/lib/loader-utils/normalize-loader.js":
/*!*************************************************************************************!*\
  !*** ../../node_modules/@loaders.gl/core/dist/lib/loader-utils/normalize-loader.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   isLoaderObject: () => (/* binding */ isLoaderObject),
/* harmony export */   normalizeLoader: () => (/* binding */ normalizeLoader)
/* harmony export */ });
/* harmony import */ var _loaders_gl_loader_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @loaders.gl/loader-utils */ "../../node_modules/@loaders.gl/loader-utils/dist/lib/env-utils/assert.js");

function isLoaderObject(loader) {
  var _loader;
  if (!loader) {
    return false;
  }
  if (Array.isArray(loader)) {
    loader = loader[0];
  }
  const hasExtensions = Array.isArray((_loader = loader) === null || _loader === void 0 ? void 0 : _loader.extensions);
  return hasExtensions;
}
function normalizeLoader(loader) {
  var _loader2, _loader3;
  (0,_loaders_gl_loader_utils__WEBPACK_IMPORTED_MODULE_0__.assert)(loader, 'null loader');
  (0,_loaders_gl_loader_utils__WEBPACK_IMPORTED_MODULE_0__.assert)(isLoaderObject(loader), 'invalid loader');
  let options;
  if (Array.isArray(loader)) {
    options = loader[1];
    loader = loader[0];
    loader = {
      ...loader,
      options: {
        ...loader.options,
        ...options
      }
    };
  }
  if ((_loader2 = loader) !== null && _loader2 !== void 0 && _loader2.parseTextSync || (_loader3 = loader) !== null && _loader3 !== void 0 && _loader3.parseText) {
    loader.text = true;
  }
  if (!loader.text) {
    loader.binary = true;
  }
  return loader;
}
//# sourceMappingURL=normalize-loader.js.map

/***/ }),

/***/ "../../node_modules/@loaders.gl/core/dist/lib/loader-utils/option-defaults.js":
/*!************************************************************************************!*\
  !*** ../../node_modules/@loaders.gl/core/dist/lib/loader-utils/option-defaults.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   DEFAULT_LOADER_OPTIONS: () => (/* binding */ DEFAULT_LOADER_OPTIONS),
/* harmony export */   REMOVED_LOADER_OPTIONS: () => (/* binding */ REMOVED_LOADER_OPTIONS)
/* harmony export */ });
/* harmony import */ var _loaders_gl_loader_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @loaders.gl/loader-utils */ "../../node_modules/@loaders.gl/loader-utils/dist/lib/env-utils/globals.js");
/* harmony import */ var _loggers_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./loggers.js */ "../../node_modules/@loaders.gl/core/dist/lib/loader-utils/loggers.js");


const DEFAULT_LOADER_OPTIONS = {
  fetch: null,
  mimeType: undefined,
  nothrow: false,
  log: new _loggers_js__WEBPACK_IMPORTED_MODULE_0__.ConsoleLog(),
  useLocalLibraries: false,
  CDN: 'https://unpkg.com/@loaders.gl',
  worker: true,
  maxConcurrency: 3,
  maxMobileConcurrency: 1,
  reuseWorkers: _loaders_gl_loader_utils__WEBPACK_IMPORTED_MODULE_1__.isBrowser,
  _nodeWorkers: false,
  _workerType: '',
  limit: 0,
  _limitMB: 0,
  batchSize: 'auto',
  batchDebounceMs: 0,
  metadata: false,
  transforms: []
};
const REMOVED_LOADER_OPTIONS = {
  throws: 'nothrow',
  dataType: '(no longer used)',
  uri: 'baseUri',
  method: 'fetch.method',
  headers: 'fetch.headers',
  body: 'fetch.body',
  mode: 'fetch.mode',
  credentials: 'fetch.credentials',
  cache: 'fetch.cache',
  redirect: 'fetch.redirect',
  referrer: 'fetch.referrer',
  referrerPolicy: 'fetch.referrerPolicy',
  integrity: 'fetch.integrity',
  keepalive: 'fetch.keepalive',
  signal: 'fetch.signal'
};
//# sourceMappingURL=option-defaults.js.map

/***/ }),

/***/ "../../node_modules/@loaders.gl/core/dist/lib/loader-utils/option-utils.js":
/*!*********************************************************************************!*\
  !*** ../../node_modules/@loaders.gl/core/dist/lib/loader-utils/option-utils.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   getGlobalLoaderOptions: () => (/* binding */ getGlobalLoaderOptions),
/* harmony export */   getGlobalLoaderState: () => (/* binding */ getGlobalLoaderState),
/* harmony export */   normalizeOptions: () => (/* binding */ normalizeOptions),
/* harmony export */   setGlobalOptions: () => (/* binding */ setGlobalOptions)
/* harmony export */ });
/* harmony import */ var _javascript_utils_is_type_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../javascript-utils/is-type.js */ "../../node_modules/@loaders.gl/core/dist/javascript-utils/is-type.js");
/* harmony import */ var _loggers_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./loggers.js */ "../../node_modules/@loaders.gl/core/dist/lib/loader-utils/loggers.js");
/* harmony import */ var _option_defaults_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./option-defaults.js */ "../../node_modules/@loaders.gl/core/dist/lib/loader-utils/option-defaults.js");



function getGlobalLoaderState() {
  globalThis.loaders = globalThis.loaders || {};
  const {
    loaders
  } = globalThis;
  loaders._state = loaders._state || {};
  return loaders._state;
}
function getGlobalLoaderOptions() {
  const state = getGlobalLoaderState();
  state.globalOptions = state.globalOptions || {
    ..._option_defaults_js__WEBPACK_IMPORTED_MODULE_0__.DEFAULT_LOADER_OPTIONS
  };
  return state.globalOptions;
}
function setGlobalOptions(options) {
  const state = getGlobalLoaderState();
  const globalOptions = getGlobalLoaderOptions();
  state.globalOptions = normalizeOptionsInternal(globalOptions, options);
}
function normalizeOptions(options, loader, loaders, url) {
  loaders = loaders || [];
  loaders = Array.isArray(loaders) ? loaders : [loaders];
  validateOptions(options, loaders);
  return normalizeOptionsInternal(loader, options, url);
}
function validateOptions(options, loaders) {
  validateOptionsObject(options, null, _option_defaults_js__WEBPACK_IMPORTED_MODULE_0__.DEFAULT_LOADER_OPTIONS, _option_defaults_js__WEBPACK_IMPORTED_MODULE_0__.REMOVED_LOADER_OPTIONS, loaders);
  for (const loader of loaders) {
    const idOptions = options && options[loader.id] || {};
    const loaderOptions = loader.options && loader.options[loader.id] || {};
    const deprecatedOptions = loader.deprecatedOptions && loader.deprecatedOptions[loader.id] || {};
    validateOptionsObject(idOptions, loader.id, loaderOptions, deprecatedOptions, loaders);
  }
}
function validateOptionsObject(options, id, defaultOptions, deprecatedOptions, loaders) {
  const loaderName = id || 'Top level';
  const prefix = id ? `${id}.` : '';
  for (const key in options) {
    const isSubOptions = !id && (0,_javascript_utils_is_type_js__WEBPACK_IMPORTED_MODULE_1__.isObject)(options[key]);
    const isBaseUriOption = key === 'baseUri' && !id;
    const isWorkerUrlOption = key === 'workerUrl' && id;
    if (!(key in defaultOptions) && !isBaseUriOption && !isWorkerUrlOption) {
      if (key in deprecatedOptions) {
        _loggers_js__WEBPACK_IMPORTED_MODULE_2__.probeLog.warn(`${loaderName} loader option \'${prefix}${key}\' no longer supported, use \'${deprecatedOptions[key]}\'`)();
      } else if (!isSubOptions) {
        const suggestion = findSimilarOption(key, loaders);
        _loggers_js__WEBPACK_IMPORTED_MODULE_2__.probeLog.warn(`${loaderName} loader option \'${prefix}${key}\' not recognized. ${suggestion}`)();
      }
    }
  }
}
function findSimilarOption(optionKey, loaders) {
  const lowerCaseOptionKey = optionKey.toLowerCase();
  let bestSuggestion = '';
  for (const loader of loaders) {
    for (const key in loader.options) {
      if (optionKey === key) {
        return `Did you mean \'${loader.id}.${key}\'?`;
      }
      const lowerCaseKey = key.toLowerCase();
      const isPartialMatch = lowerCaseOptionKey.startsWith(lowerCaseKey) || lowerCaseKey.startsWith(lowerCaseOptionKey);
      if (isPartialMatch) {
        bestSuggestion = bestSuggestion || `Did you mean \'${loader.id}.${key}\'?`;
      }
    }
  }
  return bestSuggestion;
}
function normalizeOptionsInternal(loader, options, url) {
  const loaderDefaultOptions = loader.options || {};
  const mergedOptions = {
    ...loaderDefaultOptions
  };
  addUrlOptions(mergedOptions, url);
  if (mergedOptions.log === null) {
    mergedOptions.log = new _loggers_js__WEBPACK_IMPORTED_MODULE_2__.NullLog();
  }
  mergeNestedFields(mergedOptions, getGlobalLoaderOptions());
  mergeNestedFields(mergedOptions, options);
  return mergedOptions;
}
function mergeNestedFields(mergedOptions, options) {
  for (const key in options) {
    if (key in options) {
      const value = options[key];
      if ((0,_javascript_utils_is_type_js__WEBPACK_IMPORTED_MODULE_1__.isPureObject)(value) && (0,_javascript_utils_is_type_js__WEBPACK_IMPORTED_MODULE_1__.isPureObject)(mergedOptions[key])) {
        mergedOptions[key] = {
          ...mergedOptions[key],
          ...options[key]
        };
      } else {
        mergedOptions[key] = options[key];
      }
    }
  }
}
function addUrlOptions(options, url) {
  if (url && !('baseUri' in options)) {
    options.baseUri = url;
  }
}
//# sourceMappingURL=option-utils.js.map

/***/ }),

/***/ "../../node_modules/@loaders.gl/core/dist/lib/utils/log.js":
/*!*****************************************************************!*\
  !*** ../../node_modules/@loaders.gl/core/dist/lib/utils/log.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   log: () => (/* binding */ log)
/* harmony export */ });
/* harmony import */ var _probe_gl_log__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @probe.gl/log */ "../../node_modules/@probe.gl/log/dist/log.js");

const log = new _probe_gl_log__WEBPACK_IMPORTED_MODULE_0__.Log({
  id: 'loaders.gl'
});
//# sourceMappingURL=log.js.map

/***/ }),

/***/ "../../node_modules/@loaders.gl/core/dist/lib/utils/mime-type-utils.js":
/*!*****************************************************************************!*\
  !*** ../../node_modules/@loaders.gl/core/dist/lib/utils/mime-type-utils.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   parseMIMEType: () => (/* binding */ parseMIMEType),
/* harmony export */   parseMIMETypeFromURL: () => (/* binding */ parseMIMETypeFromURL)
/* harmony export */ });
const DATA_URL_PATTERN = /^data:([-\w.]+\/[-\w.+]+)(;|,)/;
const MIME_TYPE_PATTERN = /^([-\w.]+\/[-\w.+]+)/;
function parseMIMEType(mimeString) {
  const matches = MIME_TYPE_PATTERN.exec(mimeString);
  if (matches) {
    return matches[1];
  }
  return mimeString;
}
function parseMIMETypeFromURL(url) {
  const matches = DATA_URL_PATTERN.exec(url);
  if (matches) {
    return matches[1];
  }
  return '';
}
//# sourceMappingURL=mime-type-utils.js.map

/***/ }),

/***/ "../../node_modules/@loaders.gl/core/dist/lib/utils/resource-utils.js":
/*!****************************************************************************!*\
  !*** ../../node_modules/@loaders.gl/core/dist/lib/utils/resource-utils.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   getResourceContentLength: () => (/* binding */ getResourceContentLength),
/* harmony export */   getResourceMIMEType: () => (/* binding */ getResourceMIMEType),
/* harmony export */   getResourceUrl: () => (/* binding */ getResourceUrl)
/* harmony export */ });
/* harmony import */ var _javascript_utils_is_type_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../javascript-utils/is-type.js */ "../../node_modules/@loaders.gl/core/dist/javascript-utils/is-type.js");
/* harmony import */ var _mime_type_utils_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./mime-type-utils.js */ "../../node_modules/@loaders.gl/core/dist/lib/utils/mime-type-utils.js");
/* harmony import */ var _url_utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./url-utils.js */ "../../node_modules/@loaders.gl/core/dist/lib/utils/url-utils.js");



function getResourceUrl(resource) {
  if ((0,_javascript_utils_is_type_js__WEBPACK_IMPORTED_MODULE_0__.isResponse)(resource)) {
    const response = resource;
    return response.url;
  }
  if ((0,_javascript_utils_is_type_js__WEBPACK_IMPORTED_MODULE_0__.isBlob)(resource)) {
    const blob = resource;
    return blob.name || '';
  }
  if (typeof resource === 'string') {
    return resource;
  }
  return '';
}
function getResourceMIMEType(resource) {
  if ((0,_javascript_utils_is_type_js__WEBPACK_IMPORTED_MODULE_0__.isResponse)(resource)) {
    const response = resource;
    const contentTypeHeader = response.headers.get('content-type') || '';
    const noQueryUrl = (0,_url_utils_js__WEBPACK_IMPORTED_MODULE_1__.stripQueryString)(response.url);
    return (0,_mime_type_utils_js__WEBPACK_IMPORTED_MODULE_2__.parseMIMEType)(contentTypeHeader) || (0,_mime_type_utils_js__WEBPACK_IMPORTED_MODULE_2__.parseMIMETypeFromURL)(noQueryUrl);
  }
  if ((0,_javascript_utils_is_type_js__WEBPACK_IMPORTED_MODULE_0__.isBlob)(resource)) {
    const blob = resource;
    return blob.type || '';
  }
  if (typeof resource === 'string') {
    return (0,_mime_type_utils_js__WEBPACK_IMPORTED_MODULE_2__.parseMIMETypeFromURL)(resource);
  }
  return '';
}
function getResourceContentLength(resource) {
  if ((0,_javascript_utils_is_type_js__WEBPACK_IMPORTED_MODULE_0__.isResponse)(resource)) {
    const response = resource;
    return response.headers['content-length'] || -1;
  }
  if ((0,_javascript_utils_is_type_js__WEBPACK_IMPORTED_MODULE_0__.isBlob)(resource)) {
    const blob = resource;
    return blob.size;
  }
  if (typeof resource === 'string') {
    return resource.length;
  }
  if (resource instanceof ArrayBuffer) {
    return resource.byteLength;
  }
  if (ArrayBuffer.isView(resource)) {
    return resource.byteLength;
  }
  return -1;
}
//# sourceMappingURL=resource-utils.js.map

/***/ }),

/***/ "../../node_modules/@loaders.gl/core/dist/lib/utils/response-utils.js":
/*!****************************************************************************!*\
  !*** ../../node_modules/@loaders.gl/core/dist/lib/utils/response-utils.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   checkResponse: () => (/* binding */ checkResponse),
/* harmony export */   checkResponseSync: () => (/* binding */ checkResponseSync),
/* harmony export */   makeResponse: () => (/* binding */ makeResponse)
/* harmony export */ });
/* harmony import */ var _javascript_utils_is_type_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../javascript-utils/is-type.js */ "../../node_modules/@loaders.gl/core/dist/javascript-utils/is-type.js");
/* harmony import */ var _resource_utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./resource-utils.js */ "../../node_modules/@loaders.gl/core/dist/lib/utils/resource-utils.js");


async function makeResponse(resource) {
  if ((0,_javascript_utils_is_type_js__WEBPACK_IMPORTED_MODULE_0__.isResponse)(resource)) {
    return resource;
  }
  const headers = {};
  const contentLength = (0,_resource_utils_js__WEBPACK_IMPORTED_MODULE_1__.getResourceContentLength)(resource);
  if (contentLength >= 0) {
    headers['content-length'] = String(contentLength);
  }
  const url = (0,_resource_utils_js__WEBPACK_IMPORTED_MODULE_1__.getResourceUrl)(resource);
  const type = (0,_resource_utils_js__WEBPACK_IMPORTED_MODULE_1__.getResourceMIMEType)(resource);
  if (type) {
    headers['content-type'] = type;
  }
  const initialDataUrl = await getInitialDataUrl(resource);
  if (initialDataUrl) {
    headers['x-first-bytes'] = initialDataUrl;
  }
  if (typeof resource === 'string') {
    resource = new TextEncoder().encode(resource);
  }
  const response = new Response(resource, {
    headers
  });
  Object.defineProperty(response, 'url', {
    value: url
  });
  return response;
}
async function checkResponse(response) {
  if (!response.ok) {
    const message = await getResponseError(response);
    throw new Error(message);
  }
}
function checkResponseSync(response) {
  if (!response.ok) {
    let message = `${response.status} ${response.statusText}`;
    message = message.length > 60 ? `${message.slice(0, 60)}...` : message;
    throw new Error(message);
  }
}
async function getResponseError(response) {
  let message = `Failed to fetch resource ${response.url} (${response.status}): `;
  try {
    const contentType = response.headers.get('Content-Type');
    let text = response.statusText;
    if (contentType !== null && contentType !== void 0 && contentType.includes('application/json')) {
      text += ` ${await response.text()}`;
    }
    message += text;
    message = message.length > 60 ? `${message.slice(0, 60)}...` : message;
  } catch (error) {}
  return message;
}
async function getInitialDataUrl(resource) {
  const INITIAL_DATA_LENGTH = 5;
  if (typeof resource === 'string') {
    return `data:,${resource.slice(0, INITIAL_DATA_LENGTH)}`;
  }
  if (resource instanceof Blob) {
    const blobSlice = resource.slice(0, 5);
    return await new Promise(resolve => {
      const reader = new FileReader();
      reader.onload = event => {
        var _event$target;
        return resolve(event === null || event === void 0 ? void 0 : (_event$target = event.target) === null || _event$target === void 0 ? void 0 : _event$target.result);
      };
      reader.readAsDataURL(blobSlice);
    });
  }
  if (resource instanceof ArrayBuffer) {
    const slice = resource.slice(0, INITIAL_DATA_LENGTH);
    const base64 = arrayBufferToBase64(slice);
    return `data:base64,${base64}`;
  }
  return null;
}
function arrayBufferToBase64(buffer) {
  let binary = '';
  const bytes = new Uint8Array(buffer);
  for (let i = 0; i < bytes.byteLength; i++) {
    binary += String.fromCharCode(bytes[i]);
  }
  return btoa(binary);
}
//# sourceMappingURL=response-utils.js.map

/***/ }),

/***/ "../../node_modules/@loaders.gl/core/dist/lib/utils/url-utils.js":
/*!***********************************************************************!*\
  !*** ../../node_modules/@loaders.gl/core/dist/lib/utils/url-utils.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   extractQueryString: () => (/* binding */ extractQueryString),
/* harmony export */   stripQueryString: () => (/* binding */ stripQueryString)
/* harmony export */ });
const QUERY_STRING_PATTERN = /\?.*/;
function extractQueryString(url) {
  const matches = url.match(QUERY_STRING_PATTERN);
  return matches && matches[0];
}
function stripQueryString(url) {
  return url.replace(QUERY_STRING_PATTERN, '');
}
//# sourceMappingURL=url-utils.js.map

/***/ }),

/***/ "../../node_modules/@loaders.gl/gltf/dist/glb-loader.js":
/*!**************************************************************!*\
  !*** ../../node_modules/@loaders.gl/gltf/dist/glb-loader.js ***!
  \**************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   GLBLoader: () => (/* binding */ GLBLoader)
/* harmony export */ });
/* harmony import */ var _lib_utils_version_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./lib/utils/version.js */ "../../node_modules/@loaders.gl/gltf/dist/lib/utils/version.js");
/* harmony import */ var _lib_parsers_parse_glb_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./lib/parsers/parse-glb.js */ "../../node_modules/@loaders.gl/gltf/dist/lib/parsers/parse-glb.js");


const GLBLoader = {
  name: 'GLB',
  id: 'glb',
  module: 'gltf',
  version: _lib_utils_version_js__WEBPACK_IMPORTED_MODULE_0__.VERSION,
  extensions: ['glb'],
  mimeTypes: ['model/gltf-binary'],
  binary: true,
  parse,
  parseSync,
  options: {
    glb: {
      strict: false
    }
  }
};
async function parse(arrayBuffer, options) {
  return parseSync(arrayBuffer, options);
}
function parseSync(arrayBuffer, options) {
  const {
    byteOffset = 0
  } = options || {};
  const glb = {};
  (0,_lib_parsers_parse_glb_js__WEBPACK_IMPORTED_MODULE_1__.parseGLBSync)(glb, arrayBuffer, byteOffset, options === null || options === void 0 ? void 0 : options.glb);
  return glb;
}
//# sourceMappingURL=glb-loader.js.map

/***/ }),

/***/ "../../node_modules/@loaders.gl/gltf/dist/lib/parsers/parse-glb.js":
/*!*************************************************************************!*\
  !*** ../../node_modules/@loaders.gl/gltf/dist/lib/parsers/parse-glb.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   isGLB: () => (/* binding */ isGLB),
/* harmony export */   parseGLBSync: () => (/* binding */ parseGLBSync)
/* harmony export */ });
/* harmony import */ var _loaders_gl_loader_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @loaders.gl/loader-utils */ "../../node_modules/@loaders.gl/loader-utils/dist/lib/env-utils/assert.js");
/* harmony import */ var _loaders_gl_loader_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @loaders.gl/loader-utils */ "../../node_modules/@loaders.gl/loader-utils/dist/lib/binary-utils/memory-copy-utils.js");

const LITTLE_ENDIAN = true;
const MAGIC_glTF = 0x676c5446;
const GLB_FILE_HEADER_SIZE = 12;
const GLB_CHUNK_HEADER_SIZE = 8;
const GLB_CHUNK_TYPE_JSON = 0x4e4f534a;
const GLB_CHUNK_TYPE_BIN = 0x004e4942;
const GLB_V1_CONTENT_FORMAT_JSON = 0x0;
const GLB_CHUNK_TYPE_JSON_XVIZ_DEPRECATED = 0;
const GLB_CHUNK_TYPE_BIX_XVIZ_DEPRECATED = 1;
function getMagicString(dataView) {
  let byteOffset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
  return `\
${String.fromCharCode(dataView.getUint8(byteOffset + 0))}\
${String.fromCharCode(dataView.getUint8(byteOffset + 1))}\
${String.fromCharCode(dataView.getUint8(byteOffset + 2))}\
${String.fromCharCode(dataView.getUint8(byteOffset + 3))}`;
}
function isGLB(arrayBuffer) {
  let byteOffset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
  let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  const dataView = new DataView(arrayBuffer);
  const {
    magic = MAGIC_glTF
  } = options;
  const magic1 = dataView.getUint32(byteOffset, false);
  return magic1 === magic || magic1 === MAGIC_glTF;
}
function parseGLBSync(glb, arrayBuffer) {
  let byteOffset = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
  let options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
  const dataView = new DataView(arrayBuffer);
  const type = getMagicString(dataView, byteOffset + 0);
  const version = dataView.getUint32(byteOffset + 4, LITTLE_ENDIAN);
  const byteLength = dataView.getUint32(byteOffset + 8, LITTLE_ENDIAN);
  Object.assign(glb, {
    header: {
      byteOffset,
      byteLength,
      hasBinChunk: false
    },
    type,
    version,
    json: {},
    binChunks: []
  });
  byteOffset += GLB_FILE_HEADER_SIZE;
  switch (glb.version) {
    case 1:
      return parseGLBV1(glb, dataView, byteOffset);
    case 2:
      return parseGLBV2(glb, dataView, byteOffset, options = {});
    default:
      throw new Error(`Invalid GLB version ${glb.version}. Only supports version 1 and 2.`);
  }
}
function parseGLBV1(glb, dataView, byteOffset) {
  (0,_loaders_gl_loader_utils__WEBPACK_IMPORTED_MODULE_0__.assert)(glb.header.byteLength > GLB_FILE_HEADER_SIZE + GLB_CHUNK_HEADER_SIZE);
  const contentLength = dataView.getUint32(byteOffset + 0, LITTLE_ENDIAN);
  const contentFormat = dataView.getUint32(byteOffset + 4, LITTLE_ENDIAN);
  byteOffset += GLB_CHUNK_HEADER_SIZE;
  (0,_loaders_gl_loader_utils__WEBPACK_IMPORTED_MODULE_0__.assert)(contentFormat === GLB_V1_CONTENT_FORMAT_JSON);
  parseJSONChunk(glb, dataView, byteOffset, contentLength);
  byteOffset += contentLength;
  byteOffset += parseBINChunk(glb, dataView, byteOffset, glb.header.byteLength);
  return byteOffset;
}
function parseGLBV2(glb, dataView, byteOffset, options) {
  (0,_loaders_gl_loader_utils__WEBPACK_IMPORTED_MODULE_0__.assert)(glb.header.byteLength > GLB_FILE_HEADER_SIZE + GLB_CHUNK_HEADER_SIZE);
  parseGLBChunksSync(glb, dataView, byteOffset, options);
  return byteOffset + glb.header.byteLength;
}
function parseGLBChunksSync(glb, dataView, byteOffset, options) {
  while (byteOffset + 8 <= glb.header.byteLength) {
    const chunkLength = dataView.getUint32(byteOffset + 0, LITTLE_ENDIAN);
    const chunkFormat = dataView.getUint32(byteOffset + 4, LITTLE_ENDIAN);
    byteOffset += GLB_CHUNK_HEADER_SIZE;
    switch (chunkFormat) {
      case GLB_CHUNK_TYPE_JSON:
        parseJSONChunk(glb, dataView, byteOffset, chunkLength);
        break;
      case GLB_CHUNK_TYPE_BIN:
        parseBINChunk(glb, dataView, byteOffset, chunkLength);
        break;
      case GLB_CHUNK_TYPE_JSON_XVIZ_DEPRECATED:
        if (!options.strict) {
          parseJSONChunk(glb, dataView, byteOffset, chunkLength);
        }
        break;
      case GLB_CHUNK_TYPE_BIX_XVIZ_DEPRECATED:
        if (!options.strict) {
          parseBINChunk(glb, dataView, byteOffset, chunkLength);
        }
        break;
      default:
        break;
    }
    byteOffset += (0,_loaders_gl_loader_utils__WEBPACK_IMPORTED_MODULE_1__.padToNBytes)(chunkLength, 4);
  }
  return byteOffset;
}
function parseJSONChunk(glb, dataView, byteOffset, chunkLength) {
  const jsonChunk = new Uint8Array(dataView.buffer, byteOffset, chunkLength);
  const textDecoder = new TextDecoder('utf8');
  const jsonText = textDecoder.decode(jsonChunk);
  glb.json = JSON.parse(jsonText);
  return (0,_loaders_gl_loader_utils__WEBPACK_IMPORTED_MODULE_1__.padToNBytes)(chunkLength, 4);
}
function parseBINChunk(glb, dataView, byteOffset, chunkLength) {
  glb.header.hasBinChunk = true;
  glb.binChunks.push({
    byteOffset,
    byteLength: chunkLength,
    arrayBuffer: dataView.buffer
  });
  return (0,_loaders_gl_loader_utils__WEBPACK_IMPORTED_MODULE_1__.padToNBytes)(chunkLength, 4);
}
//# sourceMappingURL=parse-glb.js.map

/***/ }),

/***/ "../../node_modules/@loaders.gl/gltf/dist/lib/utils/version.js":
/*!*********************************************************************!*\
  !*** ../../node_modules/@loaders.gl/gltf/dist/lib/utils/version.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   VERSION: () => (/* binding */ VERSION)
/* harmony export */ });
const VERSION =  true ? "4.1.3" : 0;
//# sourceMappingURL=version.js.map

/***/ }),

/***/ "../../node_modules/@loaders.gl/loader-utils/dist/lib/binary-utils/array-buffer-utils.js":
/*!***********************************************************************************************!*\
  !*** ../../node_modules/@loaders.gl/loader-utils/dist/lib/binary-utils/array-buffer-utils.js ***!
  \***********************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   compareArrayBuffers: () => (/* binding */ compareArrayBuffers),
/* harmony export */   concatenateArrayBuffers: () => (/* binding */ concatenateArrayBuffers),
/* harmony export */   concatenateArrayBuffersFromArray: () => (/* binding */ concatenateArrayBuffersFromArray),
/* harmony export */   concatenateTypedArrays: () => (/* binding */ concatenateTypedArrays),
/* harmony export */   sliceArrayBuffer: () => (/* binding */ sliceArrayBuffer)
/* harmony export */ });
function compareArrayBuffers(arrayBuffer1, arrayBuffer2, byteLength) {
  byteLength = byteLength || arrayBuffer1.byteLength;
  if (arrayBuffer1.byteLength < byteLength || arrayBuffer2.byteLength < byteLength) {
    return false;
  }
  const array1 = new Uint8Array(arrayBuffer1);
  const array2 = new Uint8Array(arrayBuffer2);
  for (let i = 0; i < array1.length; ++i) {
    if (array1[i] !== array2[i]) {
      return false;
    }
  }
  return true;
}
function concatenateArrayBuffers() {
  for (var _len = arguments.length, sources = new Array(_len), _key = 0; _key < _len; _key++) {
    sources[_key] = arguments[_key];
  }
  return concatenateArrayBuffersFromArray(sources);
}
function concatenateArrayBuffersFromArray(sources) {
  const sourceArrays = sources.map(source2 => source2 instanceof ArrayBuffer ? new Uint8Array(source2) : source2);
  const byteLength = sourceArrays.reduce((length, typedArray) => length + typedArray.byteLength, 0);
  const result = new Uint8Array(byteLength);
  let offset = 0;
  for (const sourceArray of sourceArrays) {
    result.set(sourceArray, offset);
    offset += sourceArray.byteLength;
  }
  return result.buffer;
}
function concatenateTypedArrays() {
  for (var _len2 = arguments.length, typedArrays = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
    typedArrays[_key2] = arguments[_key2];
  }
  const arrays = typedArrays;
  const TypedArrayConstructor = arrays && arrays.length > 1 && arrays[0].constructor || null;
  if (!TypedArrayConstructor) {
    throw new Error('"concatenateTypedArrays" - incorrect quantity of arguments or arguments have incompatible data types');
  }
  const sumLength = arrays.reduce((acc, value) => acc + value.length, 0);
  const result = new TypedArrayConstructor(sumLength);
  let offset = 0;
  for (const array of arrays) {
    result.set(array, offset);
    offset += array.length;
  }
  return result;
}
function sliceArrayBuffer(arrayBuffer, byteOffset, byteLength) {
  const subArray = byteLength !== undefined ? new Uint8Array(arrayBuffer).subarray(byteOffset, byteOffset + byteLength) : new Uint8Array(arrayBuffer).subarray(byteOffset);
  const arrayCopy = new Uint8Array(subArray);
  return arrayCopy.buffer;
}
//# sourceMappingURL=array-buffer-utils.js.map

/***/ }),

/***/ "../../node_modules/@loaders.gl/loader-utils/dist/lib/binary-utils/memory-conversion-utils.js":
/*!****************************************************************************************************!*\
  !*** ../../node_modules/@loaders.gl/loader-utils/dist/lib/binary-utils/memory-conversion-utils.js ***!
  \****************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   isBuffer: () => (/* binding */ isBuffer),
/* harmony export */   toArrayBuffer: () => (/* binding */ toArrayBuffer),
/* harmony export */   toBuffer: () => (/* binding */ toBuffer)
/* harmony export */ });
/* harmony import */ var _node_buffer_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../node/buffer.js */ "../../node_modules/@loaders.gl/loader-utils/dist/lib/node/buffer.browser.js");

function isBuffer(value) {
  return value && typeof value === 'object' && value.isBuffer;
}
function toBuffer(data) {
  return _node_buffer_js__WEBPACK_IMPORTED_MODULE_0__.toBuffer ? _node_buffer_js__WEBPACK_IMPORTED_MODULE_0__.toBuffer(data) : data;
}
function toArrayBuffer(data) {
  if (isBuffer(data)) {
    return _node_buffer_js__WEBPACK_IMPORTED_MODULE_0__.toArrayBuffer(data);
  }
  if (data instanceof ArrayBuffer) {
    return data;
  }
  if (ArrayBuffer.isView(data)) {
    if (data.byteOffset === 0 && data.byteLength === data.buffer.byteLength) {
      return data.buffer;
    }
    return data.buffer.slice(data.byteOffset, data.byteOffset + data.byteLength);
  }
  if (typeof data === 'string') {
    const text = data;
    const uint8Array = new TextEncoder().encode(text);
    return uint8Array.buffer;
  }
  if (data && typeof data === 'object' && data._toArrayBuffer) {
    return data._toArrayBuffer();
  }
  throw new Error('toArrayBuffer');
}
//# sourceMappingURL=memory-conversion-utils.js.map

/***/ }),

/***/ "../../node_modules/@loaders.gl/loader-utils/dist/lib/binary-utils/memory-copy-utils.js":
/*!**********************************************************************************************!*\
  !*** ../../node_modules/@loaders.gl/loader-utils/dist/lib/binary-utils/memory-copy-utils.js ***!
  \**********************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   copyArrayBuffer: () => (/* binding */ copyArrayBuffer),
/* harmony export */   copyToArray: () => (/* binding */ copyToArray),
/* harmony export */   padToNBytes: () => (/* binding */ padToNBytes)
/* harmony export */ });
/* harmony import */ var _env_utils_assert_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../env-utils/assert.js */ "../../node_modules/@loaders.gl/loader-utils/dist/lib/env-utils/assert.js");

function padToNBytes(byteLength, padding) {
  (0,_env_utils_assert_js__WEBPACK_IMPORTED_MODULE_0__.assert)(byteLength >= 0);
  (0,_env_utils_assert_js__WEBPACK_IMPORTED_MODULE_0__.assert)(padding > 0);
  return byteLength + (padding - 1) & ~(padding - 1);
}
function copyArrayBuffer(targetBuffer, sourceBuffer, byteOffset) {
  let byteLength = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : sourceBuffer.byteLength;
  const targetArray = new Uint8Array(targetBuffer, byteOffset, byteLength);
  const sourceArray = new Uint8Array(sourceBuffer);
  targetArray.set(sourceArray);
  return targetBuffer;
}
function copyToArray(source, target, targetOffset) {
  let sourceArray;
  if (source instanceof ArrayBuffer) {
    sourceArray = new Uint8Array(source);
  } else {
    const srcByteOffset = source.byteOffset;
    const srcByteLength = source.byteLength;
    sourceArray = new Uint8Array(source.buffer || source.arrayBuffer, srcByteOffset, srcByteLength);
  }
  target.set(sourceArray, targetOffset);
  return targetOffset + padToNBytes(sourceArray.byteLength, 4);
}
//# sourceMappingURL=memory-copy-utils.js.map

/***/ }),

/***/ "../../node_modules/@loaders.gl/loader-utils/dist/lib/env-utils/assert.js":
/*!********************************************************************************!*\
  !*** ../../node_modules/@loaders.gl/loader-utils/dist/lib/env-utils/assert.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   assert: () => (/* binding */ assert)
/* harmony export */ });
function assert(condition, message) {
  if (!condition) {
    throw new Error(message || 'loader assertion failed.');
  }
}
//# sourceMappingURL=assert.js.map

/***/ }),

/***/ "../../node_modules/@loaders.gl/loader-utils/dist/lib/env-utils/globals.js":
/*!*********************************************************************************!*\
  !*** ../../node_modules/@loaders.gl/loader-utils/dist/lib/env-utils/globals.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   document: () => (/* binding */ document_),
/* harmony export */   global: () => (/* binding */ global_),
/* harmony export */   isBrowser: () => (/* binding */ isBrowser),
/* harmony export */   isWorker: () => (/* binding */ isWorker),
/* harmony export */   nodeVersion: () => (/* binding */ nodeVersion),
/* harmony export */   self: () => (/* binding */ self_),
/* harmony export */   window: () => (/* binding */ window_)
/* harmony export */ });
const globals = {
  self: typeof self !== 'undefined' && self,
  window: typeof window !== 'undefined' && window,
  global: typeof global !== 'undefined' && global,
  document: typeof document !== 'undefined' && document
};
const self_ = globals.self || globals.window || globals.global || {};
const window_ = globals.window || globals.self || globals.global || {};
const global_ = globals.global || globals.self || globals.window || {};
const document_ = globals.document || {};

const isBrowser = Boolean(typeof process !== 'object' || String(process) !== '[object process]' || process.browser);
const isWorker = typeof importScripts === 'function';
const matches = typeof process !== 'undefined' && process.version && /v([0-9]*)/.exec(process.version);
const nodeVersion = matches && parseFloat(matches[1]) || 0;
//# sourceMappingURL=globals.js.map

/***/ }),

/***/ "../../node_modules/@loaders.gl/loader-utils/dist/lib/iterators/async-iteration.js":
/*!*****************************************************************************************!*\
  !*** ../../node_modules/@loaders.gl/loader-utils/dist/lib/iterators/async-iteration.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   concatenateArrayBuffersAsync: () => (/* binding */ concatenateArrayBuffersAsync),
/* harmony export */   concatenateStringsAsync: () => (/* binding */ concatenateStringsAsync),
/* harmony export */   forEach: () => (/* binding */ forEach)
/* harmony export */ });
/* harmony import */ var _binary_utils_array_buffer_utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../binary-utils/array-buffer-utils.js */ "../../node_modules/@loaders.gl/loader-utils/dist/lib/binary-utils/array-buffer-utils.js");

async function forEach(iterator, visitor) {
  while (true) {
    const {
      done,
      value
    } = await iterator.next();
    if (done) {
      iterator.return();
      return;
    }
    const cancel = visitor(value);
    if (cancel) {
      return;
    }
  }
}
async function concatenateArrayBuffersAsync(asyncIterator) {
  const arrayBuffers = [];
  for await (const chunk of asyncIterator) {
    arrayBuffers.push(chunk);
  }
  return (0,_binary_utils_array_buffer_utils_js__WEBPACK_IMPORTED_MODULE_0__.concatenateArrayBuffers)(...arrayBuffers);
}
async function concatenateStringsAsync(asyncIterator) {
  const strings = [];
  for await (const chunk of asyncIterator) {
    strings.push(chunk);
  }
  return strings.join('');
}
//# sourceMappingURL=async-iteration.js.map

/***/ }),

/***/ "../../node_modules/@loaders.gl/loader-utils/dist/lib/node/buffer.browser.js":
/*!***********************************************************************************!*\
  !*** ../../node_modules/@loaders.gl/loader-utils/dist/lib/node/buffer.browser.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   toArrayBuffer: () => (/* binding */ toArrayBuffer),
/* harmony export */   toBuffer: () => (/* binding */ toBuffer)
/* harmony export */ });
function toArrayBuffer(buffer) {
  return buffer;
}
function toBuffer(binaryData) {
  throw new Error('Buffer not supported in browser');
}
//# sourceMappingURL=buffer.browser.js.map

/***/ }),

/***/ "../../node_modules/@loaders.gl/loader-utils/dist/lib/option-utils/merge-loader-options.js":
/*!*************************************************************************************************!*\
  !*** ../../node_modules/@loaders.gl/loader-utils/dist/lib/option-utils/merge-loader-options.js ***!
  \*************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   mergeLoaderOptions: () => (/* binding */ mergeLoaderOptions)
/* harmony export */ });
function mergeLoaderOptions(baseOptions, newOptions) {
  return mergeOptionsRecursively(baseOptions || {}, newOptions);
}
function mergeOptionsRecursively(baseOptions, newOptions) {
  let level = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
  if (level > 3) {
    return newOptions;
  }
  const options = {
    ...baseOptions
  };
  for (const [key, newValue] of Object.entries(newOptions)) {
    if (newValue && typeof newValue === 'object' && !Array.isArray(newValue)) {
      options[key] = mergeOptionsRecursively(options[key] || {}, newOptions[key], level + 1);
    } else {
      options[key] = newOptions[key];
    }
  }
  return options;
}
//# sourceMappingURL=merge-loader-options.js.map

/***/ }),

/***/ "../../node_modules/@loaders.gl/loader-utils/dist/lib/path-utils/file-aliases.js":
/*!***************************************************************************************!*\
  !*** ../../node_modules/@loaders.gl/loader-utils/dist/lib/path-utils/file-aliases.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   addAliases: () => (/* binding */ addAliases),
/* harmony export */   getPathPrefix: () => (/* binding */ getPathPrefix),
/* harmony export */   resolvePath: () => (/* binding */ resolvePath),
/* harmony export */   setPathPrefix: () => (/* binding */ setPathPrefix)
/* harmony export */ });
let pathPrefix = '';
const fileAliases = {};
function setPathPrefix(prefix) {
  pathPrefix = prefix;
}
function getPathPrefix() {
  return pathPrefix;
}
function addAliases(aliases) {
  Object.assign(fileAliases, aliases);
}
function resolvePath(filename) {
  for (const alias in fileAliases) {
    if (filename.startsWith(alias)) {
      const replacement = fileAliases[alias];
      filename = filename.replace(alias, replacement);
    }
  }
  if (!filename.startsWith('http://') && !filename.startsWith('https://')) {
    filename = `${pathPrefix}${filename}`;
  }
  return filename;
}
//# sourceMappingURL=file-aliases.js.map

/***/ }),

/***/ "../../node_modules/@loaders.gl/loader-utils/dist/lib/path-utils/get-cwd.js":
/*!**********************************************************************************!*\
  !*** ../../node_modules/@loaders.gl/loader-utils/dist/lib/path-utils/get-cwd.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   getCWD: () => (/* binding */ getCWD)
/* harmony export */ });
function getCWD() {
  var _window$location;
  if (typeof process !== 'undefined' && typeof process.cwd !== 'undefined') {
    return process.cwd();
  }
  const pathname = (_window$location = window.location) === null || _window$location === void 0 ? void 0 : _window$location.pathname;
  return (pathname === null || pathname === void 0 ? void 0 : pathname.slice(0, pathname.lastIndexOf('/') + 1)) || '';
}
//# sourceMappingURL=get-cwd.js.map

/***/ }),

/***/ "../../node_modules/@loaders.gl/loader-utils/dist/lib/path-utils/path.js":
/*!*******************************************************************************!*\
  !*** ../../node_modules/@loaders.gl/loader-utils/dist/lib/path-utils/path.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   dirname: () => (/* binding */ dirname),
/* harmony export */   filename: () => (/* binding */ filename),
/* harmony export */   join: () => (/* binding */ join),
/* harmony export */   resolve: () => (/* binding */ resolve)
/* harmony export */ });
/* harmony import */ var _get_cwd_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./get-cwd.js */ "../../node_modules/@loaders.gl/loader-utils/dist/lib/path-utils/get-cwd.js");

function filename(url) {
  const slashIndex = url ? url.lastIndexOf('/') : -1;
  return slashIndex >= 0 ? url.substr(slashIndex + 1) : '';
}
function dirname(url) {
  const slashIndex = url ? url.lastIndexOf('/') : -1;
  return slashIndex >= 0 ? url.substr(0, slashIndex) : '';
}
function join() {
  for (var _len = arguments.length, parts = new Array(_len), _key = 0; _key < _len; _key++) {
    parts[_key] = arguments[_key];
  }
  const separator = '/';
  parts = parts.map((part, index) => {
    if (index) {
      part = part.replace(new RegExp(`^${separator}`), '');
    }
    if (index !== parts.length - 1) {
      part = part.replace(new RegExp(`${separator}$`), '');
    }
    return part;
  });
  return parts.join(separator);
}
function resolve() {
  const paths = [];
  for (let _i = 0; _i < arguments.length; _i++) {
    paths[_i] = _i < 0 || arguments.length <= _i ? undefined : arguments[_i];
  }
  let resolvedPath = '';
  let resolvedAbsolute = false;
  let cwd;
  for (let i = paths.length - 1; i >= -1 && !resolvedAbsolute; i--) {
    let path;
    if (i >= 0) {
      path = paths[i];
    } else {
      if (cwd === undefined) {
        cwd = (0,_get_cwd_js__WEBPACK_IMPORTED_MODULE_0__.getCWD)();
      }
      path = cwd;
    }
    if (path.length === 0) {
      continue;
    }
    resolvedPath = `${path}/${resolvedPath}`;
    resolvedAbsolute = path.charCodeAt(0) === SLASH;
  }
  resolvedPath = normalizeStringPosix(resolvedPath, !resolvedAbsolute);
  if (resolvedAbsolute) {
    return `/${resolvedPath}`;
  } else if (resolvedPath.length > 0) {
    return resolvedPath;
  }
  return '.';
}
const SLASH = 47;
const DOT = 46;
function normalizeStringPosix(path, allowAboveRoot) {
  let res = '';
  let lastSlash = -1;
  let dots = 0;
  let code;
  let isAboveRoot = false;
  for (let i = 0; i <= path.length; ++i) {
    if (i < path.length) {
      code = path.charCodeAt(i);
    } else if (code === SLASH) {
      break;
    } else {
      code = SLASH;
    }
    if (code === SLASH) {
      if (lastSlash === i - 1 || dots === 1) {} else if (lastSlash !== i - 1 && dots === 2) {
        if (res.length < 2 || !isAboveRoot || res.charCodeAt(res.length - 1) !== DOT || res.charCodeAt(res.length - 2) !== DOT) {
          if (res.length > 2) {
            const start = res.length - 1;
            let j = start;
            for (; j >= 0; --j) {
              if (res.charCodeAt(j) === SLASH) {
                break;
              }
            }
            if (j !== start) {
              res = j === -1 ? '' : res.slice(0, j);
              lastSlash = i;
              dots = 0;
              isAboveRoot = false;
              continue;
            }
          } else if (res.length === 2 || res.length === 1) {
            res = '';
            lastSlash = i;
            dots = 0;
            isAboveRoot = false;
            continue;
          }
        }
        if (allowAboveRoot) {
          if (res.length > 0) {
            res += '/..';
          } else {
            res = '..';
          }
          isAboveRoot = true;
        }
      } else {
        const slice = path.slice(lastSlash + 1, i);
        if (res.length > 0) {
          res += `/${slice}`;
        } else {
          res = slice;
        }
        isAboveRoot = false;
      }
      lastSlash = i;
      dots = 0;
    } else if (code === DOT && dots !== -1) {
      ++dots;
    } else {
      dots = -1;
    }
  }
  return res;
}
//# sourceMappingURL=path.js.map

/***/ }),

/***/ "../../node_modules/@loaders.gl/loader-utils/dist/lib/worker-loader-utils/parse-with-worker.js":
/*!*****************************************************************************************************!*\
  !*** ../../node_modules/@loaders.gl/loader-utils/dist/lib/worker-loader-utils/parse-with-worker.js ***!
  \*****************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   canParseWithWorker: () => (/* binding */ canParseWithWorker),
/* harmony export */   parseWithWorker: () => (/* binding */ parseWithWorker)
/* harmony export */ });
/* harmony import */ var _loaders_gl_worker_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @loaders.gl/worker-utils */ "../../node_modules/@loaders.gl/worker-utils/dist/lib/env-utils/globals.js");
/* harmony import */ var _loaders_gl_worker_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @loaders.gl/worker-utils */ "../../node_modules/@loaders.gl/worker-utils/dist/lib/worker-farm/worker-farm.js");
/* harmony import */ var _loaders_gl_worker_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @loaders.gl/worker-utils */ "../../node_modules/@loaders.gl/worker-utils/dist/lib/worker-api/get-worker-url.js");


function canParseWithWorker(loader, options) {
  if (!_loaders_gl_worker_utils__WEBPACK_IMPORTED_MODULE_0__["default"].isSupported()) {
    return false;
  }
  if (!_loaders_gl_worker_utils__WEBPACK_IMPORTED_MODULE_1__.isBrowser && !(options !== null && options !== void 0 && options._nodeWorkers)) {
    return false;
  }
  return loader.worker && (options === null || options === void 0 ? void 0 : options.worker);
}
async function parseWithWorker(loader, data, options, context, parseOnMainThread) {
  const name = loader.id;
  const url = (0,_loaders_gl_worker_utils__WEBPACK_IMPORTED_MODULE_2__.getWorkerURL)(loader, options);
  const workerFarm = _loaders_gl_worker_utils__WEBPACK_IMPORTED_MODULE_0__["default"].getWorkerFarm(options);
  const workerPool = workerFarm.getWorkerPool({
    name,
    url
  });
  options = JSON.parse(JSON.stringify(options));
  context = JSON.parse(JSON.stringify(context || {}));
  const job = await workerPool.startJob('process-on-worker', onMessage.bind(null, parseOnMainThread));
  job.postMessage('process', {
    input: data,
    options,
    context
  });
  const result = await job.result;
  return await result.result;
}
async function onMessage(parseOnMainThread, job, type, payload) {
  switch (type) {
    case 'done':
      job.done(payload);
      break;
    case 'error':
      job.error(new Error(payload.error));
      break;
    case 'process':
      const {
        id,
        input,
        options
      } = payload;
      try {
        const result = await parseOnMainThread(input, options);
        job.postMessage('done', {
          id,
          result
        });
      } catch (error) {
        const message = error instanceof Error ? error.message : 'unknown error';
        job.postMessage('error', {
          id,
          error: message
        });
      }
      break;
    default:
      console.warn(`parse-with-worker unknown message ${type}`);
  }
}
//# sourceMappingURL=parse-with-worker.js.map

/***/ }),

/***/ "../../node_modules/@loaders.gl/worker-utils/dist/lib/env-utils/assert.js":
/*!********************************************************************************!*\
  !*** ../../node_modules/@loaders.gl/worker-utils/dist/lib/env-utils/assert.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   assert: () => (/* binding */ assert)
/* harmony export */ });
function assert(condition, message) {
  if (!condition) {
    throw new Error(message || 'loaders.gl assertion failed.');
  }
}
//# sourceMappingURL=assert.js.map

/***/ }),

/***/ "../../node_modules/@loaders.gl/worker-utils/dist/lib/env-utils/globals.js":
/*!*********************************************************************************!*\
  !*** ../../node_modules/@loaders.gl/worker-utils/dist/lib/env-utils/globals.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   document: () => (/* binding */ document_),
/* harmony export */   global: () => (/* binding */ global_),
/* harmony export */   isBrowser: () => (/* binding */ isBrowser),
/* harmony export */   isMobile: () => (/* binding */ isMobile),
/* harmony export */   isWorker: () => (/* binding */ isWorker),
/* harmony export */   nodeVersion: () => (/* binding */ nodeVersion),
/* harmony export */   self: () => (/* binding */ self_),
/* harmony export */   window: () => (/* binding */ window_)
/* harmony export */ });
const globals = {
  self: typeof self !== 'undefined' && self,
  window: typeof window !== 'undefined' && window,
  global: typeof global !== 'undefined' && global,
  document: typeof document !== 'undefined' && document
};
const self_ = globals.self || globals.window || globals.global || {};
const window_ = globals.window || globals.self || globals.global || {};
const global_ = globals.global || globals.self || globals.window || {};
const document_ = globals.document || {};

const isBrowser = typeof process !== 'object' || String(process) !== '[object process]' || process.browser;
const isWorker = typeof importScripts === 'function';
const isMobile = typeof window !== 'undefined' && typeof window.orientation !== 'undefined';
const matches = typeof process !== 'undefined' && process.version && /v([0-9]*)/.exec(process.version);
const nodeVersion = matches && parseFloat(matches[1]) || 0;
//# sourceMappingURL=globals.js.map

/***/ }),

/***/ "../../node_modules/@loaders.gl/worker-utils/dist/lib/env-utils/version.js":
/*!*********************************************************************************!*\
  !*** ../../node_modules/@loaders.gl/worker-utils/dist/lib/env-utils/version.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   NPM_TAG: () => (/* binding */ NPM_TAG),
/* harmony export */   VERSION: () => (/* binding */ VERSION)
/* harmony export */ });
const NPM_TAG = 'latest';
function getVersion() {
  var _globalThis$_loadersg;
  if (!((_globalThis$_loadersg = globalThis._loadersgl_) !== null && _globalThis$_loadersg !== void 0 && _globalThis$_loadersg.version)) {
    globalThis._loadersgl_ = globalThis._loadersgl_ || {};
    if (false) {} else {
      globalThis._loadersgl_.version = "4.1.3";
    }
  }
  return globalThis._loadersgl_.version;
}
const VERSION = getVersion();
//# sourceMappingURL=version.js.map

/***/ }),

/***/ "../../node_modules/@loaders.gl/worker-utils/dist/lib/node/worker_threads-browser.js":
/*!*******************************************************************************************!*\
  !*** ../../node_modules/@loaders.gl/worker-utils/dist/lib/node/worker_threads-browser.js ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   NodeWorker: () => (/* binding */ NodeWorker),
/* harmony export */   parentPort: () => (/* binding */ parentPort)
/* harmony export */ });
class NodeWorker {
  terminate() {}
}
const parentPort = null;
//# sourceMappingURL=worker_threads-browser.js.map

/***/ }),

/***/ "../../node_modules/@loaders.gl/worker-utils/dist/lib/worker-api/get-worker-url.js":
/*!*****************************************************************************************!*\
  !*** ../../node_modules/@loaders.gl/worker-utils/dist/lib/worker-api/get-worker-url.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   getWorkerName: () => (/* binding */ getWorkerName),
/* harmony export */   getWorkerURL: () => (/* binding */ getWorkerURL)
/* harmony export */ });
/* harmony import */ var _env_utils_assert_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../env-utils/assert.js */ "../../node_modules/@loaders.gl/worker-utils/dist/lib/env-utils/assert.js");
/* harmony import */ var _env_utils_globals_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../env-utils/globals.js */ "../../node_modules/@loaders.gl/worker-utils/dist/lib/env-utils/globals.js");
/* harmony import */ var _env_utils_version_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../env-utils/version.js */ "../../node_modules/@loaders.gl/worker-utils/dist/lib/env-utils/version.js");



function getWorkerName(worker) {
  const warning = worker.version !== _env_utils_version_js__WEBPACK_IMPORTED_MODULE_0__.VERSION ? ` (worker-utils@${_env_utils_version_js__WEBPACK_IMPORTED_MODULE_0__.VERSION})` : '';
  return `${worker.name}@${worker.version}${warning}`;
}
function getWorkerURL(worker) {
  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  const workerOptions = options[worker.id] || {};
  const workerFile = _env_utils_globals_js__WEBPACK_IMPORTED_MODULE_1__.isBrowser ? `${worker.id}-worker.js` : `${worker.id}-worker-node.js`;
  let url = workerOptions.workerUrl;
  if (!url && worker.id === 'compression') {
    url = options.workerUrl;
  }
  if (options._workerType === 'test') {
    if (_env_utils_globals_js__WEBPACK_IMPORTED_MODULE_1__.isBrowser) {
      url = `modules/${worker.module}/dist/${workerFile}`;
    } else {
      url = `modules/${worker.module}/src/workers/${worker.id}-worker-node.ts`;
    }
  }
  if (!url) {
    let version = worker.version;
    if (version === 'latest') {
      version = _env_utils_version_js__WEBPACK_IMPORTED_MODULE_0__.NPM_TAG;
    }
    const versionTag = version ? `@${version}` : '';
    url = `https://unpkg.com/@loaders.gl/${worker.module}${versionTag}/dist/${workerFile}`;
  }
  (0,_env_utils_assert_js__WEBPACK_IMPORTED_MODULE_2__.assert)(url);
  return url;
}
//# sourceMappingURL=get-worker-url.js.map

/***/ }),

/***/ "../../node_modules/@loaders.gl/worker-utils/dist/lib/worker-api/validate-worker-version.js":
/*!**************************************************************************************************!*\
  !*** ../../node_modules/@loaders.gl/worker-utils/dist/lib/worker-api/validate-worker-version.js ***!
  \**************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   validateWorkerVersion: () => (/* binding */ validateWorkerVersion)
/* harmony export */ });
/* harmony import */ var _env_utils_assert_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../env-utils/assert.js */ "../../node_modules/@loaders.gl/worker-utils/dist/lib/env-utils/assert.js");
/* harmony import */ var _env_utils_version_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../env-utils/version.js */ "../../node_modules/@loaders.gl/worker-utils/dist/lib/env-utils/version.js");


function validateWorkerVersion(worker) {
  let coreVersion = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _env_utils_version_js__WEBPACK_IMPORTED_MODULE_0__.VERSION;
  (0,_env_utils_assert_js__WEBPACK_IMPORTED_MODULE_1__.assert)(worker, 'no worker provided');
  const workerVersion = worker.version;
  if (!coreVersion || !workerVersion) {
    return false;
  }
  return true;
}
function parseVersion(version) {
  const parts = version.split('.').map(Number);
  return {
    major: parts[0],
    minor: parts[1]
  };
}
//# sourceMappingURL=validate-worker-version.js.map

/***/ }),

/***/ "../../node_modules/@loaders.gl/worker-utils/dist/lib/worker-farm/worker-farm.js":
/*!***************************************************************************************!*\
  !*** ../../node_modules/@loaders.gl/worker-utils/dist/lib/worker-farm/worker-farm.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ WorkerFarm)
/* harmony export */ });
/* harmony import */ var _worker_pool_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./worker-pool.js */ "../../node_modules/@loaders.gl/worker-utils/dist/lib/worker-farm/worker-pool.js");
/* harmony import */ var _worker_thread_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./worker-thread.js */ "../../node_modules/@loaders.gl/worker-utils/dist/lib/worker-farm/worker-thread.js");


const DEFAULT_PROPS = {
  maxConcurrency: 3,
  maxMobileConcurrency: 1,
  reuseWorkers: true,
  onDebug: () => {}
};
class WorkerFarm {
  static isSupported() {
    return _worker_thread_js__WEBPACK_IMPORTED_MODULE_0__["default"].isSupported();
  }
  static getWorkerFarm() {
    let props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    WorkerFarm._workerFarm = WorkerFarm._workerFarm || new WorkerFarm({});
    WorkerFarm._workerFarm.setProps(props);
    return WorkerFarm._workerFarm;
  }
  constructor(props) {
    this.props = void 0;
    this.workerPools = new Map();
    this.props = {
      ...DEFAULT_PROPS
    };
    this.setProps(props);
    this.workerPools = new Map();
  }
  destroy() {
    for (const workerPool of this.workerPools.values()) {
      workerPool.destroy();
    }
    this.workerPools = new Map();
  }
  setProps(props) {
    this.props = {
      ...this.props,
      ...props
    };
    for (const workerPool of this.workerPools.values()) {
      workerPool.setProps(this._getWorkerPoolProps());
    }
  }
  getWorkerPool(options) {
    const {
      name,
      source,
      url
    } = options;
    let workerPool = this.workerPools.get(name);
    if (!workerPool) {
      workerPool = new _worker_pool_js__WEBPACK_IMPORTED_MODULE_1__["default"]({
        name,
        source,
        url
      });
      workerPool.setProps(this._getWorkerPoolProps());
      this.workerPools.set(name, workerPool);
    }
    return workerPool;
  }
  _getWorkerPoolProps() {
    return {
      maxConcurrency: this.props.maxConcurrency,
      maxMobileConcurrency: this.props.maxMobileConcurrency,
      reuseWorkers: this.props.reuseWorkers,
      onDebug: this.props.onDebug
    };
  }
}
WorkerFarm._workerFarm = void 0;
//# sourceMappingURL=worker-farm.js.map

/***/ }),

/***/ "../../node_modules/@loaders.gl/worker-utils/dist/lib/worker-farm/worker-job.js":
/*!**************************************************************************************!*\
  !*** ../../node_modules/@loaders.gl/worker-utils/dist/lib/worker-farm/worker-job.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ WorkerJob)
/* harmony export */ });
/* harmony import */ var _env_utils_assert_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../env-utils/assert.js */ "../../node_modules/@loaders.gl/worker-utils/dist/lib/env-utils/assert.js");

class WorkerJob {
  constructor(jobName, workerThread) {
    this.name = void 0;
    this.workerThread = void 0;
    this.isRunning = true;
    this.result = void 0;
    this._resolve = () => {};
    this._reject = () => {};
    this.name = jobName;
    this.workerThread = workerThread;
    this.result = new Promise((resolve, reject) => {
      this._resolve = resolve;
      this._reject = reject;
    });
  }
  postMessage(type, payload) {
    this.workerThread.postMessage({
      source: 'loaders.gl',
      type,
      payload
    });
  }
  done(value) {
    (0,_env_utils_assert_js__WEBPACK_IMPORTED_MODULE_0__.assert)(this.isRunning);
    this.isRunning = false;
    this._resolve(value);
  }
  error(error) {
    (0,_env_utils_assert_js__WEBPACK_IMPORTED_MODULE_0__.assert)(this.isRunning);
    this.isRunning = false;
    this._reject(error);
  }
}
//# sourceMappingURL=worker-job.js.map

/***/ }),

/***/ "../../node_modules/@loaders.gl/worker-utils/dist/lib/worker-farm/worker-pool.js":
/*!***************************************************************************************!*\
  !*** ../../node_modules/@loaders.gl/worker-utils/dist/lib/worker-farm/worker-pool.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ WorkerPool)
/* harmony export */ });
/* harmony import */ var _env_utils_globals_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../env-utils/globals.js */ "../../node_modules/@loaders.gl/worker-utils/dist/lib/env-utils/globals.js");
/* harmony import */ var _worker_thread_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./worker-thread.js */ "../../node_modules/@loaders.gl/worker-utils/dist/lib/worker-farm/worker-thread.js");
/* harmony import */ var _worker_job_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./worker-job.js */ "../../node_modules/@loaders.gl/worker-utils/dist/lib/worker-farm/worker-job.js");



class WorkerPool {
  static isSupported() {
    return _worker_thread_js__WEBPACK_IMPORTED_MODULE_0__["default"].isSupported();
  }
  constructor(props) {
    this.name = 'unnamed';
    this.source = void 0;
    this.url = void 0;
    this.maxConcurrency = 1;
    this.maxMobileConcurrency = 1;
    this.onDebug = () => {};
    this.reuseWorkers = true;
    this.props = {};
    this.jobQueue = [];
    this.idleQueue = [];
    this.count = 0;
    this.isDestroyed = false;
    this.source = props.source;
    this.url = props.url;
    this.setProps(props);
  }
  destroy() {
    this.idleQueue.forEach(worker => worker.destroy());
    this.isDestroyed = true;
  }
  setProps(props) {
    this.props = {
      ...this.props,
      ...props
    };
    if (props.name !== undefined) {
      this.name = props.name;
    }
    if (props.maxConcurrency !== undefined) {
      this.maxConcurrency = props.maxConcurrency;
    }
    if (props.maxMobileConcurrency !== undefined) {
      this.maxMobileConcurrency = props.maxMobileConcurrency;
    }
    if (props.reuseWorkers !== undefined) {
      this.reuseWorkers = props.reuseWorkers;
    }
    if (props.onDebug !== undefined) {
      this.onDebug = props.onDebug;
    }
  }
  async startJob(name) {
    let onMessage = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : (job, type, data) => job.done(data);
    let onError = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : (job, error) => job.error(error);
    const startPromise = new Promise(onStart => {
      this.jobQueue.push({
        name,
        onMessage,
        onError,
        onStart
      });
      return this;
    });
    this._startQueuedJob();
    return await startPromise;
  }
  async _startQueuedJob() {
    if (!this.jobQueue.length) {
      return;
    }
    const workerThread = this._getAvailableWorker();
    if (!workerThread) {
      return;
    }
    const queuedJob = this.jobQueue.shift();
    if (queuedJob) {
      this.onDebug({
        message: 'Starting job',
        name: queuedJob.name,
        workerThread,
        backlog: this.jobQueue.length
      });
      const job = new _worker_job_js__WEBPACK_IMPORTED_MODULE_1__["default"](queuedJob.name, workerThread);
      workerThread.onMessage = data => queuedJob.onMessage(job, data.type, data.payload);
      workerThread.onError = error => queuedJob.onError(job, error);
      queuedJob.onStart(job);
      try {
        await job.result;
      } catch (error) {
        console.error(`Worker exception: ${error}`);
      } finally {
        this.returnWorkerToQueue(workerThread);
      }
    }
  }
  returnWorkerToQueue(worker) {
    const shouldDestroyWorker = !_env_utils_globals_js__WEBPACK_IMPORTED_MODULE_2__.isBrowser || this.isDestroyed || !this.reuseWorkers || this.count > this._getMaxConcurrency();
    if (shouldDestroyWorker) {
      worker.destroy();
      this.count--;
    } else {
      this.idleQueue.push(worker);
    }
    if (!this.isDestroyed) {
      this._startQueuedJob();
    }
  }
  _getAvailableWorker() {
    if (this.idleQueue.length > 0) {
      return this.idleQueue.shift() || null;
    }
    if (this.count < this._getMaxConcurrency()) {
      this.count++;
      const name = `${this.name.toLowerCase()} (#${this.count} of ${this.maxConcurrency})`;
      return new _worker_thread_js__WEBPACK_IMPORTED_MODULE_0__["default"]({
        name,
        source: this.source,
        url: this.url
      });
    }
    return null;
  }
  _getMaxConcurrency() {
    return _env_utils_globals_js__WEBPACK_IMPORTED_MODULE_2__.isMobile ? this.maxMobileConcurrency : this.maxConcurrency;
  }
}
//# sourceMappingURL=worker-pool.js.map

/***/ }),

/***/ "../../node_modules/@loaders.gl/worker-utils/dist/lib/worker-farm/worker-thread.js":
/*!*****************************************************************************************!*\
  !*** ../../node_modules/@loaders.gl/worker-utils/dist/lib/worker-farm/worker-thread.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ WorkerThread)
/* harmony export */ });
/* harmony import */ var _node_worker_threads_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../node/worker_threads.js */ "../../node_modules/@loaders.gl/worker-utils/dist/lib/node/worker_threads-browser.js");
/* harmony import */ var _env_utils_globals_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../env-utils/globals.js */ "../../node_modules/@loaders.gl/worker-utils/dist/lib/env-utils/globals.js");
/* harmony import */ var _env_utils_assert_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../env-utils/assert.js */ "../../node_modules/@loaders.gl/worker-utils/dist/lib/env-utils/assert.js");
/* harmony import */ var _worker_utils_get_loadable_worker_url_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../worker-utils/get-loadable-worker-url.js */ "../../node_modules/@loaders.gl/worker-utils/dist/lib/worker-utils/get-loadable-worker-url.js");
/* harmony import */ var _worker_utils_get_transfer_list_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../worker-utils/get-transfer-list.js */ "../../node_modules/@loaders.gl/worker-utils/dist/lib/worker-utils/get-transfer-list.js");





const NOOP = () => {};
class WorkerThread {
  static isSupported() {
    return typeof Worker !== 'undefined' && _env_utils_globals_js__WEBPACK_IMPORTED_MODULE_0__.isBrowser || typeof _node_worker_threads_js__WEBPACK_IMPORTED_MODULE_1__.NodeWorker !== 'undefined' && !_env_utils_globals_js__WEBPACK_IMPORTED_MODULE_0__.isBrowser;
  }
  constructor(props) {
    this.name = void 0;
    this.source = void 0;
    this.url = void 0;
    this.terminated = false;
    this.worker = void 0;
    this.onMessage = void 0;
    this.onError = void 0;
    this._loadableURL = '';
    const {
      name,
      source,
      url
    } = props;
    (0,_env_utils_assert_js__WEBPACK_IMPORTED_MODULE_2__.assert)(source || url);
    this.name = name;
    this.source = source;
    this.url = url;
    this.onMessage = NOOP;
    this.onError = error => console.log(error);
    this.worker = _env_utils_globals_js__WEBPACK_IMPORTED_MODULE_0__.isBrowser ? this._createBrowserWorker() : this._createNodeWorker();
  }
  destroy() {
    this.onMessage = NOOP;
    this.onError = NOOP;
    this.worker.terminate();
    this.terminated = true;
  }
  get isRunning() {
    return Boolean(this.onMessage);
  }
  postMessage(data, transferList) {
    transferList = transferList || (0,_worker_utils_get_transfer_list_js__WEBPACK_IMPORTED_MODULE_3__.getTransferList)(data);
    this.worker.postMessage(data, transferList);
  }
  _getErrorFromErrorEvent(event) {
    let message = 'Failed to load ';
    message += `worker ${this.name} from ${this.url}. `;
    if (event.message) {
      message += `${event.message} in `;
    }
    if (event.lineno) {
      message += `:${event.lineno}:${event.colno}`;
    }
    return new Error(message);
  }
  _createBrowserWorker() {
    this._loadableURL = (0,_worker_utils_get_loadable_worker_url_js__WEBPACK_IMPORTED_MODULE_4__.getLoadableWorkerURL)({
      source: this.source,
      url: this.url
    });
    const worker = new Worker(this._loadableURL, {
      name: this.name
    });
    worker.onmessage = event => {
      if (!event.data) {
        this.onError(new Error('No data received'));
      } else {
        this.onMessage(event.data);
      }
    };
    worker.onerror = error => {
      this.onError(this._getErrorFromErrorEvent(error));
      this.terminated = true;
    };
    worker.onmessageerror = event => console.error(event);
    return worker;
  }
  _createNodeWorker() {
    let worker;
    if (this.url) {
      const absolute = this.url.includes(':/') || this.url.startsWith('/');
      const url = absolute ? this.url : `./${this.url}`;
      worker = new _node_worker_threads_js__WEBPACK_IMPORTED_MODULE_1__.NodeWorker(url, {
        eval: false
      });
    } else if (this.source) {
      worker = new _node_worker_threads_js__WEBPACK_IMPORTED_MODULE_1__.NodeWorker(this.source, {
        eval: true
      });
    } else {
      throw new Error('no worker');
    }
    worker.on('message', data => {
      this.onMessage(data);
    });
    worker.on('error', error => {
      this.onError(error);
    });
    worker.on('exit', code => {});
    return worker;
  }
}
//# sourceMappingURL=worker-thread.js.map

/***/ }),

/***/ "../../node_modules/@loaders.gl/worker-utils/dist/lib/worker-utils/get-loadable-worker-url.js":
/*!****************************************************************************************************!*\
  !*** ../../node_modules/@loaders.gl/worker-utils/dist/lib/worker-utils/get-loadable-worker-url.js ***!
  \****************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   getLoadableWorkerURL: () => (/* binding */ getLoadableWorkerURL)
/* harmony export */ });
/* harmony import */ var _env_utils_assert_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../env-utils/assert.js */ "../../node_modules/@loaders.gl/worker-utils/dist/lib/env-utils/assert.js");

const workerURLCache = new Map();
function getLoadableWorkerURL(props) {
  (0,_env_utils_assert_js__WEBPACK_IMPORTED_MODULE_0__.assert)(props.source && !props.url || !props.source && props.url);
  let workerURL = workerURLCache.get(props.source || props.url);
  if (!workerURL) {
    if (props.url) {
      workerURL = getLoadableWorkerURLFromURL(props.url);
      workerURLCache.set(props.url, workerURL);
    }
    if (props.source) {
      workerURL = getLoadableWorkerURLFromSource(props.source);
      workerURLCache.set(props.source, workerURL);
    }
  }
  (0,_env_utils_assert_js__WEBPACK_IMPORTED_MODULE_0__.assert)(workerURL);
  return workerURL;
}
function getLoadableWorkerURLFromURL(url) {
  if (!url.startsWith('http')) {
    return url;
  }
  const workerSource = buildScriptSource(url);
  return getLoadableWorkerURLFromSource(workerSource);
}
function getLoadableWorkerURLFromSource(workerSource) {
  const blob = new Blob([workerSource], {
    type: 'application/javascript'
  });
  return URL.createObjectURL(blob);
}
function buildScriptSource(workerUrl) {
  return `\
try {
  importScripts('${workerUrl}');
} catch (error) {
  console.error(error);
  throw error;
}`;
}
//# sourceMappingURL=get-loadable-worker-url.js.map

/***/ }),

/***/ "../../node_modules/@loaders.gl/worker-utils/dist/lib/worker-utils/get-transfer-list.js":
/*!**********************************************************************************************!*\
  !*** ../../node_modules/@loaders.gl/worker-utils/dist/lib/worker-utils/get-transfer-list.js ***!
  \**********************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   getTransferList: () => (/* binding */ getTransferList),
/* harmony export */   getTransferListForWriter: () => (/* binding */ getTransferListForWriter)
/* harmony export */ });
function getTransferList(object) {
  let recursive = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
  let transfers = arguments.length > 2 ? arguments[2] : undefined;
  const transfersSet = transfers || new Set();
  if (!object) {} else if (isTransferable(object)) {
    transfersSet.add(object);
  } else if (isTransferable(object.buffer)) {
    transfersSet.add(object.buffer);
  } else if (ArrayBuffer.isView(object)) {} else if (recursive && typeof object === 'object') {
    for (const key in object) {
      getTransferList(object[key], recursive, transfersSet);
    }
  }
  return transfers === undefined ? Array.from(transfersSet) : [];
}
function isTransferable(object) {
  if (!object) {
    return false;
  }
  if (object instanceof ArrayBuffer) {
    return true;
  }
  if (typeof MessagePort !== 'undefined' && object instanceof MessagePort) {
    return true;
  }
  if (typeof ImageBitmap !== 'undefined' && object instanceof ImageBitmap) {
    return true;
  }
  if (typeof OffscreenCanvas !== 'undefined' && object instanceof OffscreenCanvas) {
    return true;
  }
  return false;
}
function getTransferListForWriter(object) {
  if (object === null) {
    return {};
  }
  const clone = Object.assign({}, object);
  Object.keys(clone).forEach(key => {
    if (typeof object[key] === 'object' && !ArrayBuffer.isView(object[key]) && !(object[key] instanceof Array)) {
      clone[key] = getTransferListForWriter(object[key]);
    } else if (typeof clone[key] === 'function' || clone[key] instanceof RegExp) {
      clone[key] = {};
    } else {
      clone[key] = object[key];
    }
  });
  return clone;
}
//# sourceMappingURL=get-transfer-list.js.map

/***/ }),

/***/ "../../node_modules/@probe.gl/env/dist/index.js":
/*!******************************************************!*\
  !*** ../../node_modules/@probe.gl/env/dist/index.js ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   VERSION: () => (/* binding */ VERSION),
/* harmony export */   assert: () => (/* reexport safe */ _utils_assert_js__WEBPACK_IMPORTED_MODULE_4__.assert),
/* harmony export */   console: () => (/* reexport safe */ _lib_globals_js__WEBPACK_IMPORTED_MODULE_0__.console),
/* harmony export */   document: () => (/* reexport safe */ _lib_globals_js__WEBPACK_IMPORTED_MODULE_0__.document),
/* harmony export */   getBrowser: () => (/* reexport safe */ _lib_get_browser_js__WEBPACK_IMPORTED_MODULE_2__.getBrowser),
/* harmony export */   global: () => (/* reexport safe */ _lib_globals_js__WEBPACK_IMPORTED_MODULE_0__.global),
/* harmony export */   isBrowser: () => (/* reexport safe */ _lib_is_browser_js__WEBPACK_IMPORTED_MODULE_1__.isBrowser),
/* harmony export */   isElectron: () => (/* reexport safe */ _lib_is_electron_js__WEBPACK_IMPORTED_MODULE_3__.isElectron),
/* harmony export */   isMobile: () => (/* reexport safe */ _lib_get_browser_js__WEBPACK_IMPORTED_MODULE_2__.isMobile),
/* harmony export */   process: () => (/* reexport safe */ _lib_globals_js__WEBPACK_IMPORTED_MODULE_0__.process),
/* harmony export */   self: () => (/* reexport safe */ _lib_globals_js__WEBPACK_IMPORTED_MODULE_0__.self),
/* harmony export */   window: () => (/* reexport safe */ _lib_globals_js__WEBPACK_IMPORTED_MODULE_0__.window)
/* harmony export */ });
/* harmony import */ var _lib_globals_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./lib/globals.js */ "../../node_modules/@probe.gl/env/dist/lib/globals.js");
/* harmony import */ var _lib_is_browser_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./lib/is-browser.js */ "../../node_modules/@probe.gl/env/dist/lib/is-browser.js");
/* harmony import */ var _lib_get_browser_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./lib/get-browser.js */ "../../node_modules/@probe.gl/env/dist/lib/get-browser.js");
/* harmony import */ var _lib_is_electron_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./lib/is-electron.js */ "../../node_modules/@probe.gl/env/dist/lib/is-electron.js");
/* harmony import */ var _utils_assert_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./utils/assert.js */ "../../node_modules/@probe.gl/env/dist/utils/assert.js");
// Extract injected version from package.json (injected by babel plugin)
// @ts-expect-error
const VERSION =  true ? "4.0.7" : 0;
// ENVIRONMENT




// ENVIRONMENT'S ASSERT IS 5-15KB, SO WE PROVIDE OUR OWN

// TODO - wish we could just export a constant
// export const isBrowser = checkIfBrowser();


/***/ }),

/***/ "../../node_modules/@probe.gl/env/dist/lib/get-browser.js":
/*!****************************************************************!*\
  !*** ../../node_modules/@probe.gl/env/dist/lib/get-browser.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   getBrowser: () => (/* binding */ getBrowser),
/* harmony export */   isMobile: () => (/* binding */ isMobile)
/* harmony export */ });
/* harmony import */ var _is_browser_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./is-browser.js */ "../../node_modules/@probe.gl/env/dist/lib/is-browser.js");
/* harmony import */ var _is_electron_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./is-electron.js */ "../../node_modules/@probe.gl/env/dist/lib/is-electron.js");
/* harmony import */ var _globals_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./globals.js */ "../../node_modules/@probe.gl/env/dist/lib/globals.js");
// Copyright (c) 2017 Uber Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.
// This function is needed in initialization stages,
// make sure it can be imported in isolation



function isMobile() {
    return typeof globalThis.orientation !== 'undefined';
}
// Simple browser detection
// `mockUserAgent` parameter allows user agent to be overridden for testing
/* eslint-disable complexity */
function getBrowser(mockUserAgent) {
    if (!mockUserAgent && !(0,_is_browser_js__WEBPACK_IMPORTED_MODULE_0__.isBrowser)()) {
        return 'Node';
    }
    if ((0,_is_electron_js__WEBPACK_IMPORTED_MODULE_1__.isElectron)(mockUserAgent)) {
        return 'Electron';
    }
    const userAgent = mockUserAgent || _globals_js__WEBPACK_IMPORTED_MODULE_2__.navigator.userAgent || '';
    // NOTE: Order of tests matter, as many agents list Chrome etc.
    if (userAgent.indexOf('Edge') > -1) {
        return 'Edge';
    }
    if (globalThis.chrome) {
        return 'Chrome';
    }
    if (globalThis.safari) {
        return 'Safari';
    }
    if (globalThis.mozInnerScreenX) {
        return 'Firefox';
    }
    return 'Unknown';
}


/***/ }),

/***/ "../../node_modules/@probe.gl/env/dist/lib/globals.js":
/*!************************************************************!*\
  !*** ../../node_modules/@probe.gl/env/dist/lib/globals.js ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   console: () => (/* binding */ console_),
/* harmony export */   document: () => (/* binding */ document_),
/* harmony export */   global: () => (/* binding */ global_),
/* harmony export */   navigator: () => (/* binding */ navigator_),
/* harmony export */   process: () => (/* binding */ process_),
/* harmony export */   self: () => (/* binding */ global_),
/* harmony export */   window: () => (/* binding */ window_)
/* harmony export */ });
// Do not name these variables the same as the global objects - will break bundling
const global_ = globalThis;
const window_ = globalThis;
const document_ = globalThis.document || {};
const process_ = globalThis.process || {};
const console_ = globalThis.console;
const navigator_ = globalThis.navigator || {};



/***/ }),

/***/ "../../node_modules/@probe.gl/env/dist/lib/is-browser.js":
/*!***************************************************************!*\
  !*** ../../node_modules/@probe.gl/env/dist/lib/is-browser.js ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   isBrowser: () => (/* binding */ isBrowser)
/* harmony export */ });
/* harmony import */ var _is_electron_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./is-electron.js */ "../../node_modules/@probe.gl/env/dist/lib/is-electron.js");
// This function is needed in initialization stages,
// make sure it can be imported in isolation

/** Check if in browser by duck-typing Node context */
function isBrowser() {
    const isNode = 
    // @ts-expect-error
    typeof process === 'object' && String(process) === '[object process]' && !process?.browser;
    return !isNode || (0,_is_electron_js__WEBPACK_IMPORTED_MODULE_0__.isElectron)();
}


/***/ }),

/***/ "../../node_modules/@probe.gl/env/dist/lib/is-electron.js":
/*!****************************************************************!*\
  !*** ../../node_modules/@probe.gl/env/dist/lib/is-electron.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   isElectron: () => (/* binding */ isElectron)
/* harmony export */ });
// based on https://github.com/cheton/is-electron
// https://github.com/electron/electron/issues/2288
/* eslint-disable complexity */
function isElectron(mockUserAgent) {
    // Renderer process
    // @ts-expect-error
    if (typeof window !== 'undefined' && window.process?.type === 'renderer') {
        return true;
    }
    // Main process
    // eslint-disable-next-line
    if (typeof process !== 'undefined' && Boolean(process.versions?.['electron'])) {
        return true;
    }
    // Detect the user agent when the `nodeIntegration` option is set to true
    const realUserAgent = typeof navigator !== 'undefined' && navigator.userAgent;
    const userAgent = mockUserAgent || realUserAgent;
    return Boolean(userAgent && userAgent.indexOf('Electron') >= 0);
}


/***/ }),

/***/ "../../node_modules/@probe.gl/env/dist/utils/assert.js":
/*!*************************************************************!*\
  !*** ../../node_modules/@probe.gl/env/dist/utils/assert.js ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   assert: () => (/* binding */ assert)
/* harmony export */ });
function assert(condition, message) {
    if (!condition) {
        throw new Error(message || 'Assertion failed');
    }
}


/***/ }),

/***/ "../../node_modules/@probe.gl/log/dist/log.js":
/*!****************************************************!*\
  !*** ../../node_modules/@probe.gl/log/dist/log.js ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Log: () => (/* binding */ Log),
/* harmony export */   normalizeArguments: () => (/* binding */ normalizeArguments)
/* harmony export */ });
/* harmony import */ var _probe_gl_env__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @probe.gl/env */ "../../node_modules/@probe.gl/env/dist/lib/is-browser.js");
/* harmony import */ var _probe_gl_env__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @probe.gl/env */ "../../node_modules/@probe.gl/env/dist/index.js");
/* harmony import */ var _utils_local_storage_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./utils/local-storage.js */ "../../node_modules/@probe.gl/log/dist/utils/local-storage.js");
/* harmony import */ var _utils_formatters_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./utils/formatters.js */ "../../node_modules/@probe.gl/log/dist/utils/formatters.js");
/* harmony import */ var _utils_color_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./utils/color.js */ "../../node_modules/@probe.gl/log/dist/utils/color.js");
/* harmony import */ var _utils_autobind_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./utils/autobind.js */ "../../node_modules/@probe.gl/log/dist/utils/autobind.js");
/* harmony import */ var _utils_assert_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./utils/assert.js */ "../../node_modules/@probe.gl/log/dist/utils/assert.js");
/* harmony import */ var _utils_hi_res_timestamp_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils/hi-res-timestamp.js */ "../../node_modules/@probe.gl/log/dist/utils/hi-res-timestamp.js");
// probe.gl, MIT license
/* eslint-disable no-console */







// Instrumentation in other packages may override console methods, so preserve them here
const originalConsole = {
    debug: (0,_probe_gl_env__WEBPACK_IMPORTED_MODULE_0__.isBrowser)() ? console.debug || console.log : console.log,
    log: console.log,
    info: console.info,
    warn: console.warn,
    error: console.error
};
const DEFAULT_LOG_CONFIGURATION = {
    enabled: true,
    level: 0
};
function noop() { } // eslint-disable-line @typescript-eslint/no-empty-function
const cache = {};
const ONCE = { once: true };
/** A console wrapper */
class Log {
    constructor({ id } = { id: '' }) {
        this.VERSION = _probe_gl_env__WEBPACK_IMPORTED_MODULE_1__.VERSION;
        this._startTs = (0,_utils_hi_res_timestamp_js__WEBPACK_IMPORTED_MODULE_2__.getHiResTimestamp)();
        this._deltaTs = (0,_utils_hi_res_timestamp_js__WEBPACK_IMPORTED_MODULE_2__.getHiResTimestamp)();
        this.userData = {};
        // TODO - fix support from throttling groups
        this.LOG_THROTTLE_TIMEOUT = 0; // Time before throttled messages are logged again
        this.id = id;
        this.userData = {};
        this._storage = new _utils_local_storage_js__WEBPACK_IMPORTED_MODULE_3__.LocalStorage(`__probe-${this.id}__`, DEFAULT_LOG_CONFIGURATION);
        this.timeStamp(`${this.id} started`);
        (0,_utils_autobind_js__WEBPACK_IMPORTED_MODULE_4__.autobind)(this);
        Object.seal(this);
    }
    set level(newLevel) {
        this.setLevel(newLevel);
    }
    get level() {
        return this.getLevel();
    }
    isEnabled() {
        return this._storage.config.enabled;
    }
    getLevel() {
        return this._storage.config.level;
    }
    /** @return milliseconds, with fractions */
    getTotal() {
        return Number(((0,_utils_hi_res_timestamp_js__WEBPACK_IMPORTED_MODULE_2__.getHiResTimestamp)() - this._startTs).toPrecision(10));
    }
    /** @return milliseconds, with fractions */
    getDelta() {
        return Number(((0,_utils_hi_res_timestamp_js__WEBPACK_IMPORTED_MODULE_2__.getHiResTimestamp)() - this._deltaTs).toPrecision(10));
    }
    /** @deprecated use logLevel */
    set priority(newPriority) {
        this.level = newPriority;
    }
    /** @deprecated use logLevel */
    get priority() {
        return this.level;
    }
    /** @deprecated use logLevel */
    getPriority() {
        return this.level;
    }
    // Configure
    enable(enabled = true) {
        this._storage.setConfiguration({ enabled });
        return this;
    }
    setLevel(level) {
        this._storage.setConfiguration({ level });
        return this;
    }
    /** return the current status of the setting */
    get(setting) {
        return this._storage.config[setting];
    }
    // update the status of the setting
    set(setting, value) {
        this._storage.setConfiguration({ [setting]: value });
    }
    /** Logs the current settings as a table */
    settings() {
        if (console.table) {
            console.table(this._storage.config);
        }
        else {
            console.log(this._storage.config);
        }
    }
    // Unconditional logging
    assert(condition, message) {
        if (!condition) {
            throw new Error(message || 'Assertion failed');
        }
    }
    warn(message) {
        return this._getLogFunction(0, message, originalConsole.warn, arguments, ONCE);
    }
    error(message) {
        return this._getLogFunction(0, message, originalConsole.error, arguments);
    }
    /** Print a deprecation warning */
    deprecated(oldUsage, newUsage) {
        return this.warn(`\`${oldUsage}\` is deprecated and will be removed \
in a later version. Use \`${newUsage}\` instead`);
    }
    /** Print a removal warning */
    removed(oldUsage, newUsage) {
        return this.error(`\`${oldUsage}\` has been removed. Use \`${newUsage}\` instead`);
    }
    probe(logLevel, message) {
        return this._getLogFunction(logLevel, message, originalConsole.log, arguments, {
            time: true,
            once: true
        });
    }
    log(logLevel, message) {
        return this._getLogFunction(logLevel, message, originalConsole.debug, arguments);
    }
    info(logLevel, message) {
        return this._getLogFunction(logLevel, message, console.info, arguments);
    }
    once(logLevel, message) {
        return this._getLogFunction(logLevel, message, originalConsole.debug || originalConsole.info, arguments, ONCE);
    }
    /** Logs an object as a table */
    table(logLevel, table, columns) {
        if (table) {
            return this._getLogFunction(logLevel, table, console.table || noop, (columns && [columns]), {
                tag: getTableHeader(table)
            });
        }
        return noop;
    }
    time(logLevel, message) {
        return this._getLogFunction(logLevel, message, console.time ? console.time : console.info);
    }
    timeEnd(logLevel, message) {
        return this._getLogFunction(logLevel, message, console.timeEnd ? console.timeEnd : console.info);
    }
    timeStamp(logLevel, message) {
        return this._getLogFunction(logLevel, message, console.timeStamp || noop);
    }
    group(logLevel, message, opts = { collapsed: false }) {
        const options = normalizeArguments({ logLevel, message, opts });
        const { collapsed } = opts;
        // @ts-expect-error
        options.method = (collapsed ? console.groupCollapsed : console.group) || console.info;
        return this._getLogFunction(options);
    }
    groupCollapsed(logLevel, message, opts = {}) {
        return this.group(logLevel, message, Object.assign({}, opts, { collapsed: true }));
    }
    groupEnd(logLevel) {
        return this._getLogFunction(logLevel, '', console.groupEnd || noop);
    }
    // EXPERIMENTAL
    withGroup(logLevel, message, func) {
        this.group(logLevel, message)();
        try {
            func();
        }
        finally {
            this.groupEnd(logLevel)();
        }
    }
    trace() {
        if (console.trace) {
            console.trace();
        }
    }
    // PRIVATE METHODS
    /** Deduces log level from a variety of arguments */
    _shouldLog(logLevel) {
        return this.isEnabled() && this.getLevel() >= normalizeLogLevel(logLevel);
    }
    _getLogFunction(logLevel, message, method, args, opts) {
        if (this._shouldLog(logLevel)) {
            // normalized opts + timings
            opts = normalizeArguments({ logLevel, message, args, opts });
            method = method || opts.method;
            (0,_utils_assert_js__WEBPACK_IMPORTED_MODULE_5__["default"])(method);
            opts.total = this.getTotal();
            opts.delta = this.getDelta();
            // reset delta timer
            this._deltaTs = (0,_utils_hi_res_timestamp_js__WEBPACK_IMPORTED_MODULE_2__.getHiResTimestamp)();
            const tag = opts.tag || opts.message;
            if (opts.once && tag) {
                if (!cache[tag]) {
                    cache[tag] = (0,_utils_hi_res_timestamp_js__WEBPACK_IMPORTED_MODULE_2__.getHiResTimestamp)();
                }
                else {
                    return noop;
                }
            }
            // TODO - Make throttling work with groups
            // if (opts.nothrottle || !throttle(tag, this.LOG_THROTTLE_TIMEOUT)) {
            //   return noop;
            // }
            message = decorateMessage(this.id, opts.message, opts);
            // Bind console function so that it can be called after being returned
            return method.bind(console, message, ...opts.args);
        }
        return noop;
    }
}
Log.VERSION = _probe_gl_env__WEBPACK_IMPORTED_MODULE_1__.VERSION;
/**
 * Get logLevel from first argument:
 * - log(logLevel, message, args) => logLevel
 * - log(message, args) => 0
 * - log({logLevel, ...}, message, args) => logLevel
 * - log({logLevel, message, args}) => logLevel
 */
function normalizeLogLevel(logLevel) {
    if (!logLevel) {
        return 0;
    }
    let resolvedLevel;
    switch (typeof logLevel) {
        case 'number':
            resolvedLevel = logLevel;
            break;
        case 'object':
            // Backward compatibility
            // TODO - deprecate `priority`
            // @ts-expect-error
            resolvedLevel = logLevel.logLevel || logLevel.priority || 0;
            break;
        default:
            return 0;
    }
    // 'log level must be a number'
    (0,_utils_assert_js__WEBPACK_IMPORTED_MODULE_5__["default"])(Number.isFinite(resolvedLevel) && resolvedLevel >= 0);
    return resolvedLevel;
}
/**
 * "Normalizes" the various argument patterns into an object with known types
 * - log(logLevel, message, args) => {logLevel, message, args}
 * - log(message, args) => {logLevel: 0, message, args}
 * - log({logLevel, ...}, message, args) => {logLevel, message, args}
 * - log({logLevel, message, args}) => {logLevel, message, args}
 */
function normalizeArguments(opts) {
    const { logLevel, message } = opts;
    opts.logLevel = normalizeLogLevel(logLevel);
    // We use `arguments` instead of rest parameters (...args) because IE
    // does not support the syntax. Rest parameters is transpiled to code with
    // perf impact. Doing it here instead avoids constructing args when logging is
    // disabled.
    // TODO - remove when/if IE support is dropped
    const args = opts.args ? Array.from(opts.args) : [];
    // args should only contain arguments that appear after `message`
    // eslint-disable-next-line no-empty
    while (args.length && args.shift() !== message) { }
    switch (typeof logLevel) {
        case 'string':
        case 'function':
            if (message !== undefined) {
                args.unshift(message);
            }
            opts.message = logLevel;
            break;
        case 'object':
            Object.assign(opts, logLevel);
            break;
        default:
    }
    // Resolve functions into strings by calling them
    if (typeof opts.message === 'function') {
        opts.message = opts.message();
    }
    const messageType = typeof opts.message;
    // 'log message must be a string' or object
    (0,_utils_assert_js__WEBPACK_IMPORTED_MODULE_5__["default"])(messageType === 'string' || messageType === 'object');
    // original opts + normalized opts + opts arg + fixed up message
    return Object.assign(opts, { args }, opts.opts);
}
function decorateMessage(id, message, opts) {
    if (typeof message === 'string') {
        const time = opts.time ? (0,_utils_formatters_js__WEBPACK_IMPORTED_MODULE_6__.leftPad)((0,_utils_formatters_js__WEBPACK_IMPORTED_MODULE_6__.formatTime)(opts.total)) : '';
        message = opts.time ? `${id}: ${time}  ${message}` : `${id}: ${message}`;
        message = (0,_utils_color_js__WEBPACK_IMPORTED_MODULE_7__.addColor)(message, opts.color, opts.background);
    }
    return message;
}
function getTableHeader(table) {
    for (const key in table) {
        for (const title in table[key]) {
            return title || 'untitled';
        }
    }
    return 'empty';
}


/***/ }),

/***/ "../../node_modules/@probe.gl/log/dist/utils/assert.js":
/*!*************************************************************!*\
  !*** ../../node_modules/@probe.gl/log/dist/utils/assert.js ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ assert)
/* harmony export */ });
function assert(condition, message) {
    if (!condition) {
        throw new Error(message || 'Assertion failed');
    }
}


/***/ }),

/***/ "../../node_modules/@probe.gl/log/dist/utils/autobind.js":
/*!***************************************************************!*\
  !*** ../../node_modules/@probe.gl/log/dist/utils/autobind.js ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   autobind: () => (/* binding */ autobind)
/* harmony export */ });
// Copyright (c) 2015 - 2017 Uber Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.
/**
 * Binds the "this" argument of all functions on a class instance to the instance
 * @param obj - class instance (typically a react component)
 */
function autobind(obj, predefined = ['constructor']) {
    const proto = Object.getPrototypeOf(obj);
    const propNames = Object.getOwnPropertyNames(proto);
    const object = obj;
    for (const key of propNames) {
        const value = object[key];
        if (typeof value === 'function') {
            if (!predefined.find(name => key === name)) {
                object[key] = value.bind(obj);
            }
        }
    }
}


/***/ }),

/***/ "../../node_modules/@probe.gl/log/dist/utils/color.js":
/*!************************************************************!*\
  !*** ../../node_modules/@probe.gl/log/dist/utils/color.js ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   COLOR: () => (/* binding */ COLOR),
/* harmony export */   addColor: () => (/* binding */ addColor)
/* harmony export */ });
/* harmony import */ var _probe_gl_env__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @probe.gl/env */ "../../node_modules/@probe.gl/env/dist/lib/is-browser.js");

var COLOR;
(function (COLOR) {
    COLOR[COLOR["BLACK"] = 30] = "BLACK";
    COLOR[COLOR["RED"] = 31] = "RED";
    COLOR[COLOR["GREEN"] = 32] = "GREEN";
    COLOR[COLOR["YELLOW"] = 33] = "YELLOW";
    COLOR[COLOR["BLUE"] = 34] = "BLUE";
    COLOR[COLOR["MAGENTA"] = 35] = "MAGENTA";
    COLOR[COLOR["CYAN"] = 36] = "CYAN";
    COLOR[COLOR["WHITE"] = 37] = "WHITE";
    COLOR[COLOR["BRIGHT_BLACK"] = 90] = "BRIGHT_BLACK";
    COLOR[COLOR["BRIGHT_RED"] = 91] = "BRIGHT_RED";
    COLOR[COLOR["BRIGHT_GREEN"] = 92] = "BRIGHT_GREEN";
    COLOR[COLOR["BRIGHT_YELLOW"] = 93] = "BRIGHT_YELLOW";
    COLOR[COLOR["BRIGHT_BLUE"] = 94] = "BRIGHT_BLUE";
    COLOR[COLOR["BRIGHT_MAGENTA"] = 95] = "BRIGHT_MAGENTA";
    COLOR[COLOR["BRIGHT_CYAN"] = 96] = "BRIGHT_CYAN";
    COLOR[COLOR["BRIGHT_WHITE"] = 97] = "BRIGHT_WHITE";
})(COLOR || (COLOR = {}));
const BACKGROUND_INCREMENT = 10;
function getColor(color) {
    if (typeof color !== 'string') {
        return color;
    }
    color = color.toUpperCase();
    return COLOR[color] || COLOR.WHITE;
}
function addColor(string, color, background) {
    if (!_probe_gl_env__WEBPACK_IMPORTED_MODULE_0__.isBrowser && typeof string === 'string') {
        if (color) {
            const colorCode = getColor(color);
            string = `\u001b[${colorCode}m${string}\u001b[39m`;
        }
        if (background) {
            // background colors values are +10
            const colorCode = getColor(background);
            string = `\u001b[${colorCode + BACKGROUND_INCREMENT}m${string}\u001b[49m`;
        }
    }
    return string;
}


/***/ }),

/***/ "../../node_modules/@probe.gl/log/dist/utils/formatters.js":
/*!*****************************************************************!*\
  !*** ../../node_modules/@probe.gl/log/dist/utils/formatters.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   formatTime: () => (/* binding */ formatTime),
/* harmony export */   formatValue: () => (/* binding */ formatValue),
/* harmony export */   leftPad: () => (/* binding */ leftPad),
/* harmony export */   rightPad: () => (/* binding */ rightPad)
/* harmony export */ });
// probe.gl, MIT license
/**
 * Format time
 */
function formatTime(ms) {
    let formatted;
    if (ms < 10) {
        formatted = `${ms.toFixed(2)}ms`;
    }
    else if (ms < 100) {
        formatted = `${ms.toFixed(1)}ms`;
    }
    else if (ms < 1000) {
        formatted = `${ms.toFixed(0)}ms`;
    }
    else {
        formatted = `${(ms / 1000).toFixed(2)}s`;
    }
    return formatted;
}
function leftPad(string, length = 8) {
    const padLength = Math.max(length - string.length, 0);
    return `${' '.repeat(padLength)}${string}`;
}
function rightPad(string, length = 8) {
    const padLength = Math.max(length - string.length, 0);
    return `${string}${' '.repeat(padLength)}`;
}
function formatValue(v, options = {}) {
    const EPSILON = 1e-16;
    const { isInteger = false } = options;
    if (Array.isArray(v) || ArrayBuffer.isView(v)) {
        return formatArrayValue(v, options);
    }
    if (!Number.isFinite(v)) {
        return String(v);
    }
    // @ts-expect-error
    if (Math.abs(v) < EPSILON) {
        return isInteger ? '0' : '0.';
    }
    if (isInteger) {
        // @ts-expect-error
        return v.toFixed(0);
    }
    // @ts-expect-error
    if (Math.abs(v) > 100 && Math.abs(v) < 10000) {
        // @ts-expect-error
        return v.toFixed(0);
    }
    // @ts-expect-error
    const string = v.toPrecision(2);
    const decimal = string.indexOf('.0');
    return decimal === string.length - 2 ? string.slice(0, -1) : string;
}
/** Helper to formatValue */
function formatArrayValue(v, options) {
    const { maxElts = 16, size = 1 } = options;
    let string = '[';
    for (let i = 0; i < v.length && i < maxElts; ++i) {
        if (i > 0) {
            string += `,${i % size === 0 ? ' ' : ''}`;
        }
        string += formatValue(v[i], options);
    }
    const terminator = v.length > maxElts ? '...' : ']';
    return `${string}${terminator}`;
}


/***/ }),

/***/ "../../node_modules/@probe.gl/log/dist/utils/hi-res-timestamp.js":
/*!***********************************************************************!*\
  !*** ../../node_modules/@probe.gl/log/dist/utils/hi-res-timestamp.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   getHiResTimestamp: () => (/* binding */ getHiResTimestamp)
/* harmony export */ });
/* harmony import */ var _probe_gl_env__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @probe.gl/env */ "../../node_modules/@probe.gl/env/dist/lib/is-browser.js");
/* harmony import */ var _probe_gl_env__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @probe.gl/env */ "../../node_modules/@probe.gl/env/dist/lib/globals.js");
// probe.gl, MIT license

/** Get best timer available. */
function getHiResTimestamp() {
    let timestamp;
    if ((0,_probe_gl_env__WEBPACK_IMPORTED_MODULE_0__.isBrowser)() && _probe_gl_env__WEBPACK_IMPORTED_MODULE_1__.window.performance) {
        timestamp = _probe_gl_env__WEBPACK_IMPORTED_MODULE_1__.window?.performance?.now?.();
    }
    else if ("hrtime" in _probe_gl_env__WEBPACK_IMPORTED_MODULE_1__.process) {
        // @ts-ignore
        const timeParts = _probe_gl_env__WEBPACK_IMPORTED_MODULE_1__.process?.hrtime?.();
        timestamp = timeParts[0] * 1000 + timeParts[1] / 1e6;
    }
    else {
        timestamp = Date.now();
    }
    return timestamp;
}


/***/ }),

/***/ "../../node_modules/@probe.gl/log/dist/utils/local-storage.js":
/*!********************************************************************!*\
  !*** ../../node_modules/@probe.gl/log/dist/utils/local-storage.js ***!
  \********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   LocalStorage: () => (/* binding */ LocalStorage)
/* harmony export */ });
// probe.gl, MIT license
function getStorage(type) {
    try {
        const storage = window[type];
        const x = '__storage_test__';
        storage.setItem(x, x);
        storage.removeItem(x);
        return storage;
    }
    catch (e) {
        return null;
    }
}
// Store keys in local storage via simple interface
class LocalStorage {
    constructor(id, defaultConfig, type = 'sessionStorage') {
        this.storage = getStorage(type);
        this.id = id;
        this.config = defaultConfig;
        this._loadConfiguration();
    }
    getConfiguration() {
        return this.config;
    }
    setConfiguration(configuration) {
        Object.assign(this.config, configuration);
        if (this.storage) {
            const serialized = JSON.stringify(this.config);
            this.storage.setItem(this.id, serialized);
        }
    }
    // Get config from persistent store, if available
    _loadConfiguration() {
        let configuration = {};
        if (this.storage) {
            const serializedConfiguration = this.storage.getItem(this.id);
            configuration = serializedConfiguration ? JSON.parse(serializedConfiguration) : {};
        }
        Object.assign(this.config, configuration);
        return this;
    }
}


/***/ }),

/***/ "../../node_modules/wgpu-matrix/dist/3.x/wgpu-matrix.module.js":
/*!*********************************************************************!*\
  !*** ../../node_modules/wgpu-matrix/dist/3.x/wgpu-matrix.module.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   mat3: () => (/* binding */ mat3),
/* harmony export */   mat3d: () => (/* binding */ mat3d),
/* harmony export */   mat3n: () => (/* binding */ mat3n),
/* harmony export */   mat4: () => (/* binding */ mat4),
/* harmony export */   mat4d: () => (/* binding */ mat4d),
/* harmony export */   mat4n: () => (/* binding */ mat4n),
/* harmony export */   quat: () => (/* binding */ quat),
/* harmony export */   quatd: () => (/* binding */ quatd),
/* harmony export */   quatn: () => (/* binding */ quatn),
/* harmony export */   utils: () => (/* binding */ utils),
/* harmony export */   vec2: () => (/* binding */ vec2),
/* harmony export */   vec2d: () => (/* binding */ vec2d),
/* harmony export */   vec2n: () => (/* binding */ vec2n),
/* harmony export */   vec3: () => (/* binding */ vec3),
/* harmony export */   vec3d: () => (/* binding */ vec3d),
/* harmony export */   vec3n: () => (/* binding */ vec3n),
/* harmony export */   vec4: () => (/* binding */ vec4),
/* harmony export */   vec4d: () => (/* binding */ vec4d),
/* harmony export */   vec4n: () => (/* binding */ vec4n)
/* harmony export */ });
/* wgpu-matrix@3.0.1, license MIT */
function wrapConstructor(OriginalConstructor, modifier) {
    return class extends OriginalConstructor {
        constructor(...args) {
            super(...args);
            modifier(this);
        }
    }; // Type assertion is necessary here
}
const ZeroArray = wrapConstructor((Array), a => a.fill(0));

/*
 * Copyright 2022 Gregg Tavares
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */
let EPSILON = 0.000001;
/**
 * Set the value for EPSILON for various checks
 * @param v - Value to use for EPSILON.
 * @returns previous value of EPSILON;
 */
function setEpsilon(v) {
    const old = EPSILON;
    EPSILON = v;
    return old;
}
/**
 * Convert degrees to radians
 * @param degrees - Angle in degrees
 * @returns angle converted to radians
 */
function degToRad(degrees) {
    return degrees * Math.PI / 180;
}
/**
 * Convert radians to degrees
 * @param radians - Angle in radians
 * @returns angle converted to degrees
 */
function radToDeg(radians) {
    return radians * 180 / Math.PI;
}
/**
 * Lerps between a and b via t
 * @param a - starting value
 * @param b - ending value
 * @param t - value where 0 = a and 1 = b
 * @returns a + (b - a) * t
 */
function lerp(a, b, t) {
    return a + (b - a) * t;
}
/**
 * Compute the opposite of lerp. Given a and b and a value between
 * a and b returns a value between 0 and 1. 0 if a, 1 if b.
 * Note: no clamping is done.
 * @param a - start value
 * @param b - end value
 * @param v - value between a and b
 * @returns (v - a) / (b - a)
 */
function inverseLerp(a, b, v) {
    const d = b - a;
    return (Math.abs(b - a) < EPSILON)
        ? a
        : (v - a) / d;
}
/**
 * Compute the euclidean modulo
 *
 * ```
 * // table for n / 3
 * -5, -4, -3, -2, -1,  0,  1,  2,  3,  4,  5   <- n
 * ------------------------------------
 * -2  -1  -0  -2  -1   0,  1,  2,  0,  1,  2   <- n % 3
 *  1   2   0   1   2   0,  1,  2,  0,  1,  2   <- euclideanModule(n, 3)
 * ```
 *
 * @param n - dividend
 * @param m - divisor
 * @returns the euclidean modulo of n / m
 */
function euclideanModulo(n, m) {
    return ((n % m) + m) % m;
}

var utils = {
    __proto__: null,
    get EPSILON () { return EPSILON; },
    degToRad: degToRad,
    euclideanModulo: euclideanModulo,
    inverseLerp: inverseLerp,
    lerp: lerp,
    radToDeg: radToDeg,
    setEpsilon: setEpsilon
};

/*
 * Copyright 2022 Gregg Tavares
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */
/**
 * Generates am typed API for Vec3
 */
function getAPIImpl$5(Ctor) {
    /**
     * Creates a Vec2; may be called with x, y, z to set initial values.
     *
     * Note: Since passing in a raw JavaScript array
     * is valid in all circumstances, if you want to
     * force a JavaScript array into a Vec2's specified type
     * it would be faster to use
     *
     * ```
     * const v = vec2.clone(someJSArray);
     * ```
     *
     * @param x - Initial x value.
     * @param y - Initial y value.
     * @returns the created vector
     */
    function create(x = 0, y = 0) {
        const newDst = new Ctor(2);
        if (x !== undefined) {
            newDst[0] = x;
            if (y !== undefined) {
                newDst[1] = y;
            }
        }
        return newDst;
    }
    /**
     * Creates a Vec2; may be called with x, y, z to set initial values. (same as create)
     * @param x - Initial x value.
     * @param y - Initial y value.
     * @returns the created vector
     */
    const fromValues = create;
    /**
     * Sets the values of a Vec2
     * Also see {@link vec2.create} and {@link vec2.copy}
     *
     * @param x first value
     * @param y second value
     * @param dst - vector to hold result. If not passed in a new one is created.
     * @returns A vector with its elements set.
     */
    function set(x, y, dst) {
        const newDst = (dst ?? new Ctor(2));
        newDst[0] = x;
        newDst[1] = y;
        return newDst;
    }
    /**
     * Applies Math.ceil to each element of vector
     * @param v - Operand vector.
     * @param dst - vector to hold result. If not passed in a new one is created.
     * @returns A vector that is the ceil of each element of v.
     */
    function ceil(v, dst) {
        const newDst = (dst ?? new Ctor(2));
        newDst[0] = Math.ceil(v[0]);
        newDst[1] = Math.ceil(v[1]);
        return newDst;
    }
    /**
     * Applies Math.floor to each element of vector
     * @param v - Operand vector.
     * @param dst - vector to hold result. If not passed in a new one is created.
     * @returns A vector that is the floor of each element of v.
     */
    function floor(v, dst) {
        const newDst = (dst ?? new Ctor(2));
        newDst[0] = Math.floor(v[0]);
        newDst[1] = Math.floor(v[1]);
        return newDst;
    }
    /**
     * Applies Math.round to each element of vector
     * @param v - Operand vector.
     * @param dst - vector to hold result. If not passed in a new one is created.
     * @returns A vector that is the round of each element of v.
     */
    function round(v, dst) {
        const newDst = (dst ?? new Ctor(2));
        newDst[0] = Math.round(v[0]);
        newDst[1] = Math.round(v[1]);
        return newDst;
    }
    /**
     * Clamp each element of vector between min and max
     * @param v - Operand vector.
     * @param max - Min value, default 0
     * @param min - Max value, default 1
     * @param dst - vector to hold result. If not passed in a new one is created.
     * @returns A vector that the clamped value of each element of v.
     */
    function clamp(v, min = 0, max = 1, dst) {
        const newDst = (dst ?? new Ctor(2));
        newDst[0] = Math.min(max, Math.max(min, v[0]));
        newDst[1] = Math.min(max, Math.max(min, v[1]));
        return newDst;
    }
    /**
     * Adds two vectors; assumes a and b have the same dimension.
     * @param a - Operand vector.
     * @param b - Operand vector.
     * @param dst - vector to hold result. If not passed in a new one is created.
     * @returns A vector that is the sum of a and b.
     */
    function add(a, b, dst) {
        const newDst = (dst ?? new Ctor(2));
        newDst[0] = a[0] + b[0];
        newDst[1] = a[1] + b[1];
        return newDst;
    }
    /**
     * Adds two vectors, scaling the 2nd; assumes a and b have the same dimension.
     * @param a - Operand vector.
     * @param b - Operand vector.
     * @param scale - Amount to scale b
     * @param dst - vector to hold result. If not passed in a new one is created.
     * @returns A vector that is the sum of a + b * scale.
     */
    function addScaled(a, b, scale, dst) {
        const newDst = (dst ?? new Ctor(2));
        newDst[0] = a[0] + b[0] * scale;
        newDst[1] = a[1] + b[1] * scale;
        return newDst;
    }
    /**
     * Returns the angle in radians between two vectors.
     * @param a - Operand vector.
     * @param b - Operand vector.
     * @returns The angle in radians between the 2 vectors.
     */
    function angle(a, b) {
        const ax = a[0];
        const ay = a[1];
        const bx = b[0];
        const by = b[1];
        const mag1 = Math.sqrt(ax * ax + ay * ay);
        const mag2 = Math.sqrt(bx * bx + by * by);
        const mag = mag1 * mag2;
        const cosine = mag && dot(a, b) / mag;
        return Math.acos(cosine);
    }
    /**
     * Subtracts two vectors.
     * @param a - Operand vector.
     * @param b - Operand vector.
     * @param dst - vector to hold result. If not passed in a new one is created.
     * @returns A vector that is the difference of a and b.
     */
    function subtract(a, b, dst) {
        const newDst = (dst ?? new Ctor(2));
        newDst[0] = a[0] - b[0];
        newDst[1] = a[1] - b[1];
        return newDst;
    }
    /**
     * Subtracts two vectors.
     * @param a - Operand vector.
     * @param b - Operand vector.
     * @param dst - vector to hold result. If not passed in a new one is created.
     * @returns A vector that is the difference of a and b.
     */
    const sub = subtract;
    /**
     * Check if 2 vectors are approximately equal
     * @param a - Operand vector.
     * @param b - Operand vector.
     * @returns true if vectors are approximately equal
     */
    function equalsApproximately(a, b) {
        return Math.abs(a[0] - b[0]) < EPSILON &&
            Math.abs(a[1] - b[1]) < EPSILON;
    }
    /**
     * Check if 2 vectors are exactly equal
     * @param a - Operand vector.
     * @param b - Operand vector.
     * @returns true if vectors are exactly equal
     */
    function equals(a, b) {
        return a[0] === b[0] && a[1] === b[1];
    }
    /**
     * Performs linear interpolation on two vectors.
     * Given vectors a and b and interpolation coefficient t, returns
     * a + t * (b - a).
     * @param a - Operand vector.
     * @param b - Operand vector.
     * @param t - Interpolation coefficient.
     * @param dst - vector to hold result. If not passed in a new one is created.
     * @returns The linear interpolated result.
     */
    function lerp(a, b, t, dst) {
        const newDst = (dst ?? new Ctor(2));
        newDst[0] = a[0] + t * (b[0] - a[0]);
        newDst[1] = a[1] + t * (b[1] - a[1]);
        return newDst;
    }
    /**
     * Performs linear interpolation on two vectors.
     * Given vectors a and b and interpolation coefficient vector t, returns
     * a + t * (b - a).
     * @param a - Operand vector.
     * @param b - Operand vector.
     * @param t - Interpolation coefficients vector.
     * @param dst - vector to hold result. If not passed in a new one is created.
     * @returns the linear interpolated result.
     */
    function lerpV(a, b, t, dst) {
        const newDst = (dst ?? new Ctor(2));
        newDst[0] = a[0] + t[0] * (b[0] - a[0]);
        newDst[1] = a[1] + t[1] * (b[1] - a[1]);
        return newDst;
    }
    /**
     * Return max values of two vectors.
     * Given vectors a and b returns
     * [max(a[0], b[0]), max(a[1], b[1]), max(a[2], b[2])].
     * @param a - Operand vector.
     * @param b - Operand vector.
     * @param dst - vector to hold result. If not passed in a new one is created.
     * @returns The max components vector.
     */
    function max(a, b, dst) {
        const newDst = (dst ?? new Ctor(2));
        newDst[0] = Math.max(a[0], b[0]);
        newDst[1] = Math.max(a[1], b[1]);
        return newDst;
    }
    /**
     * Return min values of two vectors.
     * Given vectors a and b returns
     * [min(a[0], b[0]), min(a[1], b[1]), min(a[2], b[2])].
     * @param a - Operand vector.
     * @param b - Operand vector.
     * @param dst - vector to hold result. If not passed in a new one is created.
     * @returns The min components vector.
     */
    function min(a, b, dst) {
        const newDst = (dst ?? new Ctor(2));
        newDst[0] = Math.min(a[0], b[0]);
        newDst[1] = Math.min(a[1], b[1]);
        return newDst;
    }
    /**
     * Multiplies a vector by a scalar.
     * @param v - The vector.
     * @param k - The scalar.
     * @param dst - vector to hold result. If not passed in a new one is created.
     * @returns The scaled vector.
     */
    function mulScalar(v, k, dst) {
        const newDst = (dst ?? new Ctor(2));
        newDst[0] = v[0] * k;
        newDst[1] = v[1] * k;
        return newDst;
    }
    /**
     * Multiplies a vector by a scalar. (same as mulScalar)
     * @param v - The vector.
     * @param k - The scalar.
     * @param dst - vector to hold result. If not passed in a new one is created.
     * @returns The scaled vector.
     */
    const scale = mulScalar;
    /**
     * Divides a vector by a scalar.
     * @param v - The vector.
     * @param k - The scalar.
     * @param dst - vector to hold result. If not passed in a new one is created.
     * @returns The scaled vector.
     */
    function divScalar(v, k, dst) {
        const newDst = (dst ?? new Ctor(2));
        newDst[0] = v[0] / k;
        newDst[1] = v[1] / k;
        return newDst;
    }
    /**
     * Inverse a vector.
     * @param v - The vector.
     * @param dst - vector to hold result. If not passed in a new one is created.
     * @returns The inverted vector.
     */
    function inverse(v, dst) {
        const newDst = (dst ?? new Ctor(2));
        newDst[0] = 1 / v[0];
        newDst[1] = 1 / v[1];
        return newDst;
    }
    /**
     * Invert a vector. (same as inverse)
     * @param v - The vector.
     * @param dst - vector to hold result. If not passed in a new one is created.
     * @returns The inverted vector.
     */
    const invert = inverse;
    /**
     * Computes the cross product of two vectors; assumes both vectors have
     * three entries.
     * @param a - Operand vector.
     * @param b - Operand vector.
     * @param dst - vector to hold result. If not passed in a new one is created.
     * @returns The vector of a cross b.
     */
    function cross(a, b, dst) {
        const newDst = (dst ?? new Ctor(3));
        const z = a[0] * b[1] - a[1] * b[0];
        newDst[0] = 0;
        newDst[1] = 0;
        newDst[2] = z;
        return newDst;
    }
    /**
     * Computes the dot product of two vectors; assumes both vectors have
     * three entries.
     * @param a - Operand vector.
     * @param b - Operand vector.
     * @returns dot product
     */
    function dot(a, b) {
        return a[0] * b[0] + a[1] * b[1];
    }
    /**
     * Computes the length of vector
     * @param v - vector.
     * @returns length of vector.
     */
    function length(v) {
        const v0 = v[0];
        const v1 = v[1];
        return Math.sqrt(v0 * v0 + v1 * v1);
    }
    /**
     * Computes the length of vector (same as length)
     * @param v - vector.
     * @returns length of vector.
     */
    const len = length;
    /**
     * Computes the square of the length of vector
     * @param v - vector.
     * @returns square of the length of vector.
     */
    function lengthSq(v) {
        const v0 = v[0];
        const v1 = v[1];
        return v0 * v0 + v1 * v1;
    }
    /**
     * Computes the square of the length of vector (same as lengthSq)
     * @param v - vector.
     * @returns square of the length of vector.
     */
    const lenSq = lengthSq;
    /**
     * Computes the distance between 2 points
     * @param a - vector.
     * @param b - vector.
     * @returns distance between a and b
     */
    function distance(a, b) {
        const dx = a[0] - b[0];
        const dy = a[1] - b[1];
        return Math.sqrt(dx * dx + dy * dy);
    }
    /**
     * Computes the distance between 2 points (same as distance)
     * @param a - vector.
     * @param b - vector.
     * @returns distance between a and b
     */
    const dist = distance;
    /**
     * Computes the square of the distance between 2 points
     * @param a - vector.
     * @param b - vector.
     * @returns square of the distance between a and b
     */
    function distanceSq(a, b) {
        const dx = a[0] - b[0];
        const dy = a[1] - b[1];
        return dx * dx + dy * dy;
    }
    /**
     * Computes the square of the distance between 2 points (same as distanceSq)
     * @param a - vector.
     * @param b - vector.
     * @returns square of the distance between a and b
     */
    const distSq = distanceSq;
    /**
     * Divides a vector by its Euclidean length and returns the quotient.
     * @param v - The vector.
     * @param dst - vector to hold result. If not passed in a new one is created.
     * @returns The normalized vector.
     */
    function normalize(v, dst) {
        const newDst = (dst ?? new Ctor(2));
        const v0 = v[0];
        const v1 = v[1];
        const len = Math.sqrt(v0 * v0 + v1 * v1);
        if (len > 0.00001) {
            newDst[0] = v0 / len;
            newDst[1] = v1 / len;
        }
        else {
            newDst[0] = 0;
            newDst[1] = 0;
        }
        return newDst;
    }
    /**
     * Negates a vector.
     * @param v - The vector.
     * @param dst - vector to hold result. If not passed in a new one is created.
     * @returns -v.
     */
    function negate(v, dst) {
        const newDst = (dst ?? new Ctor(2));
        newDst[0] = -v[0];
        newDst[1] = -v[1];
        return newDst;
    }
    /**
     * Copies a vector. (same as {@link vec2.clone})
     * Also see {@link vec2.create} and {@link vec2.set}
     * @param v - The vector.
     * @param dst - vector to hold result. If not passed in a new one is created.
     * @returns A copy of v.
     */
    function copy(v, dst) {
        const newDst = (dst ?? new Ctor(2));
        newDst[0] = v[0];
        newDst[1] = v[1];
        return newDst;
    }
    /**
     * Clones a vector. (same as {@link vec2.copy})
     * Also see {@link vec2.create} and {@link vec2.set}
     * @param v - The vector.
     * @param dst - vector to hold result. If not passed in a new one is created.
     * @returns A copy of v.
     */
    const clone = copy;
    /**
     * Multiplies a vector by another vector (component-wise); assumes a and
     * b have the same length.
     * @param a - Operand vector.
     * @param b - Operand vector.
     * @param dst - vector to hold result. If not passed in a new one is created.
     * @returns The vector of products of entries of a and b.
     */
    function multiply(a, b, dst) {
        const newDst = (dst ?? new Ctor(2));
        newDst[0] = a[0] * b[0];
        newDst[1] = a[1] * b[1];
        return newDst;
    }
    /**
     * Multiplies a vector by another vector (component-wise); assumes a and
     * b have the same length. (same as mul)
     * @param a - Operand vector.
     * @param b - Operand vector.
     * @param dst - vector to hold result. If not passed in a new one is created.
     * @returns The vector of products of entries of a and b.
     */
    const mul = multiply;
    /**
     * Divides a vector by another vector (component-wise); assumes a and
     * b have the same length.
     * @param a - Operand vector.
     * @param b - Operand vector.
     * @param dst - vector to hold result. If not passed in a new one is created.
     * @returns The vector of quotients of entries of a and b.
     */
    function divide(a, b, dst) {
        const newDst = (dst ?? new Ctor(2));
        newDst[0] = a[0] / b[0];
        newDst[1] = a[1] / b[1];
        return newDst;
    }
    /**
     * Divides a vector by another vector (component-wise); assumes a and
     * b have the same length. (same as divide)
     * @param a - Operand vector.
     * @param b - Operand vector.
     * @param dst - vector to hold result. If not passed in a new one is created.
     * @returns The vector of quotients of entries of a and b.
     */
    const div = divide;
    /**
     * Creates a random unit vector * scale
     * @param scale - Default 1
     * @param dst - vector to hold result. If not passed in a new one is created.
     * @returns The random vector.
     */
    function random(scale = 1, dst) {
        const newDst = (dst ?? new Ctor(2));
        const angle = Math.random() * 2 * Math.PI;
        newDst[0] = Math.cos(angle) * scale;
        newDst[1] = Math.sin(angle) * scale;
        return newDst;
    }
    /**
     * Zero's a vector
     * @param dst - vector to hold result. If not passed in a new one is created.
     * @returns The zeroed vector.
     */
    function zero(dst) {
        const newDst = (dst ?? new Ctor(2));
        newDst[0] = 0;
        newDst[1] = 0;
        return newDst;
    }
    /**
     * transform Vec2 by 4x4 matrix
     * @param v - the vector
     * @param m - The matrix.
     * @param dst - optional Vec2 to store result. If not passed a new one is created.
     * @returns the transformed vector
     */
    function transformMat4(v, m, dst) {
        const newDst = (dst ?? new Ctor(2));
        const x = v[0];
        const y = v[1];
        newDst[0] = x * m[0] + y * m[4] + m[12];
        newDst[1] = x * m[1] + y * m[5] + m[13];
        return newDst;
    }
    /**
     * Transforms vec4 by 3x3 matrix
     *
     * @param v - the vector
     * @param m - The matrix.
     * @param dst - optional Vec2 to store result. If not passed a new one is created.
     * @returns the transformed vector
     */
    function transformMat3(v, m, dst) {
        const newDst = (dst ?? new Ctor(2));
        const x = v[0];
        const y = v[1];
        newDst[0] = m[0] * x + m[4] * y + m[8];
        newDst[1] = m[1] * x + m[5] * y + m[9];
        return newDst;
    }
    /**
     * Rotate a 2D vector
     *
     * @param a The vec2 point to rotate
     * @param b The origin of the rotation
     * @param rad The angle of rotation in radians
     * @returns the rotated vector
     */
    function rotate(a, b, rad, dst) {
        const newDst = (dst ?? new Ctor(2));
        // Translate point to the origin
        const p0 = a[0] - b[0];
        const p1 = a[1] - b[1];
        const sinC = Math.sin(rad);
        const cosC = Math.cos(rad);
        //perform rotation and translate to correct position
        newDst[0] = p0 * cosC - p1 * sinC + b[0];
        newDst[1] = p0 * sinC + p1 * cosC + b[1];
        return newDst;
    }
    /**
     * Treat a 2D vector as a direction and set it's length
     *
     * @param a The vec2 to lengthen
     * @param len The length of the resulting vector
     * @returns The lengthened vector
     */
    function setLength(a, len, dst) {
        const newDst = (dst ?? new Ctor(2));
        normalize(a, newDst);
        return mulScalar(newDst, len, newDst);
    }
    /**
     * Ensure a vector is not longer than a max length
     *
     * @param a The vec2 to limit
     * @param maxLen The longest length of the resulting vector
     * @returns The vector, shortened to maxLen if it's too long
     */
    function truncate(a, maxLen, dst) {
        const newDst = (dst ?? new Ctor(2));
        if (length(a) > maxLen) {
            return setLength(a, maxLen, newDst);
        }
        return copy(a, newDst);
    }
    /**
     * Return the vector exactly between 2 endpoint vectors
     *
     * @param a Endpoint 1
     * @param b Endpoint 2
     * @returns The vector exactly residing between endpoints 1 and 2
     */
    function midpoint(a, b, dst) {
        const newDst = (dst ?? new Ctor(2));
        return lerp(a, b, 0.5, newDst);
    }
    return {
        create,
        fromValues,
        set,
        ceil,
        floor,
        round,
        clamp,
        add,
        addScaled,
        angle,
        subtract,
        sub,
        equalsApproximately,
        equals,
        lerp,
        lerpV,
        max,
        min,
        mulScalar,
        scale,
        divScalar,
        inverse,
        invert,
        cross,
        dot,
        length,
        len,
        lengthSq,
        lenSq,
        distance,
        dist,
        distanceSq,
        distSq,
        normalize,
        negate,
        copy,
        clone,
        multiply,
        mul,
        divide,
        div,
        random,
        zero,
        transformMat4,
        transformMat3,
        rotate,
        setLength,
        truncate,
        midpoint,
    };
}
const cache$5 = new Map();
function getAPI$5(Ctor) {
    let api = cache$5.get(Ctor);
    if (!api) {
        api = getAPIImpl$5(Ctor);
        cache$5.set(Ctor, api);
    }
    return api;
}

/*
 * Copyright 2022 Gregg Tavares
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */
/**
 * Generates a typed API for Mat3
 * */
function getAPIImpl$4(Ctor) {
    const vec2 = getAPI$5(Ctor);
    /**
     * Create a Mat3 from values
     *
     * Note: Since passing in a raw JavaScript array
     * is valid in all circumstances, if you want to
     * force a JavaScript array into a Mat3's specified type
     * it would be faster to use
     *
     * ```
     * const m = mat3.clone(someJSArray);
     * ```
     *
     * @param v0 - value for element 0
     * @param v1 - value for element 1
     * @param v2 - value for element 2
     * @param v3 - value for element 3
     * @param v4 - value for element 4
     * @param v5 - value for element 5
     * @param v6 - value for element 6
     * @param v7 - value for element 7
     * @param v8 - value for element 8
     * @returns matrix created from values.
     */
    function create(v0, v1, v2, v3, v4, v5, v6, v7, v8) {
        const newDst = new Ctor(12);
        // to make the array homogenous
        newDst[3] = 0;
        newDst[7] = 0;
        newDst[11] = 0;
        if (v0 !== undefined) {
            newDst[0] = v0;
            if (v1 !== undefined) {
                newDst[1] = v1;
                if (v2 !== undefined) {
                    newDst[2] = v2;
                    if (v3 !== undefined) {
                        newDst[4] = v3;
                        if (v4 !== undefined) {
                            newDst[5] = v4;
                            if (v5 !== undefined) {
                                newDst[6] = v5;
                                if (v6 !== undefined) {
                                    newDst[8] = v6;
                                    if (v7 !== undefined) {
                                        newDst[9] = v7;
                                        if (v8 !== undefined) {
                                            newDst[10] = v8;
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
        return newDst;
    }
    /**
     * Sets the values of a Mat3
     * Also see {@link mat3.create} and {@link mat3.copy}
     *
     * @param v0 - value for element 0
     * @param v1 - value for element 1
     * @param v2 - value for element 2
     * @param v3 - value for element 3
     * @param v4 - value for element 4
     * @param v5 - value for element 5
     * @param v6 - value for element 6
     * @param v7 - value for element 7
     * @param v8 - value for element 8
     * @param dst - matrix to hold result. If not passed a new one is created.
     * @returns Mat3 set from values.
     */
    function set(v0, v1, v2, v3, v4, v5, v6, v7, v8, dst) {
        const newDst = (dst ?? new Ctor(12));
        newDst[0] = v0;
        newDst[1] = v1;
        newDst[2] = v2;
        newDst[3] = 0;
        newDst[4] = v3;
        newDst[5] = v4;
        newDst[6] = v5;
        newDst[7] = 0;
        newDst[8] = v6;
        newDst[9] = v7;
        newDst[10] = v8;
        newDst[11] = 0;
        return newDst;
    }
    /**
     * Creates a Mat3 from the upper left 3x3 part of a Mat4
     * @param m4 - source matrix
     * @param dst - matrix to hold result. If not passed a new one is created.
     * @returns Mat3 made from m4
     */
    function fromMat4(m4, dst) {
        const newDst = (dst ?? new Ctor(12));
        newDst[0] = m4[0];
        newDst[1] = m4[1];
        newDst[2] = m4[2];
        newDst[3] = 0;
        newDst[4] = m4[4];
        newDst[5] = m4[5];
        newDst[6] = m4[6];
        newDst[7] = 0;
        newDst[8] = m4[8];
        newDst[9] = m4[9];
        newDst[10] = m4[10];
        newDst[11] = 0;
        return newDst;
    }
    /**
     * Creates a Mat3 rotation matrix from a quaternion
     * @param q - quaternion to create matrix from
     * @param dst - matrix to hold result. If not passed a new one is created.
     * @returns Mat3 made from q
     */
    function fromQuat(q, dst) {
        const newDst = (dst ?? new Ctor(12));
        const x = q[0];
        const y = q[1];
        const z = q[2];
        const w = q[3];
        const x2 = x + x;
        const y2 = y + y;
        const z2 = z + z;
        const xx = x * x2;
        const yx = y * x2;
        const yy = y * y2;
        const zx = z * x2;
        const zy = z * y2;
        const zz = z * z2;
        const wx = w * x2;
        const wy = w * y2;
        const wz = w * z2;
        newDst[0] = 1 - yy - zz;
        newDst[1] = yx + wz;
        newDst[2] = zx - wy;
        newDst[3] = 0;
        newDst[4] = yx - wz;
        newDst[5] = 1 - xx - zz;
        newDst[6] = zy + wx;
        newDst[7] = 0;
        newDst[8] = zx + wy;
        newDst[9] = zy - wx;
        newDst[10] = 1 - xx - yy;
        newDst[11] = 0;
        return newDst;
    }
    /**
     * Negates a matrix.
     * @param m - The matrix.
     * @param dst - matrix to hold result. If not passed a new one is created.
     * @returns -m.
     */
    function negate(m, dst) {
        const newDst = (dst ?? new Ctor(12));
        newDst[0] = -m[0];
        newDst[1] = -m[1];
        newDst[2] = -m[2];
        newDst[4] = -m[4];
        newDst[5] = -m[5];
        newDst[6] = -m[6];
        newDst[8] = -m[8];
        newDst[9] = -m[9];
        newDst[10] = -m[10];
        return newDst;
    }
    /**
     * Copies a matrix. (same as {@link mat3.clone})
     * Also see {@link mat3.create} and {@link mat3.set}
     * @param m - The matrix.
     * @param dst - The matrix. If not passed a new one is created.
     * @returns A copy of m.
     */
    function copy(m, dst) {
        const newDst = (dst ?? new Ctor(12));
        newDst[0] = m[0];
        newDst[1] = m[1];
        newDst[2] = m[2];
        newDst[4] = m[4];
        newDst[5] = m[5];
        newDst[6] = m[6];
        newDst[8] = m[8];
        newDst[9] = m[9];
        newDst[10] = m[10];
        return newDst;
    }
    /**
     * Copies a matrix (same as {@link mat3.copy})
     * Also see {@link mat3.create} and {@link mat3.set}
     * @param m - The matrix.
     * @param dst - The matrix. If not passed a new one is created.
     * @returns A copy of m.
     */
    const clone = copy;
    /**
     * Check if 2 matrices are approximately equal
     * @param a Operand matrix.
     * @param b Operand matrix.
     * @returns true if matrices are approximately equal
     */
    function equalsApproximately(a, b) {
        return Math.abs(a[0] - b[0]) < EPSILON &&
            Math.abs(a[1] - b[1]) < EPSILON &&
            Math.abs(a[2] - b[2]) < EPSILON &&
            Math.abs(a[4] - b[4]) < EPSILON &&
            Math.abs(a[5] - b[5]) < EPSILON &&
            Math.abs(a[6] - b[6]) < EPSILON &&
            Math.abs(a[8] - b[8]) < EPSILON &&
            Math.abs(a[9] - b[9]) < EPSILON &&
            Math.abs(a[10] - b[10]) < EPSILON;
    }
    /**
     * Check if 2 matrices are exactly equal
     * @param a Operand matrix.
     * @param b Operand matrix.
     * @returns true if matrices are exactly equal
     */
    function equals(a, b) {
        return a[0] === b[0] &&
            a[1] === b[1] &&
            a[2] === b[2] &&
            a[4] === b[4] &&
            a[5] === b[5] &&
            a[6] === b[6] &&
            a[8] === b[8] &&
            a[9] === b[9] &&
            a[10] === b[10];
    }
    /**
     * Creates a 3-by-3 identity matrix.
     *
     * @param dst - matrix to hold result. If not passed a new one is created.
     * @returns A 3-by-3 identity matrix.
     */
    function identity(dst) {
        const newDst = (dst ?? new Ctor(12));
        newDst[0] = 1;
        newDst[1] = 0;
        newDst[2] = 0;
        newDst[4] = 0;
        newDst[5] = 1;
        newDst[6] = 0;
        newDst[8] = 0;
        newDst[9] = 0;
        newDst[10] = 1;
        return newDst;
    }
    /**
     * Takes the transpose of a matrix.
     * @param m - The matrix.
     * @param dst - matrix to hold result. If not passed a new one is created.
     * @returns The transpose of m.
     */
    function transpose(m, dst) {
        const newDst = (dst ?? new Ctor(12));
        if (newDst === m) {
            let t;
            // 0 1 2
            // 4 5 6
            // 8 9 10
            t = m[1];
            m[1] = m[4];
            m[4] = t;
            t = m[2];
            m[2] = m[8];
            m[8] = t;
            t = m[6];
            m[6] = m[9];
            m[9] = t;
            return newDst;
        }
        const m00 = m[0 * 4 + 0];
        const m01 = m[0 * 4 + 1];
        const m02 = m[0 * 4 + 2];
        const m10 = m[1 * 4 + 0];
        const m11 = m[1 * 4 + 1];
        const m12 = m[1 * 4 + 2];
        const m20 = m[2 * 4 + 0];
        const m21 = m[2 * 4 + 1];
        const m22 = m[2 * 4 + 2];
        newDst[0] = m00;
        newDst[1] = m10;
        newDst[2] = m20;
        newDst[4] = m01;
        newDst[5] = m11;
        newDst[6] = m21;
        newDst[8] = m02;
        newDst[9] = m12;
        newDst[10] = m22;
        return newDst;
    }
    /**
     * Computes the inverse of a 3-by-3 matrix.
     * @param m - The matrix.
     * @param dst - matrix to hold result. If not passed a new one is created.
     * @returns The inverse of m.
     */
    function inverse(m, dst) {
        const newDst = (dst ?? new Ctor(12));
        const m00 = m[0 * 4 + 0];
        const m01 = m[0 * 4 + 1];
        const m02 = m[0 * 4 + 2];
        const m10 = m[1 * 4 + 0];
        const m11 = m[1 * 4 + 1];
        const m12 = m[1 * 4 + 2];
        const m20 = m[2 * 4 + 0];
        const m21 = m[2 * 4 + 1];
        const m22 = m[2 * 4 + 2];
        const b01 = m22 * m11 - m12 * m21;
        const b11 = -m22 * m10 + m12 * m20;
        const b21 = m21 * m10 - m11 * m20;
        const invDet = 1 / (m00 * b01 + m01 * b11 + m02 * b21);
        newDst[0] = b01 * invDet;
        newDst[1] = (-m22 * m01 + m02 * m21) * invDet;
        newDst[2] = (m12 * m01 - m02 * m11) * invDet;
        newDst[4] = b11 * invDet;
        newDst[5] = (m22 * m00 - m02 * m20) * invDet;
        newDst[6] = (-m12 * m00 + m02 * m10) * invDet;
        newDst[8] = b21 * invDet;
        newDst[9] = (-m21 * m00 + m01 * m20) * invDet;
        newDst[10] = (m11 * m00 - m01 * m10) * invDet;
        return newDst;
    }
    /**
     * Compute the determinant of a matrix
     * @param m - the matrix
     * @returns the determinant
     */
    function determinant(m) {
        const m00 = m[0 * 4 + 0];
        const m01 = m[0 * 4 + 1];
        const m02 = m[0 * 4 + 2];
        const m10 = m[1 * 4 + 0];
        const m11 = m[1 * 4 + 1];
        const m12 = m[1 * 4 + 2];
        const m20 = m[2 * 4 + 0];
        const m21 = m[2 * 4 + 1];
        const m22 = m[2 * 4 + 2];
        return m00 * (m11 * m22 - m21 * m12) -
            m10 * (m01 * m22 - m21 * m02) +
            m20 * (m01 * m12 - m11 * m02);
    }
    /**
     * Computes the inverse of a 3-by-3 matrix. (same as inverse)
     * @param m - The matrix.
     * @param dst - matrix to hold result. If not passed a new one is created.
     * @returns The inverse of m.
     */
    const invert = inverse;
    /**
     * Multiplies two 3-by-3 matrices with a on the left and b on the right
     * @param a - The matrix on the left.
     * @param b - The matrix on the right.
     * @param dst - matrix to hold result. If not passed a new one is created.
     * @returns The matrix product of a and b.
     */
    function multiply(a, b, dst) {
        const newDst = (dst ?? new Ctor(12));
        const a00 = a[0];
        const a01 = a[1];
        const a02 = a[2];
        const a10 = a[4 + 0];
        const a11 = a[4 + 1];
        const a12 = a[4 + 2];
        const a20 = a[8 + 0];
        const a21 = a[8 + 1];
        const a22 = a[8 + 2];
        const b00 = b[0];
        const b01 = b[1];
        const b02 = b[2];
        const b10 = b[4 + 0];
        const b11 = b[4 + 1];
        const b12 = b[4 + 2];
        const b20 = b[8 + 0];
        const b21 = b[8 + 1];
        const b22 = b[8 + 2];
        newDst[0] = a00 * b00 + a10 * b01 + a20 * b02;
        newDst[1] = a01 * b00 + a11 * b01 + a21 * b02;
        newDst[2] = a02 * b00 + a12 * b01 + a22 * b02;
        newDst[4] = a00 * b10 + a10 * b11 + a20 * b12;
        newDst[5] = a01 * b10 + a11 * b11 + a21 * b12;
        newDst[6] = a02 * b10 + a12 * b11 + a22 * b12;
        newDst[8] = a00 * b20 + a10 * b21 + a20 * b22;
        newDst[9] = a01 * b20 + a11 * b21 + a21 * b22;
        newDst[10] = a02 * b20 + a12 * b21 + a22 * b22;
        return newDst;
    }
    /**
     * Multiplies two 3-by-3 matrices with a on the left and b on the right (same as multiply)
     * @param a - The matrix on the left.
     * @param b - The matrix on the right.
     * @param dst - matrix to hold result. If not passed a new one is created.
     * @returns The matrix product of a and b.
     */
    const mul = multiply;
    /**
     * Sets the translation component of a 3-by-3 matrix to the given
     * vector.
     * @param a - The matrix.
     * @param v - The vector.
     * @param dst - matrix to hold result. If not passed a new one is created.
     * @returns The matrix with translation set.
     */
    function setTranslation(a, v, dst) {
        const newDst = (dst ?? identity());
        if (a !== newDst) {
            newDst[0] = a[0];
            newDst[1] = a[1];
            newDst[2] = a[2];
            newDst[4] = a[4];
            newDst[5] = a[5];
            newDst[6] = a[6];
        }
        newDst[8] = v[0];
        newDst[9] = v[1];
        newDst[10] = 1;
        return newDst;
    }
    /**
     * Returns the translation component of a 3-by-3 matrix as a vector with 3
     * entries.
     * @param m - The matrix.
     * @param dst - vector to hold result. If not passed a new one is created.
     * @returns The translation component of m.
     */
    function getTranslation(m, dst) {
        const newDst = (dst ?? vec2.create());
        newDst[0] = m[8];
        newDst[1] = m[9];
        return newDst;
    }
    /**
     * Returns an axis of a 3x3 matrix as a vector with 2 entries
     * @param m - The matrix.
     * @param axis - The axis 0 = x, 1 = y,
     * @returns The axis component of m.
     */
    function getAxis(m, axis, dst) {
        const newDst = (dst ?? vec2.create());
        const off = axis * 4;
        newDst[0] = m[off + 0];
        newDst[1] = m[off + 1];
        return newDst;
    }
    /**
     * Sets an axis of a 3x3 matrix as a vector with 2 entries
     * @param m - The matrix.
     * @param v - the axis vector
     * @param axis - The axis  0 = x, 1 = y;
     * @param dst - The matrix to set. If not passed a new one is created.
     * @returns The matrix with axis set.
     */
    function setAxis(m, v, axis, dst) {
        const newDst = (dst === m ? m : copy(m, dst));
        const off = axis * 4;
        newDst[off + 0] = v[0];
        newDst[off + 1] = v[1];
        return newDst;
    }
    ///**
    // * Returns the scaling component of the matrix
    // * @param m - The Matrix
    // * @param dst - The vector to set. If not passed a new one is created.
    // */
    function getScaling(m, dst) {
        const newDst = (dst ?? vec2.create());
        const xx = m[0];
        const xy = m[1];
        const yx = m[4];
        const yy = m[5];
        newDst[0] = Math.sqrt(xx * xx + xy * xy);
        newDst[1] = Math.sqrt(yx * yx + yy * yy);
        return newDst;
    }
    /**
     * Creates a 3-by-3 matrix which translates by the given vector v.
     * @param v - The vector by which to translate.
     * @param dst - matrix to hold result. If not passed a new one is created.
     * @returns The translation matrix.
     */
    function translation(v, dst) {
        const newDst = (dst ?? new Ctor(12));
        newDst[0] = 1;
        newDst[1] = 0;
        newDst[2] = 0;
        newDst[4] = 0;
        newDst[5] = 1;
        newDst[6] = 0;
        newDst[8] = v[0];
        newDst[9] = v[1];
        newDst[10] = 1;
        return newDst;
    }
    /**
     * Translates the given 3-by-3 matrix by the given vector v.
     * @param m - The matrix.
     * @param v - The vector by which to translate.
     * @param dst - matrix to hold result. If not passed a new one is created.
     * @returns The translated matrix.
     */
    function translate(m, v, dst) {
        const newDst = (dst ?? new Ctor(12));
        const v0 = v[0];
        const v1 = v[1];
        const m00 = m[0];
        const m01 = m[1];
        const m02 = m[2];
        const m10 = m[1 * 4 + 0];
        const m11 = m[1 * 4 + 1];
        const m12 = m[1 * 4 + 2];
        const m20 = m[2 * 4 + 0];
        const m21 = m[2 * 4 + 1];
        const m22 = m[2 * 4 + 2];
        if (m !== newDst) {
            newDst[0] = m00;
            newDst[1] = m01;
            newDst[2] = m02;
            newDst[4] = m10;
            newDst[5] = m11;
            newDst[6] = m12;
        }
        newDst[8] = m00 * v0 + m10 * v1 + m20;
        newDst[9] = m01 * v0 + m11 * v1 + m21;
        newDst[10] = m02 * v0 + m12 * v1 + m22;
        return newDst;
    }
    /**
     * Creates a 3-by-3 matrix which rotates  by the given angle.
     * @param angleInRadians - The angle by which to rotate (in radians).
     * @param dst - matrix to hold result. If not passed a new one is created.
     * @returns The rotation matrix.
     */
    function rotation(angleInRadians, dst) {
        const newDst = (dst ?? new Ctor(12));
        const c = Math.cos(angleInRadians);
        const s = Math.sin(angleInRadians);
        newDst[0] = c;
        newDst[1] = s;
        newDst[2] = 0;
        newDst[4] = -s;
        newDst[5] = c;
        newDst[6] = 0;
        newDst[8] = 0;
        newDst[9] = 0;
        newDst[10] = 1;
        return newDst;
    }
    /**
     * Rotates the given 3-by-3 matrix  by the given angle.
     * @param m - The matrix.
     * @param angleInRadians - The angle by which to rotate (in radians).
     * @param dst - matrix to hold result. If not passed a new one is created.
     * @returns The rotated matrix.
     */
    function rotate(m, angleInRadians, dst) {
        const newDst = (dst ?? new Ctor(12));
        const m00 = m[0 * 4 + 0];
        const m01 = m[0 * 4 + 1];
        const m02 = m[0 * 4 + 2];
        const m10 = m[1 * 4 + 0];
        const m11 = m[1 * 4 + 1];
        const m12 = m[1 * 4 + 2];
        const c = Math.cos(angleInRadians);
        const s = Math.sin(angleInRadians);
        newDst[0] = c * m00 + s * m10;
        newDst[1] = c * m01 + s * m11;
        newDst[2] = c * m02 + s * m12;
        newDst[4] = c * m10 - s * m00;
        newDst[5] = c * m11 - s * m01;
        newDst[6] = c * m12 - s * m02;
        if (m !== newDst) {
            newDst[8] = m[8];
            newDst[9] = m[9];
            newDst[10] = m[10];
        }
        return newDst;
    }
    /**
     * Creates a 3-by-3 matrix which scales in each dimension by an amount given by
     * the corresponding entry in the given vector; assumes the vector has three
     * entries.
     * @param v - A vector of
     *     2 entries specifying the factor by which to scale in each dimension.
     * @param dst - matrix to hold result. If not passed a new one is created.
     * @returns The scaling matrix.
     */
    function scaling(v, dst) {
        const newDst = (dst ?? new Ctor(12));
        newDst[0] = v[0];
        newDst[1] = 0;
        newDst[2] = 0;
        newDst[4] = 0;
        newDst[5] = v[1];
        newDst[6] = 0;
        newDst[8] = 0;
        newDst[9] = 0;
        newDst[10] = 1;
        return newDst;
    }
    /**
     * Scales the given 3-by-3 matrix in each dimension by an amount
     * given by the corresponding entry in the given vector; assumes the vector has
     * three entries.
     * @param m - The matrix to be modified.
     * @param v - A vector of 2 entries specifying the
     *     factor by which to scale in each dimension.
     * @param dst - matrix to hold result. If not passed a new one is created.
     * @returns The scaled matrix.
     */
    function scale(m, v, dst) {
        const newDst = (dst ?? new Ctor(12));
        const v0 = v[0];
        const v1 = v[1];
        newDst[0] = v0 * m[0 * 4 + 0];
        newDst[1] = v0 * m[0 * 4 + 1];
        newDst[2] = v0 * m[0 * 4 + 2];
        newDst[4] = v1 * m[1 * 4 + 0];
        newDst[5] = v1 * m[1 * 4 + 1];
        newDst[6] = v1 * m[1 * 4 + 2];
        if (m !== newDst) {
            newDst[8] = m[8];
            newDst[9] = m[9];
            newDst[10] = m[10];
        }
        return newDst;
    }
    /**
     * Creates a 3-by-3 matrix which scales uniformly in each dimension
     * @param s - Amount to scale
     * @param dst - matrix to hold result. If not passed a new one is created.
     * @returns The scaling matrix.
     */
    function uniformScaling(s, dst) {
        const newDst = (dst ?? new Ctor(12));
        newDst[0] = s;
        newDst[1] = 0;
        newDst[2] = 0;
        newDst[4] = 0;
        newDst[5] = s;
        newDst[6] = 0;
        newDst[8] = 0;
        newDst[9] = 0;
        newDst[10] = 1;
        return newDst;
    }
    /**
     * Scales the given 3-by-3 matrix in each dimension by an amount
     * given.
     * @param m - The matrix to be modified.
     * @param s - Amount to scale.
     * @param dst - matrix to hold result. If not passed a new one is created.
     * @returns The scaled matrix.
     */
    function uniformScale(m, s, dst) {
        const newDst = (dst ?? new Ctor(12));
        newDst[0] = s * m[0 * 4 + 0];
        newDst[1] = s * m[0 * 4 + 1];
        newDst[2] = s * m[0 * 4 + 2];
        newDst[4] = s * m[1 * 4 + 0];
        newDst[5] = s * m[1 * 4 + 1];
        newDst[6] = s * m[1 * 4 + 2];
        if (m !== newDst) {
            newDst[8] = m[8];
            newDst[9] = m[9];
            newDst[10] = m[10];
        }
        return newDst;
    }
    return {
        clone,
        create,
        set,
        fromMat4,
        fromQuat,
        negate,
        copy,
        equalsApproximately,
        equals,
        identity,
        transpose,
        inverse,
        invert,
        determinant,
        mul,
        multiply,
        setTranslation,
        getTranslation,
        getAxis,
        setAxis,
        getScaling,
        translation,
        translate,
        rotation,
        rotate,
        scaling,
        scale,
        uniformScaling,
        uniformScale,
    };
}
const cache$4 = new Map();
function getAPI$4(Ctor) {
    let api = cache$4.get(Ctor);
    if (!api) {
        api = getAPIImpl$4(Ctor);
        cache$4.set(Ctor, api);
    }
    return api;
}

/*
 * Copyright 2022 Gregg Tavares
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */
/**
 * Generates am typed API for Vec3
 * */
function getAPIImpl$3(Ctor) {
    /**
     * Creates a vec3; may be called with x, y, z to set initial values.
     * @param x - Initial x value.
     * @param y - Initial y value.
     * @param z - Initial z value.
     * @returns the created vector
     */
    function create(x, y, z) {
        const newDst = new Ctor(3);
        if (x !== undefined) {
            newDst[0] = x;
            if (y !== undefined) {
                newDst[1] = y;
                if (z !== undefined) {
                    newDst[2] = z;
                }
            }
        }
        return newDst;
    }
    /**
     * Creates a vec3; may be called with x, y, z to set initial values. (same as create)
     * @param x - Initial x value.
     * @param y - Initial y value.
     * @param z - Initial z value.
     * @returns the created vector
     */
    const fromValues = create;
    /**
     * Sets the values of a Vec3
     * Also see {@link vec3.create} and {@link vec3.copy}
     *
     * @param x first value
     * @param y second value
     * @param z third value
     * @param dst - vector to hold result. If not passed in a new one is created.
     * @returns A vector with its elements set.
     */
    function set(x, y, z, dst) {
        const newDst = (dst ?? new Ctor(3));
        newDst[0] = x;
        newDst[1] = y;
        newDst[2] = z;
        return newDst;
    }
    /**
     * Applies Math.ceil to each element of vector
     * @param v - Operand vector.
     * @param dst - vector to hold result. If not passed in a new one is created.
     * @returns A vector that is the ceil of each element of v.
     */
    function ceil(v, dst) {
        const newDst = (dst ?? new Ctor(3));
        newDst[0] = Math.ceil(v[0]);
        newDst[1] = Math.ceil(v[1]);
        newDst[2] = Math.ceil(v[2]);
        return newDst;
    }
    /**
     * Applies Math.floor to each element of vector
     * @param v - Operand vector.
     * @param dst - vector to hold result. If not passed in a new one is created.
     * @returns A vector that is the floor of each element of v.
     */
    function floor(v, dst) {
        const newDst = (dst ?? new Ctor(3));
        newDst[0] = Math.floor(v[0]);
        newDst[1] = Math.floor(v[1]);
        newDst[2] = Math.floor(v[2]);
        return newDst;
    }
    /**
     * Applies Math.round to each element of vector
     * @param v - Operand vector.
     * @param dst - vector to hold result. If not passed in a new one is created.
     * @returns A vector that is the round of each element of v.
     */
    function round(v, dst) {
        const newDst = (dst ?? new Ctor(3));
        newDst[0] = Math.round(v[0]);
        newDst[1] = Math.round(v[1]);
        newDst[2] = Math.round(v[2]);
        return newDst;
    }
    /**
     * Clamp each element of vector between min and max
     * @param v - Operand vector.
     * @param max - Min value, default 0
     * @param min - Max value, default 1
     * @param dst - vector to hold result. If not passed in a new one is created.
     * @returns A vector that the clamped value of each element of v.
     */
    function clamp(v, min = 0, max = 1, dst) {
        const newDst = (dst ?? new Ctor(3));
        newDst[0] = Math.min(max, Math.max(min, v[0]));
        newDst[1] = Math.min(max, Math.max(min, v[1]));
        newDst[2] = Math.min(max, Math.max(min, v[2]));
        return newDst;
    }
    /**
     * Adds two vectors; assumes a and b have the same dimension.
     * @param a - Operand vector.
     * @param b - Operand vector.
     * @param dst - vector to hold result. If not passed in a new one is created.
     * @returns A vector that is the sum of a and b.
     */
    function add(a, b, dst) {
        const newDst = (dst ?? new Ctor(3));
        newDst[0] = a[0] + b[0];
        newDst[1] = a[1] + b[1];
        newDst[2] = a[2] + b[2];
        return newDst;
    }
    /**
     * Adds two vectors, scaling the 2nd; assumes a and b have the same dimension.
     * @param a - Operand vector.
     * @param b - Operand vector.
     * @param scale - Amount to scale b
     * @param dst - vector to hold result. If not passed in a new one is created.
     * @returns A vector that is the sum of a + b * scale.
     */
    function addScaled(a, b, scale, dst) {
        const newDst = (dst ?? new Ctor(3));
        newDst[0] = a[0] + b[0] * scale;
        newDst[1] = a[1] + b[1] * scale;
        newDst[2] = a[2] + b[2] * scale;
        return newDst;
    }
    /**
     * Returns the angle in radians between two vectors.
     * @param a - Operand vector.
     * @param b - Operand vector.
     * @returns The angle in radians between the 2 vectors.
     */
    function angle(a, b) {
        const ax = a[0];
        const ay = a[1];
        const az = a[2];
        const bx = b[0];
        const by = b[1];
        const bz = b[2];
        const mag1 = Math.sqrt(ax * ax + ay * ay + az * az);
        const mag2 = Math.sqrt(bx * bx + by * by + bz * bz);
        const mag = mag1 * mag2;
        const cosine = mag && dot(a, b) / mag;
        return Math.acos(cosine);
    }
    /**
     * Subtracts two vectors.
     * @param a - Operand vector.
     * @param b - Operand vector.
     * @param dst - vector to hold result. If not passed in a new one is created.
     * @returns A vector that is the difference of a and b.
     */
    function subtract(a, b, dst) {
        const newDst = (dst ?? new Ctor(3));
        newDst[0] = a[0] - b[0];
        newDst[1] = a[1] - b[1];
        newDst[2] = a[2] - b[2];
        return newDst;
    }
    /**
     * Subtracts two vectors.
     * @param a - Operand vector.
     * @param b - Operand vector.
     * @param dst - vector to hold result. If not passed in a new one is created.
     * @returns A vector that is the difference of a and b.
     */
    const sub = subtract;
    /**
     * Check if 2 vectors are approximately equal
     * @param a - Operand vector.
     * @param b - Operand vector.
     * @returns true if vectors are approximately equal
     */
    function equalsApproximately(a, b) {
        return Math.abs(a[0] - b[0]) < EPSILON &&
            Math.abs(a[1] - b[1]) < EPSILON &&
            Math.abs(a[2] - b[2]) < EPSILON;
    }
    /**
     * Check if 2 vectors are exactly equal
     * @param a - Operand vector.
     * @param b - Operand vector.
     * @returns true if vectors are exactly equal
     */
    function equals(a, b) {
        return a[0] === b[0] && a[1] === b[1] && a[2] === b[2];
    }
    /**
     * Performs linear interpolation on two vectors.
     * Given vectors a and b and interpolation coefficient t, returns
     * a + t * (b - a).
     * @param a - Operand vector.
     * @param b - Operand vector.
     * @param t - Interpolation coefficient.
     * @param dst - vector to hold result. If not passed in a new one is created.
     * @returns The linear interpolated result.
     */
    function lerp(a, b, t, dst) {
        const newDst = (dst ?? new Ctor(3));
        newDst[0] = a[0] + t * (b[0] - a[0]);
        newDst[1] = a[1] + t * (b[1] - a[1]);
        newDst[2] = a[2] + t * (b[2] - a[2]);
        return newDst;
    }
    /**
     * Performs linear interpolation on two vectors.
     * Given vectors a and b and interpolation coefficient vector t, returns
     * a + t * (b - a).
     * @param a - Operand vector.
     * @param b - Operand vector.
     * @param t - Interpolation coefficients vector.
     * @param dst - vector to hold result. If not passed in a new one is created.
     * @returns the linear interpolated result.
     */
    function lerpV(a, b, t, dst) {
        const newDst = (dst ?? new Ctor(3));
        newDst[0] = a[0] + t[0] * (b[0] - a[0]);
        newDst[1] = a[1] + t[1] * (b[1] - a[1]);
        newDst[2] = a[2] + t[2] * (b[2] - a[2]);
        return newDst;
    }
    /**
     * Return max values of two vectors.
     * Given vectors a and b returns
     * [max(a[0], b[0]), max(a[1], b[1]), max(a[2], b[2])].
     * @param a - Operand vector.
     * @param b - Operand vector.
     * @param dst - vector to hold result. If not passed in a new one is created.
     * @returns The max components vector.
     */
    function max(a, b, dst) {
        const newDst = (dst ?? new Ctor(3));
        newDst[0] = Math.max(a[0], b[0]);
        newDst[1] = Math.max(a[1], b[1]);
        newDst[2] = Math.max(a[2], b[2]);
        return newDst;
    }
    /**
     * Return min values of two vectors.
     * Given vectors a and b returns
     * [min(a[0], b[0]), min(a[1], b[1]), min(a[2], b[2])].
     * @param a - Operand vector.
     * @param b - Operand vector.
     * @param dst - vector to hold result. If not passed in a new one is created.
     * @returns The min components vector.
     */
    function min(a, b, dst) {
        const newDst = (dst ?? new Ctor(3));
        newDst[0] = Math.min(a[0], b[0]);
        newDst[1] = Math.min(a[1], b[1]);
        newDst[2] = Math.min(a[2], b[2]);
        return newDst;
    }
    /**
     * Multiplies a vector by a scalar.
     * @param v - The vector.
     * @param k - The scalar.
     * @param dst - vector to hold result. If not passed in a new one is created.
     * @returns The scaled vector.
     */
    function mulScalar(v, k, dst) {
        const newDst = (dst ?? new Ctor(3));
        newDst[0] = v[0] * k;
        newDst[1] = v[1] * k;
        newDst[2] = v[2] * k;
        return newDst;
    }
    /**
     * Multiplies a vector by a scalar. (same as mulScalar)
     * @param v - The vector.
     * @param k - The scalar.
     * @param dst - vector to hold result. If not passed in a new one is created.
     * @returns The scaled vector.
     */
    const scale = mulScalar;
    /**
     * Divides a vector by a scalar.
     * @param v - The vector.
     * @param k - The scalar.
     * @param dst - vector to hold result. If not passed in a new one is created.
     * @returns The scaled vector.
     */
    function divScalar(v, k, dst) {
        const newDst = (dst ?? new Ctor(3));
        newDst[0] = v[0] / k;
        newDst[1] = v[1] / k;
        newDst[2] = v[2] / k;
        return newDst;
    }
    /**
     * Inverse a vector.
     * @param v - The vector.
     * @param dst - vector to hold result. If not passed in a new one is created.
     * @returns The inverted vector.
     */
    function inverse(v, dst) {
        const newDst = (dst ?? new Ctor(3));
        newDst[0] = 1 / v[0];
        newDst[1] = 1 / v[1];
        newDst[2] = 1 / v[2];
        return newDst;
    }
    /**
     * Invert a vector. (same as inverse)
     * @param v - The vector.
     * @param dst - vector to hold result. If not passed in a new one is created.
     * @returns The inverted vector.
     */
    const invert = inverse;
    /**
     * Computes the cross product of two vectors; assumes both vectors have
     * three entries.
     * @param a - Operand vector.
     * @param b - Operand vector.
     * @param dst - vector to hold result. If not passed in a new one is created.
     * @returns The vector of a cross b.
     */
    function cross(a, b, dst) {
        const newDst = (dst ?? new Ctor(3));
        const t1 = a[2] * b[0] - a[0] * b[2];
        const t2 = a[0] * b[1] - a[1] * b[0];
        newDst[0] = a[1] * b[2] - a[2] * b[1];
        newDst[1] = t1;
        newDst[2] = t2;
        return newDst;
    }
    /**
     * Computes the dot product of two vectors; assumes both vectors have
     * three entries.
     * @param a - Operand vector.
     * @param b - Operand vector.
     * @returns dot product
     */
    function dot(a, b) {
        return (a[0] * b[0]) + (a[1] * b[1]) + (a[2] * b[2]);
    }
    /**
     * Computes the length of vector
     * @param v - vector.
     * @returns length of vector.
     */
    function length(v) {
        const v0 = v[0];
        const v1 = v[1];
        const v2 = v[2];
        return Math.sqrt(v0 * v0 + v1 * v1 + v2 * v2);
    }
    /**
     * Computes the length of vector (same as length)
     * @param v - vector.
     * @returns length of vector.
     */
    const len = length;
    /**
     * Computes the square of the length of vector
     * @param v - vector.
     * @returns square of the length of vector.
     */
    function lengthSq(v) {
        const v0 = v[0];
        const v1 = v[1];
        const v2 = v[2];
        return v0 * v0 + v1 * v1 + v2 * v2;
    }
    /**
     * Computes the square of the length of vector (same as lengthSq)
     * @param v - vector.
     * @returns square of the length of vector.
     */
    const lenSq = lengthSq;
    /**
     * Computes the distance between 2 points
     * @param a - vector.
     * @param b - vector.
     * @returns distance between a and b
     */
    function distance(a, b) {
        const dx = a[0] - b[0];
        const dy = a[1] - b[1];
        const dz = a[2] - b[2];
        return Math.sqrt(dx * dx + dy * dy + dz * dz);
    }
    /**
     * Computes the distance between 2 points (same as distance)
     * @param a - vector.
     * @param b - vector.
     * @returns distance between a and b
     */
    const dist = distance;
    /**
     * Computes the square of the distance between 2 points
     * @param a - vector.
     * @param b - vector.
     * @returns square of the distance between a and b
     */
    function distanceSq(a, b) {
        const dx = a[0] - b[0];
        const dy = a[1] - b[1];
        const dz = a[2] - b[2];
        return dx * dx + dy * dy + dz * dz;
    }
    /**
     * Computes the square of the distance between 2 points (same as distanceSq)
     * @param a - vector.
     * @param b - vector.
     * @returns square of the distance between a and b
     */
    const distSq = distanceSq;
    /**
     * Divides a vector by its Euclidean length and returns the quotient.
     * @param v - The vector.
     * @param dst - vector to hold result. If not passed in a new one is created.
     * @returns The normalized vector.
     */
    function normalize(v, dst) {
        const newDst = (dst ?? new Ctor(3));
        const v0 = v[0];
        const v1 = v[1];
        const v2 = v[2];
        const len = Math.sqrt(v0 * v0 + v1 * v1 + v2 * v2);
        if (len > 0.00001) {
            newDst[0] = v0 / len;
            newDst[1] = v1 / len;
            newDst[2] = v2 / len;
        }
        else {
            newDst[0] = 0;
            newDst[1] = 0;
            newDst[2] = 0;
        }
        return newDst;
    }
    /**
     * Negates a vector.
     * @param v - The vector.
     * @param dst - vector to hold result. If not passed in a new one is created.
     * @returns -v.
     */
    function negate(v, dst) {
        const newDst = (dst ?? new Ctor(3));
        newDst[0] = -v[0];
        newDst[1] = -v[1];
        newDst[2] = -v[2];
        return newDst;
    }
    /**
     * Copies a vector. (same as {@link vec3.clone})
     * Also see {@link vec3.create} and {@link vec3.set}
     * @param v - The vector.
     * @param dst - vector to hold result. If not passed in a new one is created.
     * @returns A copy of v.
     */
    function copy(v, dst) {
        const newDst = (dst ?? new Ctor(3));
        newDst[0] = v[0];
        newDst[1] = v[1];
        newDst[2] = v[2];
        return newDst;
    }
    /**
     * Clones a vector. (same as {@link vec3.copy})
     * Also see {@link vec3.create} and {@link vec3.set}
     * @param v - The vector.
     * @param dst - vector to hold result. If not passed in a new one is created.
     * @returns A copy of v.
     */
    const clone = copy;
    /**
     * Multiplies a vector by another vector (component-wise); assumes a and
     * b have the same length.
     * @param a - Operand vector.
     * @param b - Operand vector.
     * @param dst - vector to hold result. If not passed in a new one is created.
     * @returns The vector of products of entries of a and b.
     */
    function multiply(a, b, dst) {
        const newDst = (dst ?? new Ctor(3));
        newDst[0] = a[0] * b[0];
        newDst[1] = a[1] * b[1];
        newDst[2] = a[2] * b[2];
        return newDst;
    }
    /**
     * Multiplies a vector by another vector (component-wise); assumes a and
     * b have the same length. (same as mul)
     * @param a - Operand vector.
     * @param b - Operand vector.
     * @param dst - vector to hold result. If not passed in a new one is created.
     * @returns The vector of products of entries of a and b.
     */
    const mul = multiply;
    /**
     * Divides a vector by another vector (component-wise); assumes a and
     * b have the same length.
     * @param a - Operand vector.
     * @param b - Operand vector.
     * @param dst - vector to hold result. If not passed in a new one is created.
     * @returns The vector of quotients of entries of a and b.
     */
    function divide(a, b, dst) {
        const newDst = (dst ?? new Ctor(3));
        newDst[0] = a[0] / b[0];
        newDst[1] = a[1] / b[1];
        newDst[2] = a[2] / b[2];
        return newDst;
    }
    /**
     * Divides a vector by another vector (component-wise); assumes a and
     * b have the same length. (same as divide)
     * @param a - Operand vector.
     * @param b - Operand vector.
     * @param dst - vector to hold result. If not passed in a new one is created.
     * @returns The vector of quotients of entries of a and b.
     */
    const div = divide;
    /**
     * Creates a random vector
     * @param scale - Default 1
     * @param dst - vector to hold result. If not passed in a new one is created.
     * @returns The random vector.
     */
    function random(scale = 1, dst) {
        const newDst = (dst ?? new Ctor(3));
        const angle = Math.random() * 2 * Math.PI;
        const z = Math.random() * 2 - 1;
        const zScale = Math.sqrt(1 - z * z) * scale;
        newDst[0] = Math.cos(angle) * zScale;
        newDst[1] = Math.sin(angle) * zScale;
        newDst[2] = z * scale;
        return newDst;
    }
    /**
     * Zero's a vector
     * @param dst - vector to hold result. If not passed in a new one is created.
     * @returns The zeroed vector.
     */
    function zero(dst) {
        const newDst = (dst ?? new Ctor(3));
        newDst[0] = 0;
        newDst[1] = 0;
        newDst[2] = 0;
        return newDst;
    }
    /**
     * transform vec3 by 4x4 matrix
     * @param v - the vector
     * @param m - The matrix.
     * @param dst - optional vec3 to store result. If not passed a new one is created.
     * @returns the transformed vector
     */
    function transformMat4(v, m, dst) {
        const newDst = (dst ?? new Ctor(3));
        const x = v[0];
        const y = v[1];
        const z = v[2];
        const w = (m[3] * x + m[7] * y + m[11] * z + m[15]) || 1;
        newDst[0] = (m[0] * x + m[4] * y + m[8] * z + m[12]) / w;
        newDst[1] = (m[1] * x + m[5] * y + m[9] * z + m[13]) / w;
        newDst[2] = (m[2] * x + m[6] * y + m[10] * z + m[14]) / w;
        return newDst;
    }
    /**
     * Transform vec3 by upper 3x3 matrix inside 4x4 matrix.
     * @param v - The direction.
     * @param m - The matrix.
     * @param dst - optional vec3 to store result. If not passed a new one is created.
     * @returns The transformed vector.
     */
    function transformMat4Upper3x3(v, m, dst) {
        const newDst = (dst ?? new Ctor(3));
        const v0 = v[0];
        const v1 = v[1];
        const v2 = v[2];
        newDst[0] = v0 * m[0 * 4 + 0] + v1 * m[1 * 4 + 0] + v2 * m[2 * 4 + 0];
        newDst[1] = v0 * m[0 * 4 + 1] + v1 * m[1 * 4 + 1] + v2 * m[2 * 4 + 1];
        newDst[2] = v0 * m[0 * 4 + 2] + v1 * m[1 * 4 + 2] + v2 * m[2 * 4 + 2];
        return newDst;
    }
    /**
     * Transforms vec3 by 3x3 matrix
     *
     * @param v - the vector
     * @param m - The matrix.
     * @param dst - optional vec3 to store result. If not passed a new one is created.
     * @returns the transformed vector
     */
    function transformMat3(v, m, dst) {
        const newDst = (dst ?? new Ctor(3));
        const x = v[0];
        const y = v[1];
        const z = v[2];
        newDst[0] = x * m[0] + y * m[4] + z * m[8];
        newDst[1] = x * m[1] + y * m[5] + z * m[9];
        newDst[2] = x * m[2] + y * m[6] + z * m[10];
        return newDst;
    }
    /**
     * Transforms vec3 by Quaternion
     * @param v - the vector to transform
     * @param q - the quaternion to transform by
     * @param dst - optional vec3 to store result. If not passed a new one is created.
     * @returns the transformed
     */
    function transformQuat(v, q, dst) {
        const newDst = (dst ?? new Ctor(3));
        const qx = q[0];
        const qy = q[1];
        const qz = q[2];
        const w2 = q[3] * 2;
        const x = v[0];
        const y = v[1];
        const z = v[2];
        const uvX = qy * z - qz * y;
        const uvY = qz * x - qx * z;
        const uvZ = qx * y - qy * x;
        newDst[0] = x + uvX * w2 + (qy * uvZ - qz * uvY) * 2;
        newDst[1] = y + uvY * w2 + (qz * uvX - qx * uvZ) * 2;
        newDst[2] = z + uvZ * w2 + (qx * uvY - qy * uvX) * 2;
        return newDst;
    }
    /**
     * Returns the translation component of a 4-by-4 matrix as a vector with 3
     * entries.
     * @param m - The matrix.
     * @param dst - vector to hold result. If not passed a new one is created.
     * @returns The translation component of m.
     */
    function getTranslation(m, dst) {
        const newDst = (dst ?? new Ctor(3));
        newDst[0] = m[12];
        newDst[1] = m[13];
        newDst[2] = m[14];
        return newDst;
    }
    /**
     * Returns an axis of a 4x4 matrix as a vector with 3 entries
     * @param m - The matrix.
     * @param axis - The axis 0 = x, 1 = y, 2 = z;
     * @returns The axis component of m.
     */
    function getAxis(m, axis, dst) {
        const newDst = (dst ?? new Ctor(3));
        const off = axis * 4;
        newDst[0] = m[off + 0];
        newDst[1] = m[off + 1];
        newDst[2] = m[off + 2];
        return newDst;
    }
    /**
     * Returns the scaling component of the matrix
     * @param m - The Matrix
     * @param dst - The vector to set. If not passed a new one is created.
     */
    function getScaling(m, dst) {
        const newDst = (dst ?? new Ctor(3));
        const xx = m[0];
        const xy = m[1];
        const xz = m[2];
        const yx = m[4];
        const yy = m[5];
        const yz = m[6];
        const zx = m[8];
        const zy = m[9];
        const zz = m[10];
        newDst[0] = Math.sqrt(xx * xx + xy * xy + xz * xz);
        newDst[1] = Math.sqrt(yx * yx + yy * yy + yz * yz);
        newDst[2] = Math.sqrt(zx * zx + zy * zy + zz * zz);
        return newDst;
    }
    /**
     * Rotate a 3D vector around the x-axis
     *
     * @param {ReadonlyVec3} a The vec3 point to rotate
     * @param {ReadonlyVec3} b The origin of the rotation
     * @param {Number} rad The angle of rotation in radians
     * @param dst - The vector to set. If not passed a new one is created.
     * @returns the rotated vector
     */
    function rotateX(a, b, rad, dst) {
        const newDst = (dst ?? new Ctor(3));
        const p = [];
        const r = [];
        //Translate point to the origin
        p[0] = a[0] - b[0];
        p[1] = a[1] - b[1];
        p[2] = a[2] - b[2];
        //perform rotation
        r[0] = p[0];
        r[1] = p[1] * Math.cos(rad) - p[2] * Math.sin(rad);
        r[2] = p[1] * Math.sin(rad) + p[2] * Math.cos(rad);
        //translate to correct position
        newDst[0] = r[0] + b[0];
        newDst[1] = r[1] + b[1];
        newDst[2] = r[2] + b[2];
        return newDst;
    }
    /**
     * Rotate a 3D vector around the y-axis
     *
     * @param {ReadonlyVec3} a The vec3 point to rotate
     * @param {ReadonlyVec3} b The origin of the rotation
     * @param {Number} rad The angle of rotation in radians
     * @param dst - The vector to set. If not passed a new one is created.
     * @returns the rotated vector
     */
    function rotateY(a, b, rad, dst) {
        const newDst = (dst ?? new Ctor(3));
        const p = [];
        const r = [];
        // translate point to the origin
        p[0] = a[0] - b[0];
        p[1] = a[1] - b[1];
        p[2] = a[2] - b[2];
        // perform rotation
        r[0] = p[2] * Math.sin(rad) + p[0] * Math.cos(rad);
        r[1] = p[1];
        r[2] = p[2] * Math.cos(rad) - p[0] * Math.sin(rad);
        // translate to correct position
        newDst[0] = r[0] + b[0];
        newDst[1] = r[1] + b[1];
        newDst[2] = r[2] + b[2];
        return newDst;
    }
    /**
     * Rotate a 3D vector around the z-axis
     *
     * @param {ReadonlyVec3} a The vec3 point to rotate
     * @param {ReadonlyVec3} b The origin of the rotation
     * @param {Number} rad The angle of rotation in radians
     * @param dst - The vector to set. If not passed a new one is created.
     * @returns {vec3} out
     */
    function rotateZ(a, b, rad, dst) {
        const newDst = (dst ?? new Ctor(3));
        const p = [];
        const r = [];
        // translate point to the origin
        p[0] = a[0] - b[0];
        p[1] = a[1] - b[1];
        p[2] = a[2] - b[2];
        // perform rotation
        r[0] = p[0] * Math.cos(rad) - p[1] * Math.sin(rad);
        r[1] = p[0] * Math.sin(rad) + p[1] * Math.cos(rad);
        r[2] = p[2];
        // translate to correct position
        newDst[0] = r[0] + b[0];
        newDst[1] = r[1] + b[1];
        newDst[2] = r[2] + b[2];
        return newDst;
    }
    /**
     * Treat a 3D vector as a direction and set it's length
     *
     * @param a The vec3 to lengthen
     * @param len The length of the resulting vector
     * @returns The lengthened vector
     */
    function setLength(a, len, dst) {
        const newDst = (dst ?? new Ctor(3));
        normalize(a, newDst);
        return mulScalar(newDst, len, newDst);
    }
    /**
     * Ensure a vector is not longer than a max length
     *
     * @param a The vec3 to limit
     * @param maxLen The longest length of the resulting vector
     * @returns The vector, shortened to maxLen if it's too long
     */
    function truncate(a, maxLen, dst) {
        const newDst = (dst ?? new Ctor(3));
        if (length(a) > maxLen) {
            return setLength(a, maxLen, newDst);
        }
        return copy(a, newDst);
    }
    /**
     * Return the vector exactly between 2 endpoint vectors
     *
     * @param a Endpoint 1
     * @param b Endpoint 2
     * @returns The vector exactly residing between endpoints 1 and 2
     */
    function midpoint(a, b, dst) {
        const newDst = (dst ?? new Ctor(3));
        return lerp(a, b, 0.5, newDst);
    }
    return {
        create,
        fromValues,
        set,
        ceil,
        floor,
        round,
        clamp,
        add,
        addScaled,
        angle,
        subtract,
        sub,
        equalsApproximately,
        equals,
        lerp,
        lerpV,
        max,
        min,
        mulScalar,
        scale,
        divScalar,
        inverse,
        invert,
        cross,
        dot,
        length,
        len,
        lengthSq,
        lenSq,
        distance,
        dist,
        distanceSq,
        distSq,
        normalize,
        negate,
        copy,
        clone,
        multiply,
        mul,
        divide,
        div,
        random,
        zero,
        transformMat4,
        transformMat4Upper3x3,
        transformMat3,
        transformQuat,
        getTranslation,
        getAxis,
        getScaling,
        rotateX,
        rotateY,
        rotateZ,
        setLength,
        truncate,
        midpoint,
    };
}
const cache$3 = new Map();
function getAPI$3(Ctor) {
    let api = cache$3.get(Ctor);
    if (!api) {
        api = getAPIImpl$3(Ctor);
        cache$3.set(Ctor, api);
    }
    return api;
}

/**
 * Generates a typed API for Mat4
 * */
function getAPIImpl$2(Ctor) {
    const vec3 = getAPI$3(Ctor);
    /**
     * 4x4 Matrix math math functions.
     *
     * Almost all functions take an optional `newDst` argument. If it is not passed in the
     * functions will create a new matrix. In other words you can do this
     *
     *     const mat = mat4.translation([1, 2, 3]);  // Creates a new translation matrix
     *
     * or
     *
     *     const mat = mat4.create();
     *     mat4.translation([1, 2, 3], mat);  // Puts translation matrix in mat.
     *
     * The first style is often easier but depending on where it's used it generates garbage where
     * as there is almost never allocation with the second style.
     *
     * It is always save to pass any matrix as the destination. So for example
     *
     *     const mat = mat4.identity();
     *     const trans = mat4.translation([1, 2, 3]);
     *     mat4.multiply(mat, trans, mat);  // Multiplies mat * trans and puts result in mat.
     *
     */
    /**
     * Create a Mat4 from values
     *
     * Note: Since passing in a raw JavaScript array
     * is valid in all circumstances, if you want to
     * force a JavaScript array into a Mat4's specified type
     * it would be faster to use
     *
     * ```
     * const m = mat4.clone(someJSArray);
     * ```
     *
     * @param v0 - value for element 0
     * @param v1 - value for element 1
     * @param v2 - value for element 2
     * @param v3 - value for element 3
     * @param v4 - value for element 4
     * @param v5 - value for element 5
     * @param v6 - value for element 6
     * @param v7 - value for element 7
     * @param v8 - value for element 8
     * @param v9 - value for element 9
     * @param v10 - value for element 10
     * @param v11 - value for element 11
     * @param v12 - value for element 12
     * @param v13 - value for element 13
     * @param v14 - value for element 14
     * @param v15 - value for element 15
     * @returns created from values.
     */
    function create(v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15) {
        const newDst = new Ctor(16);
        if (v0 !== undefined) {
            newDst[0] = v0;
            if (v1 !== undefined) {
                newDst[1] = v1;
                if (v2 !== undefined) {
                    newDst[2] = v2;
                    if (v3 !== undefined) {
                        newDst[3] = v3;
                        if (v4 !== undefined) {
                            newDst[4] = v4;
                            if (v5 !== undefined) {
                                newDst[5] = v5;
                                if (v6 !== undefined) {
                                    newDst[6] = v6;
                                    if (v7 !== undefined) {
                                        newDst[7] = v7;
                                        if (v8 !== undefined) {
                                            newDst[8] = v8;
                                            if (v9 !== undefined) {
                                                newDst[9] = v9;
                                                if (v10 !== undefined) {
                                                    newDst[10] = v10;
                                                    if (v11 !== undefined) {
                                                        newDst[11] = v11;
                                                        if (v12 !== undefined) {
                                                            newDst[12] = v12;
                                                            if (v13 !== undefined) {
                                                                newDst[13] = v13;
                                                                if (v14 !== undefined) {
                                                                    newDst[14] = v14;
                                                                    if (v15 !== undefined) {
                                                                        newDst[15] = v15;
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
        return newDst;
    }
    /**
     * Sets the values of a Mat4
     * Also see {@link mat4.create} and {@link mat4.copy}
     *
     * @param v0 - value for element 0
     * @param v1 - value for element 1
     * @param v2 - value for element 2
     * @param v3 - value for element 3
     * @param v4 - value for element 4
     * @param v5 - value for element 5
     * @param v6 - value for element 6
     * @param v7 - value for element 7
     * @param v8 - value for element 8
     * @param v9 - value for element 9
     * @param v10 - value for element 10
     * @param v11 - value for element 11
     * @param v12 - value for element 12
     * @param v13 - value for element 13
     * @param v14 - value for element 14
     * @param v15 - value for element 15
     * @param dst - matrix to hold result. If not passed a new one is created.
     * @returns Mat4 created from values.
     */
    function set(v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, dst) {
        const newDst = (dst ?? new Ctor(16));
        newDst[0] = v0;
        newDst[1] = v1;
        newDst[2] = v2;
        newDst[3] = v3;
        newDst[4] = v4;
        newDst[5] = v5;
        newDst[6] = v6;
        newDst[7] = v7;
        newDst[8] = v8;
        newDst[9] = v9;
        newDst[10] = v10;
        newDst[11] = v11;
        newDst[12] = v12;
        newDst[13] = v13;
        newDst[14] = v14;
        newDst[15] = v15;
        return newDst;
    }
    /**
     * Creates a Mat4 from a Mat3
     * @param m3 - source matrix
     * @param dst - matrix to hold result. If not passed a new one is created.
     * @returns Mat4 made from m3
     */
    function fromMat3(m3, dst) {
        const newDst = (dst ?? new Ctor(16));
        newDst[0] = m3[0];
        newDst[1] = m3[1];
        newDst[2] = m3[2];
        newDst[3] = 0;
        newDst[4] = m3[4];
        newDst[5] = m3[5];
        newDst[6] = m3[6];
        newDst[7] = 0;
        newDst[8] = m3[8];
        newDst[9] = m3[9];
        newDst[10] = m3[10];
        newDst[11] = 0;
        newDst[12] = 0;
        newDst[13] = 0;
        newDst[14] = 0;
        newDst[15] = 1;
        return newDst;
    }
    /**
     * Creates a Mat4 rotation matrix from a quaternion
     * @param q - quaternion to create matrix from
     * @param dst - matrix to hold result. If not passed a new one is created.
     * @returns Mat4 made from q
     */
    function fromQuat(q, dst) {
        const newDst = (dst ?? new Ctor(16));
        const x = q[0];
        const y = q[1];
        const z = q[2];
        const w = q[3];
        const x2 = x + x;
        const y2 = y + y;
        const z2 = z + z;
        const xx = x * x2;
        const yx = y * x2;
        const yy = y * y2;
        const zx = z * x2;
        const zy = z * y2;
        const zz = z * z2;
        const wx = w * x2;
        const wy = w * y2;
        const wz = w * z2;
        newDst[0] = 1 - yy - zz;
        newDst[1] = yx + wz;
        newDst[2] = zx - wy;
        newDst[3] = 0;
        newDst[4] = yx - wz;
        newDst[5] = 1 - xx - zz;
        newDst[6] = zy + wx;
        newDst[7] = 0;
        newDst[8] = zx + wy;
        newDst[9] = zy - wx;
        newDst[10] = 1 - xx - yy;
        newDst[11] = 0;
        newDst[12] = 0;
        newDst[13] = 0;
        newDst[14] = 0;
        newDst[15] = 1;
        return newDst;
    }
    /**
     * Negates a matrix.
     * @param m - The matrix.
     * @param dst - matrix to hold result. If not passed a new one is created.
     * @returns -m.
     */
    function negate(m, dst) {
        const newDst = (dst ?? new Ctor(16));
        newDst[0] = -m[0];
        newDst[1] = -m[1];
        newDst[2] = -m[2];
        newDst[3] = -m[3];
        newDst[4] = -m[4];
        newDst[5] = -m[5];
        newDst[6] = -m[6];
        newDst[7] = -m[7];
        newDst[8] = -m[8];
        newDst[9] = -m[9];
        newDst[10] = -m[10];
        newDst[11] = -m[11];
        newDst[12] = -m[12];
        newDst[13] = -m[13];
        newDst[14] = -m[14];
        newDst[15] = -m[15];
        return newDst;
    }
    /**
     * Copies a matrix. (same as {@link mat4.clone})
     * Also see {@link mat4.create} and {@link mat4.set}
     * @param m - The matrix.
     * @param dst - The matrix. If not passed a new one is created.
     * @returns A copy of m.
     */
    function copy(m, dst) {
        const newDst = (dst ?? new Ctor(16));
        newDst[0] = m[0];
        newDst[1] = m[1];
        newDst[2] = m[2];
        newDst[3] = m[3];
        newDst[4] = m[4];
        newDst[5] = m[5];
        newDst[6] = m[6];
        newDst[7] = m[7];
        newDst[8] = m[8];
        newDst[9] = m[9];
        newDst[10] = m[10];
        newDst[11] = m[11];
        newDst[12] = m[12];
        newDst[13] = m[13];
        newDst[14] = m[14];
        newDst[15] = m[15];
        return newDst;
    }
    /**
     * Copies a matrix (same as {@link mat4.copy})
     * Also see {@link mat4.create} and {@link mat4.set}
     * @param m - The matrix.
     * @param dst - The matrix. If not passed a new one is created.
     * @returns A copy of m.
     */
    const clone = copy;
    /**
     * Check if 2 matrices are approximately equal
     * @param a - Operand matrix.
     * @param b - Operand matrix.
     * @returns true if matrices are approximately equal
     */
    function equalsApproximately(a, b) {
        return Math.abs(a[0] - b[0]) < EPSILON &&
            Math.abs(a[1] - b[1]) < EPSILON &&
            Math.abs(a[2] - b[2]) < EPSILON &&
            Math.abs(a[3] - b[3]) < EPSILON &&
            Math.abs(a[4] - b[4]) < EPSILON &&
            Math.abs(a[5] - b[5]) < EPSILON &&
            Math.abs(a[6] - b[6]) < EPSILON &&
            Math.abs(a[7] - b[7]) < EPSILON &&
            Math.abs(a[8] - b[8]) < EPSILON &&
            Math.abs(a[9] - b[9]) < EPSILON &&
            Math.abs(a[10] - b[10]) < EPSILON &&
            Math.abs(a[11] - b[11]) < EPSILON &&
            Math.abs(a[12] - b[12]) < EPSILON &&
            Math.abs(a[13] - b[13]) < EPSILON &&
            Math.abs(a[14] - b[14]) < EPSILON &&
            Math.abs(a[15] - b[15]) < EPSILON;
    }
    /**
     * Check if 2 matrices are exactly equal
     * @param a - Operand matrix.
     * @param b - Operand matrix.
     * @returns true if matrices are exactly equal
     */
    function equals(a, b) {
        return a[0] === b[0] &&
            a[1] === b[1] &&
            a[2] === b[2] &&
            a[3] === b[3] &&
            a[4] === b[4] &&
            a[5] === b[5] &&
            a[6] === b[6] &&
            a[7] === b[7] &&
            a[8] === b[8] &&
            a[9] === b[9] &&
            a[10] === b[10] &&
            a[11] === b[11] &&
            a[12] === b[12] &&
            a[13] === b[13] &&
            a[14] === b[14] &&
            a[15] === b[15];
    }
    /**
     * Creates a 4-by-4 identity matrix.
     *
     * @param dst - matrix to hold result. If not passed a new one is created.
     * @returns A 4-by-4 identity matrix.
     */
    function identity(dst) {
        const newDst = (dst ?? new Ctor(16));
        newDst[0] = 1;
        newDst[1] = 0;
        newDst[2] = 0;
        newDst[3] = 0;
        newDst[4] = 0;
        newDst[5] = 1;
        newDst[6] = 0;
        newDst[7] = 0;
        newDst[8] = 0;
        newDst[9] = 0;
        newDst[10] = 1;
        newDst[11] = 0;
        newDst[12] = 0;
        newDst[13] = 0;
        newDst[14] = 0;
        newDst[15] = 1;
        return newDst;
    }
    /**
     * Takes the transpose of a matrix.
     * @param m - The matrix.
     * @param dst - matrix to hold result. If not passed a new one is created.
     * @returns The transpose of m.
     */
    function transpose(m, dst) {
        const newDst = (dst ?? new Ctor(16));
        if (newDst === m) {
            let t;
            t = m[1];
            m[1] = m[4];
            m[4] = t;
            t = m[2];
            m[2] = m[8];
            m[8] = t;
            t = m[3];
            m[3] = m[12];
            m[12] = t;
            t = m[6];
            m[6] = m[9];
            m[9] = t;
            t = m[7];
            m[7] = m[13];
            m[13] = t;
            t = m[11];
            m[11] = m[14];
            m[14] = t;
            return newDst;
        }
        const m00 = m[0 * 4 + 0];
        const m01 = m[0 * 4 + 1];
        const m02 = m[0 * 4 + 2];
        const m03 = m[0 * 4 + 3];
        const m10 = m[1 * 4 + 0];
        const m11 = m[1 * 4 + 1];
        const m12 = m[1 * 4 + 2];
        const m13 = m[1 * 4 + 3];
        const m20 = m[2 * 4 + 0];
        const m21 = m[2 * 4 + 1];
        const m22 = m[2 * 4 + 2];
        const m23 = m[2 * 4 + 3];
        const m30 = m[3 * 4 + 0];
        const m31 = m[3 * 4 + 1];
        const m32 = m[3 * 4 + 2];
        const m33 = m[3 * 4 + 3];
        newDst[0] = m00;
        newDst[1] = m10;
        newDst[2] = m20;
        newDst[3] = m30;
        newDst[4] = m01;
        newDst[5] = m11;
        newDst[6] = m21;
        newDst[7] = m31;
        newDst[8] = m02;
        newDst[9] = m12;
        newDst[10] = m22;
        newDst[11] = m32;
        newDst[12] = m03;
        newDst[13] = m13;
        newDst[14] = m23;
        newDst[15] = m33;
        return newDst;
    }
    /**
     * Computes the inverse of a 4-by-4 matrix.
     * @param m - The matrix.
     * @param dst - matrix to hold result. If not passed a new one is created.
     * @returns The inverse of m.
     */
    function inverse(m, dst) {
        const newDst = (dst ?? new Ctor(16));
        const m00 = m[0 * 4 + 0];
        const m01 = m[0 * 4 + 1];
        const m02 = m[0 * 4 + 2];
        const m03 = m[0 * 4 + 3];
        const m10 = m[1 * 4 + 0];
        const m11 = m[1 * 4 + 1];
        const m12 = m[1 * 4 + 2];
        const m13 = m[1 * 4 + 3];
        const m20 = m[2 * 4 + 0];
        const m21 = m[2 * 4 + 1];
        const m22 = m[2 * 4 + 2];
        const m23 = m[2 * 4 + 3];
        const m30 = m[3 * 4 + 0];
        const m31 = m[3 * 4 + 1];
        const m32 = m[3 * 4 + 2];
        const m33 = m[3 * 4 + 3];
        const tmp0 = m22 * m33;
        const tmp1 = m32 * m23;
        const tmp2 = m12 * m33;
        const tmp3 = m32 * m13;
        const tmp4 = m12 * m23;
        const tmp5 = m22 * m13;
        const tmp6 = m02 * m33;
        const tmp7 = m32 * m03;
        const tmp8 = m02 * m23;
        const tmp9 = m22 * m03;
        const tmp10 = m02 * m13;
        const tmp11 = m12 * m03;
        const tmp12 = m20 * m31;
        const tmp13 = m30 * m21;
        const tmp14 = m10 * m31;
        const tmp15 = m30 * m11;
        const tmp16 = m10 * m21;
        const tmp17 = m20 * m11;
        const tmp18 = m00 * m31;
        const tmp19 = m30 * m01;
        const tmp20 = m00 * m21;
        const tmp21 = m20 * m01;
        const tmp22 = m00 * m11;
        const tmp23 = m10 * m01;
        const t0 = (tmp0 * m11 + tmp3 * m21 + tmp4 * m31) -
            (tmp1 * m11 + tmp2 * m21 + tmp5 * m31);
        const t1 = (tmp1 * m01 + tmp6 * m21 + tmp9 * m31) -
            (tmp0 * m01 + tmp7 * m21 + tmp8 * m31);
        const t2 = (tmp2 * m01 + tmp7 * m11 + tmp10 * m31) -
            (tmp3 * m01 + tmp6 * m11 + tmp11 * m31);
        const t3 = (tmp5 * m01 + tmp8 * m11 + tmp11 * m21) -
            (tmp4 * m01 + tmp9 * m11 + tmp10 * m21);
        const d = 1 / (m00 * t0 + m10 * t1 + m20 * t2 + m30 * t3);
        newDst[0] = d * t0;
        newDst[1] = d * t1;
        newDst[2] = d * t2;
        newDst[3] = d * t3;
        newDst[4] = d * ((tmp1 * m10 + tmp2 * m20 + tmp5 * m30) -
            (tmp0 * m10 + tmp3 * m20 + tmp4 * m30));
        newDst[5] = d * ((tmp0 * m00 + tmp7 * m20 + tmp8 * m30) -
            (tmp1 * m00 + tmp6 * m20 + tmp9 * m30));
        newDst[6] = d * ((tmp3 * m00 + tmp6 * m10 + tmp11 * m30) -
            (tmp2 * m00 + tmp7 * m10 + tmp10 * m30));
        newDst[7] = d * ((tmp4 * m00 + tmp9 * m10 + tmp10 * m20) -
            (tmp5 * m00 + tmp8 * m10 + tmp11 * m20));
        newDst[8] = d * ((tmp12 * m13 + tmp15 * m23 + tmp16 * m33) -
            (tmp13 * m13 + tmp14 * m23 + tmp17 * m33));
        newDst[9] = d * ((tmp13 * m03 + tmp18 * m23 + tmp21 * m33) -
            (tmp12 * m03 + tmp19 * m23 + tmp20 * m33));
        newDst[10] = d * ((tmp14 * m03 + tmp19 * m13 + tmp22 * m33) -
            (tmp15 * m03 + tmp18 * m13 + tmp23 * m33));
        newDst[11] = d * ((tmp17 * m03 + tmp20 * m13 + tmp23 * m23) -
            (tmp16 * m03 + tmp21 * m13 + tmp22 * m23));
        newDst[12] = d * ((tmp14 * m22 + tmp17 * m32 + tmp13 * m12) -
            (tmp16 * m32 + tmp12 * m12 + tmp15 * m22));
        newDst[13] = d * ((tmp20 * m32 + tmp12 * m02 + tmp19 * m22) -
            (tmp18 * m22 + tmp21 * m32 + tmp13 * m02));
        newDst[14] = d * ((tmp18 * m12 + tmp23 * m32 + tmp15 * m02) -
            (tmp22 * m32 + tmp14 * m02 + tmp19 * m12));
        newDst[15] = d * ((tmp22 * m22 + tmp16 * m02 + tmp21 * m12) -
            (tmp20 * m12 + tmp23 * m22 + tmp17 * m02));
        return newDst;
    }
    /**
     * Compute the determinant of a matrix
     * @param m - the matrix
     * @returns the determinant
     */
    function determinant(m) {
        const m00 = m[0 * 4 + 0];
        const m01 = m[0 * 4 + 1];
        const m02 = m[0 * 4 + 2];
        const m03 = m[0 * 4 + 3];
        const m10 = m[1 * 4 + 0];
        const m11 = m[1 * 4 + 1];
        const m12 = m[1 * 4 + 2];
        const m13 = m[1 * 4 + 3];
        const m20 = m[2 * 4 + 0];
        const m21 = m[2 * 4 + 1];
        const m22 = m[2 * 4 + 2];
        const m23 = m[2 * 4 + 3];
        const m30 = m[3 * 4 + 0];
        const m31 = m[3 * 4 + 1];
        const m32 = m[3 * 4 + 2];
        const m33 = m[3 * 4 + 3];
        const tmp0 = m22 * m33;
        const tmp1 = m32 * m23;
        const tmp2 = m12 * m33;
        const tmp3 = m32 * m13;
        const tmp4 = m12 * m23;
        const tmp5 = m22 * m13;
        const tmp6 = m02 * m33;
        const tmp7 = m32 * m03;
        const tmp8 = m02 * m23;
        const tmp9 = m22 * m03;
        const tmp10 = m02 * m13;
        const tmp11 = m12 * m03;
        const t0 = (tmp0 * m11 + tmp3 * m21 + tmp4 * m31) -
            (tmp1 * m11 + tmp2 * m21 + tmp5 * m31);
        const t1 = (tmp1 * m01 + tmp6 * m21 + tmp9 * m31) -
            (tmp0 * m01 + tmp7 * m21 + tmp8 * m31);
        const t2 = (tmp2 * m01 + tmp7 * m11 + tmp10 * m31) -
            (tmp3 * m01 + tmp6 * m11 + tmp11 * m31);
        const t3 = (tmp5 * m01 + tmp8 * m11 + tmp11 * m21) -
            (tmp4 * m01 + tmp9 * m11 + tmp10 * m21);
        return m00 * t0 + m10 * t1 + m20 * t2 + m30 * t3;
    }
    /**
     * Computes the inverse of a 4-by-4 matrix. (same as inverse)
     * @param m - The matrix.
     * @param dst - matrix to hold result. If not passed a new one is created.
     * @returns The inverse of m.
     */
    const invert = inverse;
    /**
     * Multiplies two 4-by-4 matrices with a on the left and b on the right
     * @param a - The matrix on the left.
     * @param b - The matrix on the right.
     * @param dst - matrix to hold result. If not passed a new one is created.
     * @returns The matrix product of a and b.
     */
    function multiply(a, b, dst) {
        const newDst = (dst ?? new Ctor(16));
        const a00 = a[0];
        const a01 = a[1];
        const a02 = a[2];
        const a03 = a[3];
        const a10 = a[4 + 0];
        const a11 = a[4 + 1];
        const a12 = a[4 + 2];
        const a13 = a[4 + 3];
        const a20 = a[8 + 0];
        const a21 = a[8 + 1];
        const a22 = a[8 + 2];
        const a23 = a[8 + 3];
        const a30 = a[12 + 0];
        const a31 = a[12 + 1];
        const a32 = a[12 + 2];
        const a33 = a[12 + 3];
        const b00 = b[0];
        const b01 = b[1];
        const b02 = b[2];
        const b03 = b[3];
        const b10 = b[4 + 0];
        const b11 = b[4 + 1];
        const b12 = b[4 + 2];
        const b13 = b[4 + 3];
        const b20 = b[8 + 0];
        const b21 = b[8 + 1];
        const b22 = b[8 + 2];
        const b23 = b[8 + 3];
        const b30 = b[12 + 0];
        const b31 = b[12 + 1];
        const b32 = b[12 + 2];
        const b33 = b[12 + 3];
        newDst[0] = a00 * b00 + a10 * b01 + a20 * b02 + a30 * b03;
        newDst[1] = a01 * b00 + a11 * b01 + a21 * b02 + a31 * b03;
        newDst[2] = a02 * b00 + a12 * b01 + a22 * b02 + a32 * b03;
        newDst[3] = a03 * b00 + a13 * b01 + a23 * b02 + a33 * b03;
        newDst[4] = a00 * b10 + a10 * b11 + a20 * b12 + a30 * b13;
        newDst[5] = a01 * b10 + a11 * b11 + a21 * b12 + a31 * b13;
        newDst[6] = a02 * b10 + a12 * b11 + a22 * b12 + a32 * b13;
        newDst[7] = a03 * b10 + a13 * b11 + a23 * b12 + a33 * b13;
        newDst[8] = a00 * b20 + a10 * b21 + a20 * b22 + a30 * b23;
        newDst[9] = a01 * b20 + a11 * b21 + a21 * b22 + a31 * b23;
        newDst[10] = a02 * b20 + a12 * b21 + a22 * b22 + a32 * b23;
        newDst[11] = a03 * b20 + a13 * b21 + a23 * b22 + a33 * b23;
        newDst[12] = a00 * b30 + a10 * b31 + a20 * b32 + a30 * b33;
        newDst[13] = a01 * b30 + a11 * b31 + a21 * b32 + a31 * b33;
        newDst[14] = a02 * b30 + a12 * b31 + a22 * b32 + a32 * b33;
        newDst[15] = a03 * b30 + a13 * b31 + a23 * b32 + a33 * b33;
        return newDst;
    }
    /**
     * Multiplies two 4-by-4 matrices with a on the left and b on the right (same as multiply)
     * @param a - The matrix on the left.
     * @param b - The matrix on the right.
     * @param dst - matrix to hold result. If not passed a new one is created.
     * @returns The matrix product of a and b.
     */
    const mul = multiply;
    /**
     * Sets the translation component of a 4-by-4 matrix to the given
     * vector.
     * @param a - The matrix.
     * @param v - The vector.
     * @param dst - matrix to hold result. If not passed a new one is created.
     * @returns The matrix with translation set.
     */
    function setTranslation(a, v, dst) {
        const newDst = (dst ?? identity());
        if (a !== newDst) {
            newDst[0] = a[0];
            newDst[1] = a[1];
            newDst[2] = a[2];
            newDst[3] = a[3];
            newDst[4] = a[4];
            newDst[5] = a[5];
            newDst[6] = a[6];
            newDst[7] = a[7];
            newDst[8] = a[8];
            newDst[9] = a[9];
            newDst[10] = a[10];
            newDst[11] = a[11];
        }
        newDst[12] = v[0];
        newDst[13] = v[1];
        newDst[14] = v[2];
        newDst[15] = 1;
        return newDst;
    }
    ///**
    // * Returns the translation component of a 4-by-4 matrix as a vector with 3
    // * entries.
    // * @param m - The matrix.
    // * @param dst - vector to hold result. If not passed a new one is created.
    // * @returns The translation component of m.
    // */
    function getTranslation(m, dst) {
        const newDst = (dst ?? vec3.create());
        newDst[0] = m[12];
        newDst[1] = m[13];
        newDst[2] = m[14];
        return newDst;
    }
    /**
     * Returns an axis of a 4x4 matrix as a vector with 3 entries
     * @param m - The matrix.
     * @param axis - The axis 0 = x, 1 = y, 2 = z;
     * @returns The axis component of m.
     */
    function getAxis(m, axis, dst) {
        const newDst = (dst ?? vec3.create());
        const off = axis * 4;
        newDst[0] = m[off + 0];
        newDst[1] = m[off + 1];
        newDst[2] = m[off + 2];
        return newDst;
    }
    /**
     * Sets an axis of a 4x4 matrix as a vector with 3 entries
     * @param m - The matrix.
     * @param v - the axis vector
     * @param axis - The axis  0 = x, 1 = y, 2 = z;
     * @param dst - The matrix to set. If not passed a new one is created.
     * @returns The matrix with axis set.
     */
    function setAxis(m, v, axis, dst) {
        const newDst = (dst === m) ? dst : copy(m, dst);
        const off = axis * 4;
        newDst[off + 0] = v[0];
        newDst[off + 1] = v[1];
        newDst[off + 2] = v[2];
        return newDst;
    }
    ///**
    // * Returns the scaling component of the matrix
    // * @param m - The Matrix
    // * @param dst - The vector to set. If not passed a new one is created.
    // */
    function getScaling(m, dst) {
        const newDst = (dst ?? vec3.create());
        const xx = m[0];
        const xy = m[1];
        const xz = m[2];
        const yx = m[4];
        const yy = m[5];
        const yz = m[6];
        const zx = m[8];
        const zy = m[9];
        const zz = m[10];
        newDst[0] = Math.sqrt(xx * xx + xy * xy + xz * xz);
        newDst[1] = Math.sqrt(yx * yx + yy * yy + yz * yz);
        newDst[2] = Math.sqrt(zx * zx + zy * zy + zz * zz);
        return newDst;
    }
    /**
     * Computes a 4-by-4 perspective transformation matrix given the angular height
     * of the frustum, the aspect ratio, and the near and far clipping planes.  The
     * arguments define a frustum extending in the negative z direction.  The given
     * angle is the vertical angle of the frustum, and the horizontal angle is
     * determined to produce the given aspect ratio.  The arguments near and far are
     * the distances to the near and far clipping planes.  Note that near and far
     * are not z coordinates, but rather they are distances along the negative
     * z-axis.  The matrix generated sends the viewing frustum to the unit box.
     * We assume a unit box extending from -1 to 1 in the x and y dimensions and
     * from 0 to 1 in the z dimension.
     *
     * Note: If you pass `Infinity` for zFar then it will produce a projection matrix
     * returns -Infinity for Z when transforming coordinates with Z <= 0 and +Infinity for Z
     * otherwise.
     *
     * @param fieldOfViewYInRadians - The camera angle from top to bottom (in radians).
     * @param aspect - The aspect ratio width / height.
     * @param zNear - The depth (negative z coordinate)
     *     of the near clipping plane.
     * @param zFar - The depth (negative z coordinate)
     *     of the far clipping plane.
     * @param dst - matrix to hold result. If not passed a new one is created.
     * @returns The perspective matrix.
     */
    function perspective(fieldOfViewYInRadians, aspect, zNear, zFar, dst) {
        const newDst = (dst ?? new Ctor(16));
        const f = Math.tan(Math.PI * 0.5 - 0.5 * fieldOfViewYInRadians);
        newDst[0] = f / aspect;
        newDst[1] = 0;
        newDst[2] = 0;
        newDst[3] = 0;
        newDst[4] = 0;
        newDst[5] = f;
        newDst[6] = 0;
        newDst[7] = 0;
        newDst[8] = 0;
        newDst[9] = 0;
        newDst[11] = -1;
        newDst[12] = 0;
        newDst[13] = 0;
        newDst[15] = 0;
        if (Number.isFinite(zFar)) {
            const rangeInv = 1 / (zNear - zFar);
            newDst[10] = zFar * rangeInv;
            newDst[14] = zFar * zNear * rangeInv;
        }
        else {
            newDst[10] = -1;
            newDst[14] = -zNear;
        }
        return newDst;
    }
    /**
     * Computes a 4-by-4 reverse-z perspective transformation matrix given the angular height
     * of the frustum, the aspect ratio, and the near and far clipping planes.  The
     * arguments define a frustum extending in the negative z direction.  The given
     * angle is the vertical angle of the frustum, and the horizontal angle is
     * determined to produce the given aspect ratio.  The arguments near and far are
     * the distances to the near and far clipping planes.  Note that near and far
     * are not z coordinates, but rather they are distances along the negative
     * z-axis.  The matrix generated sends the viewing frustum to the unit box.
     * We assume a unit box extending from -1 to 1 in the x and y dimensions and
     * from 1 (at -zNear) to 0 (at -zFar) in the z dimension.
     *
     * @param fieldOfViewYInRadians - The camera angle from top to bottom (in radians).
     * @param aspect - The aspect ratio width / height.
     * @param zNear - The depth (negative z coordinate)
     *     of the near clipping plane.
     * @param zFar - The depth (negative z coordinate)
     *     of the far clipping plane. (default = Infinity)
     * @param dst - matrix to hold result. If not passed a new one is created.
     * @returns The perspective matrix.
     */ function perspectiveReverseZ(fieldOfViewYInRadians, aspect, zNear, zFar = Infinity, dst) {
        const newDst = (dst ?? new Ctor(16));
        const f = 1 / Math.tan(fieldOfViewYInRadians * 0.5);
        newDst[0] = f / aspect;
        newDst[1] = 0;
        newDst[2] = 0;
        newDst[3] = 0;
        newDst[4] = 0;
        newDst[5] = f;
        newDst[6] = 0;
        newDst[7] = 0;
        newDst[8] = 0;
        newDst[9] = 0;
        newDst[11] = -1;
        newDst[12] = 0;
        newDst[13] = 0;
        newDst[15] = 0;
        if (zFar === Infinity) {
            newDst[10] = 0;
            newDst[14] = zNear;
        }
        else {
            const rangeInv = 1 / (zFar - zNear);
            newDst[10] = zNear * rangeInv;
            newDst[14] = zFar * zNear * rangeInv;
        }
        return newDst;
    }
    /**
     * Computes a 4-by-4 orthogonal transformation matrix that transforms from
     * the given the left, right, bottom, and top dimensions to -1 +1 in x, and y
     * and 0 to +1 in z.
     * @param left - Left side of the near clipping plane viewport.
     * @param right - Right side of the near clipping plane viewport.
     * @param bottom - Bottom of the near clipping plane viewport.
     * @param top - Top of the near clipping plane viewport.
     * @param near - The depth (negative z coordinate)
     *     of the near clipping plane.
     * @param far - The depth (negative z coordinate)
     *     of the far clipping plane.
     * @param dst - Output matrix. If not passed a new one is created.
     * @returns The orthographic projection matrix.
     */
    function ortho(left, right, bottom, top, near, far, dst) {
        const newDst = (dst ?? new Ctor(16));
        newDst[0] = 2 / (right - left);
        newDst[1] = 0;
        newDst[2] = 0;
        newDst[3] = 0;
        newDst[4] = 0;
        newDst[5] = 2 / (top - bottom);
        newDst[6] = 0;
        newDst[7] = 0;
        newDst[8] = 0;
        newDst[9] = 0;
        newDst[10] = 1 / (near - far);
        newDst[11] = 0;
        newDst[12] = (right + left) / (left - right);
        newDst[13] = (top + bottom) / (bottom - top);
        newDst[14] = near / (near - far);
        newDst[15] = 1;
        return newDst;
    }
    /**
     * Computes a 4-by-4 perspective transformation matrix given the left, right,
     * top, bottom, near and far clipping planes. The arguments define a frustum
     * extending in the negative z direction. The arguments near and far are the
     * distances to the near and far clipping planes. Note that near and far are not
     * z coordinates, but rather they are distances along the negative z-axis. The
     * matrix generated sends the viewing frustum to the unit box. We assume a unit
     * box extending from -1 to 1 in the x and y dimensions and from 0 to 1 in the z
     * dimension.
     * @param left - The x coordinate of the left plane of the box.
     * @param right - The x coordinate of the right plane of the box.
     * @param bottom - The y coordinate of the bottom plane of the box.
     * @param top - The y coordinate of the right plane of the box.
     * @param near - The negative z coordinate of the near plane of the box.
     * @param far - The negative z coordinate of the far plane of the box.
     * @param dst - Output matrix. If not passed a new one is created.
     * @returns The perspective projection matrix.
     */
    function frustum(left, right, bottom, top, near, far, dst) {
        const newDst = (dst ?? new Ctor(16));
        const dx = (right - left);
        const dy = (top - bottom);
        const dz = (near - far);
        newDst[0] = 2 * near / dx;
        newDst[1] = 0;
        newDst[2] = 0;
        newDst[3] = 0;
        newDst[4] = 0;
        newDst[5] = 2 * near / dy;
        newDst[6] = 0;
        newDst[7] = 0;
        newDst[8] = (left + right) / dx;
        newDst[9] = (top + bottom) / dy;
        newDst[10] = far / dz;
        newDst[11] = -1;
        newDst[12] = 0;
        newDst[13] = 0;
        newDst[14] = near * far / dz;
        newDst[15] = 0;
        return newDst;
    }
    /**
     * Computes a 4-by-4 reverse-z perspective transformation matrix given the left, right,
     * top, bottom, near and far clipping planes. The arguments define a frustum
     * extending in the negative z direction. The arguments near and far are the
     * distances to the near and far clipping planes. Note that near and far are not
     * z coordinates, but rather they are distances along the negative z-axis. The
     * matrix generated sends the viewing frustum to the unit box. We assume a unit
     * box extending from -1 to 1 in the x and y dimensions and from 1 (-near) to 0 (-far) in the z
     * dimension.
     * @param left - The x coordinate of the left plane of the box.
     * @param right - The x coordinate of the right plane of the box.
     * @param bottom - The y coordinate of the bottom plane of the box.
     * @param top - The y coordinate of the right plane of the box.
     * @param near - The negative z coordinate of the near plane of the box.
     * @param far - The negative z coordinate of the far plane of the box.
     * @param dst - Output matrix. If not passed a new one is created.
     * @returns The perspective projection matrix.
     */
    function frustumReverseZ(left, right, bottom, top, near, far = Infinity, dst) {
        const newDst = (dst ?? new Ctor(16));
        const dx = (right - left);
        const dy = (top - bottom);
        newDst[0] = 2 * near / dx;
        newDst[1] = 0;
        newDst[2] = 0;
        newDst[3] = 0;
        newDst[4] = 0;
        newDst[5] = 2 * near / dy;
        newDst[6] = 0;
        newDst[7] = 0;
        newDst[8] = (left + right) / dx;
        newDst[9] = (top + bottom) / dy;
        newDst[11] = -1;
        newDst[12] = 0;
        newDst[13] = 0;
        newDst[15] = 0;
        if (far === Infinity) {
            newDst[10] = 0;
            newDst[14] = near;
        }
        else {
            const rangeInv = 1 / (far - near);
            newDst[10] = near * rangeInv;
            newDst[14] = far * near * rangeInv;
        }
        return newDst;
    }
    const xAxis = vec3.create();
    const yAxis = vec3.create();
    const zAxis = vec3.create();
    /**
     * Computes a 4-by-4 aim transformation.
     *
     * This is a matrix which positions an object aiming down positive Z.
     * toward the target.
     *
     * Note: this is **NOT** the inverse of lookAt as lookAt looks at negative Z.
     *
     * @param position - The position of the object.
     * @param target - The position meant to be aimed at.
     * @param up - A vector pointing up.
     * @param dst - matrix to hold result. If not passed a new one is created.
     * @returns The aim matrix.
     */
    function aim(position, target, up, dst) {
        const newDst = (dst ?? new Ctor(16));
        vec3.normalize(vec3.subtract(target, position, zAxis), zAxis);
        vec3.normalize(vec3.cross(up, zAxis, xAxis), xAxis);
        vec3.normalize(vec3.cross(zAxis, xAxis, yAxis), yAxis);
        newDst[0] = xAxis[0];
        newDst[1] = xAxis[1];
        newDst[2] = xAxis[2];
        newDst[3] = 0;
        newDst[4] = yAxis[0];
        newDst[5] = yAxis[1];
        newDst[6] = yAxis[2];
        newDst[7] = 0;
        newDst[8] = zAxis[0];
        newDst[9] = zAxis[1];
        newDst[10] = zAxis[2];
        newDst[11] = 0;
        newDst[12] = position[0];
        newDst[13] = position[1];
        newDst[14] = position[2];
        newDst[15] = 1;
        return newDst;
    }
    /**
     * Computes a 4-by-4 camera aim transformation.
     *
     * This is a matrix which positions an object aiming down negative Z.
     * toward the target.
     *
     * Note: this is the inverse of `lookAt`
     *
     * @param eye - The position of the object.
     * @param target - The position meant to be aimed at.
     * @param up - A vector pointing up.
     * @param dst - matrix to hold result. If not passed a new one is created.
     * @returns The aim matrix.
     */
    function cameraAim(eye, target, up, dst) {
        const newDst = (dst ?? new Ctor(16));
        vec3.normalize(vec3.subtract(eye, target, zAxis), zAxis);
        vec3.normalize(vec3.cross(up, zAxis, xAxis), xAxis);
        vec3.normalize(vec3.cross(zAxis, xAxis, yAxis), yAxis);
        newDst[0] = xAxis[0];
        newDst[1] = xAxis[1];
        newDst[2] = xAxis[2];
        newDst[3] = 0;
        newDst[4] = yAxis[0];
        newDst[5] = yAxis[1];
        newDst[6] = yAxis[2];
        newDst[7] = 0;
        newDst[8] = zAxis[0];
        newDst[9] = zAxis[1];
        newDst[10] = zAxis[2];
        newDst[11] = 0;
        newDst[12] = eye[0];
        newDst[13] = eye[1];
        newDst[14] = eye[2];
        newDst[15] = 1;
        return newDst;
    }
    /**
     * Computes a 4-by-4 view transformation.
     *
     * This is a view matrix which transforms all other objects
     * to be in the space of the view defined by the parameters.
     *
     * @param eye - The position of the object.
     * @param target - The position meant to be aimed at.
     * @param up - A vector pointing up.
     * @param dst - matrix to hold result. If not passed a new one is created.
     * @returns The look-at matrix.
     */
    function lookAt(eye, target, up, dst) {
        const newDst = (dst ?? new Ctor(16));
        vec3.normalize(vec3.subtract(eye, target, zAxis), zAxis);
        vec3.normalize(vec3.cross(up, zAxis, xAxis), xAxis);
        vec3.normalize(vec3.cross(zAxis, xAxis, yAxis), yAxis);
        newDst[0] = xAxis[0];
        newDst[1] = yAxis[0];
        newDst[2] = zAxis[0];
        newDst[3] = 0;
        newDst[4] = xAxis[1];
        newDst[5] = yAxis[1];
        newDst[6] = zAxis[1];
        newDst[7] = 0;
        newDst[8] = xAxis[2];
        newDst[9] = yAxis[2];
        newDst[10] = zAxis[2];
        newDst[11] = 0;
        newDst[12] = -(xAxis[0] * eye[0] + xAxis[1] * eye[1] + xAxis[2] * eye[2]);
        newDst[13] = -(yAxis[0] * eye[0] + yAxis[1] * eye[1] + yAxis[2] * eye[2]);
        newDst[14] = -(zAxis[0] * eye[0] + zAxis[1] * eye[1] + zAxis[2] * eye[2]);
        newDst[15] = 1;
        return newDst;
    }
    /**
     * Creates a 4-by-4 matrix which translates by the given vector v.
     * @param v - The vector by
     *     which to translate.
     * @param dst - matrix to hold result. If not passed a new one is created.
     * @returns The translation matrix.
     */
    function translation(v, dst) {
        const newDst = (dst ?? new Ctor(16));
        newDst[0] = 1;
        newDst[1] = 0;
        newDst[2] = 0;
        newDst[3] = 0;
        newDst[4] = 0;
        newDst[5] = 1;
        newDst[6] = 0;
        newDst[7] = 0;
        newDst[8] = 0;
        newDst[9] = 0;
        newDst[10] = 1;
        newDst[11] = 0;
        newDst[12] = v[0];
        newDst[13] = v[1];
        newDst[14] = v[2];
        newDst[15] = 1;
        return newDst;
    }
    /**
     * Translates the given 4-by-4 matrix by the given vector v.
     * @param m - The matrix.
     * @param v - The vector by
     *     which to translate.
     * @param dst - matrix to hold result. If not passed a new one is created.
     * @returns The translated matrix.
     */
    function translate(m, v, dst) {
        const newDst = (dst ?? new Ctor(16));
        const v0 = v[0];
        const v1 = v[1];
        const v2 = v[2];
        const m00 = m[0];
        const m01 = m[1];
        const m02 = m[2];
        const m03 = m[3];
        const m10 = m[1 * 4 + 0];
        const m11 = m[1 * 4 + 1];
        const m12 = m[1 * 4 + 2];
        const m13 = m[1 * 4 + 3];
        const m20 = m[2 * 4 + 0];
        const m21 = m[2 * 4 + 1];
        const m22 = m[2 * 4 + 2];
        const m23 = m[2 * 4 + 3];
        const m30 = m[3 * 4 + 0];
        const m31 = m[3 * 4 + 1];
        const m32 = m[3 * 4 + 2];
        const m33 = m[3 * 4 + 3];
        if (m !== newDst) {
            newDst[0] = m00;
            newDst[1] = m01;
            newDst[2] = m02;
            newDst[3] = m03;
            newDst[4] = m10;
            newDst[5] = m11;
            newDst[6] = m12;
            newDst[7] = m13;
            newDst[8] = m20;
            newDst[9] = m21;
            newDst[10] = m22;
            newDst[11] = m23;
        }
        newDst[12] = m00 * v0 + m10 * v1 + m20 * v2 + m30;
        newDst[13] = m01 * v0 + m11 * v1 + m21 * v2 + m31;
        newDst[14] = m02 * v0 + m12 * v1 + m22 * v2 + m32;
        newDst[15] = m03 * v0 + m13 * v1 + m23 * v2 + m33;
        return newDst;
    }
    /**
     * Creates a 4-by-4 matrix which rotates around the x-axis by the given angle.
     * @param angleInRadians - The angle by which to rotate (in radians).
     * @param dst - matrix to hold result. If not passed a new one is created.
     * @returns The rotation matrix.
     */
    function rotationX(angleInRadians, dst) {
        const newDst = (dst ?? new Ctor(16));
        const c = Math.cos(angleInRadians);
        const s = Math.sin(angleInRadians);
        newDst[0] = 1;
        newDst[1] = 0;
        newDst[2] = 0;
        newDst[3] = 0;
        newDst[4] = 0;
        newDst[5] = c;
        newDst[6] = s;
        newDst[7] = 0;
        newDst[8] = 0;
        newDst[9] = -s;
        newDst[10] = c;
        newDst[11] = 0;
        newDst[12] = 0;
        newDst[13] = 0;
        newDst[14] = 0;
        newDst[15] = 1;
        return newDst;
    }
    /**
     * Rotates the given 4-by-4 matrix around the x-axis by the given
     * angle.
     * @param m - The matrix.
     * @param angleInRadians - The angle by which to rotate (in radians).
     * @param dst - matrix to hold result. If not passed a new one is created.
     * @returns The rotated matrix.
     */
    function rotateX(m, angleInRadians, dst) {
        const newDst = (dst ?? new Ctor(16));
        const m10 = m[4];
        const m11 = m[5];
        const m12 = m[6];
        const m13 = m[7];
        const m20 = m[8];
        const m21 = m[9];
        const m22 = m[10];
        const m23 = m[11];
        const c = Math.cos(angleInRadians);
        const s = Math.sin(angleInRadians);
        newDst[4] = c * m10 + s * m20;
        newDst[5] = c * m11 + s * m21;
        newDst[6] = c * m12 + s * m22;
        newDst[7] = c * m13 + s * m23;
        newDst[8] = c * m20 - s * m10;
        newDst[9] = c * m21 - s * m11;
        newDst[10] = c * m22 - s * m12;
        newDst[11] = c * m23 - s * m13;
        if (m !== newDst) {
            newDst[0] = m[0];
            newDst[1] = m[1];
            newDst[2] = m[2];
            newDst[3] = m[3];
            newDst[12] = m[12];
            newDst[13] = m[13];
            newDst[14] = m[14];
            newDst[15] = m[15];
        }
        return newDst;
    }
    /**
     * Creates a 4-by-4 matrix which rotates around the y-axis by the given angle.
     * @param angleInRadians - The angle by which to rotate (in radians).
     * @param dst - matrix to hold result. If not passed a new one is created.
     * @returns The rotation matrix.
     */
    function rotationY(angleInRadians, dst) {
        const newDst = (dst ?? new Ctor(16));
        const c = Math.cos(angleInRadians);
        const s = Math.sin(angleInRadians);
        newDst[0] = c;
        newDst[1] = 0;
        newDst[2] = -s;
        newDst[3] = 0;
        newDst[4] = 0;
        newDst[5] = 1;
        newDst[6] = 0;
        newDst[7] = 0;
        newDst[8] = s;
        newDst[9] = 0;
        newDst[10] = c;
        newDst[11] = 0;
        newDst[12] = 0;
        newDst[13] = 0;
        newDst[14] = 0;
        newDst[15] = 1;
        return newDst;
    }
    /**
     * Rotates the given 4-by-4 matrix around the y-axis by the given
     * angle.
     * @param m - The matrix.
     * @param angleInRadians - The angle by which to rotate (in radians).
     * @param dst - matrix to hold result. If not passed a new one is created.
     * @returns The rotated matrix.
     */
    function rotateY(m, angleInRadians, dst) {
        const newDst = (dst ?? new Ctor(16));
        const m00 = m[0 * 4 + 0];
        const m01 = m[0 * 4 + 1];
        const m02 = m[0 * 4 + 2];
        const m03 = m[0 * 4 + 3];
        const m20 = m[2 * 4 + 0];
        const m21 = m[2 * 4 + 1];
        const m22 = m[2 * 4 + 2];
        const m23 = m[2 * 4 + 3];
        const c = Math.cos(angleInRadians);
        const s = Math.sin(angleInRadians);
        newDst[0] = c * m00 - s * m20;
        newDst[1] = c * m01 - s * m21;
        newDst[2] = c * m02 - s * m22;
        newDst[3] = c * m03 - s * m23;
        newDst[8] = c * m20 + s * m00;
        newDst[9] = c * m21 + s * m01;
        newDst[10] = c * m22 + s * m02;
        newDst[11] = c * m23 + s * m03;
        if (m !== newDst) {
            newDst[4] = m[4];
            newDst[5] = m[5];
            newDst[6] = m[6];
            newDst[7] = m[7];
            newDst[12] = m[12];
            newDst[13] = m[13];
            newDst[14] = m[14];
            newDst[15] = m[15];
        }
        return newDst;
    }
    /**
     * Creates a 4-by-4 matrix which rotates around the z-axis by the given angle.
     * @param angleInRadians - The angle by which to rotate (in radians).
     * @param dst - matrix to hold result. If not passed a new one is created.
     * @returns The rotation matrix.
     */
    function rotationZ(angleInRadians, dst) {
        const newDst = (dst ?? new Ctor(16));
        const c = Math.cos(angleInRadians);
        const s = Math.sin(angleInRadians);
        newDst[0] = c;
        newDst[1] = s;
        newDst[2] = 0;
        newDst[3] = 0;
        newDst[4] = -s;
        newDst[5] = c;
        newDst[6] = 0;
        newDst[7] = 0;
        newDst[8] = 0;
        newDst[9] = 0;
        newDst[10] = 1;
        newDst[11] = 0;
        newDst[12] = 0;
        newDst[13] = 0;
        newDst[14] = 0;
        newDst[15] = 1;
        return newDst;
    }
    /**
     * Rotates the given 4-by-4 matrix around the z-axis by the given
     * angle.
     * @param m - The matrix.
     * @param angleInRadians - The angle by which to rotate (in radians).
     * @param dst - matrix to hold result. If not passed a new one is created.
     * @returns The rotated matrix.
     */
    function rotateZ(m, angleInRadians, dst) {
        const newDst = (dst ?? new Ctor(16));
        const m00 = m[0 * 4 + 0];
        const m01 = m[0 * 4 + 1];
        const m02 = m[0 * 4 + 2];
        const m03 = m[0 * 4 + 3];
        const m10 = m[1 * 4 + 0];
        const m11 = m[1 * 4 + 1];
        const m12 = m[1 * 4 + 2];
        const m13 = m[1 * 4 + 3];
        const c = Math.cos(angleInRadians);
        const s = Math.sin(angleInRadians);
        newDst[0] = c * m00 + s * m10;
        newDst[1] = c * m01 + s * m11;
        newDst[2] = c * m02 + s * m12;
        newDst[3] = c * m03 + s * m13;
        newDst[4] = c * m10 - s * m00;
        newDst[5] = c * m11 - s * m01;
        newDst[6] = c * m12 - s * m02;
        newDst[7] = c * m13 - s * m03;
        if (m !== newDst) {
            newDst[8] = m[8];
            newDst[9] = m[9];
            newDst[10] = m[10];
            newDst[11] = m[11];
            newDst[12] = m[12];
            newDst[13] = m[13];
            newDst[14] = m[14];
            newDst[15] = m[15];
        }
        return newDst;
    }
    /**
     * Creates a 4-by-4 matrix which rotates around the given axis by the given
     * angle.
     * @param axis - The axis
     *     about which to rotate.
     * @param angleInRadians - The angle by which to rotate (in radians).
     * @param dst - matrix to hold result. If not passed a new one is created.
     * @returns A matrix which rotates angle radians
     *     around the axis.
     */
    function axisRotation(axis, angleInRadians, dst) {
        const newDst = (dst ?? new Ctor(16));
        let x = axis[0];
        let y = axis[1];
        let z = axis[2];
        const n = Math.sqrt(x * x + y * y + z * z);
        x /= n;
        y /= n;
        z /= n;
        const xx = x * x;
        const yy = y * y;
        const zz = z * z;
        const c = Math.cos(angleInRadians);
        const s = Math.sin(angleInRadians);
        const oneMinusCosine = 1 - c;
        newDst[0] = xx + (1 - xx) * c;
        newDst[1] = x * y * oneMinusCosine + z * s;
        newDst[2] = x * z * oneMinusCosine - y * s;
        newDst[3] = 0;
        newDst[4] = x * y * oneMinusCosine - z * s;
        newDst[5] = yy + (1 - yy) * c;
        newDst[6] = y * z * oneMinusCosine + x * s;
        newDst[7] = 0;
        newDst[8] = x * z * oneMinusCosine + y * s;
        newDst[9] = y * z * oneMinusCosine - x * s;
        newDst[10] = zz + (1 - zz) * c;
        newDst[11] = 0;
        newDst[12] = 0;
        newDst[13] = 0;
        newDst[14] = 0;
        newDst[15] = 1;
        return newDst;
    }
    /**
     * Creates a 4-by-4 matrix which rotates around the given axis by the given
     * angle. (same as axisRotation)
     * @param axis - The axis
     *     about which to rotate.
     * @param angleInRadians - The angle by which to rotate (in radians).
     * @param dst - matrix to hold result. If not passed a new one is created.
     * @returns A matrix which rotates angle radians
     *     around the axis.
     */
    const rotation = axisRotation;
    /**
     * Rotates the given 4-by-4 matrix around the given axis by the
     * given angle.
     * @param m - The matrix.
     * @param axis - The axis
     *     about which to rotate.
     * @param angleInRadians - The angle by which to rotate (in radians).
     * @param dst - matrix to hold result. If not passed a new one is created.
     * @returns The rotated matrix.
     */
    function axisRotate(m, axis, angleInRadians, dst) {
        const newDst = (dst ?? new Ctor(16));
        let x = axis[0];
        let y = axis[1];
        let z = axis[2];
        const n = Math.sqrt(x * x + y * y + z * z);
        x /= n;
        y /= n;
        z /= n;
        const xx = x * x;
        const yy = y * y;
        const zz = z * z;
        const c = Math.cos(angleInRadians);
        const s = Math.sin(angleInRadians);
        const oneMinusCosine = 1 - c;
        const r00 = xx + (1 - xx) * c;
        const r01 = x * y * oneMinusCosine + z * s;
        const r02 = x * z * oneMinusCosine - y * s;
        const r10 = x * y * oneMinusCosine - z * s;
        const r11 = yy + (1 - yy) * c;
        const r12 = y * z * oneMinusCosine + x * s;
        const r20 = x * z * oneMinusCosine + y * s;
        const r21 = y * z * oneMinusCosine - x * s;
        const r22 = zz + (1 - zz) * c;
        const m00 = m[0];
        const m01 = m[1];
        const m02 = m[2];
        const m03 = m[3];
        const m10 = m[4];
        const m11 = m[5];
        const m12 = m[6];
        const m13 = m[7];
        const m20 = m[8];
        const m21 = m[9];
        const m22 = m[10];
        const m23 = m[11];
        newDst[0] = r00 * m00 + r01 * m10 + r02 * m20;
        newDst[1] = r00 * m01 + r01 * m11 + r02 * m21;
        newDst[2] = r00 * m02 + r01 * m12 + r02 * m22;
        newDst[3] = r00 * m03 + r01 * m13 + r02 * m23;
        newDst[4] = r10 * m00 + r11 * m10 + r12 * m20;
        newDst[5] = r10 * m01 + r11 * m11 + r12 * m21;
        newDst[6] = r10 * m02 + r11 * m12 + r12 * m22;
        newDst[7] = r10 * m03 + r11 * m13 + r12 * m23;
        newDst[8] = r20 * m00 + r21 * m10 + r22 * m20;
        newDst[9] = r20 * m01 + r21 * m11 + r22 * m21;
        newDst[10] = r20 * m02 + r21 * m12 + r22 * m22;
        newDst[11] = r20 * m03 + r21 * m13 + r22 * m23;
        if (m !== newDst) {
            newDst[12] = m[12];
            newDst[13] = m[13];
            newDst[14] = m[14];
            newDst[15] = m[15];
        }
        return newDst;
    }
    /**
     * Rotates the given 4-by-4 matrix around the given axis by the
     * given angle. (same as rotate)
     * @param m - The matrix.
     * @param axis - The axis
     *     about which to rotate.
     * @param angleInRadians - The angle by which to rotate (in radians).
     * @param dst - matrix to hold result. If not passed a new one is created.
     * @returns The rotated matrix.
     */
    const rotate = axisRotate;
    /**
     * Creates a 4-by-4 matrix which scales in each dimension by an amount given by
     * the corresponding entry in the given vector; assumes the vector has three
     * entries.
     * @param v - A vector of
     *     three entries specifying the factor by which to scale in each dimension.
     * @param dst - matrix to hold result. If not passed a new one is created.
     * @returns The scaling matrix.
     */
    function scaling(v, dst) {
        const newDst = (dst ?? new Ctor(16));
        newDst[0] = v[0];
        newDst[1] = 0;
        newDst[2] = 0;
        newDst[3] = 0;
        newDst[4] = 0;
        newDst[5] = v[1];
        newDst[6] = 0;
        newDst[7] = 0;
        newDst[8] = 0;
        newDst[9] = 0;
        newDst[10] = v[2];
        newDst[11] = 0;
        newDst[12] = 0;
        newDst[13] = 0;
        newDst[14] = 0;
        newDst[15] = 1;
        return newDst;
    }
    /**
     * Scales the given 4-by-4 matrix in each dimension by an amount
     * given by the corresponding entry in the given vector; assumes the vector has
     * three entries.
     * @param m - The matrix to be modified.
     * @param v - A vector of three entries specifying the
     *     factor by which to scale in each dimension.
     * @param dst - matrix to hold result. If not passed a new one is created.
     * @returns The scaled matrix.
     */
    function scale(m, v, dst) {
        const newDst = (dst ?? new Ctor(16));
        const v0 = v[0];
        const v1 = v[1];
        const v2 = v[2];
        newDst[0] = v0 * m[0 * 4 + 0];
        newDst[1] = v0 * m[0 * 4 + 1];
        newDst[2] = v0 * m[0 * 4 + 2];
        newDst[3] = v0 * m[0 * 4 + 3];
        newDst[4] = v1 * m[1 * 4 + 0];
        newDst[5] = v1 * m[1 * 4 + 1];
        newDst[6] = v1 * m[1 * 4 + 2];
        newDst[7] = v1 * m[1 * 4 + 3];
        newDst[8] = v2 * m[2 * 4 + 0];
        newDst[9] = v2 * m[2 * 4 + 1];
        newDst[10] = v2 * m[2 * 4 + 2];
        newDst[11] = v2 * m[2 * 4 + 3];
        if (m !== newDst) {
            newDst[12] = m[12];
            newDst[13] = m[13];
            newDst[14] = m[14];
            newDst[15] = m[15];
        }
        return newDst;
    }
    /**
     * Creates a 4-by-4 matrix which scales a uniform amount in each dimension.
     * @param s - the amount to scale
     * @param dst - matrix to hold result. If not passed a new one is created.
     * @returns The scaling matrix.
     */
    function uniformScaling(s, dst) {
        const newDst = (dst ?? new Ctor(16));
        newDst[0] = s;
        newDst[1] = 0;
        newDst[2] = 0;
        newDst[3] = 0;
        newDst[4] = 0;
        newDst[5] = s;
        newDst[6] = 0;
        newDst[7] = 0;
        newDst[8] = 0;
        newDst[9] = 0;
        newDst[10] = s;
        newDst[11] = 0;
        newDst[12] = 0;
        newDst[13] = 0;
        newDst[14] = 0;
        newDst[15] = 1;
        return newDst;
    }
    /**
     * Scales the given 4-by-4 matrix in each dimension by a uniform scale.
     * @param m - The matrix to be modified.
     * @param s - The amount to scale.
     * @param dst - matrix to hold result. If not passed a new one is created.
     * @returns The scaled matrix.
     */
    function uniformScale(m, s, dst) {
        const newDst = (dst ?? new Ctor(16));
        newDst[0] = s * m[0 * 4 + 0];
        newDst[1] = s * m[0 * 4 + 1];
        newDst[2] = s * m[0 * 4 + 2];
        newDst[3] = s * m[0 * 4 + 3];
        newDst[4] = s * m[1 * 4 + 0];
        newDst[5] = s * m[1 * 4 + 1];
        newDst[6] = s * m[1 * 4 + 2];
        newDst[7] = s * m[1 * 4 + 3];
        newDst[8] = s * m[2 * 4 + 0];
        newDst[9] = s * m[2 * 4 + 1];
        newDst[10] = s * m[2 * 4 + 2];
        newDst[11] = s * m[2 * 4 + 3];
        if (m !== newDst) {
            newDst[12] = m[12];
            newDst[13] = m[13];
            newDst[14] = m[14];
            newDst[15] = m[15];
        }
        return newDst;
    }
    return {
        create,
        set,
        fromMat3,
        fromQuat,
        negate,
        copy,
        clone,
        equalsApproximately,
        equals,
        identity,
        transpose,
        inverse,
        determinant,
        invert,
        multiply,
        mul,
        setTranslation,
        getTranslation,
        getAxis,
        setAxis,
        getScaling,
        perspective,
        perspectiveReverseZ,
        ortho,
        frustum,
        frustumReverseZ,
        aim,
        cameraAim,
        lookAt,
        translation,
        translate,
        rotationX,
        rotateX,
        rotationY,
        rotateY,
        rotationZ,
        rotateZ,
        axisRotation,
        rotation,
        axisRotate,
        rotate,
        scaling,
        scale,
        uniformScaling,
        uniformScale,
    };
}
const cache$2 = new Map();
function getAPI$2(Ctor) {
    let api = cache$2.get(Ctor);
    if (!api) {
        api = getAPIImpl$2(Ctor);
        cache$2.set(Ctor, api);
    }
    return api;
}

/*
 * Copyright 2022 Gregg Tavares
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */
/**
 * Generates am typed API for Qud
 * */
function getAPIImpl$1(Ctor) {
    const vec3 = getAPI$3(Ctor);
    /**
     * Creates a quat4; may be called with x, y, z to set initial values.
     * @param x - Initial x value.
     * @param y - Initial y value.
     * @param z - Initial z value.
     * @param w - Initial w value.
     * @returns the created vector
     */
    function create(x, y, z, w) {
        const newDst = new Ctor(4);
        if (x !== undefined) {
            newDst[0] = x;
            if (y !== undefined) {
                newDst[1] = y;
                if (z !== undefined) {
                    newDst[2] = z;
                    if (w !== undefined) {
                        newDst[3] = w;
                    }
                }
            }
        }
        return newDst;
    }
    /**
     * Creates a Quat; may be called with x, y, z to set initial values. (same as create)
     * @param x - Initial x value.
     * @param y - Initial y value.
     * @param z - Initial z value.
     * @param z - Initial w value.
     * @returns the created vector
     */
    const fromValues = create;
    /**
     * Sets the values of a Quat
     * Also see {@link quat.create} and {@link quat.copy}
     *
     * @param x first value
     * @param y second value
     * @param z third value
     * @param w fourth value
     * @param dst - vector to hold result. If not passed in a new one is created.
     * @returns A vector with its elements set.
     */
    function set(x, y, z, w, dst) {
        const newDst = (dst ?? new Ctor(4));
        newDst[0] = x;
        newDst[1] = y;
        newDst[2] = z;
        newDst[3] = w;
        return newDst;
    }
    /**
     * Sets a quaternion from the given angle and  axis,
     * then returns it.
     *
     * @param axis - the axis to rotate around
     * @param angleInRadians - the angle
     * @param dst - quaternion to hold result. If not passed in a new one is created.
     * @returns The quaternion that represents the given axis and angle
     **/
    function fromAxisAngle(axis, angleInRadians, dst) {
        const newDst = (dst ?? new Ctor(4));
        const halfAngle = angleInRadians * 0.5;
        const s = Math.sin(halfAngle);
        newDst[0] = s * axis[0];
        newDst[1] = s * axis[1];
        newDst[2] = s * axis[2];
        newDst[3] = Math.cos(halfAngle);
        return newDst;
    }
    /**
     * Gets the rotation axis and angle
     * @param q - quaternion to compute from
     * @param dst - Vec3 to hold result. If not passed in a new one is created.
     * @return angle and axis
     */
    function toAxisAngle(q, dst) {
        const newDst = (dst ?? vec3.create(3));
        const angle = Math.acos(q[3]) * 2;
        const s = Math.sin(angle * 0.5);
        if (s > EPSILON) {
            newDst[0] = q[0] / s;
            newDst[1] = q[1] / s;
            newDst[2] = q[2] / s;
        }
        else {
            newDst[0] = 1;
            newDst[1] = 0;
            newDst[2] = 0;
        }
        return { angle, axis: newDst };
    }
    /**
     * Returns the angle in degrees between two rotations a and b.
     * @param a - quaternion a
     * @param b - quaternion b
     * @return angle in radians between the two quaternions
     */
    function angle(a, b) {
        const d = dot(a, b);
        return Math.acos(2 * d * d - 1);
    }
    /**
     * Multiplies two quaternions
     *
     * @param a - the first quaternion
     * @param b - the second quaternion
     * @param dst - quaternion to hold result. If not passed in a new one is created.
     * @returns A quaternion that is the result of a * b
     */
    function multiply(a, b, dst) {
        const newDst = (dst ?? new Ctor(4));
        const ax = a[0];
        const ay = a[1];
        const az = a[2];
        const aw = a[3];
        const bx = b[0];
        const by = b[1];
        const bz = b[2];
        const bw = b[3];
        newDst[0] = ax * bw + aw * bx + ay * bz - az * by;
        newDst[1] = ay * bw + aw * by + az * bx - ax * bz;
        newDst[2] = az * bw + aw * bz + ax * by - ay * bx;
        newDst[3] = aw * bw - ax * bx - ay * by - az * bz;
        return newDst;
    }
    /**
     * Multiplies two quaternions
     *
     * @param a - the first quaternion
     * @param b - the second quaternion
     * @param dst - quaternion to hold result. If not passed in a new one is created.
     * @returns A quaternion that is the result of a * b
     */
    const mul = multiply;
    /**
     * Rotates the given quaternion around the X axis by the given angle.
     * @param q - quaternion to rotate
     * @param angleInRadians - The angle by which to rotate
     * @param dst - quaternion to hold result. If not passed in a new one is created.
     * @returns A quaternion that is the result of a * b
     */
    function rotateX(q, angleInRadians, dst) {
        const newDst = (dst ?? new Ctor(4));
        const halfAngle = angleInRadians * 0.5;
        const qx = q[0];
        const qy = q[1];
        const qz = q[2];
        const qw = q[3];
        const bx = Math.sin(halfAngle);
        const bw = Math.cos(halfAngle);
        newDst[0] = qx * bw + qw * bx;
        newDst[1] = qy * bw + qz * bx;
        newDst[2] = qz * bw - qy * bx;
        newDst[3] = qw * bw - qx * bx;
        return newDst;
    }
    /**
     * Rotates the given quaternion around the Y axis by the given angle.
     * @param q - quaternion to rotate
     * @param angleInRadians - The angle by which to rotate
     * @param dst - quaternion to hold result. If not passed in a new one is created.
     * @returns A quaternion that is the result of a * b
     */
    function rotateY(q, angleInRadians, dst) {
        const newDst = (dst ?? new Ctor(4));
        const halfAngle = angleInRadians * 0.5;
        const qx = q[0];
        const qy = q[1];
        const qz = q[2];
        const qw = q[3];
        const by = Math.sin(halfAngle);
        const bw = Math.cos(halfAngle);
        newDst[0] = qx * bw - qz * by;
        newDst[1] = qy * bw + qw * by;
        newDst[2] = qz * bw + qx * by;
        newDst[3] = qw * bw - qy * by;
        return newDst;
    }
    /**
     * Rotates the given quaternion around the Z axis by the given angle.
     * @param q - quaternion to rotate
     * @param angleInRadians - The angle by which to rotate
     * @param dst - quaternion to hold result. If not passed in a new one is created.
     * @returns A quaternion that is the result of a * b
     */
    function rotateZ(q, angleInRadians, dst) {
        const newDst = (dst ?? new Ctor(4));
        const halfAngle = angleInRadians * 0.5;
        const qx = q[0];
        const qy = q[1];
        const qz = q[2];
        const qw = q[3];
        const bz = Math.sin(halfAngle);
        const bw = Math.cos(halfAngle);
        newDst[0] = qx * bw + qy * bz;
        newDst[1] = qy * bw - qx * bz;
        newDst[2] = qz * bw + qw * bz;
        newDst[3] = qw * bw - qz * bz;
        return newDst;
    }
    /**
     * Spherically linear interpolate between two quaternions
     *
     * @param a - starting value
     * @param b - ending value
     * @param t - value where 0 = a and 1 = b
     * @param dst - quaternion to hold result. If not passed in a new one is created.
     * @returns A quaternion that is the result of a * b
     */
    function slerp(a, b, t, dst) {
        const newDst = (dst ?? new Ctor(4));
        const ax = a[0];
        const ay = a[1];
        const az = a[2];
        const aw = a[3];
        let bx = b[0];
        let by = b[1];
        let bz = b[2];
        let bw = b[3];
        let cosOmega = ax * bx + ay * by + az * bz + aw * bw;
        if (cosOmega < 0) {
            cosOmega = -cosOmega;
            bx = -bx;
            by = -by;
            bz = -bz;
            bw = -bw;
        }
        let scale0;
        let scale1;
        if (1.0 - cosOmega > EPSILON) {
            const omega = Math.acos(cosOmega);
            const sinOmega = Math.sin(omega);
            scale0 = Math.sin((1 - t) * omega) / sinOmega;
            scale1 = Math.sin(t * omega) / sinOmega;
        }
        else {
            scale0 = 1.0 - t;
            scale1 = t;
        }
        newDst[0] = scale0 * ax + scale1 * bx;
        newDst[1] = scale0 * ay + scale1 * by;
        newDst[2] = scale0 * az + scale1 * bz;
        newDst[3] = scale0 * aw + scale1 * bw;
        return newDst;
    }
    /**
     * Compute the inverse of a quaternion
     *
     * @param q - quaternion to compute the inverse of
     * @returns A quaternion that is the result of a * b
     */
    function inverse(q, dst) {
        const newDst = (dst ?? new Ctor(4));
        const a0 = q[0];
        const a1 = q[1];
        const a2 = q[2];
        const a3 = q[3];
        const dot = a0 * a0 + a1 * a1 + a2 * a2 + a3 * a3;
        const invDot = dot ? 1 / dot : 0;
        newDst[0] = -a0 * invDot;
        newDst[1] = -a1 * invDot;
        newDst[2] = -a2 * invDot;
        newDst[3] = a3 * invDot;
        return newDst;
    }
    /**
     * Compute the conjugate of a quaternion
     * For quaternions with a magnitude of 1 (a unit quaternion)
     * this returns the same as the inverse but is faster to calculate.
     *
     * @param q - quaternion to compute the conjugate of.
     * @param dst - quaternion to hold result. If not passed in a new one is created.
     * @returns The conjugate of q
     */
    function conjugate(q, dst) {
        const newDst = (dst ?? new Ctor(4));
        newDst[0] = -q[0];
        newDst[1] = -q[1];
        newDst[2] = -q[2];
        newDst[3] = q[3];
        return newDst;
    }
    /**
     * Creates a quaternion from the given rotation matrix.
     *
     * The created quaternion is not normalized.
     *
     * @param m - rotation matrix
     * @param dst - quaternion to hold result. If not passed in a new one is created.
     * @returns the result
     */
    function fromMat(m, dst) {
        const newDst = (dst ?? new Ctor(4));
        /*
        0 1 2
        3 4 5
        6 7 8
      
        0 1 2
        4 5 6
        8 9 10
         */
        // Algorithm in Ken Shoemake's article in 1987 SIGGRAPH course notes
        // article "Quaternion Calculus and Fast Animation".
        const trace = m[0] + m[5] + m[10];
        if (trace > 0.0) {
            // |w| > 1/2, may as well choose w > 1/2
            const root = Math.sqrt(trace + 1); // 2w
            newDst[3] = 0.5 * root;
            const invRoot = 0.5 / root; // 1/(4w)
            newDst[0] = (m[6] - m[9]) * invRoot;
            newDst[1] = (m[8] - m[2]) * invRoot;
            newDst[2] = (m[1] - m[4]) * invRoot;
        }
        else {
            // |w| <= 1/2
            let i = 0;
            if (m[5] > m[0]) {
                i = 1;
            }
            if (m[10] > m[i * 4 + i]) {
                i = 2;
            }
            const j = (i + 1) % 3;
            const k = (i + 2) % 3;
            const root = Math.sqrt(m[i * 4 + i] - m[j * 4 + j] - m[k * 4 + k] + 1.0);
            newDst[i] = 0.5 * root;
            const invRoot = 0.5 / root;
            newDst[3] = (m[j * 4 + k] - m[k * 4 + j]) * invRoot;
            newDst[j] = (m[j * 4 + i] + m[i * 4 + j]) * invRoot;
            newDst[k] = (m[k * 4 + i] + m[i * 4 + k]) * invRoot;
        }
        return newDst;
    }
    /**
     * Creates a quaternion from the given euler angle x, y, z using the provided intrinsic order for the conversion.
     *
     * @param xAngleInRadians - angle to rotate around X axis in radians.
     * @param yAngleInRadians - angle to rotate around Y axis in radians.
     * @param zAngleInRadians - angle to rotate around Z axis in radians.
     * @param order - order to apply euler angles
     * @param dst - quaternion to hold result. If not passed in a new one is created.
     * @returns A quaternion representing the same rotation as the euler angles applied in the given order
     */
    function fromEuler(xAngleInRadians, yAngleInRadians, zAngleInRadians, order, dst) {
        const newDst = (dst ?? new Ctor(4));
        const xHalfAngle = xAngleInRadians * 0.5;
        const yHalfAngle = yAngleInRadians * 0.5;
        const zHalfAngle = zAngleInRadians * 0.5;
        const sx = Math.sin(xHalfAngle);
        const cx = Math.cos(xHalfAngle);
        const sy = Math.sin(yHalfAngle);
        const cy = Math.cos(yHalfAngle);
        const sz = Math.sin(zHalfAngle);
        const cz = Math.cos(zHalfAngle);
        switch (order) {
            case 'xyz':
                newDst[0] = sx * cy * cz + cx * sy * sz;
                newDst[1] = cx * sy * cz - sx * cy * sz;
                newDst[2] = cx * cy * sz + sx * sy * cz;
                newDst[3] = cx * cy * cz - sx * sy * sz;
                break;
            case 'xzy':
                newDst[0] = sx * cy * cz - cx * sy * sz;
                newDst[1] = cx * sy * cz - sx * cy * sz;
                newDst[2] = cx * cy * sz + sx * sy * cz;
                newDst[3] = cx * cy * cz + sx * sy * sz;
                break;
            case 'yxz':
                newDst[0] = sx * cy * cz + cx * sy * sz;
                newDst[1] = cx * sy * cz - sx * cy * sz;
                newDst[2] = cx * cy * sz - sx * sy * cz;
                newDst[3] = cx * cy * cz + sx * sy * sz;
                break;
            case 'yzx':
                newDst[0] = sx * cy * cz + cx * sy * sz;
                newDst[1] = cx * sy * cz + sx * cy * sz;
                newDst[2] = cx * cy * sz - sx * sy * cz;
                newDst[3] = cx * cy * cz - sx * sy * sz;
                break;
            case 'zxy':
                newDst[0] = sx * cy * cz - cx * sy * sz;
                newDst[1] = cx * sy * cz + sx * cy * sz;
                newDst[2] = cx * cy * sz + sx * sy * cz;
                newDst[3] = cx * cy * cz - sx * sy * sz;
                break;
            case 'zyx':
                newDst[0] = sx * cy * cz - cx * sy * sz;
                newDst[1] = cx * sy * cz + sx * cy * sz;
                newDst[2] = cx * cy * sz - sx * sy * cz;
                newDst[3] = cx * cy * cz + sx * sy * sz;
                break;
            default:
                throw new Error(`Unknown rotation order: ${order}`);
        }
        return newDst;
    }
    /**
     * Copies a quaternion. (same as {@link quat.clone})
     * Also see {@link quat.create} and {@link quat.set}
     * @param q - The quaternion.
     * @param dst - quaternion to hold result. If not passed in a new one is created.
     * @returns A quaternion that is a copy of q
     */
    function copy(q, dst) {
        const newDst = (dst ?? new Ctor(4));
        newDst[0] = q[0];
        newDst[1] = q[1];
        newDst[2] = q[2];
        newDst[3] = q[3];
        return newDst;
    }
    /**
     * Clones a quaternion. (same as {@link quat.copy})
     * Also see {@link quat.create} and {@link quat.set}
     * @param q - The quaternion.
     * @param dst - quaternion to hold result. If not passed in a new one is created.
     * @returns A copy of q.
     */
    const clone = copy;
    /**
     * Adds two quaternions; assumes a and b have the same dimension.
     * @param a - Operand quaternion.
     * @param b - Operand quaternion.
     * @param dst - quaternion to hold result. If not passed in a new one is created.
     * @returns A quaternion that is the sum of a and b.
     */
    function add(a, b, dst) {
        const newDst = (dst ?? new Ctor(4));
        newDst[0] = a[0] + b[0];
        newDst[1] = a[1] + b[1];
        newDst[2] = a[2] + b[2];
        newDst[3] = a[3] + b[3];
        return newDst;
    }
    /**
     * Subtracts two quaternions.
     * @param a - Operand quaternion.
     * @param b - Operand quaternion.
     * @param dst - quaternion to hold result. If not passed in a new one is created.
     * @returns A quaternion that is the difference of a and b.
     */
    function subtract(a, b, dst) {
        const newDst = (dst ?? new Ctor(4));
        newDst[0] = a[0] - b[0];
        newDst[1] = a[1] - b[1];
        newDst[2] = a[2] - b[2];
        newDst[3] = a[3] - b[3];
        return newDst;
    }
    /**
     * Subtracts two quaternions.
     * @param a - Operand quaternion.
     * @param b - Operand quaternion.
     * @param dst - quaternion to hold result. If not passed in a new one is created.
     * @returns A quaternion that is the difference of a and b.
     */
    const sub = subtract;
    /**
     * Multiplies a quaternion by a scalar.
     * @param v - The quaternion.
     * @param k - The scalar.
     * @param dst - quaternion to hold result. If not passed in a new one is created.
     * @returns The scaled quaternion.
     */
    function mulScalar(v, k, dst) {
        const newDst = (dst ?? new Ctor(4));
        newDst[0] = v[0] * k;
        newDst[1] = v[1] * k;
        newDst[2] = v[2] * k;
        newDst[3] = v[3] * k;
        return newDst;
    }
    /**
     * Multiplies a quaternion by a scalar. (same as mulScalar)
     * @param v - The quaternion.
     * @param k - The scalar.
     * @param dst - quaternion to hold result. If not passed in a new one is created.
     * @returns The scaled quaternion.
     */
    const scale = mulScalar;
    /**
     * Divides a vector by a scalar.
     * @param v - The vector.
     * @param k - The scalar.
     * @param dst - quaternion to hold result. If not passed in a new one is created.
     * @returns The scaled quaternion.
     */
    function divScalar(v, k, dst) {
        const newDst = (dst ?? new Ctor(4));
        newDst[0] = v[0] / k;
        newDst[1] = v[1] / k;
        newDst[2] = v[2] / k;
        newDst[3] = v[3] / k;
        return newDst;
    }
    /**
     * Computes the dot product of two quaternions
     * @param a - Operand quaternion.
     * @param b - Operand quaternion.
     * @returns dot product
     */
    function dot(a, b) {
        return (a[0] * b[0]) + (a[1] * b[1]) + (a[2] * b[2]) + (a[3] * b[3]);
    }
    /**
     * Performs linear interpolation on two quaternions.
     * Given quaternions a and b and interpolation coefficient t, returns
     * a + t * (b - a).
     * @param a - Operand quaternion.
     * @param b - Operand quaternion.
     * @param t - Interpolation coefficient.
     * @param dst - quaternion to hold result. If not passed in a new one is created.
     * @returns The linear interpolated result.
     */
    function lerp(a, b, t, dst) {
        const newDst = (dst ?? new Ctor(4));
        newDst[0] = a[0] + t * (b[0] - a[0]);
        newDst[1] = a[1] + t * (b[1] - a[1]);
        newDst[2] = a[2] + t * (b[2] - a[2]);
        newDst[3] = a[3] + t * (b[3] - a[3]);
        return newDst;
    }
    /**
     * Computes the length of quaternion
     * @param v - quaternion.
     * @returns length of quaternion.
     */
    function length(v) {
        const v0 = v[0];
        const v1 = v[1];
        const v2 = v[2];
        const v3 = v[3];
        return Math.sqrt(v0 * v0 + v1 * v1 + v2 * v2 + v3 * v3);
    }
    /**
     * Computes the length of quaternion (same as length)
     * @param v - quaternion.
     * @returns length of quaternion.
     */
    const len = length;
    /**
     * Computes the square of the length of quaternion
     * @param v - quaternion.
     * @returns square of the length of quaternion.
     */
    function lengthSq(v) {
        const v0 = v[0];
        const v1 = v[1];
        const v2 = v[2];
        const v3 = v[3];
        return v0 * v0 + v1 * v1 + v2 * v2 + v3 * v3;
    }
    /**
     * Computes the square of the length of quaternion (same as lengthSq)
     * @param v - quaternion.
     * @returns square of the length of quaternion.
     */
    const lenSq = lengthSq;
    /**
     * Divides a quaternion by its Euclidean length and returns the quotient.
     * @param v - The quaternion.
     * @param dst - quaternion to hold result. If not passed in a new one is created.
     * @returns The normalized quaternion.
     */
    function normalize(v, dst) {
        const newDst = (dst ?? new Ctor(4));
        const v0 = v[0];
        const v1 = v[1];
        const v2 = v[2];
        const v3 = v[3];
        const len = Math.sqrt(v0 * v0 + v1 * v1 + v2 * v2 + v3 * v3);
        if (len > 0.00001) {
            newDst[0] = v0 / len;
            newDst[1] = v1 / len;
            newDst[2] = v2 / len;
            newDst[3] = v3 / len;
        }
        else {
            newDst[0] = 0;
            newDst[1] = 0;
            newDst[2] = 0;
            newDst[3] = 0;
        }
        return newDst;
    }
    /**
     * Check if 2 quaternions are approximately equal
     * @param a - Operand quaternion.
     * @param b - Operand quaternion.
     * @returns true if quaternions are approximately equal
     */
    function equalsApproximately(a, b) {
        return Math.abs(a[0] - b[0]) < EPSILON &&
            Math.abs(a[1] - b[1]) < EPSILON &&
            Math.abs(a[2] - b[2]) < EPSILON &&
            Math.abs(a[3] - b[3]) < EPSILON;
    }
    /**
     * Check if 2 quaternions are exactly equal
     * @param a - Operand quaternion.
     * @param b - Operand quaternion.
     * @returns true if quaternions are exactly equal
     */
    function equals(a, b) {
        return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3];
    }
    /**
     * Creates an identity quaternion
     * @param dst - quaternion to hold result. If not passed in a new one is created.
     * @returns an identity quaternion
     */
    function identity(dst) {
        const newDst = (dst ?? new Ctor(4));
        newDst[0] = 0;
        newDst[1] = 0;
        newDst[2] = 0;
        newDst[3] = 1;
        return newDst;
    }
    const tempVec3 = vec3.create();
    const xUnitVec3 = vec3.create();
    const yUnitVec3 = vec3.create();
    /**
     * Computes a quaternion to represent the shortest rotation from one vector to another.
     *
     * @param aUnit - the start vector
     * @param bUnit - the end vector
     * @param dst - quaternion to hold result. If not passed in a new one is created.
     * @returns the result
     */
    function rotationTo(aUnit, bUnit, dst) {
        const newDst = (dst ?? new Ctor(4));
        const dot = vec3.dot(aUnit, bUnit);
        if (dot < -0.999999) {
            vec3.cross(xUnitVec3, aUnit, tempVec3);
            if (vec3.len(tempVec3) < 0.000001) {
                vec3.cross(yUnitVec3, aUnit, tempVec3);
            }
            vec3.normalize(tempVec3, tempVec3);
            fromAxisAngle(tempVec3, Math.PI, newDst);
            return newDst;
        }
        else if (dot > 0.999999) {
            newDst[0] = 0;
            newDst[1] = 0;
            newDst[2] = 0;
            newDst[3] = 1;
            return newDst;
        }
        else {
            vec3.cross(aUnit, bUnit, tempVec3);
            newDst[0] = tempVec3[0];
            newDst[1] = tempVec3[1];
            newDst[2] = tempVec3[2];
            newDst[3] = 1 + dot;
            return normalize(newDst, newDst);
        }
    }
    const tempQuat1 = new Ctor(4);
    const tempQuat2 = new Ctor(4);
    /**
     * Performs a spherical linear interpolation with two control points
     *
     * @param a - the first quaternion
     * @param b - the second quaternion
     * @param c - the third quaternion
     * @param d - the fourth quaternion
     * @param t - Interpolation coefficient 0 to 1
     * @returns result
     */
    function sqlerp(a, b, c, d, t, dst) {
        const newDst = (dst ?? new Ctor(4));
        slerp(a, d, t, tempQuat1);
        slerp(b, c, t, tempQuat2);
        slerp(tempQuat1, tempQuat2, 2 * t * (1 - t), newDst);
        return newDst;
    }
    return {
        create,
        fromValues,
        set,
        fromAxisAngle,
        toAxisAngle,
        angle,
        multiply,
        mul,
        rotateX,
        rotateY,
        rotateZ,
        slerp,
        inverse,
        conjugate,
        fromMat,
        fromEuler,
        copy,
        clone,
        add,
        subtract,
        sub,
        mulScalar,
        scale,
        divScalar,
        dot,
        lerp,
        length,
        len,
        lengthSq,
        lenSq,
        normalize,
        equalsApproximately,
        equals,
        identity,
        rotationTo,
        sqlerp,
    };
}
const cache$1 = new Map();
/**
 *
 * Quat4 math functions.
 *
 * Almost all functions take an optional `newDst` argument. If it is not passed in the
 * functions will create a new `Quat4`. In other words you can do this
 *
 *     const v = quat4.cross(v1, v2);  // Creates a new Quat4 with the cross product of v1 x v2.
 *
 * or
 *
 *     const v = quat4.create();
 *     quat4.cross(v1, v2, v);  // Puts the cross product of v1 x v2 in v
 *
 * The first style is often easier but depending on where it's used it generates garbage where
 * as there is almost never allocation with the second style.
 *
 * It is always safe to pass any vector as the destination. So for example
 *
 *     quat4.cross(v1, v2, v1);  // Puts the cross product of v1 x v2 in v1
 *
 */
function getAPI$1(Ctor) {
    let api = cache$1.get(Ctor);
    if (!api) {
        api = getAPIImpl$1(Ctor);
        cache$1.set(Ctor, api);
    }
    return api;
}

/*
 * Copyright 2022 Gregg Tavares
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */
/**
 * Generates am typed API for Vec4
 * */
function getAPIImpl(Ctor) {
    /**
     * Creates a vec4; may be called with x, y, z to set initial values.
     * @param x - Initial x value.
     * @param y - Initial y value.
     * @param z - Initial z value.
     * @param w - Initial w value.
     * @returns the created vector
     */
    function create(x, y, z, w) {
        const newDst = new Ctor(4);
        if (x !== undefined) {
            newDst[0] = x;
            if (y !== undefined) {
                newDst[1] = y;
                if (z !== undefined) {
                    newDst[2] = z;
                    if (w !== undefined) {
                        newDst[3] = w;
                    }
                }
            }
        }
        return newDst;
    }
    /**
     * Creates a vec4; may be called with x, y, z to set initial values. (same as create)
     * @param x - Initial x value.
     * @param y - Initial y value.
     * @param z - Initial z value.
     * @param z - Initial w value.
     * @returns the created vector
     */
    const fromValues = create;
    /**
     * Sets the values of a Vec4
     * Also see {@link vec4.create} and {@link vec4.copy}
     *
     * @param x first value
     * @param y second value
     * @param z third value
     * @param w fourth value
     * @param dst - vector to hold result. If not passed in a new one is created.
     * @returns A vector with its elements set.
     */
    function set(x, y, z, w, dst) {
        const newDst = (dst ?? new Ctor(4));
        newDst[0] = x;
        newDst[1] = y;
        newDst[2] = z;
        newDst[3] = w;
        return newDst;
    }
    /**
     * Applies Math.ceil to each element of vector
     * @param v - Operand vector.
     * @param dst - vector to hold result. If not passed in a new one is created.
     * @returns A vector that is the ceil of each element of v.
     */
    function ceil(v, dst) {
        const newDst = (dst ?? new Ctor(4));
        newDst[0] = Math.ceil(v[0]);
        newDst[1] = Math.ceil(v[1]);
        newDst[2] = Math.ceil(v[2]);
        newDst[3] = Math.ceil(v[3]);
        return newDst;
    }
    /**
     * Applies Math.floor to each element of vector
     * @param v - Operand vector.
     * @param dst - vector to hold result. If not passed in a new one is created.
     * @returns A vector that is the floor of each element of v.
     */
    function floor(v, dst) {
        const newDst = (dst ?? new Ctor(4));
        newDst[0] = Math.floor(v[0]);
        newDst[1] = Math.floor(v[1]);
        newDst[2] = Math.floor(v[2]);
        newDst[3] = Math.floor(v[3]);
        return newDst;
    }
    /**
     * Applies Math.round to each element of vector
     * @param v - Operand vector.
     * @param dst - vector to hold result. If not passed in a new one is created.
     * @returns A vector that is the round of each element of v.
     */
    function round(v, dst) {
        const newDst = (dst ?? new Ctor(4));
        newDst[0] = Math.round(v[0]);
        newDst[1] = Math.round(v[1]);
        newDst[2] = Math.round(v[2]);
        newDst[3] = Math.round(v[3]);
        return newDst;
    }
    /**
     * Clamp each element of vector between min and max
     * @param v - Operand vector.
     * @param max - Min value, default 0
     * @param min - Max value, default 1
     * @param dst - vector to hold result. If not passed in a new one is created.
     * @returns A vector that the clamped value of each element of v.
     */
    function clamp(v, min = 0, max = 1, dst) {
        const newDst = (dst ?? new Ctor(4));
        newDst[0] = Math.min(max, Math.max(min, v[0]));
        newDst[1] = Math.min(max, Math.max(min, v[1]));
        newDst[2] = Math.min(max, Math.max(min, v[2]));
        newDst[3] = Math.min(max, Math.max(min, v[3]));
        return newDst;
    }
    /**
     * Adds two vectors; assumes a and b have the same dimension.
     * @param a - Operand vector.
     * @param b - Operand vector.
     * @param dst - vector to hold result. If not passed in a new one is created.
     * @returns A vector that is the sum of a and b.
     */
    function add(a, b, dst) {
        const newDst = (dst ?? new Ctor(4));
        newDst[0] = a[0] + b[0];
        newDst[1] = a[1] + b[1];
        newDst[2] = a[2] + b[2];
        newDst[3] = a[3] + b[3];
        return newDst;
    }
    /**
     * Adds two vectors, scaling the 2nd; assumes a and b have the same dimension.
     * @param a - Operand vector.
     * @param b - Operand vector.
     * @param scale - Amount to scale b
     * @param dst - vector to hold result. If not passed in a new one is created.
     * @returns A vector that is the sum of a + b * scale.
     */
    function addScaled(a, b, scale, dst) {
        const newDst = (dst ?? new Ctor(4));
        newDst[0] = a[0] + b[0] * scale;
        newDst[1] = a[1] + b[1] * scale;
        newDst[2] = a[2] + b[2] * scale;
        newDst[3] = a[3] + b[3] * scale;
        return newDst;
    }
    /**
     * Subtracts two vectors.
     * @param a - Operand vector.
     * @param b - Operand vector.
     * @param dst - vector to hold result. If not passed in a new one is created.
     * @returns A vector that is the difference of a and b.
     */
    function subtract(a, b, dst) {
        const newDst = (dst ?? new Ctor(4));
        newDst[0] = a[0] - b[0];
        newDst[1] = a[1] - b[1];
        newDst[2] = a[2] - b[2];
        newDst[3] = a[3] - b[3];
        return newDst;
    }
    /**
     * Subtracts two vectors.
     * @param a - Operand vector.
     * @param b - Operand vector.
     * @param dst - vector to hold result. If not passed in a new one is created.
     * @returns A vector that is the difference of a and b.
     */
    const sub = subtract;
    /**
     * Check if 2 vectors are approximately equal
     * @param a - Operand vector.
     * @param b - Operand vector.
     * @returns true if vectors are approximately equal
     */
    function equalsApproximately(a, b) {
        return Math.abs(a[0] - b[0]) < EPSILON &&
            Math.abs(a[1] - b[1]) < EPSILON &&
            Math.abs(a[2] - b[2]) < EPSILON &&
            Math.abs(a[3] - b[3]) < EPSILON;
    }
    /**
     * Check if 2 vectors are exactly equal
     * @param a - Operand vector.
     * @param b - Operand vector.
     * @returns true if vectors are exactly equal
     */
    function equals(a, b) {
        return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3];
    }
    /**
     * Performs linear interpolation on two vectors.
     * Given vectors a and b and interpolation coefficient t, returns
     * a + t * (b - a).
     * @param a - Operand vector.
     * @param b - Operand vector.
     * @param t - Interpolation coefficient.
     * @param dst - vector to hold result. If not passed in a new one is created.
     * @returns The linear interpolated result.
     */
    function lerp(a, b, t, dst) {
        const newDst = (dst ?? new Ctor(4));
        newDst[0] = a[0] + t * (b[0] - a[0]);
        newDst[1] = a[1] + t * (b[1] - a[1]);
        newDst[2] = a[2] + t * (b[2] - a[2]);
        newDst[3] = a[3] + t * (b[3] - a[3]);
        return newDst;
    }
    /**
     * Performs linear interpolation on two vectors.
     * Given vectors a and b and interpolation coefficient vector t, returns
     * a + t * (b - a).
     * @param a - Operand vector.
     * @param b - Operand vector.
     * @param t - Interpolation coefficients vector.
     * @param dst - vector to hold result. If not passed in a new one is created.
     * @returns the linear interpolated result.
     */
    function lerpV(a, b, t, dst) {
        const newDst = (dst ?? new Ctor(4));
        newDst[0] = a[0] + t[0] * (b[0] - a[0]);
        newDst[1] = a[1] + t[1] * (b[1] - a[1]);
        newDst[2] = a[2] + t[2] * (b[2] - a[2]);
        newDst[3] = a[3] + t[3] * (b[3] - a[3]);
        return newDst;
    }
    /**
     * Return max values of two vectors.
     * Given vectors a and b returns
     * [max(a[0], b[0]), max(a[1], b[1]), max(a[2], b[2])].
     * @param a - Operand vector.
     * @param b - Operand vector.
     * @param dst - vector to hold result. If not passed in a new one is created.
     * @returns The max components vector.
     */
    function max(a, b, dst) {
        const newDst = (dst ?? new Ctor(4));
        newDst[0] = Math.max(a[0], b[0]);
        newDst[1] = Math.max(a[1], b[1]);
        newDst[2] = Math.max(a[2], b[2]);
        newDst[3] = Math.max(a[3], b[3]);
        return newDst;
    }
    /**
     * Return min values of two vectors.
     * Given vectors a and b returns
     * [min(a[0], b[0]), min(a[1], b[1]), min(a[2], b[2])].
     * @param a - Operand vector.
     * @param b - Operand vector.
     * @param dst - vector to hold result. If not passed in a new one is created.
     * @returns The min components vector.
     */
    function min(a, b, dst) {
        const newDst = (dst ?? new Ctor(4));
        newDst[0] = Math.min(a[0], b[0]);
        newDst[1] = Math.min(a[1], b[1]);
        newDst[2] = Math.min(a[2], b[2]);
        newDst[3] = Math.min(a[3], b[3]);
        return newDst;
    }
    /**
     * Multiplies a vector by a scalar.
     * @param v - The vector.
     * @param k - The scalar.
     * @param dst - vector to hold result. If not passed in a new one is created.
     * @returns The scaled vector.
     */
    function mulScalar(v, k, dst) {
        const newDst = (dst ?? new Ctor(4));
        newDst[0] = v[0] * k;
        newDst[1] = v[1] * k;
        newDst[2] = v[2] * k;
        newDst[3] = v[3] * k;
        return newDst;
    }
    /**
     * Multiplies a vector by a scalar. (same as mulScalar)
     * @param v - The vector.
     * @param k - The scalar.
     * @param dst - vector to hold result. If not passed in a new one is created.
     * @returns The scaled vector.
     */
    const scale = mulScalar;
    /**
     * Divides a vector by a scalar.
     * @param v - The vector.
     * @param k - The scalar.
     * @param dst - vector to hold result. If not passed in a new one is created.
     * @returns The scaled vector.
     */
    function divScalar(v, k, dst) {
        const newDst = (dst ?? new Ctor(4));
        newDst[0] = v[0] / k;
        newDst[1] = v[1] / k;
        newDst[2] = v[2] / k;
        newDst[3] = v[3] / k;
        return newDst;
    }
    /**
     * Inverse a vector.
     * @param v - The vector.
     * @param dst - vector to hold result. If not passed in a new one is created.
     * @returns The inverted vector.
     */
    function inverse(v, dst) {
        const newDst = (dst ?? new Ctor(4));
        newDst[0] = 1 / v[0];
        newDst[1] = 1 / v[1];
        newDst[2] = 1 / v[2];
        newDst[3] = 1 / v[3];
        return newDst;
    }
    /**
     * Invert a vector. (same as inverse)
     * @param v - The vector.
     * @param dst - vector to hold result. If not passed in a new one is created.
     * @returns The inverted vector.
     */
    const invert = inverse;
    /**
     * Computes the dot product of two vectors
     * @param a - Operand vector.
     * @param b - Operand vector.
     * @returns dot product
     */
    function dot(a, b) {
        return (a[0] * b[0]) + (a[1] * b[1]) + (a[2] * b[2]) + (a[3] * b[3]);
    }
    /**
     * Computes the length of vector
     * @param v - vector.
     * @returns length of vector.
     */
    function length(v) {
        const v0 = v[0];
        const v1 = v[1];
        const v2 = v[2];
        const v3 = v[3];
        return Math.sqrt(v0 * v0 + v1 * v1 + v2 * v2 + v3 * v3);
    }
    /**
     * Computes the length of vector (same as length)
     * @param v - vector.
     * @returns length of vector.
     */
    const len = length;
    /**
     * Computes the square of the length of vector
     * @param v - vector.
     * @returns square of the length of vector.
     */
    function lengthSq(v) {
        const v0 = v[0];
        const v1 = v[1];
        const v2 = v[2];
        const v3 = v[3];
        return v0 * v0 + v1 * v1 + v2 * v2 + v3 * v3;
    }
    /**
     * Computes the square of the length of vector (same as lengthSq)
     * @param v - vector.
     * @returns square of the length of vector.
     */
    const lenSq = lengthSq;
    /**
     * Computes the distance between 2 points
     * @param a - vector.
     * @param b - vector.
     * @returns distance between a and b
     */
    function distance(a, b) {
        const dx = a[0] - b[0];
        const dy = a[1] - b[1];
        const dz = a[2] - b[2];
        const dw = a[3] - b[3];
        return Math.sqrt(dx * dx + dy * dy + dz * dz + dw * dw);
    }
    /**
     * Computes the distance between 2 points (same as distance)
     * @param a - vector.
     * @param b - vector.
     * @returns distance between a and b
     */
    const dist = distance;
    /**
     * Computes the square of the distance between 2 points
     * @param a - vector.
     * @param b - vector.
     * @returns square of the distance between a and b
     */
    function distanceSq(a, b) {
        const dx = a[0] - b[0];
        const dy = a[1] - b[1];
        const dz = a[2] - b[2];
        const dw = a[3] - b[3];
        return dx * dx + dy * dy + dz * dz + dw * dw;
    }
    /**
     * Computes the square of the distance between 2 points (same as distanceSq)
     * @param a - vector.
     * @param b - vector.
     * @returns square of the distance between a and b
     */
    const distSq = distanceSq;
    /**
     * Divides a vector by its Euclidean length and returns the quotient.
     * @param v - The vector.
     * @param dst - vector to hold result. If not passed in a new one is created.
     * @returns The normalized vector.
     */
    function normalize(v, dst) {
        const newDst = (dst ?? new Ctor(4));
        const v0 = v[0];
        const v1 = v[1];
        const v2 = v[2];
        const v3 = v[3];
        const len = Math.sqrt(v0 * v0 + v1 * v1 + v2 * v2 + v3 * v3);
        if (len > 0.00001) {
            newDst[0] = v0 / len;
            newDst[1] = v1 / len;
            newDst[2] = v2 / len;
            newDst[3] = v3 / len;
        }
        else {
            newDst[0] = 0;
            newDst[1] = 0;
            newDst[2] = 0;
            newDst[3] = 0;
        }
        return newDst;
    }
    /**
     * Negates a vector.
     * @param v - The vector.
     * @param dst - vector to hold result. If not passed in a new one is created.
     * @returns -v.
     */
    function negate(v, dst) {
        const newDst = (dst ?? new Ctor(4));
        newDst[0] = -v[0];
        newDst[1] = -v[1];
        newDst[2] = -v[2];
        newDst[3] = -v[3];
        return newDst;
    }
    /**
     * Copies a vector. (same as {@link vec4.clone})
     * Also see {@link vec4.create} and {@link vec4.set}
     * @param v - The vector.
     * @param dst - vector to hold result. If not passed in a new one is created.
     * @returns A copy of v.
     */
    function copy(v, dst) {
        const newDst = (dst ?? new Ctor(4));
        newDst[0] = v[0];
        newDst[1] = v[1];
        newDst[2] = v[2];
        newDst[3] = v[3];
        return newDst;
    }
    /**
     * Clones a vector. (same as {@link vec4.copy})
     * Also see {@link vec4.create} and {@link vec4.set}
     * @param v - The vector.
     * @param dst - vector to hold result. If not passed in a new one is created.
     * @returns A copy of v.
     */
    const clone = copy;
    /**
     * Multiplies a vector by another vector (component-wise); assumes a and
     * b have the same length.
     * @param a - Operand vector.
     * @param b - Operand vector.
     * @param dst - vector to hold result. If not passed in a new one is created.
     * @returns The vector of products of entries of a and b.
     */
    function multiply(a, b, dst) {
        const newDst = (dst ?? new Ctor(4));
        newDst[0] = a[0] * b[0];
        newDst[1] = a[1] * b[1];
        newDst[2] = a[2] * b[2];
        newDst[3] = a[3] * b[3];
        return newDst;
    }
    /**
     * Multiplies a vector by another vector (component-wise); assumes a and
     * b have the same length. (same as mul)
     * @param a - Operand vector.
     * @param b - Operand vector.
     * @param dst - vector to hold result. If not passed in a new one is created.
     * @returns The vector of products of entries of a and b.
     */
    const mul = multiply;
    /**
     * Divides a vector by another vector (component-wise); assumes a and
     * b have the same length.
     * @param a - Operand vector.
     * @param b - Operand vector.
     * @param dst - vector to hold result. If not passed in a new one is created.
     * @returns The vector of quotients of entries of a and b.
     */
    function divide(a, b, dst) {
        const newDst = (dst ?? new Ctor(4));
        newDst[0] = a[0] / b[0];
        newDst[1] = a[1] / b[1];
        newDst[2] = a[2] / b[2];
        newDst[3] = a[3] / b[3];
        return newDst;
    }
    /**
     * Divides a vector by another vector (component-wise); assumes a and
     * b have the same length. (same as divide)
     * @param a - Operand vector.
     * @param b - Operand vector.
     * @param dst - vector to hold result. If not passed in a new one is created.
     * @returns The vector of quotients of entries of a and b.
     */
    const div = divide;
    /**
     * Zero's a vector
     * @param dst - vector to hold result. If not passed in a new one is created.
     * @returns The zeroed vector.
     */
    function zero(dst) {
        const newDst = (dst ?? new Ctor(4));
        newDst[0] = 0;
        newDst[1] = 0;
        newDst[2] = 0;
        newDst[3] = 0;
        return newDst;
    }
    /**
     * transform vec4 by 4x4 matrix
     * @param v - the vector
     * @param m - The matrix.
     * @param dst - optional vec4 to store result. If not passed a new one is created.
     * @returns the transformed vector
     */
    function transformMat4(v, m, dst) {
        const newDst = (dst ?? new Ctor(4));
        const x = v[0];
        const y = v[1];
        const z = v[2];
        const w = v[3];
        newDst[0] = m[0] * x + m[4] * y + m[8] * z + m[12] * w;
        newDst[1] = m[1] * x + m[5] * y + m[9] * z + m[13] * w;
        newDst[2] = m[2] * x + m[6] * y + m[10] * z + m[14] * w;
        newDst[3] = m[3] * x + m[7] * y + m[11] * z + m[15] * w;
        return newDst;
    }
    /**
     * Treat a 4D vector as a direction and set it's length
     *
     * @param a The vec4 to lengthen
     * @param len The length of the resulting vector
     * @returns The lengthened vector
     */
    function setLength(a, len, dst) {
        const newDst = (dst ?? new Ctor(4));
        normalize(a, newDst);
        return mulScalar(newDst, len, newDst);
    }
    /**
     * Ensure a vector is not longer than a max length
     *
     * @param a The vec4 to limit
     * @param maxLen The longest length of the resulting vector
     * @returns The vector, shortened to maxLen if it's too long
     */
    function truncate(a, maxLen, dst) {
        const newDst = (dst ?? new Ctor(4));
        if (length(a) > maxLen) {
            return setLength(a, maxLen, newDst);
        }
        return copy(a, newDst);
    }
    /**
     * Return the vector exactly between 2 endpoint vectors
     *
     * @param a Endpoint 1
     * @param b Endpoint 2
     * @returns The vector exactly residing between endpoints 1 and 2
     */
    function midpoint(a, b, dst) {
        const newDst = (dst ?? new Ctor(4));
        return lerp(a, b, 0.5, newDst);
    }
    return {
        create,
        fromValues,
        set,
        ceil,
        floor,
        round,
        clamp,
        add,
        addScaled,
        subtract,
        sub,
        equalsApproximately,
        equals,
        lerp,
        lerpV,
        max,
        min,
        mulScalar,
        scale,
        divScalar,
        inverse,
        invert,
        dot,
        length,
        len,
        lengthSq,
        lenSq,
        distance,
        dist,
        distanceSq,
        distSq,
        normalize,
        negate,
        copy,
        clone,
        multiply,
        mul,
        divide,
        div,
        zero,
        transformMat4,
        setLength,
        truncate,
        midpoint,
    };
}
const cache = new Map();
/**
 *
 * Vec4 math functions.
 *
 * Almost all functions take an optional `newDst` argument. If it is not passed in the
 * functions will create a new `Vec4`. In other words you can do this
 *
 *     const v = vec4.cross(v1, v2);  // Creates a new Vec4 with the cross product of v1 x v2.
 *
 * or
 *
 *     const v = vec4.create();
 *     vec4.cross(v1, v2, v);  // Puts the cross product of v1 x v2 in v
 *
 * The first style is often easier but depending on where it's used it generates garbage where
 * as there is almost never allocation with the second style.
 *
 * It is always safe to pass any vector as the destination. So for example
 *
 *     vec4.cross(v1, v2, v1);  // Puts the cross product of v1 x v2 in v1
 *
 */
function getAPI(Ctor) {
    let api = cache.get(Ctor);
    if (!api) {
        api = getAPIImpl(Ctor);
        cache.set(Ctor, api);
    }
    return api;
}

/**
 * Generate wgpu-matrix API for type
 */
function wgpuMatrixAPI(Mat3Ctor, Mat4Ctor, QuatCtor, Vec2Ctor, Vec3Ctor, Vec4Ctor) {
    return {
        /** @namespace mat4 */
        mat4: getAPI$2(Mat3Ctor),
        /** @namespace mat3 */
        mat3: getAPI$4(Mat4Ctor),
        /** @namespace quat */
        quat: getAPI$1(QuatCtor),
        /** @namespace vec2 */
        vec2: getAPI$5(Vec2Ctor),
        /** @namespace vec3 */
        vec3: getAPI$3(Vec3Ctor),
        /** @namespace vec4 */
        vec4: getAPI(Vec4Ctor),
    };
}
const { 
/** @namespace */
mat4, 
/** @namespace */
mat3, 
/** @namespace */
quat, 
/** @namespace */
vec2, 
/** @namespace */
vec3, 
/** @namespace */
vec4, } = wgpuMatrixAPI(Float32Array, Float32Array, Float32Array, Float32Array, Float32Array, Float32Array);
const { 
/** @namespace */
mat4: mat4d, 
/** @namespace */
mat3: mat3d, 
/** @namespace */
quat: quatd, 
/** @namespace */
vec2: vec2d, 
/** @namespace */
vec3: vec3d, 
/** @namespace */
vec4: vec4d, } = wgpuMatrixAPI(Float64Array, Float64Array, Float64Array, Float64Array, Float64Array, Float64Array);
const { 
/** @namespace */
mat4: mat4n, 
/** @namespace */
mat3: mat3n, 
/** @namespace */
quat: quatn, 
/** @namespace */
vec2: vec2n, 
/** @namespace */
vec3: vec3n, 
/** @namespace */
vec4: vec4n, } = wgpuMatrixAPI(ZeroArray, Array, Array, Array, Array, Array);


//# sourceMappingURL=wgpu-matrix.module.js.map


/***/ })

},
/******/ __webpack_require__ => { // webpackRuntimeModules
/******/ var __webpack_exec__ = (moduleId) => (__webpack_require__(__webpack_require__.s = moduleId))
/******/ var __webpack_exports__ = (__webpack_exec__("./index.ts"));
/******/ }
]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QThDO0FBQzVFLE1BQU0sWUFBWSxHQUFHLENBQUMsR0FBRyxDQUFDO0FBQzFCLE1BQU0sZUFBZSxHQUFHLEVBQUU7QUFFakMsa0JBQWtCO0FBQ1gsTUFBTSxlQUFlLEdBQUcsSUFBSSxZQUFZLENBQUM7SUFDOUMsNENBQTRDO0lBQzVDLENBQUMsRUFBRSxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFJLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRyxDQUFDLEVBQUUsQ0FBQztJQUNoQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFHLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRyxDQUFDLEVBQUUsQ0FBQztJQUNoQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFHLENBQUMsRUFBRSxDQUFDO0lBQ2hDLENBQUMsRUFBRSxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUcsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFHLENBQUMsRUFBRSxDQUFDO0lBQ2hDLENBQUMsRUFBRSxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFJLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRyxDQUFDLEVBQUUsQ0FBQztJQUNoQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFHLENBQUMsRUFBRSxDQUFDO0lBRWhDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBSyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUcsQ0FBQyxFQUFFLENBQUM7SUFDaEMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUksQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFHLENBQUMsRUFBRSxDQUFDO0lBQ2hDLENBQUMsRUFBRSxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUcsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFHLENBQUMsRUFBRSxDQUFDO0lBQ2hDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFJLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRyxDQUFDLEVBQUUsQ0FBQztJQUNoQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUssQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFHLENBQUMsRUFBRSxDQUFDO0lBQ2hDLENBQUMsRUFBRSxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUcsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFHLENBQUMsRUFBRSxDQUFDO0lBRWhDLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFJLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRyxDQUFDLEVBQUUsQ0FBQztJQUNoQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUssQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFHLENBQUMsRUFBRSxDQUFDO0lBQ2hDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFJLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRyxDQUFDLEVBQUUsQ0FBQztJQUNoQyxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFHLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRyxDQUFDLEVBQUUsQ0FBQztJQUNoQyxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBSSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUcsQ0FBQyxFQUFFLENBQUM7SUFDaEMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUksQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFHLENBQUMsRUFBRSxDQUFDO0lBRWhDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUcsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFHLENBQUMsRUFBRSxDQUFDO0lBQ2hDLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFJLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRyxDQUFDLEVBQUUsQ0FBQztJQUNoQyxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFHLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRyxDQUFDLEVBQUUsQ0FBQztJQUNoQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFHLENBQUMsRUFBRSxDQUFDO0lBQ2hDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUcsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFHLENBQUMsRUFBRSxDQUFDO0lBQ2hDLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUcsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFHLENBQUMsRUFBRSxDQUFDO0lBRWhDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBSyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUcsQ0FBQyxFQUFFLENBQUM7SUFDaEMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUksQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFHLENBQUMsRUFBRSxDQUFDO0lBQ2hDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUcsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFHLENBQUMsRUFBRSxDQUFDO0lBQ2hDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUcsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFHLENBQUMsRUFBRSxDQUFDO0lBQ2hDLENBQUMsRUFBRSxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFJLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRyxDQUFDLEVBQUUsQ0FBQztJQUNoQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUssQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFHLENBQUMsRUFBRSxDQUFDO0lBRWhDLENBQUMsRUFBRSxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUcsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFHLENBQUMsRUFBRSxDQUFDO0lBQ2hDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUcsQ0FBQyxFQUFFLENBQUM7SUFDaEMs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aEM7QUFDQSwwQkFBMEIsa0RBQU87QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7OztBQ2pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ3pDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxxQkFBcUIsaUJBQWlCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsbUJBQW1CLEtBQUs7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtEO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRDtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLGlCQUFpQjtBQUNuRCxpQkFBaUIsbUJBQW1CLEtBQUs7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxnQkFBZ0I7QUFDbEQsaUJBQWlCLG1CQUFtQixLQUFLO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtEQUErRDtBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtEQUErRDtBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNERBQTREO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNERBQTREO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLG1CQUFtQixLQUFLO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLGlCQUFpQjtBQUNuRCxpQkFBaUIsbUJBQW1CLEtBQUs7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLGdCQUFnQjtBQUNqRCxpQkFBaUIsbUJBQW1CLEtBQUs7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9EO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZEQUE2RDtBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixtQkFBbUIsS0FBSztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEM7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRDtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRDtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxpQkFBaUI7QUFDbkQsaUJBQWlCLG1CQUFtQixLQUFLO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxnQkFBZ0I7QUFDbEQsaUJBQWlCLG1CQUFtQixLQUFLO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtEQUErRDtBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0RBQStEO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0REFBNEQ7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDREQUE0RDtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxjQUFjO0FBQzdCLGVBQWUsY0FBYztBQUM3QixlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxjQUFjO0FBQzdCLGVBQWUsY0FBYztBQUM3QixlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxjQUFjO0FBQzdCLGVBQWUsY0FBYztBQUM3QixlQUFlLFFBQVE7QUFDdkI7QUFDQSxpQkFBaUIsTUFBTTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFEO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEM7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixtQkFBbUIsS0FBSztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsaUJBQWlCO0FBQ25ELGlCQUFpQixtQkFBbUIsS0FBSztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxnQkFBZ0I7QUFDakQsaUJBQWlCLG1CQUFtQixLQUFLO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9EO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkRBQTZEO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsbUJBQW1CLEtBQUs7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0M7QUFDL0M7QUFDQSx3Q0FBd0M7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRCxNQUFNO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLGlCQUFpQjtBQUN2RCxpQkFBaUIsbUJBQW1CLEtBQUs7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsZ0JBQWdCO0FBQ3RELGlCQUFpQixtQkFBbUIsS0FBSztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLG1CQUFtQixLQUFLO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsaUJBQWlCO0FBQ25ELGlCQUFpQixtQkFBbUIsS0FBSztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxnQkFBZ0I7QUFDbEQsaUJBQWlCLG1CQUFtQixLQUFLO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtEQUErRDtBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrREFBK0Q7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDREQUE0RDtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0REFBNEQ7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7O0FBRTBIO0FBQ3pJIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQHdoZWV6eS9kZW1vcy8uL2luZGV4LnRzIiwid2VicGFjazovL0B3aGVlenkvZGVtb3MvLi9zcmMvRGVtbzAudHMiLCJ3ZWJwYWNrOi8vQHdoZWV6eS9kZW1vcy8uL3NyYy9EZW1vMS50cyIsIndlYnBhY2s6Ly9Ad2hlZXp5L2RlbW9zLy4uL2VuZ2luZS9pbmRleC50cyIsIndlYnBhY2s6Ly9Ad2hlZXp5L2RlbW9zLy4uL2VuZ2luZS9zcmMvZW5naW5lL2NvcmUvQnVmZmVyU3RvcmFnZS9CdWZmZXJTdG9yYWdlLnRzIiwid2VicGFjazovL0B3aGVlenkvZGVtb3MvLi4vZW5naW5lL3NyYy9lbmdpbmUvY29yZS9CdWZmZXJTdG9yYWdlL2luZGV4LnRzIiwid2VicGFjazovL0B3aGVlenkvZGVtb3MvLi4vZW5naW5lL3NyYy9lbmdpbmUvY29yZS9Db21wb25lbnQvQ29tcG9uZW50LnRzIiwid2VicGFjazovL0B3aGVlenkvZGVtb3MvLi4vZW5naW5lL3NyYy9lbmdpbmUvY29yZS9Db21wb25lbnQvaW5kZXgudHMiLCJ3ZWJwYWNrOi8vQHdoZWV6eS9kZW1vcy8uLi9lbmdpbmUvc3JjL2VuZ2luZS9jb3JlL0VuZ2luZS9FbmdpbmUudHMiLCJ3ZWJwYWNrOi8vQHdoZWV6eS9kZW1vcy8uLi9lbmdpbmUvc3JjL2VuZ2luZS9jb3JlL0VuZ2luZS9pbmRleC50cyIsIndlYnBhY2s6Ly9Ad2hlZXp5L2RlbW9zLy4uL2VuZ2luZS9zcmMvZW5naW5lL2NvcmUvRW50aXR5L0VudGl0eS50cyIsIndlYnBhY2s6Ly9Ad2hlZXp5L2RlbW9zLy4uL2VuZ2luZS9zcmMvZW5naW5lL2NvcmUvRW50aXR5L2luZGV4LnRzIiwid2VicGFjazovL0B3aGVlenkvZGVtb3MvLi4vZW5naW5lL3NyYy9lbmdpbmUvY29yZS9HYW1lT2JqZWN0L0dhbWVPYmplY3QudHMiLCJ3ZWJwYWNrOi8vQHdoZWV6eS9kZW1vcy8uLi9lbmdpbmUvc3JjL2VuZ2luZS9jb3JlL0dhbWVPYmplY3QvaW5kZXgudHMiLCJ3ZWJwYWNrOi8vQHdoZWV6eS9kZW1vcy8uLi9lbmdpbmUvc3JjL2VuZ2luZS9jb3JlL0ltYWdlU3RvcmFnZS9JbWFnZVN0b3JhZ2UudHMiLCJ3ZWJwYWNrOi8vQHdoZWV6eS9kZW1vcy8uLi9lbmdpbmUvc3JjL2VuZ2luZS9jb3JlL0ltYWdlU3RvcmFnZS9pbmRleC50cyIsIndlYnBhY2s6Ly9Ad2hlZXp5L2RlbW9zLy4uL2VuZ2luZS9zcmMvZW5naW5lL2NvcmUvTWF0ZXJpYWxTdG9yYWdlL01hdGVyaWFsU3RvcmFnZS50cyIsIndlYnBhY2s6Ly9Ad2hlZXp5L2RlbW9zLy4uL2VuZ2luZS9zcmMvZW5naW5lL2NvcmUvTWF0ZXJpYWxTdG9yYWdlL2luZGV4LnRzIiwid2VicGFjazovL0B3aGVlenkvZGVtb3MvLi4vZW5naW5lL3NyYy9lbmdpbmUvY29yZS9NZXNoL01lc2gudHMiLCJ3ZWJwYWNrOi8vQHdoZWV6eS9kZW1vcy8uLi9lbmdpbmUvc3JjL2VuZ2luZS9jb3JlL01lc2gvaW5kZXgudHMiLCJ3ZWJwYWNrOi8vQHdoZWV6eS9kZW1vcy8uLi9lbmdpbmUvc3JjL2VuZ2luZS9jb3JlL01lc2hSZW5kZXJEYXRhU3RvcmFnZS9NZXNoUmVuZGVyRGF0YVN0b3JhZ2UudHMiLCJ3ZWJwYWNrOi8vQHdoZWV6eS9kZW1vcy8uLi9lbmdpbmUvc3JjL2VuZ2luZS9jb3JlL01lc2hSZW5kZXJEYXRhU3RvcmFnZS9pbmRleC50cyIsIndlYnBhY2s6Ly9Ad2hlZXp5L2RlbW9zLy4uL2VuZ2luZS9zcmMvZW5naW5lL2NvcmUvTW9kZWxVcGxvYWRlci9Nb2RlbFVwbG9hZGVyLnRzIiwid2VicGFjazovL0B3aGVlenkvZGVtb3MvLi4vZW5naW5lL3NyYy9lbmdpbmUvY29yZS9Nb2RlbFVwbG9hZGVyL2luZGV4LnRzIiwid2VicGFjazovL0B3aGVlenkvZGVtb3MvLi4vZW5naW5lL3NyYy9lbmdpbmUvY29yZS9PYmplY3RNYW5hZ2VyL09iamVjdE1hbmFnZXIudHMiLCJ3ZWJwYWNrOi8vQHdoZWV6eS9kZW1vcy8uLi9lbmdpbmUvc3JjL2VuZ2luZS9jb3JlL09iamVjdE1hbmFnZXIvaW5kZXgudHMiLCJ3ZWJwYWNrOi8vQHdoZWV6eS9kZW1vcy8uLi9lbmdpbmUvc3JjL2VuZ2luZS9jb3JlL1JlbmRlcmVyL1JlbmRlcmVyLnRzIiwid2VicGFjazovL0B3aGVlenkvZGVtb3MvLi4vZW5naW5lL3NyYy9lbmdpbmUvY29yZS9SZW5kZXJlci9jb25zdGFudHMudHMiLCJ3ZWJwYWNrOi8vQHdoZWV6eS9kZW1vcy8uLi9lbmdpbmUvc3JjL2VuZ2luZS9jb3JlL1JlbmRlcmVyL2luZGV4LnRzIiwid2VicGFjazovL0B3aGVlenkvZGVtb3MvLi4vZW5naW5lL3NyYy9lbmdpbmUvY29yZS9TYW1wbGVyU3RvcmFnZS9TYW1wbGVyU3RvcmFnZS50cyIsIndlYnBhY2s6Ly9Ad2hlZXp5L2RlbW9zLy4uL2VuZ2luZS9zcmMvZW5naW5lL2NvcmUvU2FtcGxlclN0b3JhZ2UvaW5kZXgudHMiLCJ3ZWJwYWNrOi8vQHdoZWV6eS9kZW1vcy8uLi9lbmdpbmUvc3JjL2VuZ2luZS9jb3JlL1NjZW5lL1NjZW5lLnRzIiwid2VicGFjazovL0B3aGVlenkvZGVtb3MvLi4vZW5naW5lL3NyYy9lbmdpbmUvY29yZS9TY2VuZS9pbmRleC50cyIsIndlYnBhY2s6Ly9Ad2hlZXp5L2RlbW9zLy4uL2VuZ2luZS9zcmMvZW5naW5lL2NvcmUvU2NlbmVUcmVlL1NjZW5lVHJlZS50cyIsIndlYnBhY2s6Ly9Ad2hlZXp5L2RlbW9zLy4uL2VuZ2luZS9zcmMvZW5naW5lL2NvcmUvU2NlbmVUcmVlL2luZGV4LnRzIiwid2VicGFjazovL0B3aGVlenkvZGVtb3MvLi4vZW5naW5lL3NyYy9lbmdpbmUvY29yZS9UZXh0dXJlU3RvcmFnZS9UZXh0dXJlU3RvcmFnZS50cyIsIndlYnBhY2s6Ly9Ad2hlZXp5L2RlbW9zLy4uL2VuZ2luZS9zcmMvZW5naW5lL2NvcmUvVGV4dHVyZVN0b3JhZ2UvaW5kZXgudHMiLCJ3ZWJwYWNrOi8vQHdoZWV6eS9kZW1vcy8uLi9lbmdpbmUvc3JjL2VuZ2luZS9jb3JlL1RyYW5zZm9ybS9UcmFuc2Zvcm0udHMiLCJ3ZWJwYWNrOi8vQHdoZWV6eS9kZW1vcy8uLi9lbmdpbmUvc3JjL2VuZ2luZS9jb3JlL1RyYW5zZm9ybS9pbmRleC50cyIsIndlYnBhY2s6Ly9Ad2hlZXp5L2RlbW9zLy4uL2VuZ2luZS9zcmMvZW5naW5lL2NvcmUvY2FtZXJhcy9BcmNCYWxsQ2FtZXJhL0FyY0JhbGxDYW1lcmEudHMiLCJ3ZWJwYWNrOi8vQHdoZWV6eS9kZW1vcy8uLi9lbmdpbmUvc3JjL2VuZ2luZS9jb3JlL2NhbWVyYXMvQXJjQmFsbENhbWVyYS9pbmRleC50cyIsIndlYnBhY2s6Ly9Ad2hlZXp5L2RlbW9zLy4uL2VuZ2luZS9zcmMvZW5naW5lL2NvcmUvY2FtZXJhcy9DYW1lcmEvQ2FtZXJhLnRzIiwid2VicGFjazovL0B3aGVlenkvZGVtb3MvLi4vZW5naW5lL3NyYy9lbmdpbmUvY29yZS9jYW1lcmFzL0NhbWVyYS9pbmRleC50cyIsIndlYnBhY2s6Ly9Ad2hlZXp5L2RlbW9zLy4uL2VuZ2luZS9zcmMvZW5naW5lL2NvcmUvY2FtZXJhcy9QZXJzcGVjdGl2ZUNhbWVyYS9QZXJzcGVjdGl2ZUNhbWVyYS50cyIsIndlYnBhY2s6Ly9Ad2hlZXp5L2RlbW9zLy4uL2VuZ2luZS9zcmMvZW5naW5lL2NvcmUvY2FtZXJhcy9QZXJzcGVjdGl2ZUNhbWVyYS9pbmRleC50cyIsIndlYnBhY2s6Ly9Ad2hlZXp5L2RlbW9zLy4uL2VuZ2luZS9zcmMvZW5naW5lL2NvcmUvaW5kZXgudHMiLCJ3ZWJwYWNrOi8vQHdoZWV6eS9kZW1vcy8uLi9lbmdpbmUvc3JjL2VuZ2luZS9jb3JlL2xpZ2h0cy9CYXNlTGlnaHQvQmFzZUxpZ2h0LnRzIiwid2VicGFjazovL0B3aGVlenkvZGVtb3MvLi4vZW5naW5lL3NyYy9lbmdpbmUvY29yZS9saWdodHMvQmFzZUxpZ2h0L2luZGV4LnRzIiwid2VicGFjazovL0B3aGVlenkvZGVtb3MvLi4vZW5naW5lL3NyYy9lbmdpbmUvY29yZS9saWdodHMvRGlyZWN0aW9uYWxMaWdodC9EaXJlY3Rpb25hbExpZ2h0LnRzIiwid2VicGFjazovL0B3aGVlenkvZGVtb3MvLi4vZW5naW5lL3NyYy9lbmdpbmUvY29yZS9saWdodHMvRGlyZWN0aW9uYWxMaWdodC9pbmRleC50cyIsIndlYnBhY2s6Ly9Ad2hlZXp5L2RlbW9zLy4uL2VuZ2luZS9zcmMvZW5naW5lL2NvcmUvbGlnaHRzL2luZGV4LnRzIiwid2VicGFjazovL0B3aGVlenkvZGVtb3MvLi4vZW5naW5lL3NyYy9lbmdpbmUvcHJpbWl0aXZlcy9jdWJlLnRzIiwid2VicGFjazovL0B3aGVlenkvZGVtb3MvLi4vZW5naW5lL3NyYy9lbmdpbmUvdHlwZXMvY29yZS9CdWZmZXJTdG9yYWdlL2luZGV4LnRzIiwid2VicGFjazovL0B3aGVlenkvZGVtb3MvLi4vZW5naW5lL3NyYy9lbmdpbmUvdHlwZXMvY29yZS9Db21wb25lbnQvaW5kZXgudHMiLCJ3ZWJwYWNrOi8vQHdoZWV6eS9kZW1vcy8uLi9lbmdpbmUvc3JjL2VuZ2luZS90eXBlcy9jb3JlL0VuZ2luZS9pbmRleC50cyIsIndlYnBhY2s6Ly9Ad2hlZXp5L2RlbW9zLy4uL2VuZ2luZS9zcmMvZW5naW5lL3R5cGVzL2NvcmUvRW50aXR5L2luZGV4LnRzIiwid2VicGFjazovL0B3aGVlenkvZGVtb3MvLi4vZW5naW5lL3NyYy9lbmdpbmUvdHlwZXMvY29yZS9HYW1lT2JqZWN0L2luZGV4LnRzIiwid2VicGFjazovL0B3aGVlenkvZGVtb3MvLi4vZW5naW5lL3NyYy9lbmdpbmUvdHlwZXMvY29yZS9JbWFnZVN0b3JhZ2UvaW5kZXgudHMiLCJ3ZWJwYWNrOi8vQHdoZWV6eS9kZW1vcy8uLi9lbmdpbmUvc3JjL2VuZ2luZS90eXBlcy9jb3JlL0xpZ2h0U291cmNlL2luZGV4LnRzIiwid2VicGFjazovL0B3aGVlenkvZGVtb3MvLi4vZW5naW5lL3NyYy9lbmdpbmUvdHlwZXMvY29yZS9NZXNoL2luZGV4LnRzIiwid2VicGFjazovL0B3aGVlenkvZGVtb3MvLi4vZW5naW5lL3NyYy9lbmdpbmUvdHlwZXMvY29yZS9PYmplY3RNYW5hZ2VyL2luZGV4LnRzIiwid2VicGFjazovL0B3aGVlenkvZGVtb3MvLi4vZW5naW5lL3NyYy9lbmdpbmUvdHlwZXMvY29yZS9SZW5kZXJlci9pbmRleC50cyIsIndlYnBhY2s6Ly9Ad2hlZXp5L2RlbW9zLy4uL2VuZ2luZS9zcmMvZW5naW5lL3R5cGVzL2NvcmUvU2FtcGxlclN0b3JhZ2UvaW5kZXgudHMiLCJ3ZWJwYWNrOi8vQHdoZWV6eS9kZW1vcy8uLi9lbmdpbmUvc3JjL2VuZ2luZS90eXBlcy9jb3JlL1NjZW5lL1NjZW5lLnRzIiwid2VicGFjazovL0B3aGVlenkvZGVtb3MvLi4vZW5naW5lL3NyYy9lbmdpbmUvdHlwZXMvY29yZS9TY2VuZS9pbmRleC50cyIsIndlYnBhY2s6Ly9Ad2hlZXp5L2RlbW9zLy4uL2VuZ2luZS9zcmMvZW5naW5lL3R5cGVzL2NvcmUvU2NlbmVUcmVlL2luZGV4LnRzIiwid2VicGFjazovL0B3aGVlenkvZGVtb3MvLi4vZW5naW5lL3NyYy9lbmdpbmUvdHlwZXMvY29yZS9UZXh0dXJlU3RvcmFnZS9pbmRleC50cyIsIndlYnBhY2s6Ly9Ad2hlZXp5L2RlbW9zLy4uL2VuZ2luZS9zcmMvZW5naW5lL3R5cGVzL2NvcmUvVHJhbnNmb3JtL2luZGV4LnRzIiwid2VicGFjazovL0B3aGVlenkvZGVtb3MvLi4vZW5naW5lL3NyYy9lbmdpbmUvdHlwZXMvaW5kZXgudHMiLCJ3ZWJwYWNrOi8vQHdoZWV6eS9kZW1vcy8uLi9lbmdpbmUvc3JjL3BoeXNpY3MvQ29sbGlkZXIvaW5kZXgudHMiLCJ3ZWJwYWNrOi8vQHdoZWV6eS9kZW1vcy8uLi9lbmdpbmUvc3JjL3BoeXNpY3MvUGh5c2ljc09iamVjdC9pbmRleC50cyIsIndlYnBhY2s6Ly9Ad2hlZXp5L2RlbW9zLy4uL2VuZ2luZS9zcmMvcGh5c2ljcy9pbmRleC50cyIsIndlYnBhY2s6Ly9Ad2hlZXp5L2RlbW9zLy4uL2VuZ2luZS9zcmMvdXRpbHMvQXJjQmFsbENvbnRyb2xsZXIvQXJjQmFsbENvbnRyb2xsZXIudHMiLCJ3ZWJwYWNrOi8vQHdoZWV6eS9kZW1vcy8uLi9lbmdpbmUvc3JjL3V0aWxzL0FyY0JhbGxDb250cm9sbGVyL2luZGV4LnRzIiwid2VicGFjazovL0B3aGVlenkvZGVtb3MvLi4vZW5naW5lL3NyYy91dGlscy9TdHVmZi50cyIsIndlYnBhY2s6Ly9Ad2hlZXp5L2RlbW9zLy4uL2VuZ2luZS9zcmMvdXRpbHMvV2hlZXp5R0xCTG9hZGVyL1doZWV6eUdMQkxvYWRlci50cyIsIndlYnBhY2s6Ly9Ad2hlZXp5L2RlbW9zLy4uL2VuZ2luZS9zcmMvdXRpbHMvV2hlZXp5R0xCTG9hZGVyL2hlbHBlcnMudHMiLCJ3ZWJwYWNrOi8vQHdoZWV6eS9kZW1vcy8uLi9lbmdpbmUvc3JjL3V0aWxzL2luZGV4LnRzIiwid2VicGFjazovL0B3aGVlenkvZGVtb3MvLi4vLi4vbm9kZV9tb2R1bGVzL0Bsb2FkZXJzLmdsL2NvcmUvZGlzdC9pdGVyYXRvcnMvbWFrZS1pdGVyYXRvci9tYWtlLWFycmF5LWJ1ZmZlci1pdGVyYXRvci5qcyIsIndlYnBhY2s6Ly9Ad2hlZXp5L2RlbW9zLy4uLy4uL25vZGVfbW9kdWxlcy9AbG9hZGVycy5nbC9jb3JlL2Rpc3QvaXRlcmF0b3JzL21ha2UtaXRlcmF0b3IvbWFrZS1ibG9iLWl0ZXJhdG9yLmpzIiwid2VicGFjazovL0B3aGVlenkvZGVtb3MvLi4vLi4vbm9kZV9tb2R1bGVzL0Bsb2FkZXJzLmdsL2NvcmUvZGlzdC9pdGVyYXRvcnMvbWFrZS1pdGVyYXRvci9tYWtlLWl0ZXJhdG9yLmpzIiwid2VicGFjazovL0B3aGVlenkvZGVtb3MvLi4vLi4vbm9kZV9tb2R1bGVzL0Bsb2FkZXJzLmdsL2NvcmUvZGlzdC9pdGVyYXRvcnMvbWFrZS1pdGVyYXRvci9tYWtlLXN0cmVhbS1pdGVyYXRvci5qcyIsIndlYnBhY2s6Ly9Ad2hlZXp5L2RlbW9zLy4uLy4uL25vZGVfbW9kdWxlcy9AbG9hZGVycy5nbC9jb3JlL2Rpc3QvaXRlcmF0b3JzL21ha2UtaXRlcmF0b3IvbWFrZS1zdHJpbmctaXRlcmF0b3IuanMiLCJ3ZWJwYWNrOi8vQHdoZWV6eS9kZW1vcy8uLi8uLi9ub2RlX21vZHVsZXMvQGxvYWRlcnMuZ2wvY29yZS9kaXN0L2phdmFzY3JpcHQtdXRpbHMvaXMtdHlwZS5qcyIsIndlYnBhY2s6Ly9Ad2hlZXp5L2RlbW9zLy4uLy4uL25vZGVfbW9kdWxlcy9AbG9hZGVycy5nbC9jb3JlL2Rpc3QvbGliL2FwaS9sb2FkLmpzIiwid2VicGFjazovL0B3aGVlenkvZGVtb3MvLi4vLi4vbm9kZV9tb2R1bGVzL0Bsb2FkZXJzLmdsL2NvcmUvZGlzdC9saWIvYXBpL3BhcnNlLmpzIiwid2VicGFjazovL0B3aGVlenkvZGVtb3MvLi4vLi4vbm9kZV9tb2R1bGVzL0Bsb2FkZXJzLmdsL2NvcmUvZGlzdC9saWIvYXBpL3JlZ2lzdGVyLWxvYWRlcnMuanMiLCJ3ZWJwYWNrOi8vQHdoZWV6eS9kZW1vcy8uLi8uLi9ub2RlX21vZHVsZXMvQGxvYWRlcnMuZ2wvY29yZS9kaXN0L2xpYi9hcGkvc2VsZWN0LWxvYWRlci5qcyIsIndlYnBhY2s6Ly9Ad2hlZXp5L2RlbW9zLy4uLy4uL25vZGVfbW9kdWxlcy9AbG9hZGVycy5nbC9jb3JlL2Rpc3QvbGliL2ZldGNoL2ZldGNoLWZpbGUuanMiLCJ3ZWJwYWNrOi8vQHdoZWV6eS9kZW1vcy8uLi8uLi9ub2RlX21vZHVsZXMvQGxvYWRlcnMuZ2wvY29yZS9kaXN0L2xpYi9sb2FkZXItdXRpbHMvZ2V0LWRhdGEuanMiLCJ3ZWJwYWNrOi8vQHdoZWV6eS9kZW1vcy8uLi8uLi9ub2RlX21vZHVsZXMvQGxvYWRlcnMuZ2wvY29yZS9kaXN0L2xpYi9sb2FkZXItdXRpbHMvZ2V0LWZldGNoLWZ1bmN0aW9uLmpzIiwid2VicGFjazovL0B3aGVlenkvZGVtb3MvLi4vLi4vbm9kZV9tb2R1bGVzL0Bsb2FkZXJzLmdsL2NvcmUvZGlzdC9saWIvbG9hZGVyLXV0aWxzL2xvYWRlci1jb250ZXh0LmpzIiwid2VicGFjazovL0B3aGVlenkvZGVtb3MvLi4vLi4vbm9kZV9tb2R1bGVzL0Bsb2FkZXJzLmdsL2NvcmUvZGlzdC9saWIvbG9hZGVyLXV0aWxzL2xvZ2dlcnMuanMiLCJ3ZWJwYWNrOi8vQHdoZWV6eS9kZW1vcy8uLi8uLi9ub2RlX21vZHVsZXMvQGxvYWRlcnMuZ2wvY29yZS9kaXN0L2xpYi9sb2FkZXItdXRpbHMvbm9ybWFsaXplLWxvYWRlci5qcyIsIndlYnBhY2s6Ly9Ad2hlZXp5L2RlbW9zLy4uLy4uL25vZGVfbW9kdWxlcy9AbG9hZGVycy5nbC9jb3JlL2Rpc3QvbGliL2xvYWRlci11dGlscy9vcHRpb24tZGVmYXVsdHMuanMiLCJ3ZWJwYWNrOi8vQHdoZWV6eS9kZW1vcy8uLi8uLi9ub2RlX21vZHVsZXMvQGxvYWRlcnMuZ2wvY29yZS9kaXN0L2xpYi9sb2FkZXItdXRpbHMvb3B0aW9uLXV0aWxzLmpzIiwid2VicGFjazovL0B3aGVlenkvZGVtb3MvLi4vLi4vbm9kZV9tb2R1bGVzL0Bsb2FkZXJzLmdsL2NvcmUvZGlzdC9saWIvdXRpbHMvbG9nLmpzIiwid2VicGFjazovL0B3aGVlenkvZGVtb3MvLi4vLi4vbm9kZV9tb2R1bGVzL0Bsb2FkZXJzLmdsL2NvcmUvZGlzdC9saWIvdXRpbHMvbWltZS10eXBlLXV0aWxzLmpzIiwid2VicGFjazovL0B3aGVlenkvZGVtb3MvLi4vLi4vbm9kZV9tb2R1bGVzL0Bsb2FkZXJzLmdsL2NvcmUvZGlzdC9saWIvdXRpbHMvcmVzb3VyY2UtdXRpbHMuanMiLCJ3ZWJwYWNrOi8vQHdoZWV6eS9kZW1vcy8uLi8uLi9ub2RlX21vZHVsZXMvQGxvYWRlcnMuZ2wvY29yZS9kaXN0L2xpYi91dGlscy9yZXNwb25zZS11dGlscy5qcyIsIndlYnBhY2s6Ly9Ad2hlZXp5L2RlbW9zLy4uLy4uL25vZGVfbW9kdWxlcy9AbG9hZGVycy5nbC9jb3JlL2Rpc3QvbGliL3V0aWxzL3VybC11dGlscy5qcyIsIndlYnBhY2s6Ly9Ad2hlZXp5L2RlbW9zLy4uLy4uL25vZGVfbW9kdWxlcy9AbG9hZGVycy5nbC9nbHRmL2Rpc3QvZ2xiLWxvYWRlci5qcyIsIndlYnBhY2s6Ly9Ad2hlZXp5L2RlbW9zLy4uLy4uL25vZGVfbW9kdWxlcy9AbG9hZGVycy5nbC9nbHRmL2Rpc3QvbGliL3BhcnNlcnMvcGFyc2UtZ2xiLmpzIiwid2VicGFjazovL0B3aGVlenkvZGVtb3MvLi4vLi4vbm9kZV9tb2R1bGVzL0Bsb2FkZXJzLmdsL2dsdGYvZGlzdC9saWIvdXRpbHMvdmVyc2lvbi5qcyIsIndlYnBhY2s6Ly9Ad2hlZXp5L2RlbW9zLy4uLy4uL25vZGVfbW9kdWxlcy9AbG9hZGVycy5nbC9sb2FkZXItdXRpbHMvZGlzdC9saWIvYmluYXJ5LXV0aWxzL2FycmF5LWJ1ZmZlci11dGlscy5qcyIsIndlYnBhY2s6Ly9Ad2hlZXp5L2RlbW9zLy4uLy4uL25vZGVfbW9kdWxlcy9AbG9hZGVycy5nbC9sb2FkZXItdXRpbHMvZGlzdC9saWIvYmluYXJ5LXV0aWxzL21lbW9yeS1jb252ZXJzaW9uLXV0aWxzLmpzIiwid2VicGFjazovL0B3aGVlenkvZGVtb3MvLi4vLi4vbm9kZV9tb2R1bGVzL0Bsb2FkZXJzLmdsL2xvYWRlci11dGlscy9kaXN0L2xpYi9iaW5hcnktdXRpbHMvbWVtb3J5LWNvcHktdXRpbHMuanMiLCJ3ZWJwYWNrOi8vQHdoZWV6eS9kZW1vcy8uLi8uLi9ub2RlX21vZHVsZXMvQGxvYWRlcnMuZ2wvbG9hZGVyLXV0aWxzL2Rpc3QvbGliL2Vudi11dGlscy9hc3NlcnQuanMiLCJ3ZWJwYWNrOi8vQHdoZWV6eS9kZW1vcy8uLi8uLi9ub2RlX21vZHVsZXMvQGxvYWRlcnMuZ2wvbG9hZGVyLXV0aWxzL2Rpc3QvbGliL2Vudi11dGlscy9nbG9iYWxzLmpzIiwid2VicGFjazovL0B3aGVlenkvZGVtb3MvLi4vLi4vbm9kZV9tb2R1bGVzL0Bsb2FkZXJzLmdsL2xvYWRlci11dGlscy9kaXN0L2xpYi9pdGVyYXRvcnMvYXN5bmMtaXRlcmF0aW9uLmpzIiwid2VicGFjazovL0B3aGVlenkvZGVtb3MvLi4vLi4vbm9kZV9tb2R1bGVzL0Bsb2FkZXJzLmdsL2xvYWRlci11dGlscy9kaXN0L2xpYi9ub2RlL2J1ZmZlci5icm93c2VyLmpzIiwid2VicGFjazovL0B3aGVlenkvZGVtb3MvLi4vLi4vbm9kZV9tb2R1bGVzL0Bsb2FkZXJzLmdsL2xvYWRlci11dGlscy9kaXN0L2xpYi9vcHRpb24tdXRpbHMvbWVyZ2UtbG9hZGVyLW9wdGlvbnMuanMiLCJ3ZWJwYWNrOi8vQHdoZWV6eS9kZW1vcy8uLi8uLi9ub2RlX21vZHVsZXMvQGxvYWRlcnMuZ2wvbG9hZGVyLXV0aWxzL2Rpc3QvbGliL3BhdGgtdXRpbHMvZmlsZS1hbGlhc2VzLmpzIiwid2VicGFjazovL0B3aGVlenkvZGVtb3MvLi4vLi4vbm9kZV9tb2R1bGVzL0Bsb2FkZXJzLmdsL2xvYWRlci11dGlscy9kaXN0L2xpYi9wYXRoLXV0aWxzL2dldC1jd2QuanMiLCJ3ZWJwYWNrOi8vQHdoZWV6eS9kZW1vcy8uLi8uLi9ub2RlX21vZHVsZXMvQGxvYWRlcnMuZ2wvbG9hZGVyLXV0aWxzL2Rpc3QvbGliL3BhdGgtdXRpbHMvcGF0aC5qcyIsIndlYnBhY2s6Ly9Ad2hlZXp5L2RlbW9zLy4uLy4uL25vZGVfbW9kdWxlcy9AbG9hZGVycy5nbC9sb2FkZXItdXRpbHMvZGlzdC9saWIvd29ya2VyLWxvYWRlci11dGlscy9wYXJzZS13aXRoLXdvcmtlci5qcyIsIndlYnBhY2s6Ly9Ad2hlZXp5L2RlbW9zLy4uLy4uL25vZGVfbW9kdWxlcy9AbG9hZGVycy5nbC93b3JrZXItdXRpbHMvZGlzdC9saWIvZW52LXV0aWxzL2Fzc2VydC5qcyIsIndlYnBhY2s6Ly9Ad2hlZXp5L2RlbW9zLy4uLy4uL25vZGVfbW9kdWxlcy9AbG9hZGVycy5nbC93b3JrZXItdXRpbHMvZGlzdC9saWIvZW52LXV0aWxzL2dsb2JhbHMuanMiLCJ3ZWJwYWNrOi8vQHdoZWV6eS9kZW1vcy8uLi8uLi9ub2RlX21vZHVsZXMvQGxvYWRlcnMuZ2wvd29ya2VyLXV0aWxzL2Rpc3QvbGliL2Vudi11dGlscy92ZXJzaW9uLmpzIiwid2VicGFjazovL0B3aGVlenkvZGVtb3MvLi4vLi4vbm9kZV9tb2R1bGVzL0Bsb2FkZXJzLmdsL3dvcmtlci11dGlscy9kaXN0L2xpYi9ub2RlL3dvcmtlcl90aHJlYWRzLWJyb3dzZXIuanMiLCJ3ZWJwYWNrOi8vQHdoZWV6eS9kZW1vcy8uLi8uLi9ub2RlX21vZHVsZXMvQGxvYWRlcnMuZ2wvd29ya2VyLXV0aWxzL2Rpc3QvbGliL3dvcmtlci1hcGkvZ2V0LXdvcmtlci11cmwuanMiLCJ3ZWJwYWNrOi8vQHdoZWV6eS9kZW1vcy8uLi8uLi9ub2RlX21vZHVsZXMvQGxvYWRlcnMuZ2wvd29ya2VyLXV0aWxzL2Rpc3QvbGliL3dvcmtlci1hcGkvdmFsaWRhdGUtd29ya2VyLXZlcnNpb24uanMiLCJ3ZWJwYWNrOi8vQHdoZWV6eS9kZW1vcy8uLi8uLi9ub2RlX21vZHVsZXMvQGxvYWRlcnMuZ2wvd29ya2VyLXV0aWxzL2Rpc3QvbGliL3dvcmtlci1mYXJtL3dvcmtlci1mYXJtLmpzIiwid2VicGFjazovL0B3aGVlenkvZGVtb3MvLi4vLi4vbm9kZV9tb2R1bGVzL0Bsb2FkZXJzLmdsL3dvcmtlci11dGlscy9kaXN0L2xpYi93b3JrZXItZmFybS93b3JrZXItam9iLmpzIiwid2VicGFjazovL0B3aGVlenkvZGVtb3MvLi4vLi4vbm9kZV9tb2R1bGVzL0Bsb2FkZXJzLmdsL3dvcmtlci11dGlscy9kaXN0L2xpYi93b3JrZXItZmFybS93b3JrZXItcG9vbC5qcyIsIndlYnBhY2s6Ly9Ad2hlZXp5L2RlbW9zLy4uLy4uL25vZGVfbW9kdWxlcy9AbG9hZGVycy5nbC93b3JrZXItdXRpbHMvZGlzdC9saWIvd29ya2VyLWZhcm0vd29ya2VyLXRocmVhZC5qcyIsIndlYnBhY2s6Ly9Ad2hlZXp5L2RlbW9zLy4uLy4uL25vZGVfbW9kdWxlcy9AbG9hZGVycy5nbC93b3JrZXItdXRpbHMvZGlzdC9saWIvd29ya2VyLXV0aWxzL2dldC1sb2FkYWJsZS13b3JrZXItdXJsLmpzIiwid2VicGFjazovL0B3aGVlenkvZGVtb3MvLi4vLi4vbm9kZV9tb2R1bGVzL0Bsb2FkZXJzLmdsL3dvcmtlci11dGlscy9kaXN0L2xpYi93b3JrZXItdXRpbHMvZ2V0LXRyYW5zZmVyLWxpc3QuanMiLCJ3ZWJwYWNrOi8vQHdoZWV6eS9kZW1vcy8uLi8uLi9ub2RlX21vZHVsZXMvQHByb2JlLmdsL2Vudi9kaXN0L2luZGV4LmpzIiwid2VicGFjazovL0B3aGVlenkvZGVtb3MvLi4vLi4vbm9kZV9tb2R1bGVzL0Bwcm9iZS5nbC9lbnYvZGlzdC9saWIvZ2V0LWJyb3dzZXIuanMiLCJ3ZWJwYWNrOi8vQHdoZWV6eS9kZW1vcy8uLi8uLi9ub2RlX21vZHVsZXMvQHByb2JlLmdsL2Vudi9kaXN0L2xpYi9nbG9iYWxzLmpzIiwid2VicGFjazovL0B3aGVlenkvZGVtb3MvLi4vLi4vbm9kZV9tb2R1bGVzL0Bwcm9iZS5nbC9lbnYvZGlzdC9saWIvaXMtYnJvd3Nlci5qcyIsIndlYnBhY2s6Ly9Ad2hlZXp5L2RlbW9zLy4uLy4uL25vZGVfbW9kdWxlcy9AcHJvYmUuZ2wvZW52L2Rpc3QvbGliL2lzLWVsZWN0cm9uLmpzIiwid2VicGFjazovL0B3aGVlenkvZGVtb3MvLi4vLi4vbm9kZV9tb2R1bGVzL0Bwcm9iZS5nbC9lbnYvZGlzdC91dGlscy9hc3NlcnQuanMiLCJ3ZWJwYWNrOi8vQHdoZWV6eS9kZW1vcy8uLi8uLi9ub2RlX21vZHVsZXMvQHByb2JlLmdsL2xvZy9kaXN0L2xvZy5qcyIsIndlYnBhY2s6Ly9Ad2hlZXp5L2RlbW9zLy4uLy4uL25vZGVfbW9kdWxlcy9AcHJvYmUuZ2wvbG9nL2Rpc3QvdXRpbHMvYXNzZXJ0LmpzIiwid2VicGFjazovL0B3aGVlenkvZGVtb3MvLi4vLi4vbm9kZV9tb2R1bGVzL0Bwcm9iZS5nbC9sb2cvZGlzdC91dGlscy9hdXRvYmluZC5qcyIsIndlYnBhY2s6Ly9Ad2hlZXp5L2RlbW9zLy4uLy4uL25vZGVfbW9kdWxlcy9AcHJvYmUuZ2wvbG9nL2Rpc3QvdXRpbHMvY29sb3IuanMiLCJ3ZWJwYWNrOi8vQHdoZWV6eS9kZW1vcy8uLi8uLi9ub2RlX21vZHVsZXMvQHByb2JlLmdsL2xvZy9kaXN0L3V0aWxzL2Zvcm1hdHRlcnMuanMiLCJ3ZWJwYWNrOi8vQHdoZWV6eS9kZW1vcy8uLi8uLi9ub2RlX21vZHVsZXMvQHByb2JlLmdsL2xvZy9kaXN0L3V0aWxzL2hpLXJlcy10aW1lc3RhbXAuanMiLCJ3ZWJwYWNrOi8vQHdoZWV6eS9kZW1vcy8uLi8uLi9ub2RlX21vZHVsZXMvQHByb2JlLmdsL2xvZy9kaXN0L3V0aWxzL2xvY2FsLXN0b3JhZ2UuanMiLCJ3ZWJwYWNrOi8vQHdoZWV6eS9kZW1vcy8uLi8uLi9ub2RlX21vZHVsZXMvd2dwdS1tYXRyaXgvZGlzdC8zLngvd2dwdS1tYXRyaXgubW9kdWxlLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEVuZ2luZSwgSUVuZ2luZSB9IGZyb20gJ0B3aGVlenkvZW5naW5lJ1xuaW1wb3J0IHsgRGVtbzAgfSBmcm9tICcuL3NyYy9EZW1vMCdcbmltcG9ydCB7IERlbW8xIH0gZnJvbSAnLi9zcmMvRGVtbzEnXG5cbmNvbnN0IGNhbnZhcyA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCd3ZWJncHUtY2FudmFzJykgYXMgSFRNTENhbnZhc0VsZW1lbnRcblxuY29uc3QgaW5pdERlYnVnQ29udHJvbHMgPSAoZW5naW5lOiBJRW5naW5lKSA9PiB7XG4gICAgY29uc3QgZGVmYXVsdE91dHB1dFNvdXJjZSA9IDBcbiAgICBjb25zdCBkZWZhdWx0UmVuZGVyaW5nTW9kZSA9IDFcbiAgICBjb25zdCBkZWZhdWx0U2NlbmUgPSAxXG5cbiAgICBjb25zdCBkZWJ1Z0NvbnRhaW5lciA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFxuICAgICAgICAnZGVidWctY29udGFpbmVyJ1xuICAgICkgYXMgSFRNTERpdkVsZW1lbnRcblxuICAgIGNvbnN0IHNjZW5lU2VsZWN0b3IgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcbiAgICAgICAgJ3NjZW5lLXNlbGVjdG9yJ1xuICAgICkgYXMgSFRNTFNlbGVjdEVsZW1lbnRcblxuICAgIGNvbnN0IHNjZW5lT3B0aW9ucyA9IFtcbiAgICAgICAgeyBsYWJlbDogJ1NjZW5lIDEnLCB2YWx1ZTogMCB9LFxuICAgICAgICB7IGxhYmVsOiAnU2NlbmUgMicsIHZhbHVlOiAxIH0sXG4gICAgXVxuXG4gICAgc2NlbmVPcHRpb25zLmZvckVhY2goKGl0ZW0pID0+IHtcbiAgICAgICAgY29uc3Qgb3B0aW9uID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnb3B0aW9uJylcbiAgICAgICAgaWYgKGl0ZW0udmFsdWUgPT09IGRlZmF1bHRTY2VuZSkge1xuICAgICAgICAgICAgb3B0aW9uLnNlbGVjdGVkID0gdHJ1ZVxuICAgICAgICB9XG4gICAgICAgIG9wdGlvbi50ZXh0Q29udGVudCA9IGl0ZW0ubGFiZWxcbiAgICAgICAgb3B0aW9uLnZhbHVlID0gU3RyaW5nKGl0ZW0udmFsdWUpXG4gICAgICAgIHNjZW5lU2VsZWN0b3IuYXBwZW5kQ2hpbGQob3B0aW9uKVxuICAgIH0pXG5cbiAgICBzY2VuZVNlbGVjdG9yLmFkZEV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsIChldmVudCkgPT4ge1xuICAgICAgICBzZXRTY2VuZShlbmdpbmUsIE51bWJlcigoZXZlbnQudGFyZ2V0IGFzIEhUTUxTZWxlY3RFbGVtZW50KS52YWx1ZSkpXG4gICAgfSlcblxuICAgIGNvbnN0IG91dHB1dFNvdXJjZURyb3BEb3duID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc2VsZWN0JylcbiAgICBvdXRwdXRTb3VyY2VEcm9wRG93bi5hZGRFdmVudExpc3RlbmVyKCdjaGFuZ2UnLCAoZXZlbnQpID0+IHtcbiAgICAgICAgZW5naW5lLnJlbmRlcmVyLm91dHB1dFNvdXJjZSA9IE51bWJlcihcbiAgICAgICAgICAgIChldmVudC50YXJnZXQgYXMgSFRNTFNlbGVjdEVsZW1lbnQpLnZhbHVlXG4gICAgICAgIClcbiAgICB9KVxuXG4gICAgY29uc3QgcmVuZGVyaW5nTW9kZURyb3BEb3duID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc2VsZWN0JylcbiAgICByZW5kZXJpbmdNb2RlRHJvcERvd24uYWRkRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgKGV2ZW50KSA9PiB7XG4gICAgICAgIGVuZ2luZS5yZW5kZXJlci5yZW5kZXJpbmdNb2RlID0gTnVtYmVyKFxuICAgICAgICAgICAgKGV2ZW50LnRhcmdldCBhcyBIVE1MU2VsZWN0RWxlbWVudCkudmFsdWVcbiAgICAgICAgKVxuICAgIH0pXG5cbiAgICBjb25zdCBvdXRwdXRPcHRpb25zID0gW1xuICAgICAgICB7IGxhYmVsOiAnQ29sb3InLCB2YWx1ZTogMCB9LFxuICAgICAgICB7IGxhYmVsOiAnQW1iaWVudCBjb2xvcicsIHZhbHVlOiAyIH0sXG4gICAgICAgIHsgbGFiZWw6ICdEaWZmdXNlIGNvbG9yJywgdmFsdWU6IDMgfSxcbiAgICAgICAgeyBsYWJlbDogJ01ldGFsbGljIGNvbXBvbmVudCcsIHZhbHVlOiA0IH0sXG4gICAgICAgIHsgbGFiZWw6ICdSb3VnaG5lc3MgY29tcG9uZW50JywgdmFsdWU6IDUgfSxcbiAgICAgICAgeyBsYWJlbDogJ09jY2x1c2lvbiBjb21wb25lbnQnLCB2YWx1ZTogOCB9LFxuICAgICAgICB7IGxhYmVsOiAnU3VyZmFjZSBub3JtYWwnLCB2YWx1ZTogMSB9LFxuICAgICAgICB7IGxhYmVsOiAnRnJhZ21lbnQgbm9ybWFsJywgdmFsdWU6IDYgfSxcbiAgICAgICAgeyBsYWJlbDogJ1ZlcnRleCB0YW5nZW50JywgdmFsdWU6IDcgfSxcbiAgICBdXG5cbiAgICBvdXRwdXRPcHRpb25zLmZvckVhY2goKGl0ZW0pID0+IHtcbiAgICAgICAgY29uc3Qgb3B0aW9uID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnb3B0aW9uJylcbiAgICAgICAgaWYgKGl0ZW0udmFsdWUgPT09IGRlZmF1bHRPdXRwdXRTb3VyY2UpIHtcbiAgICAgICAgICAgIG9wdGlvbi5zZWxlY3RlZCA9IHRydWVcbiAgICAgICAgfVxuICAgICAgICBvcHRpb24udGV4dENvbnRlbnQgPSBpdGVtLmxhYmVsXG4gICAgICAgIG9wdGlvbi52YWx1ZSA9IFN0cmluZyhpdGVtLnZhbHVlKVxuICAgICAgICBvdXRwdXRTb3VyY2VEcm9wRG93bi5hcHBlbmRDaGlsZChvcHRpb24pXG4gICAgfSlcblxuICAgIGNvbnN0IHJlbmRlck1vZGVzID0gW1xuICAgICAgICB7IGxhYmVsOiAnQmxpbm4tUGhvbmcgKE5vIGJ1bXAgbWFwcGluZyknLCB2YWx1ZTogMCB9LFxuICAgICAgICB7IGxhYmVsOiAnQmxpbm4tUGhvbmcgKFdpdGggYnVtcCBtYXBwaW5nKScsIHZhbHVlOiAxIH0sXG4gICAgICAgIHsgbGFiZWw6ICdUZXJyZW5jZS1Db29rIChObyBtaXBtYXBwaW5nKScsIHZhbHVlOiAyIH0sXG4gICAgXVxuXG4gICAgcmVuZGVyTW9kZXMuZm9yRWFjaCgoaXRlbSkgPT4ge1xuICAgICAgICBjb25zdCBvcHRpb24gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdvcHRpb24nKVxuICAgICAgICBpZiAoaXRlbS52YWx1ZSA9PT0gZGVmYXVsdFJlbmRlcmluZ01vZGUpIHtcbiAgICAgICAgICAgIG9wdGlvbi5zZWxlY3RlZCA9IHRydWVcbiAgICAgICAgfVxuICAgICAgICBvcHRpb24udGV4dENvbnRlbnQgPSBpdGVtLmxhYmVsXG4gICAgICAgIG9wdGlvbi52YWx1ZSA9IFN0cmluZyhpdGVtLnZhbHVlKVxuICAgICAgICByZW5kZXJpbmdNb2RlRHJvcERvd24uYXBwZW5kQ2hpbGQob3B0aW9uKVxuICAgIH0pXG5cbiAgICBlbmdpbmUucmVuZGVyZXIub3V0cHV0U291cmNlID0gZGVmYXVsdE91dHB1dFNvdXJjZVxuICAgIGVuZ2luZS5yZW5kZXJlci5yZW5kZXJpbmdNb2RlID0gZGVmYXVsdFJlbmRlcmluZ01vZGVcbiAgICBzZXRTY2VuZShlbmdpbmUsIGRlZmF1bHRTY2VuZSlcblxuICAgIGRlYnVnQ29udGFpbmVyLmFwcGVuZENoaWxkKG91dHB1dFNvdXJjZURyb3BEb3duKVxuICAgIGRlYnVnQ29udGFpbmVyLmFwcGVuZENoaWxkKHJlbmRlcmluZ01vZGVEcm9wRG93bilcbn1cblxuY29uc3Qgc2V0U2NlbmUgPSBhc3luYyAoZW5naW5lOiBJRW5naW5lLCBpbmRleDogbnVtYmVyKSA9PiB7XG4gICAgY29uc3QgbG9hZGVyID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2xvYWRlcicpIGFzIEhUTUxEaXZFbGVtZW50XG5cbiAgICBzd2l0Y2ggKGluZGV4KSB7XG4gICAgICAgIGNhc2UgMDoge1xuICAgICAgICAgICAgbG9hZGVyLnN0eWxlLmRpc3BsYXkgPSAnYmxvY2snXG4gICAgICAgICAgICBlbmdpbmUuc2NlbmUgPSB1bmRlZmluZWRcbiAgICAgICAgICAgIGNvbnN0IHNjZW5lID0gbmV3IERlbW8wKClcbiAgICAgICAgICAgIGF3YWl0IHNjZW5lLmluaXQoKVxuXG4gICAgICAgICAgICBlbmdpbmUuc2NlbmUgPSBzY2VuZVxuICAgICAgICAgICAgbG9hZGVyLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSdcbiAgICAgICAgICAgIGVuZ2luZS5yZW5kZXIoKVxuXG4gICAgICAgICAgICBicmVha1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgMToge1xuICAgICAgICAgICAgbG9hZGVyLnN0eWxlLmRpc3BsYXkgPSAnYmxvY2snXG4gICAgICAgICAgICBlbmdpbmUuc2NlbmUgPSB1bmRlZmluZWRcbiAgICAgICAgICAgIGNvbnN0IHNjZW5lID0gbmV3IERlbW8xKClcbiAgICAgICAgICAgIGF3YWl0IHNjZW5lLmluaXQoKVxuXG4gICAgICAgICAgICBlbmdpbmUuc2NlbmUgPSBzY2VuZVxuICAgICAgICAgICAgbG9hZGVyLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSdcbiAgICAgICAgICAgIGVuZ2luZS5yZW5kZXIoKVxuICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuY29uc3QgcnVuID0gYXN5bmMgKCkgPT4ge1xuICAgIGNvbnN0IGVuZ2luZSA9IChhd2FpdCBFbmdpbmUuZ2V0T3JJbml0KHsgY2FudmFzIH0pKSBhcyBFbmdpbmVcblxuICAgIGluaXREZWJ1Z0NvbnRyb2xzKGVuZ2luZSlcbn1cblxucnVuKClcbiIsImltcG9ydCB7IHZlYzMgfSBmcm9tICd3Z3B1LW1hdHJpeCdcbmltcG9ydCB7XG4gICAgV2hlZXp5R0xCTG9hZGVyLFxuICAgIFNjZW5lLFxuICAgIElHYW1lT2JqZWN0LFxuICAgIEdhbWVPYmplY3QsXG4gICAgVHJhbnNmb3JtLFxuICAgIERpcmVjdGlvbmFsTGlnaHQsXG4gICAgVFNreWJveEJpdG1hcHMsXG4gICAgSVNjZW5lLFxufSBmcm9tICdAd2hlZXp5L2VuZ2luZSdcbmltcG9ydCB7IEFyY0JhbGxDYW1lcmEgfSBmcm9tICdAd2hlZXp5L2VuZ2luZS9zcmMvZW5naW5lL2NvcmUvY2FtZXJhcy9BcmNCYWxsQ2FtZXJhJ1xuaW1wb3J0IHsgQXJjQmFsbENvbnRyb2xsZXIgfSBmcm9tICdAd2hlZXp5L2VuZ2luZS9zcmMvdXRpbHMvQXJjQmFsbENvbnRyb2xsZXInXG5cbi8vVGhpcyBpcyBzdXBwb3NlZCB0byBkZW1vbnN0cmF0ZSBiYXNpYyB3b3JrZmxvd1xuZXhwb3J0IGNsYXNzIERlbW8wIGV4dGVuZHMgU2NlbmUgaW1wbGVtZW50cyBJU2NlbmUge1xuICAgIHByaXZhdGUgc3VuITogSUdhbWVPYmplY3RcblxuICAgIHByaXZhdGUgbWVyY3VyeSE6IElHYW1lT2JqZWN0XG4gICAgcHJpdmF0ZSBtZXJjdXJ5SG9vazogSUdhbWVPYmplY3QgPSB0aGlzLl9jcmVhdGVUcmFuc2Zvcm1PYmplY3QoKVxuICAgIHByaXZhdGUgdmVudXMhOiBJR2FtZU9iamVjdFxuICAgIHByaXZhdGUgdmVudXNIb29rOiBJR2FtZU9iamVjdCA9IHRoaXMuX2NyZWF0ZVRyYW5zZm9ybU9iamVjdCgpXG4gICAgcHJpdmF0ZSBlYXJ0aCE6IElHYW1lT2JqZWN0XG4gICAgcHJpdmF0ZSBlYXJ0aEhvb2s6IElHYW1lT2JqZWN0ID0gdGhpcy5fY3JlYXRlVHJhbnNmb3JtT2JqZWN0KClcbiAgICBwcml2YXRlIG1hcnMhOiBJR2FtZU9iamVjdFxuICAgIHByaXZhdGUgbWFyc0hvb2s6IElHYW1lT2JqZWN0ID0gdGhpcy5fY3JlYXRlVHJhbnNmb3JtT2JqZWN0KClcbiAgICBwcml2YXRlIGp1cGl0ZXIhOiBJR2FtZU9iamVjdFxuICAgIHByaXZhdGUganVwaXRlckhvb2s6IElHYW1lT2JqZWN0ID0gdGhpcy5fY3JlYXRlVHJhbnNmb3JtT2JqZWN0KClcbiAgICBwcml2YXRlIHNhdHVybiE6IElHYW1lT2JqZWN0XG4gICAgcHJpdmF0ZSBzYXR1cm5Ib29rOiBJR2FtZU9iamVjdCA9IHRoaXMuX2NyZWF0ZVRyYW5zZm9ybU9iamVjdCgpXG4gICAgcHJpdmF0ZSB1cmFudXMhOiBJR2FtZU9iamVjdFxuICAgIHByaXZhdGUgdXJhbnVzSG9vazogSUdhbWVPYmplY3QgPSB0aGlzLl9jcmVhdGVUcmFuc2Zvcm1PYmplY3QoKVxuICAgIHByaXZhdGUgbmVwdHVuZSE6IElHYW1lT2JqZWN0XG4gICAgcHJpdmF0ZSBuZXB0dW5lSG9vazogSUdhbWVPYmplY3QgPSB0aGlzLl9jcmVhdGVUcmFuc2Zvcm1PYmplY3QoKVxuXG4gICAgcHVibGljIHllYXJzUGVyTWludXRlID0gMVxuXG4gICAgcHJpdmF0ZSBjb250cm9sbGVyOiBBcmNCYWxsQ29udHJvbGxlclxuXG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKClcbiAgICAgICAgdGhpcy5jYW1lcmEgPSBuZXcgQXJjQmFsbENhbWVyYSh7XG4gICAgICAgICAgICB6RmFyOiAxMDAwLFxuICAgICAgICAgICAgek5lYXI6IDAuMSxcbiAgICAgICAgICAgIGNhbnZhc1dpZHRoOiB0aGlzLl9lbmdpbmUhLnJlbmRlcmVyLmNvbnRleHQuY2FudmFzLndpZHRoLFxuICAgICAgICAgICAgY2FudmFzSGVpZ2h0OiB0aGlzLl9lbmdpbmUhLnJlbmRlcmVyLmNvbnRleHQuY2FudmFzLmhlaWdodCxcbiAgICAgICAgICAgIHBvc2l0aW9uOiB2ZWMzLmNyZWF0ZSgwLCA0LCA1KSxcbiAgICAgICAgfSlcblxuICAgICAgICB0aGlzLmNvbnRyb2xsZXIgPSBuZXcgQXJjQmFsbENvbnRyb2xsZXIoe1xuICAgICAgICAgICAgY2FtZXJhOiB0aGlzLmNhbWVyYSBhcyBBcmNCYWxsQ2FtZXJhLFxuICAgICAgICAgICAgY2FudmFzOiB0aGlzLl9lbmdpbmU/LnJlbmRlcmVyLmNvbnRleHQuY2FudmFzIGFzIEhUTUxDYW52YXNFbGVtZW50LFxuICAgICAgICB9KVxuXG4gICAgICAgIHRoaXMubGlnaHQgPSBuZXcgRGlyZWN0aW9uYWxMaWdodCh7XG4gICAgICAgICAgICBwYXJlbnQ6IHRoaXMucm9vdCxcbiAgICAgICAgICAgIHBvc2l0aW9uOiB2ZWMzLmNyZWF0ZSgwLCAwLCAwKSxcbiAgICAgICAgfSlcblxuICAgICAgICB0aGlzLl9zZXR1cFNreUJveCgpXG4gICAgfVxuXG4gICAgcHJpdmF0ZSBhc3luYyBfc2V0dXBTa3lCb3goKSB7XG4gICAgICAgIGNvbnN0IGltZ1NyY3MgPSBbXG4gICAgICAgICAgICAnc3RhdGljL2N1YmVtYXBzL3NwYWNlL3Bvc3gucG5nJyxcbiAgICAgICAgICAgICdzdGF0aWMvY3ViZW1hcHMvc3BhY2UvbmVneC5wbmcnLFxuICAgICAgICAgICAgJ3N0YXRpYy9jdWJlbWFwcy9zcGFjZS9wb3N5LnBuZycsXG4gICAgICAgICAgICAnc3RhdGljL2N1YmVtYXBzL3NwYWNlL25lZ3kucG5nJyxcbiAgICAgICAgICAgICdzdGF0aWMvY3ViZW1hcHMvc3BhY2UvcG9zei5wbmcnLFxuICAgICAgICAgICAgJ3N0YXRpYy9jdWJlbWFwcy9zcGFjZS9uZWd6LnBuZycsXG4gICAgICAgIF1cblxuICAgICAgICBjb25zdCBwcm9taXNlcyA9IGltZ1NyY3MubWFwKGFzeW5jIChzb3VyY2UpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goc291cmNlKVxuICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZUltYWdlQml0bWFwKGF3YWl0IHJlc3BvbnNlLmJsb2IoKSlcbiAgICAgICAgfSlcbiAgICAgICAgY29uc3QgaW1hZ2VCaXRtYXBzID0gKGF3YWl0IFByb21pc2UuYWxsKHByb21pc2VzKSkgYXMgVFNreWJveEJpdG1hcHNcblxuICAgICAgICB0aGlzLl9lbmdpbmU/LnJlbmRlcmVyLnNldFNreUJveFRleHR1cmUoaW1hZ2VCaXRtYXBzKVxuICAgIH1cblxuICAgIHByaXZhdGUgX2NyZWF0ZVRyYW5zZm9ybU9iamVjdCgpOiBHYW1lT2JqZWN0IHtcbiAgICAgICAgY29uc3QgZ2FtZU9iamVjdCA9IG5ldyBHYW1lT2JqZWN0KClcblxuICAgICAgICB0aGlzLm9iamVjdE1hbmFnZXIuYWRkT2JqZWN0KGdhbWVPYmplY3QsIHRoaXMucm9vdClcblxuICAgICAgICBuZXcgVHJhbnNmb3JtKGdhbWVPYmplY3QpXG5cbiAgICAgICAgcmV0dXJuIGdhbWVPYmplY3RcbiAgICB9XG5cbiAgICBwcml2YXRlIGFzeW5jIF9zZXR1cFN1bigpIHtcbiAgICAgICAgY29uc3QgcGxhbmV0TUQgPSBhd2FpdCBXaGVlenlHTEJMb2FkZXIubG9hZEZyb21VcmwoXG4gICAgICAgICAgICAnc3RhdGljL21vZGVscy9wbGFuZXRzL3N1bi5nbGInXG4gICAgICAgIClcbiAgICAgICAgdGhpcy5zdW4gPSBhd2FpdCB0aGlzLnVwbG9hZE1vZGVsKHtcbiAgICAgICAgICAgIG1vZGVsRGF0YTogcGxhbmV0TUQsXG4gICAgICAgIH0pXG5cbiAgICAgICAgdGhpcy5zdW4udHJhbnNmb3JtLnNjYWxlKHZlYzMuY3JlYXRlKDAuMTIsIDAuMTIsIDAuMTIpKVxuICAgIH1cblxuICAgIHByaXZhdGUgYXN5bmMgX3NldHVwTWVyY3VyeSgpIHtcbiAgICAgICAgY29uc3QgcGxhbmV0TUQgPSBhd2FpdCBXaGVlenlHTEJMb2FkZXIubG9hZEZyb21VcmwoXG4gICAgICAgICAgICAnc3RhdGljL21vZGVscy9wbGFuZXRzL21lcmN1cnkuZ2xiJ1xuICAgICAgICApXG4gICAgICAgIHRoaXMubWVyY3VyeSA9IGF3YWl0IHRoaXMudXBsb2FkTW9kZWwoe1xuICAgICAgICAgICAgbW9kZWxEYXRhOiBwbGFuZXRNRCxcbiAgICAgICAgfSlcblxuICAgICAgICB0aGlzLm9iamVjdE1hbmFnZXIucmVwYXJlbnRPYmplY3QodGhpcy5tZXJjdXJ5LCB0aGlzLm1lcmN1cnlIb29rKVxuXG4gICAgICAgIHRoaXMubWVyY3VyeUhvb2sudHJhbnNmb3JtLnJvdGF0ZURlZ3JlZXNFdWxlcih7IHk6IDgwIH0pXG5cbiAgICAgICAgdGhpcy5tZXJjdXJ5LnRyYW5zZm9ybS5zY2FsZSh2ZWMzLmNyZWF0ZSgwLjA4LCAwLjA4LCAwLjA4KSlcbiAgICAgICAgdGhpcy5tZXJjdXJ5LnRyYW5zZm9ybS50cmFuc2xhdGUodmVjMy5jcmVhdGUoMS40KSlcbiAgICB9XG5cbiAgICBwcml2YXRlIGFzeW5jIF9zZXR1cFZlbnVzKCkge1xuICAgICAgICBjb25zdCBwbGFuZXRNRCA9IGF3YWl0IFdoZWV6eUdMQkxvYWRlci5sb2FkRnJvbVVybChcbiAgICAgICAgICAgICdzdGF0aWMvbW9kZWxzL3BsYW5ldHMvdmVudXMuZ2xiJ1xuICAgICAgICApXG4gICAgICAgIHRoaXMudmVudXMgPSBhd2FpdCB0aGlzLnVwbG9hZE1vZGVsKHtcbiAgICAgICAgICAgIG1vZGVsRGF0YTogcGxhbmV0TUQsXG4gICAgICAgIH0pXG5cbiAgICAgICAgdGhpcy5vYmplY3RNYW5hZ2VyLnJlcGFyZW50T2JqZWN0KHRoaXMudmVudXMsIHRoaXMudmVudXNIb29rKVxuXG4gICAgICAgIHRoaXMudmVudXNIb29rLnRyYW5zZm9ybS5yb3RhdGVEZWdyZWVzRXVsZXIoeyB5OiAxNjAgfSlcblxuICAgICAgICB0aGlzLnZlbnVzLnRyYW5zZm9ybS5zY2FsZSh2ZWMzLmNyZWF0ZSgwLjEyLCAwLjEyLCAwLjEyKSlcbiAgICAgICAgdGhpcy52ZW51cy50cmFuc2Zvcm0udHJhbnNsYXRlKHZlYzMuY3JlYXRlKDEuNywgMCwgMCkpXG4gICAgfVxuXG4gICAgcHJpdmF0ZSBhc3luYyBfc2V0dXBFYXJ0aCgpIHtcbiAgICAgICAgY29uc3QgcGxhbmV0TUQgPSBhd2FpdCBXaGVlenlHTEJMb2FkZXIubG9hZEZyb21VcmwoXG4gICAgICAgICAgICAnc3RhdGljL21vZGVscy9wbGFuZXRzL2VhcnRoLmdsYidcbiAgICAgICAgKVxuICAgICAgICB0aGlzLmVhcnRoID0gYXdhaXQgdGhpcy51cGxvYWRNb2RlbCh7XG4gICAgICAgICAgICBtb2RlbERhdGE6IHBsYW5ldE1ELFxuICAgICAgICB9KVxuXG4gICAgICAgIHRoaXMub2JqZWN0TWFuYWdlci5yZXBhcmVudE9iamVjdCh0aGlzLmVhcnRoLCB0aGlzLmVhcnRoSG9vaylcblxuICAgICAgICB0aGlzLmVhcnRoSG9vay50cmFuc2Zvcm0ucm90YXRlRGVncmVlc0V1bGVyKHsgeTogMTAgfSlcblxuICAgICAgICB0aGlzLmVhcnRoLnRyYW5zZm9ybS5yb3RhdGVEZWdyZWVzRXVsZXIoeyB4OiAtOTAgfSlcblxuICAgICAgICB0aGlzLmVhcnRoLnRyYW5zZm9ybS5zY2FsZSh2ZWMzLmNyZWF0ZSgwLjE2LCAwLjE2LCAwLjE2KSlcbiAgICAgICAgdGhpcy5lYXJ0aC50cmFuc2Zvcm0udHJhbnNsYXRlKHZlYzMuY3JlYXRlKDIuMiwgMCwgMCkpXG4gICAgfVxuXG4gICAgcHJpdmF0ZSBhc3luYyBfc2V0dXBNYXJzKCkge1xuICAgICAgICBjb25zdCBwbGFuZXRNRCA9IGF3YWl0IFdoZWV6eUdMQkxvYWRlci5sb2FkRnJvbVVybChcbiAgICAgICAgICAgICdzdGF0aWMvbW9kZWxzL3BsYW5ldHMvbWFycy5nbGInXG4gICAgICAgIClcbiAgICAgICAgdGhpcy5tYXJzID0gYXdhaXQgdGhpcy51cGxvYWRNb2RlbCh7XG4gICAgICAgICAgICBtb2RlbERhdGE6IHBsYW5ldE1ELFxuICAgICAgICB9KVxuXG4gICAgICAgIHRoaXMub2JqZWN0TWFuYWdlci5yZXBhcmVudE9iamVjdCh0aGlzLm1hcnMsIHRoaXMubWFyc0hvb2spXG5cbiAgICAgICAgdGhpcy5tYXJzSG9vay50cmFuc2Zvcm0ucm90YXRlRGVncmVlc0V1bGVyKHsgeTogNTAgfSlcblxuICAgICAgICB0aGlzLm1hcnMudHJhbnNmb3JtLnNjYWxlKHZlYzMuY3JlYXRlKDAuMTQsIDAuMTQsIDAuMTQpKVxuICAgICAgICB0aGlzLm1hcnMudHJhbnNmb3JtLnRyYW5zbGF0ZSh2ZWMzLmNyZWF0ZSgyLjcsIDAsIDApKVxuICAgIH1cblxuICAgIHByaXZhdGUgYXN5bmMgX3NldHVwSnVwaXRlcigpIHtcbiAgICAgICAgY29uc3QgcGxhbmV0TUQgPSBhd2FpdCBXaGVlenlHTEJMb2FkZXIubG9hZEZyb21VcmwoXG4gICAgICAgICAgICAnc3RhdGljL21vZGVscy9wbGFuZXRzL2p1cGl0ZXIuZ2xiJ1xuICAgICAgICApXG4gICAgICAgIHRoaXMuanVwaXRlciA9IGF3YWl0IHRoaXMudXBsb2FkTW9kZWwoe1xuICAgICAgICAgICAgbW9kZWxEYXRhOiBwbGFuZXRNRCxcbiAgICAgICAgfSlcblxuICAgICAgICB0aGlzLm9iamVjdE1hbmFnZXIucmVwYXJlbnRPYmplY3QodGhpcy5qdXBpdGVyLCB0aGlzLmp1cGl0ZXJIb29rKVxuXG4gICAgICAgIHRoaXMuanVwaXRlckhvb2sudHJhbnNmb3JtLnJvdGF0ZURlZ3JlZXNFdWxlcih7IHk6IDE1MCB9KVxuXG4gICAgICAgIHRoaXMuanVwaXRlci50cmFuc2Zvcm0uc2NhbGUodmVjMy5jcmVhdGUoMC4xNSwgMC4xNSwgMC4xNSkpXG4gICAgICAgIHRoaXMuanVwaXRlci50cmFuc2Zvcm0ucm90YXRlRGVncmVlc0V1bGVyKHsgeDogOTAgfSlcbiAgICAgICAgdGhpcy5qdXBpdGVyLnRyYW5zZm9ybS50cmFuc2xhdGUodmVjMy5jcmVhdGUoMy40LCAwLCAwKSlcbiAgICB9XG5cbiAgICBwcml2YXRlIGFzeW5jIF9zZXR1cFNhdHVybigpIHtcbiAgICAgICAgY29uc3QgcGxhbmV0TUQgPSBhd2FpdCBXaGVlenlHTEJMb2FkZXIubG9hZEZyb21VcmwoXG4gICAgICAgICAgICAnc3RhdGljL21vZGVscy9wbGFuZXRzL3NhdHVybi5nbGInXG4gICAgICAgIClcbiAgICAgICAgdGhpcy5zYXR1cm4gPSBhd2FpdCB0aGlzLnVwbG9hZE1vZGVsKHtcbiAgICAgICAgICAgIG1vZGVsRGF0YTogcGxhbmV0TUQsXG4gICAgICAgIH0pXG5cbiAgICAgICAgdGhpcy5vYmplY3RNYW5hZ2VyLnJlcGFyZW50T2JqZWN0KHRoaXMuc2F0dXJuLCB0aGlzLnNhdHVybkhvb2spXG5cbiAgICAgICAgdGhpcy5zYXR1cm5Ib29rLnRyYW5zZm9ybS5yb3RhdGVEZWdyZWVzRXVsZXIoeyB5OiAyMTAgfSlcblxuICAgICAgICB0aGlzLnNhdHVybi50cmFuc2Zvcm0uc2NhbGUodmVjMy5jcmVhdGUoMC4wMDEyLCAwLjAwMTIsIDAuMDAxMikpXG4gICAgICAgIHRoaXMuc2F0dXJuLnRyYW5zZm9ybS5yb3RhdGVEZWdyZWVzRXVsZXIoeyB4OiA3NiB9KVxuICAgICAgICB0aGlzLnNhdHVybi50cmFuc2Zvcm0udHJhbnNsYXRlKHZlYzMuY3JlYXRlKDQuMywgMCwgMCkpXG4gICAgfVxuXG4gICAgcHJpdmF0ZSBhc3luYyBfc2V0dXBVcmFudXMoKSB7XG4gICAgICAgIGNvbnN0IHBsYW5ldE1EID0gYXdhaXQgV2hlZXp5R0xCTG9hZGVyLmxvYWRGcm9tVXJsKFxuICAgICAgICAgICAgJ3N0YXRpYy9tb2RlbHMvcGxhbmV0cy91cmFudXMuZ2xiJ1xuICAgICAgICApXG4gICAgICAgIHRoaXMudXJhbnVzID0gYXdhaXQgdGhpcy51cGxvYWRNb2RlbCh7XG4gICAgICAgICAgICBtb2RlbERhdGE6IHBsYW5ldE1ELFxuICAgICAgICB9KVxuXG4gICAgICAgIHRoaXMub2JqZWN0TWFuYWdlci5yZXBhcmVudE9iamVjdCh0aGlzLnVyYW51cywgdGhpcy51cmFudXNIb29rKVxuXG4gICAgICAgIHRoaXMudXJhbnVzSG9vay50cmFuc2Zvcm0ucm90YXRlRGVncmVlc0V1bGVyKHsgeTogMjcwIH0pXG5cbiAgICAgICAgdGhpcy51cmFudXMudHJhbnNmb3JtLnNjYWxlKHZlYzMuY3JlYXRlKDAuMiwgMC4yLCAwLjIpKVxuICAgICAgICB0aGlzLnVyYW51cy50cmFuc2Zvcm0ucm90YXRlRGVncmVlc0V1bGVyKHsgeDogOTAgfSlcbiAgICAgICAgdGhpcy51cmFudXMudHJhbnNmb3JtLnRyYW5zbGF0ZSh2ZWMzLmNyZWF0ZSg1LjIsIDAsIDApKVxuICAgIH1cblxuICAgIHByaXZhdGUgYXN5bmMgX3NldHVwTmVwdHVuZSgpIHtcbiAgICAgICAgY29uc3QgcGxhbmV0TUQgPSBhd2FpdCBXaGVlenlHTEJMb2FkZXIubG9hZEZyb21VcmwoXG4gICAgICAgICAgICAnc3RhdGljL21vZGVscy9wbGFuZXRzL25lcHR1bmUuZ2xiJ1xuICAgICAgICApXG4gICAgICAgIHRoaXMubmVwdHVuZSA9IGF3YWl0IHRoaXMudXBsb2FkTW9kZWwoe1xuICAgICAgICAgICAgbW9kZWxEYXRhOiBwbGFuZXRNRCxcbiAgICAgICAgfSlcblxuICAgICAgICB0aGlzLm9iamVjdE1hbmFnZXIucmVwYXJlbnRPYmplY3QodGhpcy5uZXB0dW5lLCB0aGlzLm5lcHR1bmVIb29rKVxuXG4gICAgICAgIHRoaXMubmVwdHVuZUhvb2sudHJhbnNmb3JtLnJvdGF0ZURlZ3JlZXNFdWxlcih7IHk6IDEwMCB9KVxuXG4gICAgICAgIHRoaXMubmVwdHVuZS50cmFuc2Zvcm0uc2NhbGUodmVjMy5jcmVhdGUoMC4yLCAwLjIsIDAuMikpXG4gICAgICAgIHRoaXMubmVwdHVuZS50cmFuc2Zvcm0ucm90YXRlRGVncmVlc0V1bGVyKHsgeDogOTAgfSlcbiAgICAgICAgdGhpcy5uZXB0dW5lLnRyYW5zZm9ybS50cmFuc2xhdGUodmVjMy5jcmVhdGUoNS44LCAwLCAwKSlcbiAgICB9XG5cbiAgICBwdWJsaWMgYXN5bmMgaW5pdCgpIHtcbiAgICAgICAgYXdhaXQgc3VwZXIuaW5pdCgpXG5cbiAgICAgICAgYXdhaXQgdGhpcy5fc2V0dXBTdW4oKVxuICAgICAgICBhd2FpdCB0aGlzLl9zZXR1cE1lcmN1cnkoKVxuICAgICAgICBhd2FpdCB0aGlzLl9zZXR1cFZlbnVzKClcbiAgICAgICAgYXdhaXQgdGhpcy5fc2V0dXBFYXJ0aCgpXG4gICAgICAgIGF3YWl0IHRoaXMuX3NldHVwTWFycygpXG4gICAgICAgIGF3YWl0IHRoaXMuX3NldHVwSnVwaXRlcigpXG4gICAgICAgIGF3YWl0IHRoaXMuX3NldHVwU2F0dXJuKClcbiAgICAgICAgYXdhaXQgdGhpcy5fc2V0dXBVcmFudXMoKVxuICAgICAgICBhd2FpdCB0aGlzLl9zZXR1cE5lcHR1bmUoKVxuXG4gICAgICAgIGNvbnN0IHdyYXBwZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKVxuICAgICAgICB3cmFwcGVyLnN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJ1xuICAgICAgICB3cmFwcGVyLnN0eWxlLnRvcCA9ICcwJ1xuICAgICAgICB3cmFwcGVyLnN0eWxlLnpJbmRleCA9ICcxMCdcbiAgICAgICAgd3JhcHBlci5zdHlsZS5wYWRkaW5nID0gJzEwcHgnXG5cbiAgICAgICAgY29uc3QgYnV0dG9uMCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2J1dHRvbicpXG4gICAgICAgIGJ1dHRvbjAudGV4dENvbnRlbnQgPSAnMSDQs9C+0LQg0LIg0LzQuNC90YPRgtGDJ1xuXG4gICAgICAgIGJ1dHRvbjAuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnllYXJzUGVyTWludXRlID0gMVxuICAgICAgICB9KVxuXG4gICAgICAgIGNvbnN0IGJ1dHRvbjEgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdidXR0b24nKVxuICAgICAgICBidXR0b24xLnRleHRDb250ZW50ID0gJzEwMCDQu9C10YIg0LIg0LzQuNC90YPRgtGDJ1xuXG4gICAgICAgIGJ1dHRvbjEuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnllYXJzUGVyTWludXRlID0gMTAwXG4gICAgICAgIH0pXG5cbiAgICAgICAgd3JhcHBlci5hcHBlbmRDaGlsZChidXR0b24wKVxuICAgICAgICB3cmFwcGVyLmFwcGVuZENoaWxkKGJ1dHRvbjEpXG5cbiAgICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZCh3cmFwcGVyKVxuICAgIH1cblxuICAgIHByaXZhdGUgZ2V0T3JiaXRSb3RhdGlvblBlckZyYW1lKG5hbWU6IHN0cmluZykge1xuICAgICAgICBjb25zdCBjb21tb25EaXZpZGVyID0gMzYwMCAvIHRoaXMueWVhcnNQZXJNaW51dGVcblxuICAgICAgICBzd2l0Y2ggKG5hbWUpIHtcbiAgICAgICAgICAgIGNhc2UgJ21lcmN1cnknOlxuICAgICAgICAgICAgICAgIHJldHVybiAoMzYwICogNC4xNykgLyBjb21tb25EaXZpZGVyXG4gICAgICAgICAgICBjYXNlICd2ZW51cyc6XG4gICAgICAgICAgICAgICAgcmV0dXJuICgzNjAgKiAxLjYzKSAvIGNvbW1vbkRpdmlkZXJcbiAgICAgICAgICAgIGNhc2UgJ2VhcnRoJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gKDM2MCAqIDEpIC8gY29tbW9uRGl2aWRlclxuICAgICAgICAgICAgY2FzZSAnbWFycyc6XG4gICAgICAgICAgICAgICAgcmV0dXJuICgzNjAgKiAwLjUzKSAvIGNvbW1vbkRpdmlkZXJcbiAgICAgICAgICAgIGNhc2UgJ2p1cGl0ZXInOlxuICAgICAgICAgICAgICAgIHJldHVybiAoMzYwICogMC4wODQpIC8gY29tbW9uRGl2aWRlclxuICAgICAgICAgICAgY2FzZSAnc2F0dXJuJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gKDM2MCAqIDAuMDM0KSAvIGNvbW1vbkRpdmlkZXJcbiAgICAgICAgICAgIGNhc2UgJ3VyYW51cyc6XG4gICAgICAgICAgICAgICAgcmV0dXJuICgzNjAgKiAwLjAxMikgLyBjb21tb25EaXZpZGVyXG4gICAgICAgICAgICBjYXNlICduZXB0dW5lJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gKDM2MCAqIDAuMDA2KSAvIGNvbW1vbkRpdmlkZXJcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuIDBcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHByaXZhdGUgZ2V0U2VsZlJvdGF0aW9uUGVyRnJhbWUobmFtZTogc3RyaW5nKSB7XG4gICAgICAgIGNvbnN0IGNvbW1vbkRpdmlkZXIgPSAzNjAwIC8gdGhpcy55ZWFyc1Blck1pbnV0ZVxuXG4gICAgICAgIHN3aXRjaCAobmFtZSkge1xuICAgICAgICAgICAgY2FzZSAnc3VuJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gKDM2MCAqIDAuMDQgKiAzNjUpIC8gY29tbW9uRGl2aWRlclxuICAgICAgICAgICAgY2FzZSAnbWVyY3VyeSc6XG4gICAgICAgICAgICAgICAgcmV0dXJuICgzNjAgKiAxLjUgKiAzNjUpIC8gY29tbW9uRGl2aWRlclxuICAgICAgICAgICAgY2FzZSAndmVudXMnOlxuICAgICAgICAgICAgICAgIHJldHVybiAoMzYwICogMS41MDIgKiAzNjUpIC8gY29tbW9uRGl2aWRlclxuICAgICAgICAgICAgY2FzZSAnZWFydGgnOlxuICAgICAgICAgICAgICAgIHJldHVybiAoMzYwICogMSAqIDM2NSkgLyBjb21tb25EaXZpZGVyXG4gICAgICAgICAgICBjYXNlICdtYXJzJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gKDM2MCAqIDEuMDMgKiAzNjUpIC8gY29tbW9uRGl2aWRlclxuICAgICAgICAgICAgY2FzZSAnanVwaXRlcic6XG4gICAgICAgICAgICAgICAgcmV0dXJuICgzNjAgKiAwLjQxICogMzY1KSAvIGNvbW1vbkRpdmlkZXJcbiAgICAgICAgICAgIGNhc2UgJ3NhdHVybic6XG4gICAgICAgICAgICAgICAgcmV0dXJuICgzNjAgKiAwLjQ1ICogMzY1KSAvIGNvbW1vbkRpdmlkZXJcbiAgICAgICAgICAgIGNhc2UgJ3VyYW51cyc6XG4gICAgICAgICAgICAgICAgcmV0dXJuICgzNjAgKiAwLjY2NiAqIDM2NSkgLyBjb21tb25EaXZpZGVyXG4gICAgICAgICAgICBjYXNlICduZXB0dW5lJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gKDM2MCAqIDAuNzA4ICogMzY1KSAvIGNvbW1vbkRpdmlkZXJcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuIDBcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHB1YmxpYyBvblJlbmRlcihkZWx0YVRpbWU6IG51bWJlcik6IHZvaWQge1xuICAgICAgICB0aGlzLmNvbnRyb2xsZXIudXBkYXRlKGRlbHRhVGltZSlcbiAgICAgICAgLy9GWUk6IEFsd2F5cyByZW1lbWJlciB0byByZXNldCBvcmllbnRhdGlvbiBpbiBibGVuZGVyIDovXG4gICAgICAgIHRoaXMuc3VuLnRyYW5zZm9ybS5yb3RhdGVEZWdyZWVzRXVsZXIoe1xuICAgICAgICAgICAgeTogdGhpcy5nZXRTZWxmUm90YXRpb25QZXJGcmFtZSgnc3VuJyksXG4gICAgICAgIH0pXG4gICAgICAgIHRoaXMubWVyY3VyeS50cmFuc2Zvcm0ucm90YXRlRGVncmVlc0V1bGVyKHtcbiAgICAgICAgICAgIHk6IHRoaXMuZ2V0U2VsZlJvdGF0aW9uUGVyRnJhbWUoJ21lcmN1cnknKSxcbiAgICAgICAgfSlcbiAgICAgICAgdGhpcy5tZXJjdXJ5SG9vay50cmFuc2Zvcm0ucm90YXRlRGVncmVlc0V1bGVyKHtcbiAgICAgICAgICAgIHk6IHRoaXMuZ2V0T3JiaXRSb3RhdGlvblBlckZyYW1lKCdtZXJjdXJ5JyksXG4gICAgICAgIH0pXG4gICAgICAgIHRoaXMudmVudXMudHJhbnNmb3JtLnJvdGF0ZURlZ3JlZXNFdWxlcih7XG4gICAgICAgICAgICB5OiB0aGlzLmdldFNlbGZSb3RhdGlvblBlckZyYW1lKCd2ZW51cycpLFxuICAgICAgICB9KVxuICAgICAgICB0aGlzLnZlbnVzSG9vay50cmFuc2Zvcm0ucm90YXRlRGVncmVlc0V1bGVyKHtcbiAgICAgICAgICAgIHk6IHRoaXMuZ2V0T3JiaXRSb3RhdGlvblBlckZyYW1lKCd2ZW51cycpLFxuICAgICAgICB9KVxuICAgICAgICB0aGlzLmVhcnRoLnRyYW5zZm9ybS5yb3RhdGVEZWdyZWVzRXVsZXIoe1xuICAgICAgICAgICAgejogdGhpcy5nZXRTZWxmUm90YXRpb25QZXJGcmFtZSgnZWFydGgnKSxcbiAgICAgICAgfSlcbiAgICAgICAgdGhpcy5lYXJ0aEhvb2sudHJhbnNmb3JtLnJvdGF0ZURlZ3JlZXNFdWxlcih7XG4gICAgICAgICAgICB5OiB0aGlzLmdldE9yYml0Um90YXRpb25QZXJGcmFtZSgnZWFydGgnKSxcbiAgICAgICAgfSlcbiAgICAgICAgdGhpcy5tYXJzLnRyYW5zZm9ybS5yb3RhdGVEZWdyZWVzRXVsZXIoe1xuICAgICAgICAgICAgeTogdGhpcy5nZXRTZWxmUm90YXRpb25QZXJGcmFtZSgnbWFycycpLFxuICAgICAgICB9KVxuICAgICAgICB0aGlzLm1hcnNIb29rLnRyYW5zZm9ybS5yb3RhdGVEZWdyZWVzRXVsZXIoe1xuICAgICAgICAgICAgeTogdGhpcy5nZXRPcmJpdFJvdGF0aW9uUGVyRnJhbWUoJ21hcnMnKSxcbiAgICAgICAgfSlcbiAgICAgICAgdGhpcy5qdXBpdGVyLnRyYW5zZm9ybS5yb3RhdGVEZWdyZWVzRXVsZXIoe1xuICAgICAgICAgICAgejogLXRoaXMuZ2V0U2VsZlJvdGF0aW9uUGVyRnJhbWUoJ2p1cGl0ZXInKSxcbiAgICAgICAgfSlcbiAgICAgICAgdGhpcy5qdXBpdGVySG9vay50cmFuc2Zvcm0ucm90YXRlRGVncmVlc0V1bGVyKHtcbiAgICAgICAgICAgIHk6IHRoaXMuZ2V0T3JiaXRSb3RhdGlvblBlckZyYW1lKCdqdXBpdGVyJyksXG4gICAgICAgIH0pXG4gICAgICAgIHRoaXMuc2F0dXJuLnRyYW5zZm9ybS5yb3RhdGVEZWdyZWVzRXVsZXIoe1xuICAgICAgICAgICAgejogLXRoaXMuZ2V0U2VsZlJvdGF0aW9uUGVyRnJhbWUoJ3NhdHVybicpLFxuICAgICAgICB9KVxuICAgICAgICB0aGlzLnNhdHVybkhvb2sudHJhbnNmb3JtLnJvdGF0ZURlZ3JlZXNFdWxlcih7XG4gICAgICAgICAgICB5OiB0aGlzLmdldE9yYml0Um90YXRpb25QZXJGcmFtZSgnc2F0dXJuJyksXG4gICAgICAgIH0pXG4gICAgICAgIHRoaXMudXJhbnVzLnRyYW5zZm9ybS5yb3RhdGVEZWdyZWVzRXVsZXIoe1xuICAgICAgICAgICAgejogLXRoaXMuZ2V0U2VsZlJvdGF0aW9uUGVyRnJhbWUoJ3VyYW51cycpLFxuICAgICAgICB9KVxuICAgICAgICB0aGlzLnVyYW51c0hvb2sudHJhbnNmb3JtLnJvdGF0ZURlZ3JlZXNFdWxlcih7XG4gICAgICAgICAgICB5OiB0aGlzLmdldE9yYml0Um90YXRpb25QZXJGcmFtZSgndXJhbnVzJyksXG4gICAgICAgIH0pXG4gICAgICAgIHRoaXMubmVwdHVuZS50cmFuc2Zvcm0ucm90YXRlRGVncmVlc0V1bGVyKHtcbiAgICAgICAgICAgIHo6IC10aGlzLmdldFNlbGZSb3RhdGlvblBlckZyYW1lKCduZXB0dW5lJyksXG4gICAgICAgIH0pXG4gICAgICAgIHRoaXMubmVwdHVuZUhvb2sudHJhbnNmb3JtLnJvdGF0ZURlZ3JlZXNFdWxlcih7XG4gICAgICAgICAgICB5OiB0aGlzLmdldE9yYml0Um90YXRpb25QZXJGcmFtZSgnbmVwdHVuZScpLFxuICAgICAgICB9KVxuICAgIH1cbn1cbiIsImltcG9ydCB7XG4gICAgRGlyZWN0aW9uYWxMaWdodCxcbiAgICBHYW1lT2JqZWN0LFxuICAgIElHYW1lT2JqZWN0LFxuICAgIElTY2VuZSxcbiAgICBJVHJhbnNmb3JtLFxuICAgIFNjZW5lLFxuICAgIFRyYW5zZm9ybSxcbiAgICBUU2t5Ym94Qml0bWFwcyxcbiAgICBXaGVlenlHTEJMb2FkZXIsXG59IGZyb20gJ0B3aGVlenkvZW5naW5lJ1xuaW1wb3J0IHsgQXJjQmFsbENhbWVyYSB9IGZyb20gJ0B3aGVlenkvZW5naW5lL3NyYy9lbmdpbmUvY29yZS9jYW1lcmFzL0FyY0JhbGxDYW1lcmEnXG5pbXBvcnQgeyBBcmNCYWxsQ29udHJvbGxlciB9IGZyb20gJ0B3aGVlenkvZW5naW5lL3NyYy91dGlscy9BcmNCYWxsQ29udHJvbGxlcidcbmltcG9ydCB7IHZlYzMgfSBmcm9tICd3Z3B1LW1hdHJpeCdcblxuZXhwb3J0IGNsYXNzIERlbW8xIGV4dGVuZHMgU2NlbmUgaW1wbGVtZW50cyBJU2NlbmUge1xuICAgIHByaXZhdGUgX2NvbnRyb2xsZXI6IEFyY0JhbGxDb250cm9sbGVyXG5cbiAgICBwcml2YXRlIF9oZWxtZXQhOiBJVHJhbnNmb3JtXG5cbiAgICBwcml2YXRlIF9oZWxtZXQxITogSVRyYW5zZm9ybVxuXG4gICAgcHJpdmF0ZSBfdGVzdEhvb2shOiBJR2FtZU9iamVjdFxuXG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKClcblxuICAgICAgICB0aGlzLmNhbWVyYSA9IG5ldyBBcmNCYWxsQ2FtZXJhKHtcbiAgICAgICAgICAgIGNhbnZhc0hlaWdodDogdGhpcy5lbmdpbmUucmVuZGVyZXIuY29udGV4dC5jYW52YXMuaGVpZ2h0LFxuICAgICAgICAgICAgY2FudmFzV2lkdGg6IHRoaXMuZW5naW5lLnJlbmRlcmVyLmNvbnRleHQuY2FudmFzLndpZHRoLFxuICAgICAgICAgICAgcG9zaXRpb246IHZlYzMuY3JlYXRlKDcsIDAsIC03KSxcbiAgICAgICAgfSlcblxuICAgICAgICB0aGlzLl9jb250cm9sbGVyID0gbmV3IEFyY0JhbGxDb250cm9sbGVyKHtcbiAgICAgICAgICAgIGNhbWVyYTogdGhpcy5jYW1lcmEgYXMgQXJjQmFsbENhbWVyYSxcbiAgICAgICAgICAgIGNhbnZhczogdGhpcy5lbmdpbmUucmVuZGVyZXIuY29udGV4dC5jYW52YXMgYXMgSFRNTENhbnZhc0VsZW1lbnQsXG4gICAgICAgIH0pXG4gICAgfVxuXG4gICAgcHVibGljIGFzeW5jIGluaXQoKSB7XG4gICAgICAgIGF3YWl0IHN1cGVyLmluaXQoKVxuXG4gICAgICAgIGF3YWl0IHRoaXMuX3NldHVwU2t5Qm94KClcblxuICAgICAgICBjb25zdCBtb2RlbERhdGEgPSBhd2FpdCBXaGVlenlHTEJMb2FkZXIubG9hZEZyb21VcmwoXG4gICAgICAgICAgICAnc3RhdGljL21vZGVscy9EYW1hZ2VkSGVsbWV0LmdsYidcbiAgICAgICAgKVxuXG4gICAgICAgIC8vRklYTUU6IHdoZW4gdGhlIG1vZGVsIGlzIGF0IG9yaWdpbiwgbGlnaHRpbmcgc2hpdHMgaXRzZWxmXG4gICAgICAgIGNvbnN0IG1vZGVsR08wID0gYXdhaXQgdGhpcy51cGxvYWRNb2RlbCh7XG4gICAgICAgICAgICBtb2RlbERhdGE6IG1vZGVsRGF0YSxcbiAgICAgICAgfSlcblxuICAgICAgICBjb25zdCBtb2RlbEdPMSA9IGF3YWl0IHRoaXMudXBsb2FkTW9kZWwoe1xuICAgICAgICAgICAgbW9kZWxEYXRhOiBtb2RlbERhdGEsXG4gICAgICAgIH0pXG5cbiAgICAgICAgdGhpcy5fdGVzdEhvb2sgPSBuZXcgR2FtZU9iamVjdCgpXG4gICAgICAgIHRoaXMub2JqZWN0TWFuYWdlci5hZGRPYmplY3QodGhpcy5fdGVzdEhvb2ssIHRoaXMucm9vdClcbiAgICAgICAgdGhpcy5vYmplY3RNYW5hZ2VyLnJlcGFyZW50T2JqZWN0KG1vZGVsR08wLCB0aGlzLl90ZXN0SG9vaylcbiAgICAgICAgdGhpcy5vYmplY3RNYW5hZ2VyLnJlcGFyZW50T2JqZWN0KG1vZGVsR08xLCB0aGlzLl90ZXN0SG9vaylcbiAgICAgICAgbmV3IFRyYW5zZm9ybSh0aGlzLl90ZXN0SG9vaylcblxuICAgICAgICB0aGlzLmxpZ2h0ID0gbmV3IERpcmVjdGlvbmFsTGlnaHQoe1xuICAgICAgICAgICAgcGFyZW50OiB0aGlzLnJvb3QsXG4gICAgICAgICAgICBwb3NpdGlvbjogdmVjMy5jcmVhdGUoMTAsIDAsIC0xMCksXG4gICAgICAgIH0pXG5cbiAgICAgICAgbW9kZWxHTzAudHJhbnNmb3JtLnJvdGF0ZURlZ3JlZXNFdWxlcih7IHg6IDkwIH0pXG4gICAgICAgIG1vZGVsR08wLnRyYW5zZm9ybS50cmFuc2xhdGUodmVjMy5jcmVhdGUoMCwgMCwgLTQpKVxuICAgICAgICBtb2RlbEdPMC50cmFuc2Zvcm0uc2NhbGUodmVjMy5jcmVhdGUoMS41LCAxLjUsIDEuNSkpXG5cbiAgICAgICAgbW9kZWxHTzEudHJhbnNmb3JtLnJvdGF0ZURlZ3JlZXNFdWxlcih7IHg6IDkwLCB6OiAxMzAgfSlcbiAgICAgICAgbW9kZWxHTzEudHJhbnNmb3JtLnNjYWxlKHZlYzMuY3JlYXRlKDMsIDMsIDMpKVxuICAgICAgICBtb2RlbEdPMS50cmFuc2Zvcm0udHJhbnNsYXRlKHZlYzMuY3JlYXRlKC0xLCAwLCA3KSlcblxuICAgICAgICB0aGlzLl9oZWxtZXQgPSBtb2RlbEdPMC50cmFuc2Zvcm1cbiAgICAgICAgdGhpcy5faGVsbWV0MSA9IG1vZGVsR08xLnRyYW5zZm9ybVxuXG4gICAgICAgIHRoaXMuX3Rlc3RIb29rLnRyYW5zZm9ybS5yb3RhdGVEZWdyZWVzRXVsZXIoeyB5OiAtNDAgfSlcbiAgICB9XG5cbiAgICBwcml2YXRlIGFzeW5jIF9zZXR1cFNreUJveCgpIHtcbiAgICAgICAgY29uc3QgaW1nU3JjcyA9IFtcbiAgICAgICAgICAgICdzdGF0aWMvY3ViZW1hcHMvYnJpZGdlL3Bvc3guanBnJyxcbiAgICAgICAgICAgICdzdGF0aWMvY3ViZW1hcHMvYnJpZGdlL25lZ3guanBnJyxcbiAgICAgICAgICAgICdzdGF0aWMvY3ViZW1hcHMvYnJpZGdlL3Bvc3kuanBnJyxcbiAgICAgICAgICAgICdzdGF0aWMvY3ViZW1hcHMvYnJpZGdlL25lZ3kuanBnJyxcbiAgICAgICAgICAgICdzdGF0aWMvY3ViZW1hcHMvYnJpZGdlL3Bvc3ouanBnJyxcbiAgICAgICAgICAgICdzdGF0aWMvY3ViZW1hcHMvYnJpZGdlL25lZ3ouanBnJyxcbiAgICAgICAgXVxuXG4gICAgICAgIGNvbnN0IHByb21pc2VzID0gaW1nU3Jjcy5tYXAoYXN5bmMgKHNvdXJjZSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChzb3VyY2UpXG4gICAgICAgICAgICByZXR1cm4gY3JlYXRlSW1hZ2VCaXRtYXAoYXdhaXQgcmVzcG9uc2UuYmxvYigpKVxuICAgICAgICB9KVxuICAgICAgICBjb25zdCBpbWFnZUJpdG1hcHMgPSAoYXdhaXQgUHJvbWlzZS5hbGwocHJvbWlzZXMpKSBhcyBUU2t5Ym94Qml0bWFwc1xuXG4gICAgICAgIHRoaXMuX2VuZ2luZT8ucmVuZGVyZXIuc2V0U2t5Qm94VGV4dHVyZShpbWFnZUJpdG1hcHMpXG4gICAgfVxuXG4gICAgcHVibGljIG9uUmVuZGVyKGR0OiBudW1iZXIpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5fY29udHJvbGxlci51cGRhdGUoZHQpXG5cbiAgICAgICAgdGhpcy5faGVsbWV0LnJvdGF0ZURlZ3JlZXNFdWxlcih7IHo6IC01ICogZHQgfSlcbiAgICAgICAgLy8gdGhpcy5faGVsbWV0MS5yb3RhdGVEZWdyZWVzRXVsZXIoeyB6OiA1ICogZHQgfSlcbiAgICB9XG59XG4iLCJleHBvcnQgKiBmcm9tICcuL3NyYy9lbmdpbmUvY29yZSdcbmV4cG9ydCAqIGZyb20gJy4vc3JjL2VuZ2luZS90eXBlcydcbmV4cG9ydCAqIGZyb20gJy4vc3JjL3BoeXNpY3MnXG5leHBvcnQgKiBmcm9tICcuL3NyYy91dGlscydcbiIsImltcG9ydCB7IElCdWZmZXJTdG9yYWdlIH0gZnJvbSAnLi4vLi4vdHlwZXMvY29yZS9CdWZmZXJTdG9yYWdlJ1xuXG5leHBvcnQgY2xhc3MgQnVmZmVyU3RvcmFnZSBpbXBsZW1lbnRzIElCdWZmZXJTdG9yYWdlIHtcbiAgICBfYnVmZmVyczogTWFwPHN0cmluZywgQXJyYXlCdWZmZXI+ID0gbmV3IE1hcCgpXG5cbiAgICBnZXQgYnVmZmVycygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2J1ZmZlcnNcbiAgICB9XG59XG4iLCJleHBvcnQgKiBmcm9tICcuL0J1ZmZlclN0b3JhZ2UnXG4iLCJpbXBvcnQgeyBFbnRpdHlUeXBlcywgSUNvbXBvbmVudCB9IGZyb20gJy4uLy4uL3R5cGVzJ1xuaW1wb3J0IHsgRW50aXR5IH0gZnJvbSAnLi4vRW50aXR5J1xuXG5leHBvcnQgY2xhc3MgQ29tcG9uZW50PFQgZXh0ZW5kcyBFbnRpdHlUeXBlcz5cbiAgICBleHRlbmRzIEVudGl0eTxUPlxuICAgIGltcGxlbWVudHMgSUNvbXBvbmVudDxUPlxue1xuICAgIF9wYXJlbnQ6IElDb21wb25lbnQ8VD5bJ3BhcmVudCddXG5cbiAgICBjb25zdHJ1Y3RvcihwYXJlbnQ6IElDb21wb25lbnQ8VD5bJ3BhcmVudCddLCBjb21wb25lbnRUeXBlOiBUKSB7XG4gICAgICAgIHN1cGVyKGNvbXBvbmVudFR5cGUpXG4gICAgICAgIHRoaXMuX3BhcmVudCA9IHBhcmVudFxuICAgICAgICB0aGlzLl9wYXJlbnQuYWRkQ29tcG9uZW50KHRoaXMpXG4gICAgfVxuXG4gICAgZ2V0IHBhcmVudCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3BhcmVudFxuICAgIH1cbn1cbiIsImV4cG9ydCAqIGZyb20gJy4vQ29tcG9uZW50J1xuIiwiaW1wb3J0IHsgSVNjZW5lLCBJRW5naW5lLCBJRW5naW5lUHJvcHMsIElSZW5kZXJlciB9IGZyb20gJy4uLy4uL3R5cGVzJ1xuaW1wb3J0IHsgUmVuZGVyZXIgfSBmcm9tICcuLi9SZW5kZXJlcidcblxuZXhwb3J0IGNsYXNzIEVuZ2luZSBpbXBsZW1lbnRzIElFbmdpbmUge1xuICAgIHByaXZhdGUgX3JlbmRlcmVyITogSVJlbmRlcmVyXG5cbiAgICBwcml2YXRlIF9wcmV2RnJhbWVUaW1lOiBudW1iZXIgPSAwXG5cbiAgICBwcml2YXRlIF9zY2VuZT86IElTY2VuZVxuXG4gICAgcHVibGljIGFzeW5jIGluaXRSZW5kZXJlcihjYW52YXM6IEhUTUxDYW52YXNFbGVtZW50KSB7XG4gICAgICAgIHRoaXMuX3JlbmRlcmVyID0gbmV3IFJlbmRlcmVyKHsgY2FudmFzIH0pXG4gICAgICAgIGF3YWl0IHRoaXMuX3JlbmRlcmVyLmluaXQoKVxuICAgIH1cblxuICAgIHB1YmxpYyBzdGF0aWMgYXN5bmMgZ2V0T3JJbml0KHtcbiAgICAgICAgY2FudmFzLFxuICAgIH06IElFbmdpbmVQcm9wcyk6IFByb21pc2U8RW5naW5lIHwgdW5kZWZpbmVkPiB7XG4gICAgICAgIC8vRklYTUU6IHR5cGVzXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAoKHdpbmRvdyBhcyBhbnkpLldoZWV6eUVuZ2luZSkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybignRW5naW5lIGhhcyBhbHJlYWR5IGJlZW4gaW5zdGFuY2VkJylcbiAgICAgICAgICAgICAgICByZXR1cm4gKHdpbmRvdyBhcyBhbnkpLldoZWV6eUVuZ2luZSBhcyBFbmdpbmVcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29uc3QgZW5naW5lSW5zdGFuY2UgPSBuZXcgRW5naW5lKClcbiAgICAgICAgICAgIGF3YWl0IGVuZ2luZUluc3RhbmNlLmluaXRSZW5kZXJlcihjYW52YXMpXG4gICAgICAgICAgICA7KHdpbmRvdyBhcyBhbnkpLldoZWV6eUVuZ2luZSA9IGVuZ2luZUluc3RhbmNlXG5cbiAgICAgICAgICAgIHJldHVybiBlbmdpbmVJbnN0YW5jZVxuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIGFsZXJ0KGVycilcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGdldCByZW5kZXJlcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3JlbmRlcmVyXG4gICAgfVxuXG4gICAgZ2V0IHNjZW5lKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fc2NlbmVcbiAgICB9XG5cbiAgICBzZXQgc2NlbmUoc2NlbmU6IElTY2VuZSB8IHVuZGVmaW5lZCkge1xuICAgICAgICB0aGlzLl9zY2VuZSA9IHNjZW5lXG4gICAgfVxuXG4gICAgcHVibGljIHJlbmRlcih0aW1lOiBudW1iZXIgPSAwKSB7XG4gICAgICAgIGlmICghdGhpcy5zY2VuZSkgcmV0dXJuXG5cbiAgICAgICAgY29uc3QgZHQgPSAodGltZSAtIHRoaXMuX3ByZXZGcmFtZVRpbWUpIC8gMTAwXG4gICAgICAgIHRoaXMuX3ByZXZGcmFtZVRpbWUgPSB0aW1lXG5cbiAgICAgICAgdGhpcy5fcmVuZGVyZXIucmVuZGVyKGR0LCB0aGlzLnNjZW5lKVxuXG4gICAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZSgodGltZTogbnVtYmVyKSA9PiB0aGlzLnJlbmRlcih0aW1lKSlcbiAgICB9XG59XG4iLCJleHBvcnQgKiBmcm9tICcuL0VuZ2luZSdcbmV4cG9ydCAqIGZyb20gJy4uL1JlbmRlcmVyL2NvbnN0YW50cydcbiIsImltcG9ydCB7IEVudGl0eVR5cGVzLCBJRW50aXR5IH0gZnJvbSAnLi4vLi4vdHlwZXMnXG5cbmV4cG9ydCBjbGFzcyBFbnRpdHk8VCBleHRlbmRzIEVudGl0eVR5cGVzPiBpbXBsZW1lbnRzIElFbnRpdHk8VD4ge1xuICAgIHByaXZhdGUgX2lkOiBzdHJpbmdcbiAgICBwcml2YXRlIF90eXBlOiBUXG5cbiAgICBjb25zdHJ1Y3Rvcih0eXBlOiBUKSB7XG4gICAgICAgIHRoaXMuX2lkID0gdGhpcy5fZ2VuZXJhdGVJZCgpXG4gICAgICAgIHRoaXMuX3R5cGUgPSB0eXBlXG4gICAgfVxuXG4gICAgcHJpdmF0ZSBfZ2VuZXJhdGVJZCgpIHtcbiAgICAgICAgcmV0dXJuIFN0cmluZyhNYXRoLnJhbmRvbSgpKVxuICAgIH1cblxuICAgIGdldCBpZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2lkXG4gICAgfVxuXG4gICAgZ2V0IHR5cGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl90eXBlXG4gICAgfVxufVxuIiwiZXhwb3J0ICogZnJvbSAnLi9FbnRpdHknXG4iLCJpbXBvcnQge1xuICAgIEVudGl0eUlELFxuICAgIEVudGl0eVR5cGVzLFxuICAgIElDb21wb25lbnQsXG4gICAgSUdhbWVPYmplY3QsXG4gICAgSVRyYW5zZm9ybSxcbn0gZnJvbSAnLi4vLi4vdHlwZXMnXG5pbXBvcnQgeyBFbnRpdHkgfSBmcm9tICcuLi9FbnRpdHknXG5cbmV4cG9ydCBjbGFzcyBHYW1lT2JqZWN0XG4gICAgZXh0ZW5kcyBFbnRpdHk8RW50aXR5VHlwZXMuZ2FtZU9iamVjdD5cbiAgICBpbXBsZW1lbnRzIElHYW1lT2JqZWN0XG57XG4gICAgX25hbWU6IHN0cmluZ1xuICAgIF9jb21wb25lbnRzID0gbmV3IE1hcCgpIGFzIE1hcDxFbnRpdHlJRCwgSUNvbXBvbmVudDxFbnRpdHlUeXBlcz4+XG4gICAgX3RyYW5zZm9ybT86IElUcmFuc2Zvcm1cblxuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcihFbnRpdHlUeXBlcy5nYW1lT2JqZWN0KVxuICAgICAgICB0aGlzLl9uYW1lID0gYEdhbWVPYmplY3QgJHtzdXBlci5pZH1gXG4gICAgfVxuXG4gICAgZ2V0IG5hbWUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9uYW1lXG4gICAgfVxuXG4gICAgc2V0IG5hbWUodmFsdWU6IHN0cmluZykge1xuICAgICAgICB0aGlzLl9uYW1lID0gdmFsdWVcbiAgICB9XG5cbiAgICBnZXQgY29tcG9uZW50cygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NvbXBvbmVudHNcbiAgICB9XG5cbiAgICBnZXQgdHJhbnNmb3JtKCkge1xuICAgICAgICAvL0ZJWE1FOiBmaW5kIGEgbGVzcyBkdW1iIHdheSB0byBkbyBpdFxuICAgICAgICBpZiAodGhpcy5fdHJhbnNmb3JtKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fdHJhbnNmb3JtXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gWy4uLnRoaXMuY29tcG9uZW50cy52YWx1ZXMoKV0uZmluZChcbiAgICAgICAgICAgIChjb21wb25lbnQpID0+IGNvbXBvbmVudC50eXBlID09PSBFbnRpdHlUeXBlcy50cmFuc2Zvcm1cbiAgICAgICAgKSBhcyBJVHJhbnNmb3JtXG4gICAgfVxuXG4gICAgcHVibGljIGFkZENvbXBvbmVudChjb21wb25lbnQ6IElDb21wb25lbnQ8RW50aXR5VHlwZXM+KSB7XG4gICAgICAgIHRoaXMuX2NvbXBvbmVudHMuc2V0KGNvbXBvbmVudC5pZCwgY29tcG9uZW50KVxuICAgIH1cblxuICAgIHB1YmxpYyByZW1vdmVDb21wb25lbnQoaWQ6IEVudGl0eUlEKSB7XG4gICAgICAgIHRoaXMuX2NvbXBvbmVudHMuZGVsZXRlKGlkKVxuICAgIH1cbn1cbiIsImV4cG9ydCAqIGZyb20gJy4vR2FtZU9iamVjdCdcbiIsImltcG9ydCB7IERFRkFVTFRfSU1BR0VfSURTLCBJSW1hZ2VTdG9yYWdlIH0gZnJvbSAnLi4vLi4vdHlwZXMvY29yZS9JbWFnZVN0b3JhZ2UnXG5cbmV4cG9ydCBjbGFzcyBJbWFnZVN0b3JhZ2UgaW1wbGVtZW50cyBJSW1hZ2VTdG9yYWdlIHtcbiAgICBwcml2YXRlIF9pbWFnZXM6IE1hcDxzdHJpbmcsIEltYWdlQml0bWFwPiA9IG5ldyBNYXAoKVxuXG4gICAgcHVibGljIGFzeW5jIGNyZWF0ZURlZmF1bHRzKCkge1xuICAgICAgICBjb25zdCB3aGl0ZUJpdG1hcCA9IGF3YWl0IGNyZWF0ZUltYWdlQml0bWFwKFxuICAgICAgICAgICAgbmV3IEltYWdlRGF0YShuZXcgVWludDhDbGFtcGVkQXJyYXkoWzI1NSwgMjU1LCAyNTUsIDI1NV0pLCAxLCAxKVxuICAgICAgICApXG5cbiAgICAgICAgY29uc3QgZ3JleUJpdG1hcCA9IGF3YWl0IGNyZWF0ZUltYWdlQml0bWFwKFxuICAgICAgICAgICAgbmV3IEltYWdlRGF0YShuZXcgVWludDhDbGFtcGVkQXJyYXkoWzI1NSwgMjUyLCAyMzUsIDI1NV0pLCAxLCAxKVxuICAgICAgICApXG5cbiAgICAgICAgY29uc3QgYmxhY2tCaXRtYXAgPSBhd2FpdCBjcmVhdGVJbWFnZUJpdG1hcChcbiAgICAgICAgICAgIG5ldyBJbWFnZURhdGEobmV3IFVpbnQ4Q2xhbXBlZEFycmF5KFswLCAwLCAwLCAyNTVdKSwgMSwgMSlcbiAgICAgICAgKVxuXG4gICAgICAgIGNvbnN0IG5vcm1hbEJpdG1hcCA9IGF3YWl0IGNyZWF0ZUltYWdlQml0bWFwKFxuICAgICAgICAgICAgbmV3IEltYWdlRGF0YShuZXcgVWludDhDbGFtcGVkQXJyYXkoWzEyOCwgMTI4LCAyNTUsIDI1NV0pLCAxLCAxKVxuICAgICAgICApXG5cbiAgICAgICAgdGhpcy5faW1hZ2VzLnNldChERUZBVUxUX0lNQUdFX0lEUy5tZXRhbGxpY1JvdWdobmVzcywgd2hpdGVCaXRtYXApXG4gICAgICAgIHRoaXMuX2ltYWdlcy5zZXQoREVGQVVMVF9JTUFHRV9JRFMub2NjbHVzaW9uLCB3aGl0ZUJpdG1hcClcblxuICAgICAgICB0aGlzLl9pbWFnZXMuc2V0KERFRkFVTFRfSU1BR0VfSURTLmJhc2VDb2xvciwgZ3JleUJpdG1hcClcblxuICAgICAgICB0aGlzLl9pbWFnZXMuc2V0KERFRkFVTFRfSU1BR0VfSURTLmVtaXNzaW9uLCBibGFja0JpdG1hcClcblxuICAgICAgICB0aGlzLl9pbWFnZXMuc2V0KERFRkFVTFRfSU1BR0VfSURTLm5vcm1hbCwgbm9ybWFsQml0bWFwKVxuICAgIH1cblxuICAgIGdldCBpbWFnZXMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pbWFnZXNcbiAgICB9XG59XG4iLCJleHBvcnQgKiBmcm9tICcuL0ltYWdlU3RvcmFnZSdcbiIsImltcG9ydCB7IElNYXRlcmlhbCB9IGZyb20gJy4uLy4uL3R5cGVzJ1xuaW1wb3J0IHsgSU1hdGVyaWFsU3RvcmFnZSB9IGZyb20gJy4uLy4uL3R5cGVzL2NvcmUvTWF0ZXJpYWxTdG9yYWdlJ1xuXG5leHBvcnQgY2xhc3MgTWF0ZXJpYWxTdG9yYWdlIGltcGxlbWVudHMgSU1hdGVyaWFsU3RvcmFnZSB7XG4gICAgX21hdGVyaWFsczogTWFwPHN0cmluZywgSU1hdGVyaWFsPiA9IG5ldyBNYXAoKVxuXG4gICAgZ2V0IG1hdGVyaWFscygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX21hdGVyaWFsc1xuICAgIH1cbn1cbiIsImV4cG9ydCAqIGZyb20gJy4vTWF0ZXJpYWxTdG9yYWdlJ1xuIiwiaW1wb3J0IHtcbiAgICBFbnRpdHlUeXBlcyxcbiAgICBHTFRGQWNjZXNzb3IsXG4gICAgSUdhbWVPYmplY3QsXG4gICAgSU1hdGVyaWFsLFxuICAgIElNZXNoLFxufSBmcm9tICcuLi8uLi90eXBlcydcbmltcG9ydCB7IENvbXBvbmVudCB9IGZyb20gJy4uL0NvbXBvbmVudCdcblxuZXhwb3J0IGNsYXNzIE1lc2ggZXh0ZW5kcyBDb21wb25lbnQ8RW50aXR5VHlwZXMubWVzaD4gaW1wbGVtZW50cyBJTWVzaCB7XG4gICAgbW9kZSA9IDQgLy8gR1BVIHRvcG9sb2d5IG1vZGVcbiAgICBwb3NpdGlvbnM6IEdMVEZBY2Nlc3NvclxuICAgIGluZGljZXM6IEdMVEZBY2Nlc3NvclxuICAgIHRleHR1cmVDb29yZGluYXRlczogR0xURkFjY2Vzc29yXG4gICAgdGFuZ2VudHM6IEdMVEZBY2Nlc3NvclxuICAgIG5vcm1hbHM6IEdMVEZBY2Nlc3NvclxuICAgIG1hdGVyaWFsOiBJTWF0ZXJpYWxcbiAgICBpc1BpcGVsaW5lQnVpbHQ6IGJvb2xlYW4gPSBmYWxzZVxuXG4gICAgY29uc3RydWN0b3IoXG4gICAgICAgIHBhcmVudDogSUdhbWVPYmplY3QsXG4gICAgICAgIHBvc2l0aW9uczogR0xURkFjY2Vzc29yLFxuICAgICAgICBpbmRpY2VzOiBHTFRGQWNjZXNzb3IsXG4gICAgICAgIG5vcm1hbHM6IEdMVEZBY2Nlc3NvcixcbiAgICAgICAgdGV4dHVyZUNvb3JkaW5hdGVzOiBHTFRGQWNjZXNzb3IsXG4gICAgICAgIHRhbmdlbnRzOiBHTFRGQWNjZXNzb3IsXG4gICAgICAgIG1hdGVyaWFsOiBJTWF0ZXJpYWxcbiAgICApIHtcbiAgICAgICAgc3VwZXIocGFyZW50LCBFbnRpdHlUeXBlcy5tZXNoKVxuXG4gICAgICAgIHRoaXMucG9zaXRpb25zID0gcG9zaXRpb25zXG4gICAgICAgIHRoaXMuaW5kaWNlcyA9IGluZGljZXNcbiAgICAgICAgdGhpcy50ZXh0dXJlQ29vcmRpbmF0ZXMgPSB0ZXh0dXJlQ29vcmRpbmF0ZXNcbiAgICAgICAgdGhpcy5tYXRlcmlhbCA9IG1hdGVyaWFsXG4gICAgICAgIHRoaXMubm9ybWFscyA9IG5vcm1hbHNcbiAgICAgICAgdGhpcy50YW5nZW50cyA9IHRhbmdlbnRzXG4gICAgfVxufVxuIiwiZXhwb3J0ICogZnJvbSAnLi9NZXNoJ1xuIiwiaW1wb3J0IHtcbiAgICBJTWVzaFJlbmRlckRhdGEsXG4gICAgSU1lc2hSZW5kZXJEYXRhU3RvcmFnZSxcbn0gZnJvbSAnLi4vLi4vdHlwZXMvY29yZS9NZXNoUmVuZGVyRGF0YVN0b3JhZ2UnXG5cbmV4cG9ydCBjbGFzcyBNZXNoUmVuZGVyRGF0YVN0b3JhZ2UgaW1wbGVtZW50cyBJTWVzaFJlbmRlckRhdGFTdG9yYWdlIHtcbiAgICBfZGF0YTogTWFwPHN0cmluZywgSU1lc2hSZW5kZXJEYXRhPiA9IG5ldyBNYXAoKVxuXG4gICAgZ2V0IGRhdGEoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kYXRhXG4gICAgfVxufVxuIiwiZXhwb3J0ICogZnJvbSAnLi9NZXNoUmVuZGVyRGF0YVN0b3JhZ2UnXG4iLCJpbXBvcnQgeyB2ZWMzLCB2ZWM0IH0gZnJvbSAnd2dwdS1tYXRyaXgnXG5pbXBvcnQge1xuICAgIEdMVEZBY2Nlc3NvcixcbiAgICBHTFRGVGV4dHVyZUZpbHRlcixcbiAgICBHTFRGVGV4dHVyZVdyYXAsXG4gICAgSUJ1ZmZlclN0b3JhZ2UsXG4gICAgSUdhbWVPYmplY3QsXG4gICAgSUltYWdlU3RvcmFnZSxcbiAgICBJTWF0ZXJpYWwsXG4gICAgSU1vZGVsUHJlbG9hZERhdGEsXG4gICAgSU9iamVjdE1hbmFnZXIsXG4gICAgSVByZWxvYWRFbnRpdHksXG4gICAgSVNhbXBsZXJTdG9yYWdlLFxuICAgIElUZXh0dXJlLFxuICAgIElUZXh0dXJlU3RvcmFnZSxcbn0gZnJvbSAnLi4vLi4vdHlwZXMnXG5pbXBvcnQgeyBJTWF0ZXJpYWxTdG9yYWdlIH0gZnJvbSAnLi4vLi4vdHlwZXMvY29yZS9NYXRlcmlhbFN0b3JhZ2UnXG5pbXBvcnQgeyBHYW1lT2JqZWN0IH0gZnJvbSAnLi4vR2FtZU9iamVjdCdcbmltcG9ydCB7IE1lc2ggfSBmcm9tICcuLi9NZXNoJ1xuaW1wb3J0IHsgVHJhbnNmb3JtIH0gZnJvbSAnLi4vVHJhbnNmb3JtJ1xuXG5leHBvcnQgY2xhc3MgTW9kZWxVcGxvYWRlciB7XG4gICAgcHJpdmF0ZSBzdGF0aWMgZ2V0VGV4dHVyZUZpbHRlck1vZGUoZmlsdGVyPzogR0xURlRleHR1cmVGaWx0ZXIpIHtcbiAgICAgICAgc3dpdGNoIChmaWx0ZXIpIHtcbiAgICAgICAgICAgIGNhc2UgR0xURlRleHR1cmVGaWx0ZXIuTkVBUkVTVF9NSVBNQVBfTkVBUkVTVDpcbiAgICAgICAgICAgIGNhc2UgR0xURlRleHR1cmVGaWx0ZXIuTkVBUkVTVF9NSVBNQVBfTElORUFSOlxuICAgICAgICAgICAgY2FzZSBHTFRGVGV4dHVyZUZpbHRlci5ORUFSRVNUOlxuICAgICAgICAgICAgICAgIHJldHVybiAnbmVhcmVzdCcgYXMgR1BVRmlsdGVyTW9kZVxuICAgICAgICAgICAgY2FzZSBHTFRGVGV4dHVyZUZpbHRlci5MSU5FQVJfTUlQTUFQX05FQVJFU1Q6XG4gICAgICAgICAgICBjYXNlIEdMVEZUZXh0dXJlRmlsdGVyLkxJTkVBUl9NSVBNQVBfTElORUFSOlxuICAgICAgICAgICAgY2FzZSBHTFRGVGV4dHVyZUZpbHRlci5MSU5FQVI6XG4gICAgICAgICAgICAgICAgcmV0dXJuICdsaW5lYXInIGFzIEdQVUZpbHRlck1vZGVcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuICdsaW5lYXInXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwcml2YXRlIHN0YXRpYyBnZXRUZXh0dXJlTWlwTWFwTW9kZShmaWx0ZXI6IEdMVEZUZXh0dXJlRmlsdGVyKSB7XG4gICAgICAgIHN3aXRjaCAoZmlsdGVyKSB7XG4gICAgICAgICAgICBjYXNlIEdMVEZUZXh0dXJlRmlsdGVyLk5FQVJFU1RfTUlQTUFQX05FQVJFU1Q6XG4gICAgICAgICAgICBjYXNlIEdMVEZUZXh0dXJlRmlsdGVyLkxJTkVBUl9NSVBNQVBfTkVBUkVTVDpcbiAgICAgICAgICAgIGNhc2UgR0xURlRleHR1cmVGaWx0ZXIuTkVBUkVTVDpcbiAgICAgICAgICAgICAgICByZXR1cm4gJ25lYXJlc3QnIGFzIEdQVU1pcG1hcEZpbHRlck1vZGVcbiAgICAgICAgICAgIGNhc2UgR0xURlRleHR1cmVGaWx0ZXIuTElORUFSX01JUE1BUF9MSU5FQVI6XG4gICAgICAgICAgICBjYXNlIEdMVEZUZXh0dXJlRmlsdGVyLk5FQVJFU1RfTUlQTUFQX0xJTkVBUjpcbiAgICAgICAgICAgIGNhc2UgR0xURlRleHR1cmVGaWx0ZXIuTElORUFSOlxuICAgICAgICAgICAgICAgIHJldHVybiAnbGluZWFyJyBhcyBHUFVNaXBtYXBGaWx0ZXJNb2RlXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwcml2YXRlIHN0YXRpYyBnZXRUZXh0dXJlQWRkcmVzc01vZGUobW9kZT86IEdMVEZUZXh0dXJlV3JhcCkge1xuICAgICAgICBzd2l0Y2ggKG1vZGUpIHtcbiAgICAgICAgICAgIGNhc2UgR0xURlRleHR1cmVXcmFwLlJFUEVBVDpcbiAgICAgICAgICAgICAgICByZXR1cm4gJ3JlcGVhdCcgYXMgR1BVQWRkcmVzc01vZGVcbiAgICAgICAgICAgIGNhc2UgR0xURlRleHR1cmVXcmFwLkNMQU1QX1RPX0VER0U6XG4gICAgICAgICAgICAgICAgcmV0dXJuICdjbGFtcC10by1lZGdlJyBhcyBHUFVBZGRyZXNzTW9kZVxuICAgICAgICAgICAgY2FzZSBHTFRGVGV4dHVyZVdyYXAuTUlSUk9SRURfUkVQRUFUOlxuICAgICAgICAgICAgICAgIHJldHVybiAnbWlycm9yLXJlcGVhdCcgYXMgR1BVQWRkcmVzc01vZGVcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuICdyZXBlYXQnXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwcml2YXRlIHN0YXRpYyBhc3luYyB1cGxvYWRJbWFnZXMoXG4gICAgICAgIG1vZGVsRGF0YTogSU1vZGVsUHJlbG9hZERhdGEsXG4gICAgICAgIGJ1ZmZlclN0b3JhZ2U6IElCdWZmZXJTdG9yYWdlLFxuICAgICAgICBpbWFnZVN0b3JhZ2U6IElJbWFnZVN0b3JhZ2VcbiAgICApIHtcbiAgICAgICAgZm9yIChsZXQgW2tleSwgdmFsdWVdIG9mIG1vZGVsRGF0YS5pbWFnZXMuZW50cmllcygpKSB7XG4gICAgICAgICAgICBjb25zdCB7XG4gICAgICAgICAgICAgICAgYnVmZmVyVmlldzogeyBidWZmZXIsIGJ5dGVMZW5ndGgsIGJ5dGVPZmZzZXQgfSxcbiAgICAgICAgICAgICAgICBtaW1lVHlwZSxcbiAgICAgICAgICAgIH0gPSB2YWx1ZVxuXG4gICAgICAgICAgICBjb25zdCBpbWFnZVZpZXcgPSBuZXcgVWludDhBcnJheShcbiAgICAgICAgICAgICAgICBidWZmZXJTdG9yYWdlLmJ1ZmZlcnMuZ2V0KGJ1ZmZlcikgYXMgQXJyYXlCdWZmZXIsXG4gICAgICAgICAgICAgICAgYnl0ZU9mZnNldCxcbiAgICAgICAgICAgICAgICBieXRlTGVuZ3RoXG4gICAgICAgICAgICApXG5cbiAgICAgICAgICAgIGNvbnN0IGJsb2IgPSBuZXcgQmxvYihbaW1hZ2VWaWV3XSwgeyB0eXBlOiBtaW1lVHlwZSB9KVxuICAgICAgICAgICAgY29uc3QgYml0bWFwID0gYXdhaXQgY3JlYXRlSW1hZ2VCaXRtYXAoYmxvYilcbiAgICAgICAgICAgIGltYWdlU3RvcmFnZS5pbWFnZXMuc2V0KGtleSwgYml0bWFwKVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBzdGF0aWMgdXBsb2FkQnVmZmVycyhcbiAgICAgICAgbW9kZWxEYXRhOiBJTW9kZWxQcmVsb2FkRGF0YSxcbiAgICAgICAgYnVmZmVyU3RvcmFnZTogSUJ1ZmZlclN0b3JhZ2VcbiAgICApIHtcbiAgICAgICAgbW9kZWxEYXRhLmJ1ZmZlcnMuZm9yRWFjaCgodmFsdWUsIGtleSkgPT4ge1xuICAgICAgICAgICAgYnVmZmVyU3RvcmFnZS5idWZmZXJzLnNldChrZXksIHZhbHVlKVxuICAgICAgICB9KVxuICAgIH1cblxuICAgIHByaXZhdGUgc3RhdGljIHVwbG9hZFNhbXBsZXJzKFxuICAgICAgICBtb2RlbERhdGE6IElNb2RlbFByZWxvYWREYXRhLFxuICAgICAgICBzYW1wbGVyU3RvcmFnZTogSVNhbXBsZXJTdG9yYWdlLFxuICAgICAgICBkZXZpY2U6IEdQVURldmljZVxuICAgICkge1xuICAgICAgICBtb2RlbERhdGEuc2FtcGxlcnMuZm9yRWFjaCgodmFsdWUsIGtleSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgZ3B1U2FtcGxlciA9IGRldmljZS5jcmVhdGVTYW1wbGVyKHtcbiAgICAgICAgICAgICAgICBtYWdGaWx0ZXI6IHRoaXMuZ2V0VGV4dHVyZUZpbHRlck1vZGUodmFsdWU/Lm1hZ0ZpbHRlciksXG4gICAgICAgICAgICAgICAgbWluRmlsdGVyOiB0aGlzLmdldFRleHR1cmVGaWx0ZXJNb2RlKHZhbHVlPy5taW5GaWx0ZXIpLFxuICAgICAgICAgICAgICAgIGFkZHJlc3NNb2RlVTogdGhpcy5nZXRUZXh0dXJlQWRkcmVzc01vZGUodmFsdWU/LndyYXBTKSxcbiAgICAgICAgICAgICAgICBhZGRyZXNzTW9kZVY6IHRoaXMuZ2V0VGV4dHVyZUFkZHJlc3NNb2RlKHZhbHVlPy53cmFwVCksXG4gICAgICAgICAgICAgICAgLy9GSVhNRTogdXNlIG1pcG1hcCBmaWx0cmF0aW9uXG4gICAgICAgICAgICAgICAgbWlwbWFwRmlsdGVyOiAnbmVhcmVzdCcsXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgc2FtcGxlclN0b3JhZ2Uuc2FtcGxlcnMuc2V0KGtleSwgZ3B1U2FtcGxlcilcbiAgICAgICAgfSlcbiAgICB9XG5cbiAgICBwcml2YXRlIHN0YXRpYyB1cGxvYWRUZXh0dXJlcyhcbiAgICAgICAgbW9kZWxEYXRhOiBJTW9kZWxQcmVsb2FkRGF0YSxcbiAgICAgICAgdGV4dHVyZVN0b3JhZ2U6IElUZXh0dXJlU3RvcmFnZVxuICAgICkge1xuICAgICAgICBtb2RlbERhdGEudGV4dHVyZXMuZm9yRWFjaCgodmFsdWUsIGtleSkgPT4ge1xuICAgICAgICAgICAgdGV4dHVyZVN0b3JhZ2UudGV4dHVyZXMuc2V0KGtleSwgdmFsdWUpXG4gICAgICAgIH0pXG4gICAgfVxuXG4gICAgcHJpdmF0ZSBzdGF0aWMgY3JlYXRlR1BVVGV4dHVyZShcbiAgICAgICAgZGV2aWNlOiBHUFVEZXZpY2UsXG4gICAgICAgIGZvcm1hdDogR1BVVGV4dHVyZUZvcm1hdCxcbiAgICAgICAgc2FtcGxlclN0b3JhZ2U6IElTYW1wbGVyU3RvcmFnZSxcbiAgICAgICAgaW1hZ2VTdG9yYWdlOiBJSW1hZ2VTdG9yYWdlLFxuICAgICAgICB0ZXh0dXJlUHJlbG9hZERhdGE/OiBJVGV4dHVyZVxuICAgICkge1xuICAgICAgICBsZXQgdGV4dHVyZVZpZXc6IEdQVVRleHR1cmVWaWV3IHwgdW5kZWZpbmVkXG4gICAgICAgIGxldCB0ZXh0dXJlU2FtcGxlcjogR1BVU2FtcGxlciB8IHVuZGVmaW5lZFxuXG4gICAgICAgIGlmICghdGV4dHVyZVByZWxvYWREYXRhKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIHRleHR1cmUgZGF0YScpXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXRleHR1cmVQcmVsb2FkRGF0YS5pbWFnZUlkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIGltYWdlIHZpZXcgZm9yIHRoaXMgdGV4dHVyZScpXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXRleHR1cmVQcmVsb2FkRGF0YS5zYW1wbGVySWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTm8gc2FtcGxlciBmb3IgdGhpcyB0ZXh0dXJlJylcbiAgICAgICAgfVxuXG4gICAgICAgIHRleHR1cmVTYW1wbGVyID0gc2FtcGxlclN0b3JhZ2Uuc2FtcGxlcnMuZ2V0KFxuICAgICAgICAgICAgdGV4dHVyZVByZWxvYWREYXRhLnNhbXBsZXJJZFxuICAgICAgICApIGFzIEdQVVNhbXBsZXJcblxuICAgICAgICBjb25zdCBpbWFnZUJpdG1hcCA9IGltYWdlU3RvcmFnZS5pbWFnZXMuZ2V0KFxuICAgICAgICAgICAgdGV4dHVyZVByZWxvYWREYXRhLmltYWdlSWRcbiAgICAgICAgKSBhcyBJbWFnZUJpdG1hcFxuXG4gICAgICAgIGNvbnN0IGltYWdlU2l6ZSA9IFtpbWFnZUJpdG1hcC53aWR0aCwgaW1hZ2VCaXRtYXAuaGVpZ2h0LCAxXVxuXG4gICAgICAgIGNvbnN0IGltYWdlVGV4dHVyZSA9IGRldmljZS5jcmVhdGVUZXh0dXJlKHtcbiAgICAgICAgICAgIHNpemU6IGltYWdlU2l6ZSxcbiAgICAgICAgICAgIGZvcm1hdDogZm9ybWF0LFxuICAgICAgICAgICAgdXNhZ2U6XG4gICAgICAgICAgICAgICAgR1BVVGV4dHVyZVVzYWdlLlRFWFRVUkVfQklORElORyB8XG4gICAgICAgICAgICAgICAgR1BVVGV4dHVyZVVzYWdlLkNPUFlfRFNUIHxcbiAgICAgICAgICAgICAgICBHUFVUZXh0dXJlVXNhZ2UuUkVOREVSX0FUVEFDSE1FTlQsXG4gICAgICAgIH0pXG5cbiAgICAgICAgZGV2aWNlLnF1ZXVlLmNvcHlFeHRlcm5hbEltYWdlVG9UZXh0dXJlKFxuICAgICAgICAgICAgeyBzb3VyY2U6IGltYWdlQml0bWFwIH0sXG4gICAgICAgICAgICB7IHRleHR1cmU6IGltYWdlVGV4dHVyZSB9LFxuICAgICAgICAgICAgaW1hZ2VTaXplXG4gICAgICAgIClcblxuICAgICAgICB0ZXh0dXJlVmlldyA9IGltYWdlVGV4dHVyZS5jcmVhdGVWaWV3KClcblxuICAgICAgICByZXR1cm4geyB2aWV3OiB0ZXh0dXJlVmlldywgc2FtcGxlcjogdGV4dHVyZVNhbXBsZXIgfVxuICAgIH1cblxuICAgIHByaXZhdGUgc3RhdGljIHVwbG9hZE1hdGVyaWFscyhcbiAgICAgICAgbW9kZWxEYXRhOiBJTW9kZWxQcmVsb2FkRGF0YSxcbiAgICAgICAgdGV4dHVyZVN0b3JhZ2U6IElUZXh0dXJlU3RvcmFnZSxcbiAgICAgICAgc2FtcGxlclN0b3JhZ2U6IElTYW1wbGVyU3RvcmFnZSxcbiAgICAgICAgaW1hZ2VTdG9yYWdlOiBJSW1hZ2VTdG9yYWdlLFxuICAgICAgICBtYXRlcmlhbFN0b3JhZ2U6IElNYXRlcmlhbFN0b3JhZ2UsXG4gICAgICAgIGRldmljZTogR1BVRGV2aWNlXG4gICAgKSB7XG4gICAgICAgIGxldCBkZWZhdWx0TWF0ZXJpYWwgPSBtYXRlcmlhbFN0b3JhZ2UubWF0ZXJpYWxzLmdldChcbiAgICAgICAgICAgICdkZWZhdWx0J1xuICAgICAgICApIGFzIElNYXRlcmlhbFxuXG4gICAgICAgIGlmICghZGVmYXVsdE1hdGVyaWFsKSB7XG4gICAgICAgICAgICBkZWZhdWx0TWF0ZXJpYWwgPSB7XG4gICAgICAgICAgICAgICAgbmFtZTogJ0RlZmF1bHQgd2hlZXp5IG1hdGVyaWFsJyxcbiAgICAgICAgICAgICAgICBlbWlzc2l2ZUZhY3RvcjogdmVjMy5jcmVhdGUoMSwgMSwgMSksXG4gICAgICAgICAgICAgICAgbWV0YWxsaWNGYWN0b3I6IDEsXG4gICAgICAgICAgICAgICAgcm91Z2huZXNzRmFjdG9yOiAxLFxuICAgICAgICAgICAgICAgIGJhc2VDb2xvckZhY3RvcjogdmVjNC5jcmVhdGUoMSwgMSwgMSwgMSksXG4gICAgICAgICAgICAgICAgYmFzZUNvbG9yVGV4dHVyZTogdGhpcy5jcmVhdGVHUFVUZXh0dXJlKFxuICAgICAgICAgICAgICAgICAgICBkZXZpY2UsXG4gICAgICAgICAgICAgICAgICAgICdyZ2JhOHVub3JtLXNyZ2InLFxuICAgICAgICAgICAgICAgICAgICBzYW1wbGVyU3RvcmFnZSxcbiAgICAgICAgICAgICAgICAgICAgaW1hZ2VTdG9yYWdlLFxuICAgICAgICAgICAgICAgICAgICB0ZXh0dXJlU3RvcmFnZS5kZWZhdWx0QmFzZUNvbG9yXG4gICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICBtZXRhbGxpY1JvdWdobmVzc1RleHR1cmU6IHRoaXMuY3JlYXRlR1BVVGV4dHVyZShcbiAgICAgICAgICAgICAgICAgICAgZGV2aWNlLFxuICAgICAgICAgICAgICAgICAgICAncmdiYTh1bm9ybScsXG4gICAgICAgICAgICAgICAgICAgIHNhbXBsZXJTdG9yYWdlLFxuICAgICAgICAgICAgICAgICAgICBpbWFnZVN0b3JhZ2UsXG4gICAgICAgICAgICAgICAgICAgIHRleHR1cmVTdG9yYWdlLmRlZmF1bHRNZXRhbGxpY1JvdWdobmVzc1xuICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgbm9ybWFsVGV4dHVyZTogdGhpcy5jcmVhdGVHUFVUZXh0dXJlKFxuICAgICAgICAgICAgICAgICAgICBkZXZpY2UsXG4gICAgICAgICAgICAgICAgICAgICdyZ2JhOHVub3JtJyxcbiAgICAgICAgICAgICAgICAgICAgc2FtcGxlclN0b3JhZ2UsXG4gICAgICAgICAgICAgICAgICAgIGltYWdlU3RvcmFnZSxcbiAgICAgICAgICAgICAgICAgICAgdGV4dHVyZVN0b3JhZ2UuZGVmYXVsdE5vcm1hbFxuICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgb2NjbHVzaW9uVGV4dHVyZTogdGhpcy5jcmVhdGVHUFVUZXh0dXJlKFxuICAgICAgICAgICAgICAgICAgICBkZXZpY2UsXG4gICAgICAgICAgICAgICAgICAgICdyZ2JhOHVub3JtJyxcbiAgICAgICAgICAgICAgICAgICAgc2FtcGxlclN0b3JhZ2UsXG4gICAgICAgICAgICAgICAgICAgIGltYWdlU3RvcmFnZSxcbiAgICAgICAgICAgICAgICAgICAgdGV4dHVyZVN0b3JhZ2UuZGVmYXVsdE9jY2x1c2lvblxuICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgZW1pc3NpdmVUZXh0dXJlOiB0aGlzLmNyZWF0ZUdQVVRleHR1cmUoXG4gICAgICAgICAgICAgICAgICAgIGRldmljZSxcbiAgICAgICAgICAgICAgICAgICAgJ3JnYmE4dW5vcm0nLFxuICAgICAgICAgICAgICAgICAgICBzYW1wbGVyU3RvcmFnZSxcbiAgICAgICAgICAgICAgICAgICAgaW1hZ2VTdG9yYWdlLFxuICAgICAgICAgICAgICAgICAgICB0ZXh0dXJlU3RvcmFnZS5kZWZhdWx0RW1pc3Npb25cbiAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbWF0ZXJpYWxTdG9yYWdlLm1hdGVyaWFscy5zZXQoJ2RlZmF1bHQnLCBkZWZhdWx0TWF0ZXJpYWwpXG4gICAgICAgIH1cblxuICAgICAgICBtb2RlbERhdGEubWF0ZXJpYWxzLmZvckVhY2goKHZhbHVlLCBrZXkpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IG1hdGVyaWFsOiBJTWF0ZXJpYWwgPSB7XG4gICAgICAgICAgICAgICAgbmFtZTogdmFsdWUubmFtZSxcbiAgICAgICAgICAgICAgICBlbWlzc2l2ZUZhY3RvcjpcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU/LmVtaXNzaXZlRmFjdG9yID8/IGRlZmF1bHRNYXRlcmlhbC5lbWlzc2l2ZUZhY3RvcixcbiAgICAgICAgICAgICAgICBtZXRhbGxpY0ZhY3RvcjpcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU/Lm1ldGFsbGljRmFjdG9yID8/IGRlZmF1bHRNYXRlcmlhbC5tZXRhbGxpY0ZhY3RvcixcbiAgICAgICAgICAgICAgICByb3VnaG5lc3NGYWN0b3I6XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlLnJvdWdobmVzc0ZhY3RvciA/PyBkZWZhdWx0TWF0ZXJpYWwucm91Z2huZXNzRmFjdG9yLFxuICAgICAgICAgICAgICAgIGJhc2VDb2xvckZhY3RvcjpcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU/LmJhc2VDb2xvckZhY3RvciA/PyBkZWZhdWx0TWF0ZXJpYWwuYmFzZUNvbG9yRmFjdG9yLFxuICAgICAgICAgICAgICAgIGJhc2VDb2xvclRleHR1cmU6IHZhbHVlLmJhc2VDb2xvclRleHR1cmVJZFxuICAgICAgICAgICAgICAgICAgICA/IHRoaXMuY3JlYXRlR1BVVGV4dHVyZShcbiAgICAgICAgICAgICAgICAgICAgICAgICAgZGV2aWNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAncmdiYTh1bm9ybS1zcmdiJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgc2FtcGxlclN0b3JhZ2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGltYWdlU3RvcmFnZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgdGV4dHVyZVN0b3JhZ2UudGV4dHVyZXMuZ2V0KHZhbHVlLmJhc2VDb2xvclRleHR1cmVJZClcbiAgICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICAgIDogZGVmYXVsdE1hdGVyaWFsLmJhc2VDb2xvclRleHR1cmUsXG4gICAgICAgICAgICAgICAgbWV0YWxsaWNSb3VnaG5lc3NUZXh0dXJlOiB2YWx1ZS5tZXRhbGxpY1JvdWdobmVzc1RleHR1cmVJZFxuICAgICAgICAgICAgICAgICAgICA/IHRoaXMuY3JlYXRlR1BVVGV4dHVyZShcbiAgICAgICAgICAgICAgICAgICAgICAgICAgZGV2aWNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAncmdiYTh1bm9ybScsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHNhbXBsZXJTdG9yYWdlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBpbWFnZVN0b3JhZ2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHRleHR1cmVTdG9yYWdlLnRleHR1cmVzLmdldChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlLm1ldGFsbGljUm91Z2huZXNzVGV4dHVyZUlkXG4gICAgICAgICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICAgIDogZGVmYXVsdE1hdGVyaWFsLm1ldGFsbGljUm91Z2huZXNzVGV4dHVyZSxcbiAgICAgICAgICAgICAgICBub3JtYWxUZXh0dXJlOiB2YWx1ZS5ub3JtYWxUZXh0dXJlSWRcbiAgICAgICAgICAgICAgICAgICAgPyB0aGlzLmNyZWF0ZUdQVVRleHR1cmUoXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGRldmljZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgJ3JnYmE4dW5vcm0nLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBzYW1wbGVyU3RvcmFnZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgaW1hZ2VTdG9yYWdlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICB0ZXh0dXJlU3RvcmFnZS50ZXh0dXJlcy5nZXQodmFsdWUubm9ybWFsVGV4dHVyZUlkKVxuICAgICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgICAgOiBkZWZhdWx0TWF0ZXJpYWwubm9ybWFsVGV4dHVyZSxcbiAgICAgICAgICAgICAgICBvY2NsdXNpb25UZXh0dXJlOiB2YWx1ZS5vY2NsdXNpb25UZXh0dXJlSWRcbiAgICAgICAgICAgICAgICAgICAgPyB0aGlzLmNyZWF0ZUdQVVRleHR1cmUoXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGRldmljZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgJ3JnYmE4dW5vcm0nLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBzYW1wbGVyU3RvcmFnZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgaW1hZ2VTdG9yYWdlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICB0ZXh0dXJlU3RvcmFnZS50ZXh0dXJlcy5nZXQodmFsdWUub2NjbHVzaW9uVGV4dHVyZUlkKVxuICAgICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgICAgOiBkZWZhdWx0TWF0ZXJpYWwub2NjbHVzaW9uVGV4dHVyZSxcbiAgICAgICAgICAgICAgICBlbWlzc2l2ZVRleHR1cmU6IHZhbHVlLmVtaXNzaXZlVGV4dHVyZUlkXG4gICAgICAgICAgICAgICAgICAgID8gdGhpcy5jcmVhdGVHUFVUZXh0dXJlKFxuICAgICAgICAgICAgICAgICAgICAgICAgICBkZXZpY2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICdyZ2JhOHVub3JtJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgc2FtcGxlclN0b3JhZ2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGltYWdlU3RvcmFnZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgdGV4dHVyZVN0b3JhZ2UudGV4dHVyZXMuZ2V0KHZhbHVlLmVtaXNzaXZlVGV4dHVyZUlkKVxuICAgICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgICAgOiBkZWZhdWx0TWF0ZXJpYWwuZW1pc3NpdmVUZXh0dXJlLFxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBtYXRlcmlhbFN0b3JhZ2UubWF0ZXJpYWxzLnNldChrZXksIG1hdGVyaWFsKVxuICAgICAgICB9KVxuICAgIH1cblxuICAgIHByaXZhdGUgc3RhdGljIHRyYXZlcnNlUHJlbG9hZE5vZGUoXG4gICAgICAgIG5vZGU6IElQcmVsb2FkRW50aXR5LFxuICAgICAgICBwYXJlbnRHYW1lT2JqZWN0OiBJR2FtZU9iamVjdCxcbiAgICAgICAgb2JqZWN0TWFuYWdlcjogSU9iamVjdE1hbmFnZXIsXG4gICAgICAgIGJ1ZmZlclN0b3JhZ2U6IElCdWZmZXJTdG9yYWdlLFxuICAgICAgICBtYXRlcmlhbFN0b3JhZ2U6IElNYXRlcmlhbFN0b3JhZ2UsXG4gICAgICAgIGRldmljZTogR1BVRGV2aWNlXG4gICAgKSB7XG4gICAgICAgIGNvbnN0IHsgdHJzTWF0cml4LCBtZXNoZXMsIGNoaWxkcmVuIH0gPSBub2RlXG5cbiAgICAgICAgY29uc3QgZ2FtZU9iamVjdCA9IG5ldyBHYW1lT2JqZWN0KClcblxuICAgICAgICBvYmplY3RNYW5hZ2VyLmFkZE9iamVjdChnYW1lT2JqZWN0LCBwYXJlbnRHYW1lT2JqZWN0KVxuXG4gICAgICAgIG5ldyBUcmFuc2Zvcm0oZ2FtZU9iamVjdCwgdHJzTWF0cml4KVxuXG4gICAgICAgIG1lc2hlcy5mb3JFYWNoKChtZXNoRGF0YSkgPT4ge1xuICAgICAgICAgICAgbmV3IE1lc2goXG4gICAgICAgICAgICAgICAgZ2FtZU9iamVjdCxcbiAgICAgICAgICAgICAgICBtZXNoRGF0YS5wb3NpdGlvbnMgYXMgR0xURkFjY2Vzc29yLFxuICAgICAgICAgICAgICAgIG1lc2hEYXRhLmluZGljZXMsXG4gICAgICAgICAgICAgICAgbWVzaERhdGEubm9ybWFscyxcbiAgICAgICAgICAgICAgICBtZXNoRGF0YS50ZXh0dXJlQ29vcmRpbmF0ZXMsXG4gICAgICAgICAgICAgICAgbWVzaERhdGEudGFuZ2VudHMsXG4gICAgICAgICAgICAgICAgbWF0ZXJpYWxTdG9yYWdlLm1hdGVyaWFscy5nZXQobWVzaERhdGEubWF0ZXJpYWxJZCkgYXMgSU1hdGVyaWFsXG4gICAgICAgICAgICApXG4gICAgICAgIH0pXG5cbiAgICAgICAgY2hpbGRyZW4uZm9yRWFjaCgoY2hpbGQpID0+IHtcbiAgICAgICAgICAgIHRoaXMudHJhdmVyc2VQcmVsb2FkTm9kZShcbiAgICAgICAgICAgICAgICBjaGlsZCxcbiAgICAgICAgICAgICAgICBnYW1lT2JqZWN0LFxuICAgICAgICAgICAgICAgIG9iamVjdE1hbmFnZXIsXG4gICAgICAgICAgICAgICAgYnVmZmVyU3RvcmFnZSxcbiAgICAgICAgICAgICAgICBtYXRlcmlhbFN0b3JhZ2UsXG4gICAgICAgICAgICAgICAgZGV2aWNlXG4gICAgICAgICAgICApXG4gICAgICAgIH0pXG4gICAgfVxuXG4gICAgcHVibGljIHN0YXRpYyBhc3luYyB1cGxvYWRNb2RlbChcbiAgICAgICAgbW9kZWxEYXRhOiBJTW9kZWxQcmVsb2FkRGF0YSxcbiAgICAgICAgb2JqZWN0TWFuYWdlcjogSU9iamVjdE1hbmFnZXIsXG4gICAgICAgIGJ1ZmZlclN0b3JhZ2U6IElCdWZmZXJTdG9yYWdlLFxuICAgICAgICBpbWFnZVN0b3JhZ2U6IElJbWFnZVN0b3JhZ2UsXG4gICAgICAgIHNhbXBsZXJTdG9yYWdlOiBJU2FtcGxlclN0b3JhZ2UsXG4gICAgICAgIG1hdGVyaWFsU3RvcmFnZTogSU1hdGVyaWFsU3RvcmFnZSxcbiAgICAgICAgdGV4dHVyZVN0b3JhZ2U6IElUZXh0dXJlU3RvcmFnZSxcbiAgICAgICAgc2NlbmVPYmplY3Q6IElHYW1lT2JqZWN0LFxuICAgICAgICBkZXZpY2U6IEdQVURldmljZVxuICAgICkge1xuICAgICAgICB0aGlzLnVwbG9hZEJ1ZmZlcnMobW9kZWxEYXRhLCBidWZmZXJTdG9yYWdlKVxuICAgICAgICBhd2FpdCB0aGlzLnVwbG9hZEltYWdlcyhtb2RlbERhdGEsIGJ1ZmZlclN0b3JhZ2UsIGltYWdlU3RvcmFnZSlcbiAgICAgICAgdGhpcy51cGxvYWRTYW1wbGVycyhtb2RlbERhdGEsIHNhbXBsZXJTdG9yYWdlLCBkZXZpY2UpXG4gICAgICAgIHRoaXMudXBsb2FkVGV4dHVyZXMobW9kZWxEYXRhLCB0ZXh0dXJlU3RvcmFnZSlcbiAgICAgICAgdGhpcy51cGxvYWRNYXRlcmlhbHMoXG4gICAgICAgICAgICBtb2RlbERhdGEsXG4gICAgICAgICAgICB0ZXh0dXJlU3RvcmFnZSxcbiAgICAgICAgICAgIHNhbXBsZXJTdG9yYWdlLFxuICAgICAgICAgICAgaW1hZ2VTdG9yYWdlLFxuICAgICAgICAgICAgbWF0ZXJpYWxTdG9yYWdlLFxuICAgICAgICAgICAgZGV2aWNlXG4gICAgICAgIClcblxuICAgICAgICBjb25zdCB7IHRyc01hdHJpeCwgbWVzaGVzLCBjaGlsZHJlbiB9ID0gbW9kZWxEYXRhLm1vZGVsXG5cbiAgICAgICAgY29uc3QgbWVzaE9iamVjdCA9IG5ldyBHYW1lT2JqZWN0KClcblxuICAgICAgICBvYmplY3RNYW5hZ2VyLmFkZE9iamVjdChtZXNoT2JqZWN0LCBzY2VuZU9iamVjdClcblxuICAgICAgICBuZXcgVHJhbnNmb3JtKG1lc2hPYmplY3QsIHRyc01hdHJpeClcblxuICAgICAgICBtZXNoZXMuZm9yRWFjaCgobWVzaERhdGEpID0+IHtcbiAgICAgICAgICAgIG5ldyBNZXNoKFxuICAgICAgICAgICAgICAgIG1lc2hPYmplY3QsXG4gICAgICAgICAgICAgICAgbWVzaERhdGEucG9zaXRpb25zIGFzIEdMVEZBY2Nlc3NvcixcbiAgICAgICAgICAgICAgICBtZXNoRGF0YS5pbmRpY2VzLFxuICAgICAgICAgICAgICAgIG1lc2hEYXRhLm5vcm1hbHMsXG4gICAgICAgICAgICAgICAgbWVzaERhdGEudGV4dHVyZUNvb3JkaW5hdGVzLFxuICAgICAgICAgICAgICAgIG1lc2hEYXRhLnRhbmdlbnRzLFxuICAgICAgICAgICAgICAgIG1hdGVyaWFsU3RvcmFnZS5tYXRlcmlhbHMuZ2V0KG1lc2hEYXRhLm1hdGVyaWFsSWQpIGFzIElNYXRlcmlhbFxuICAgICAgICAgICAgKVxuICAgICAgICB9KVxuXG4gICAgICAgIGNoaWxkcmVuLmZvckVhY2goKGNoaWxkKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnRyYXZlcnNlUHJlbG9hZE5vZGUoXG4gICAgICAgICAgICAgICAgY2hpbGQsXG4gICAgICAgICAgICAgICAgbWVzaE9iamVjdCxcbiAgICAgICAgICAgICAgICBvYmplY3RNYW5hZ2VyLFxuICAgICAgICAgICAgICAgIGJ1ZmZlclN0b3JhZ2UsXG4gICAgICAgICAgICAgICAgbWF0ZXJpYWxTdG9yYWdlLFxuICAgICAgICAgICAgICAgIGRldmljZVxuICAgICAgICAgICAgKVxuICAgICAgICB9KVxuXG4gICAgICAgIHJldHVybiBtZXNoT2JqZWN0XG4gICAgfVxufVxuIiwiZXhwb3J0ICogZnJvbSAnLi9Nb2RlbFVwbG9hZGVyJ1xuIiwiaW1wb3J0IHtcbiAgICBFbnRpdHlJRCxcbiAgICBJR2FtZU9iamVjdCxcbiAgICBJT2JqZWN0TWFuYWdlcixcbiAgICBJU2NlbmVUcmVlLFxuICAgIFNjZW5lVHJlZVBvc2l0aW9uLFxufSBmcm9tICcuLi8uLi90eXBlcydcbmltcG9ydCB7IFNjZW5lVHJlZSB9IGZyb20gJy4uL1NjZW5lVHJlZSdcblxudHlwZSBPYmplY3RQb3NpdGlvbnMgPSBNYXA8RW50aXR5SUQsIFNjZW5lVHJlZVBvc2l0aW9uIHwgbnVsbD5cblxuZXhwb3J0IGNsYXNzIE9iamVjdE1hbmFnZXIgaW1wbGVtZW50cyBJT2JqZWN0TWFuYWdlciB7XG4gICAgcHJpdmF0ZSBfb2JqZWN0UG9zaXRpb25zOiBPYmplY3RQb3NpdGlvbnMgPSBuZXcgTWFwKClcbiAgICBwcml2YXRlIF9zY2VuZVRyZWU6IElTY2VuZVRyZWUgPSBuZXcgU2NlbmVUcmVlKClcblxuICAgIHB1YmxpYyBnZXQgc2NlbmVUcmVlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fc2NlbmVUcmVlXG4gICAgfVxuXG4gICAgcHJpdmF0ZSBnZXRPYmplY3RQb3NpdGlvbihnYW1lT2JqZWN0PzogSUdhbWVPYmplY3QgfCBudWxsKSB7XG4gICAgICAgIHJldHVybiBnYW1lT2JqZWN0XG4gICAgICAgICAgICA/IHRoaXMuX29iamVjdFBvc2l0aW9ucy5nZXQoZ2FtZU9iamVjdC5pZCkgPz8gbnVsbFxuICAgICAgICAgICAgOiBudWxsXG4gICAgfVxuXG4gICAgcHVibGljIGFkZE9iamVjdChjaGlsZDogSUdhbWVPYmplY3QsIHRhcmdldD86IElHYW1lT2JqZWN0KSB7XG4gICAgICAgIGNvbnN0IHBvc2l0aW9uID0gdGhpcy5fc2NlbmVUcmVlLmFkZE5vZGVBdChcbiAgICAgICAgICAgIHRoaXMuZ2V0T2JqZWN0UG9zaXRpb24odGFyZ2V0KSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBnYW1lT2JqZWN0OiBjaGlsZCxcbiAgICAgICAgICAgICAgICBjaGlsZHJlbjogbmV3IE1hcCgpLFxuICAgICAgICAgICAgfVxuICAgICAgICApXG5cbiAgICAgICAgdGhpcy5fb2JqZWN0UG9zaXRpb25zLnNldChjaGlsZC5pZCwgcG9zaXRpb24pXG4gICAgfVxuXG4gICAgcHVibGljIHJlcGFyZW50T2JqZWN0KGNoaWxkOiBJR2FtZU9iamVjdCwgdGFyZ2V0PzogSUdhbWVPYmplY3QpIHtcbiAgICAgICAgY29uc3QgY2hpbGRQb3NpdGlvbiA9IHRoaXMuX29iamVjdFBvc2l0aW9ucy5nZXQoY2hpbGQuaWQpXG5cbiAgICAgICAgaWYgKCFjaGlsZFBvc2l0aW9uKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFBvc2l0aW9uIHJlY29yZCBub3QgZm91bmQgZm9yICR7Y2hpbGQuaWR9YClcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IG5ld1Bvc2l0aW9uID0gdGhpcy5fc2NlbmVUcmVlLnJlcGFyZW50Tm9kZShcbiAgICAgICAgICAgIHRoaXMuZ2V0T2JqZWN0UG9zaXRpb24odGFyZ2V0KSxcbiAgICAgICAgICAgIGNoaWxkUG9zaXRpb25cbiAgICAgICAgKVxuXG4gICAgICAgIHRoaXMuX29iamVjdFBvc2l0aW9ucy5zZXQoY2hpbGQuaWQsIG5ld1Bvc2l0aW9uKVxuICAgIH1cblxuICAgIHB1YmxpYyBkZXN0cm95T2JqZWN0KGdhbWVPYmplY3Q6IElHYW1lT2JqZWN0KSB7XG4gICAgICAgIGNvbnN0IGNoaWxkUG9zaXRpb24gPSB0aGlzLl9vYmplY3RQb3NpdGlvbnMuZ2V0KGdhbWVPYmplY3QuaWQpXG5cbiAgICAgICAgaWYgKCFjaGlsZFBvc2l0aW9uKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFBvc2l0aW9uIHJlY29yZCBub3QgZm91bmQgZm9yICR7Z2FtZU9iamVjdC5pZH1gKVxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgaWRzVG9SZW1vdmUgPSB0aGlzLl9zY2VuZVRyZWUucmVtb3ZlTm9kZShjaGlsZFBvc2l0aW9uKVxuXG4gICAgICAgIGlkc1RvUmVtb3ZlLmZvckVhY2goKGlkKSA9PiB7XG4gICAgICAgICAgICB0aGlzLl9vYmplY3RQb3NpdGlvbnMuZGVsZXRlKGlkKVxuICAgICAgICB9KVxuICAgIH1cbn1cbiIsImV4cG9ydCAqIGZyb20gJy4vT2JqZWN0TWFuYWdlcidcbiIsImltcG9ydCB7IG1hdDQsIE1hdDQsIHZlYzMsIHZlYzQgfSBmcm9tICd3Z3B1LW1hdHJpeCdcbmltcG9ydCB7XG4gICAgRW50aXR5VHlwZXMsXG4gICAgR0xURkFjY2Vzc29yLFxuICAgIElNZXNoLFxuICAgIElSZW5kZXJlcixcbiAgICBJUmVuZGVyZXJQcm9wcyxcbiAgICBJU2NlbmUsXG4gICAgUkVOREVSX01PREVTLFxuICAgIFJFTkRFUl9PVVRQVVRfU09VUkNFUyxcbiAgICBTY2VuZU5vZGVDb250ZW50LFxuICAgIFRTa3lib3hCaXRtYXBzLFxufSBmcm9tICcuLi8uLi90eXBlcydcbmltcG9ydCB7XG4gICAgREVGQVVMVF9ERVBUSF9GT1JNQVQsXG4gICAgREVGQVVMVF9TSEFET1dfREVQVEhfRk9STUFULFxuICAgIERFRkFVTFRfU1dBUF9DSEFJTl9GT1JNQVQsXG4gICAgREVGVUxUX1NIQURPV19URVhUVVJFX1NJWkUsXG4gICAgTVNBQV9TQU1QTEVfQ09VTlQsXG4gICAgVklFV19QQVJBTVNfQlVGRkVSX1NJWkUsXG59IGZyb20gJy4vY29uc3RhbnRzJ1xuaW1wb3J0IHsgSU1lc2hSZW5kZXJEYXRhIH0gZnJvbSAnLi4vLi4vdHlwZXMvY29yZS9NZXNoUmVuZGVyRGF0YVN0b3JhZ2UnXG5pbXBvcnQgc2hhZGVyQ29kZSBmcm9tICcuLi8uLi9zaGFkZXJzL3Rlc3RTaGFkZXIud2dzbCdcbmltcG9ydCBzaGFkb3dTaGFkZXJDb2RlIGZyb20gJy4uLy4uL3NoYWRlcnMvdmVydGV4U2hhZG93Lndnc2wnXG5pbXBvcnQgc2t5Ym94U2hhZGVyQ29kZSBmcm9tICcuLi8uLi9zaGFkZXJzL3NreWJveC53Z3NsJ1xuaW1wb3J0IHtcbiAgICBjdWJlUG9zaXRpb25PZmZzZXQsXG4gICAgY3ViZVVWT2Zmc2V0LFxuICAgIGN1YmVWZXJ0ZXhBcnJheSxcbiAgICBjdWJlVmVydGV4Q291bnQsXG4gICAgY3ViZVZlcnRleFNpemUsXG59IGZyb20gJy4uLy4uL3ByaW1pdGl2ZXMvY3ViZSdcblxuZXhwb3J0IGNvbnN0IGFsaWduVG8gPSAodmFsOiBudW1iZXIsIGFsaWduOiBudW1iZXIpID0+IHtcbiAgICByZXR1cm4gTWF0aC5mbG9vcigodmFsICsgYWxpZ24gLSAxKSAvIGFsaWduKSAqIGFsaWduXG59XG5cbmNvbnN0IHNreUJveFVuaWZvcm1CdWZmZXJTaXplID0gNCAqIDE2ICsgNCAqIDE2ICsgNCAqIDE2ICsgNCAqIDRcblxuZXhwb3J0IGNsYXNzIFJlbmRlcmVyIGltcGxlbWVudHMgSVJlbmRlcmVyIHtcbiAgICBwcml2YXRlIF9hZGFwdGVyITogR1BVQWRhcHRlclxuICAgIHByaXZhdGUgX2RldmljZSE6IEdQVURldmljZVxuICAgIHByaXZhdGUgX2NvbnRleHQhOiBHUFVDYW52YXNDb250ZXh0XG4gICAgcHJpdmF0ZSBfY2FudmFzOiBIVE1MQ2FudmFzRWxlbWVudFxuXG4gICAgcHJpdmF0ZSBfc3dhcENoYWluRm9ybWF0OiBHUFVUZXh0dXJlRm9ybWF0ID0gREVGQVVMVF9TV0FQX0NIQUlOX0ZPUk1BVFxuICAgIHByaXZhdGUgX2RlcHRoVGV4dHVyZUZvcm1hdDogR1BVVGV4dHVyZUZvcm1hdCA9IERFRkFVTFRfREVQVEhfRk9STUFUXG4gICAgcHJpdmF0ZSBfZGVwdGhUZXh0dXJlITogR1BVVGV4dHVyZVxuICAgIHByaXZhdGUgX3NoYWRvd0RlcHRoVGV4dHVyZSE6IEdQVVRleHR1cmVcbiAgICBwcml2YXRlIF9zaGFkb3dEZXB0aFRleHR1cmVWaWV3ITogR1BVVGV4dHVyZVZpZXdcbiAgICBwcml2YXRlIF9zaGFkb3dEZXB0aFRleHR1cmVTaXplID0gREVGVUxUX1NIQURPV19URVhUVVJFX1NJWkVcbiAgICBwcml2YXRlIF9zaGFkb3dEZXB0aFNhbXBsZXIhOiBHUFVTYW1wbGVyXG5cbiAgICBwcml2YXRlIF9za3lCb3hWZXJ0aWNlc0J1ZmZlciE6IEdQVUJ1ZmZlclxuICAgIHByaXZhdGUgX3NreUJveFBpcGVsaW5lITogR1BVUmVuZGVyUGlwZWxpbmVcbiAgICBwcml2YXRlIF9za3lCb3hVbmlmb3JtQnVmZmVyITogR1BVQnVmZmVyXG4gICAgcHJpdmF0ZSBfc2t5Qm94VW5pZm9ybUJ1ZmZlclNpemUgPSAxNiAqIDQgKiAzICsgNCAqIDRcbiAgICBwcml2YXRlIF9za3lCb3hSZW5kZXJQYXNzRGVzY3JpcHRvciE6IEdQVVJlbmRlclBhc3NEZXNjcmlwdG9yXG4gICAgcHJpdmF0ZSBfc2t5Qm94VW5pZm9ybUJpbmRHcm91cCE6IEdQVUJpbmRHcm91cFxuICAgIHByaXZhdGUgX3NreUJveE1vZGVsTWF0cml4OiBNYXQ0ID0gbWF0NC5zY2FsaW5nKFxuICAgICAgICB2ZWMzLmZyb21WYWx1ZXMoMTAwLCAxMDAsIDEwMClcbiAgICApXG4gICAgcHJpdmF0ZSBfc2t5Ym94VGV4dHVyZSE6IEdQVVRleHR1cmVcbiAgICBwcml2YXRlIF9za3lib3hTYW1wbGVyITogR1BVU2FtcGxlclxuXG4gICAgcHJpdmF0ZSBfdW5pZm9ybXNCR0xheW91dCE6IEdQVUJpbmRHcm91cExheW91dFxuICAgIHByaXZhdGUgX25vZGVQYXJhbXNCR0xheW91dCE6IEdQVUJpbmRHcm91cExheW91dFxuXG4gICAgcHJpdmF0ZSBfdmlld1BhcmFtc0J1ZmZlclNpemU6IG51bWJlciA9IFZJRVdfUEFSQU1TX0JVRkZFUl9TSVpFXG4gICAgcHJpdmF0ZSBfbXNhYVNhbXBsZUNvdW50OiBudW1iZXIgPSBNU0FBX1NBTVBMRV9DT1VOVFxuXG4gICAgcHJpdmF0ZSBfcmVuZGVyUGFzc0Rlc2NyaXB0b3IhOiBHUFVSZW5kZXJQYXNzRGVzY3JpcHRvclxuICAgIHByaXZhdGUgX3NoYWRvd1Bhc3NEZXNjcmlwdG9yITogR1BVUmVuZGVyUGFzc0Rlc2NyaXB0b3JcblxuICAgIHByaXZhdGUgX3ZpZXdQYXJhbXNCdWZmZXIhOiBHUFVCdWZmZXJcbiAgICBwcml2YXRlIF92aWV3UGFyYW1zQmluZEdyb3VwITogR1BVQmluZEdyb3VwXG5cbiAgICBwcml2YXRlIF9kZWJ1Z1BhcmFtc0J1ZmZlciE6IEdQVUJ1ZmZlclxuXG4gICAgcHJpdmF0ZSBfbXVsdGlzYW1wbGVUZXh0dXJlVmlldz86IEdQVVRleHR1cmVWaWV3XG5cbiAgICBwcml2YXRlIF9zaGFkZXJNb2R1bGUhOiBHUFVTaGFkZXJNb2R1bGVcblxuICAgIHB1YmxpYyBhbWJpZW50TGlnaHRDb2xvciA9IHZlYzMuY3JlYXRlKDEsIDEsIDEpXG4gICAgcHVibGljIGFtYmllbnRMaWdodEludGVuc2l0eTogbnVtYmVyID0gMC4wM1xuXG4gICAgcHVibGljIG91dHB1dFNvdXJjZSA9IFJFTkRFUl9PVVRQVVRfU09VUkNFUy5ERUZBVUxUXG4gICAgcHVibGljIHJlbmRlcmluZ01vZGUgPSBSRU5ERVJfTU9ERVMuVVNFX0ZfTk9STUFMXG5cbiAgICBjb25zdHJ1Y3Rvcih7IGNhbnZhcyB9OiBJUmVuZGVyZXJQcm9wcykge1xuICAgICAgICB0aGlzLl9jYW52YXMgPSBjYW52YXNcbiAgICB9XG5cbiAgICBwdWJsaWMgYXN5bmMgaW5pdCgpIHtcbiAgICAgICAgYXdhaXQgdGhpcy5faW5pdGlhbGl6ZUNvbnRleHQodGhpcy5fY2FudmFzKVxuXG4gICAgICAgIHRoaXMuX2NvbnRleHQuY29uZmlndXJlKHtcbiAgICAgICAgICAgIGRldmljZTogdGhpcy5fZGV2aWNlLFxuICAgICAgICAgICAgdXNhZ2U6IEdQVVRleHR1cmVVc2FnZS5SRU5ERVJfQVRUQUNITUVOVCxcbiAgICAgICAgICAgIGZvcm1hdDogdGhpcy5fc3dhcENoYWluRm9ybWF0LFxuICAgICAgICB9KVxuXG4gICAgICAgIHRoaXMuX2RlcHRoVGV4dHVyZSA9IHRoaXMuX2RldmljZS5jcmVhdGVUZXh0dXJlKHtcbiAgICAgICAgICAgIGxhYmVsOiAnZGVwdGhUZXh0dXJlJyxcbiAgICAgICAgICAgIHNpemU6IHtcbiAgICAgICAgICAgICAgICB3aWR0aDogdGhpcy5fY29udGV4dC5jYW52YXMud2lkdGgsXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiB0aGlzLl9jb250ZXh0LmNhbnZhcy5oZWlnaHQsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc2FtcGxlQ291bnQ6IHRoaXMuX21zYWFTYW1wbGVDb3VudCxcbiAgICAgICAgICAgIGZvcm1hdDogdGhpcy5fZGVwdGhUZXh0dXJlRm9ybWF0LFxuICAgICAgICAgICAgdXNhZ2U6IEdQVVRleHR1cmVVc2FnZS5SRU5ERVJfQVRUQUNITUVOVCxcbiAgICAgICAgfSlcblxuICAgICAgICB0aGlzLl9zaGFkb3dEZXB0aFRleHR1cmUgPSB0aGlzLl9kZXZpY2UuY3JlYXRlVGV4dHVyZSh7XG4gICAgICAgICAgICBsYWJlbDogJ3NoYWRvd0RlcHRoVGV4dHVyZScsXG4gICAgICAgICAgICBzaXplOiBbXG4gICAgICAgICAgICAgICAgdGhpcy5fc2hhZG93RGVwdGhUZXh0dXJlU2l6ZSxcbiAgICAgICAgICAgICAgICB0aGlzLl9zaGFkb3dEZXB0aFRleHR1cmVTaXplLFxuICAgICAgICAgICAgICAgIDEsXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgdXNhZ2U6XG4gICAgICAgICAgICAgICAgR1BVVGV4dHVyZVVzYWdlLlJFTkRFUl9BVFRBQ0hNRU5UIHxcbiAgICAgICAgICAgICAgICBHUFVUZXh0dXJlVXNhZ2UuVEVYVFVSRV9CSU5ESU5HLFxuICAgICAgICAgICAgZm9ybWF0OiBERUZBVUxUX1NIQURPV19ERVBUSF9GT1JNQVQsXG4gICAgICAgIH0pXG5cbiAgICAgICAgdGhpcy5fc2hhZG93RGVwdGhTYW1wbGVyID0gdGhpcy5kZXZpY2UuY3JlYXRlU2FtcGxlcih7XG4gICAgICAgICAgICBjb21wYXJlOiAnbGVzcycsXG4gICAgICAgICAgICBsYWJlbDogJ3NoYWRvdyBkZXB0aCBzYW1wbGVyJyxcbiAgICAgICAgfSlcblxuICAgICAgICB0aGlzLl9zaGFkb3dEZXB0aFRleHR1cmVWaWV3ID0gdGhpcy5fc2hhZG93RGVwdGhUZXh0dXJlLmNyZWF0ZVZpZXcoKVxuXG4gICAgICAgIHRoaXMuX3NoYWRlck1vZHVsZSA9IHRoaXMuZGV2aWNlLmNyZWF0ZVNoYWRlck1vZHVsZSh7XG4gICAgICAgICAgICBsYWJlbDogJ21haW4gc2hhZGVyJyxcbiAgICAgICAgICAgIGNvZGU6IHNoYWRlckNvZGUsXG4gICAgICAgIH0pXG5cbiAgICAgICAgdGhpcy5faW5pdGlhbGl6ZUJpbmRHcm91cExheW91dHMoKVxuXG4gICAgICAgIHRoaXMuX2luaXRpYWxpemVWaWV3UGFyYW1zKClcblxuICAgICAgICBpZiAodGhpcy5fbXNhYVNhbXBsZUNvdW50ICE9PSAxKSB7XG4gICAgICAgICAgICB0aGlzLl9tdWx0aXNhbXBsZVRleHR1cmVWaWV3ID0gdGhpcy5kZXZpY2VcbiAgICAgICAgICAgICAgICAuY3JlYXRlVGV4dHVyZSh7XG4gICAgICAgICAgICAgICAgICAgIHNpemU6IFt0aGlzLl9jYW52YXMud2lkdGgsIHRoaXMuX2NhbnZhcy5oZWlnaHRdLFxuICAgICAgICAgICAgICAgICAgICBzYW1wbGVDb3VudDogdGhpcy5fbXNhYVNhbXBsZUNvdW50LFxuICAgICAgICAgICAgICAgICAgICBmb3JtYXQ6IHRoaXMuc3dhcENoYWluRm9ybWF0LFxuICAgICAgICAgICAgICAgICAgICB1c2FnZTogR1BVVGV4dHVyZVVzYWdlLlJFTkRFUl9BVFRBQ0hNRU5ULFxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLmNyZWF0ZVZpZXcoKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fbXVsdGlzYW1wbGVUZXh0dXJlVmlldyA9IHVuZGVmaW5lZFxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fcmVuZGVyUGFzc0Rlc2NyaXB0b3IgPSB7XG4gICAgICAgICAgICBsYWJlbDogJ21haW4gcmVuZGVyIHBhc3MgZGVzY3JpcHRvcicsXG4gICAgICAgICAgICBjb2xvckF0dGFjaG1lbnRzOiBbXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICB2aWV3OiBudWxsIGFzIHVua25vd24gYXMgR1BVVGV4dHVyZVZpZXcsXG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmVUYXJnZXQ6ICh0aGlzLl9tc2FhU2FtcGxlQ291bnQgPT09IDFcbiAgICAgICAgICAgICAgICAgICAgICAgID8gdW5kZWZpbmVkXG4gICAgICAgICAgICAgICAgICAgICAgICA6IG51bGwpIGFzIHVua25vd24gYXMgR1BVVGV4dHVyZVZpZXcsXG4gICAgICAgICAgICAgICAgICAgIGxvYWRPcDogJ2xvYWQnIGFzIEdQVUxvYWRPcCxcbiAgICAgICAgICAgICAgICAgICAgY2xlYXJWYWx1ZTogWzAuMCwgMC4wLCAwLjAsIDAuMF0sXG4gICAgICAgICAgICAgICAgICAgIHN0b3JlT3A6ICdzdG9yZScsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBkZXB0aFN0ZW5jaWxBdHRhY2htZW50OiB7XG4gICAgICAgICAgICAgICAgdmlldzogdGhpcy5fZGVwdGhUZXh0dXJlLmNyZWF0ZVZpZXcoKSxcbiAgICAgICAgICAgICAgICBkZXB0aExvYWRPcDogJ2NsZWFyJyBhcyBHUFVMb2FkT3AsXG4gICAgICAgICAgICAgICAgZGVwdGhDbGVhclZhbHVlOiAxLjAsXG4gICAgICAgICAgICAgICAgZGVwdGhTdG9yZU9wOiAnc3RvcmUnIGFzIEdQVVN0b3JlT3AsXG4gICAgICAgICAgICAgICAgc3RlbmNpbExvYWRPcDogJ2NsZWFyJyBhcyBHUFVMb2FkT3AsXG4gICAgICAgICAgICAgICAgc3RlbmNpbENsZWFyVmFsdWU6IDAsXG4gICAgICAgICAgICAgICAgc3RlbmNpbFN0b3JlT3A6ICdzdG9yZScgYXMgR1BVU3RvcmVPcCxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9zaGFkb3dQYXNzRGVzY3JpcHRvciA9IHtcbiAgICAgICAgICAgIGNvbG9yQXR0YWNobWVudHM6IFtdLFxuICAgICAgICAgICAgZGVwdGhTdGVuY2lsQXR0YWNobWVudDoge1xuICAgICAgICAgICAgICAgIHZpZXc6IHRoaXMuX3NoYWRvd0RlcHRoVGV4dHVyZVZpZXcsXG4gICAgICAgICAgICAgICAgZGVwdGhDbGVhclZhbHVlOiAxLjAsXG4gICAgICAgICAgICAgICAgZGVwdGhMb2FkT3A6ICdjbGVhcicsXG4gICAgICAgICAgICAgICAgZGVwdGhTdG9yZU9wOiAnc3RvcmUnLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX3NreUJveFZlcnRpY2VzQnVmZmVyID0gdGhpcy5fZGV2aWNlLmNyZWF0ZUJ1ZmZlcih7XG4gICAgICAgICAgICBzaXplOiBjdWJlVmVydGV4QXJyYXkuYnl0ZUxlbmd0aCxcbiAgICAgICAgICAgIHVzYWdlOiBHUFVCdWZmZXJVc2FnZS5WRVJURVgsXG4gICAgICAgICAgICBtYXBwZWRBdENyZWF0aW9uOiB0cnVlLFxuICAgICAgICB9KVxuICAgICAgICBuZXcgRmxvYXQzMkFycmF5KHRoaXMuX3NreUJveFZlcnRpY2VzQnVmZmVyLmdldE1hcHBlZFJhbmdlKCkpLnNldChcbiAgICAgICAgICAgIGN1YmVWZXJ0ZXhBcnJheVxuICAgICAgICApXG4gICAgICAgIHRoaXMuX3NreUJveFZlcnRpY2VzQnVmZmVyLnVubWFwKClcblxuICAgICAgICB0aGlzLl9za3lCb3hQaXBlbGluZSA9IHRoaXMuX2RldmljZS5jcmVhdGVSZW5kZXJQaXBlbGluZSh7XG4gICAgICAgICAgICBsYXlvdXQ6ICdhdXRvJyxcbiAgICAgICAgICAgIHZlcnRleDoge1xuICAgICAgICAgICAgICAgIG1vZHVsZTogdGhpcy5fZGV2aWNlLmNyZWF0ZVNoYWRlck1vZHVsZSh7XG4gICAgICAgICAgICAgICAgICAgIGNvZGU6IHNreWJveFNoYWRlckNvZGUsXG4gICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgYnVmZmVyczogW1xuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhcnJheVN0cmlkZTogY3ViZVZlcnRleFNpemUsXG4gICAgICAgICAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaGFkZXJMb2NhdGlvbjogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb2Zmc2V0OiBjdWJlUG9zaXRpb25PZmZzZXQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvcm1hdDogJ2Zsb2F0MzJ4NCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNoYWRlckxvY2F0aW9uOiAxLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvZmZzZXQ6IGN1YmVVVk9mZnNldCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9ybWF0OiAnZmxvYXQzMngyJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGZyYWdtZW50OiB7XG4gICAgICAgICAgICAgICAgbW9kdWxlOiB0aGlzLl9kZXZpY2UuY3JlYXRlU2hhZGVyTW9kdWxlKHtcbiAgICAgICAgICAgICAgICAgICAgY29kZTogc2t5Ym94U2hhZGVyQ29kZSxcbiAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICB0YXJnZXRzOiBbXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvcm1hdDogdGhpcy5fc3dhcENoYWluRm9ybWF0LFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcHJpbWl0aXZlOiB7XG4gICAgICAgICAgICAgICAgdG9wb2xvZ3k6ICd0cmlhbmdsZS1saXN0JyxcbiAgICAgICAgICAgICAgICBjdWxsTW9kZTogJ2Zyb250JyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBkZXB0aFN0ZW5jaWw6IHtcbiAgICAgICAgICAgICAgICBkZXB0aFdyaXRlRW5hYmxlZDogdHJ1ZSxcbiAgICAgICAgICAgICAgICBkZXB0aENvbXBhcmU6ICdsZXNzJyxcbiAgICAgICAgICAgICAgICBmb3JtYXQ6IHRoaXMuX2RlcHRoVGV4dHVyZUZvcm1hdCxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBtdWx0aXNhbXBsZToge1xuICAgICAgICAgICAgICAgIGNvdW50OiB0aGlzLl9tc2FhU2FtcGxlQ291bnQsXG4gICAgICAgICAgICB9LFxuICAgICAgICB9KVxuXG4gICAgICAgIHRoaXMuX3NreWJveFNhbXBsZXIgPSB0aGlzLl9kZXZpY2UuY3JlYXRlU2FtcGxlcih7XG4gICAgICAgICAgICBtYWdGaWx0ZXI6ICdsaW5lYXInLFxuICAgICAgICAgICAgbWluRmlsdGVyOiAnbGluZWFyJyxcbiAgICAgICAgfSlcblxuICAgICAgICB0aGlzLl9za3lCb3hVbmlmb3JtQnVmZmVyID0gdGhpcy5fZGV2aWNlLmNyZWF0ZUJ1ZmZlcih7XG4gICAgICAgICAgICBzaXplOiBza3lCb3hVbmlmb3JtQnVmZmVyU2l6ZSxcbiAgICAgICAgICAgIHVzYWdlOiBHUFVCdWZmZXJVc2FnZS5VTklGT1JNIHwgR1BVQnVmZmVyVXNhZ2UuQ09QWV9EU1QsXG4gICAgICAgIH0pXG5cbiAgICAgICAgdGhpcy5fc2t5Qm94UmVuZGVyUGFzc0Rlc2NyaXB0b3IgPSB7XG4gICAgICAgICAgICBsYWJlbDogJ3NreWJveCByZW5kZXIgcGFzcycsXG4gICAgICAgICAgICBjb2xvckF0dGFjaG1lbnRzOiBbXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICB2aWV3OiBudWxsIGFzIHVua25vd24gYXMgR1BVVGV4dHVyZVZpZXcsIC8vIEFzc2lnbmVkIGxhdGVyXG4gICAgICAgICAgICAgICAgICAgIGxvYWRPcDogJ2NsZWFyJyxcbiAgICAgICAgICAgICAgICAgICAgc3RvcmVPcDogJ3N0b3JlJyxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIGRlcHRoU3RlbmNpbEF0dGFjaG1lbnQ6IHtcbiAgICAgICAgICAgICAgICB2aWV3OiB0aGlzLl9kZXB0aFRleHR1cmUuY3JlYXRlVmlldygpLFxuICAgICAgICAgICAgICAgIGRlcHRoTG9hZE9wOiAnY2xlYXInIGFzIEdQVUxvYWRPcCxcbiAgICAgICAgICAgICAgICBkZXB0aENsZWFyVmFsdWU6IDEuMCxcbiAgICAgICAgICAgICAgICBkZXB0aFN0b3JlT3A6ICdzdG9yZScgYXMgR1BVU3RvcmVPcCxcbiAgICAgICAgICAgICAgICBzdGVuY2lsTG9hZE9wOiAnY2xlYXInIGFzIEdQVUxvYWRPcCxcbiAgICAgICAgICAgICAgICBzdGVuY2lsQ2xlYXJWYWx1ZTogMCxcbiAgICAgICAgICAgICAgICBzdGVuY2lsU3RvcmVPcDogJ3N0b3JlJyBhcyBHUFVTdG9yZU9wLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfVxuXG4gICAgICAgIGF3YWl0IHRoaXMuc2V0RGVmYXVsdFNreUJveFRleHR1cmUoKVxuICAgIH1cblxuICAgIHB1YmxpYyBhc3luYyBzZXREZWZhdWx0U2t5Qm94VGV4dHVyZSgpIHtcbiAgICAgICAgY29uc3QgaW1hZ2VzID0gbmV3IEFycmF5KDYpLmZpbGwoXG4gICAgICAgICAgICBuZXcgSW1hZ2VEYXRhKG5ldyBVaW50OENsYW1wZWRBcnJheShbNzUsIDc2LCA3NiwgMjU1XSksIDEsIDEpXG4gICAgICAgIClcbiAgICAgICAgY29uc3QgcHJvbWlzZXMgPSBpbWFnZXMubWFwKGFzeW5jIChpbWFnZSkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZUltYWdlQml0bWFwKGltYWdlKVxuICAgICAgICB9KVxuICAgICAgICBjb25zdCBpbWFnZUJpdG1hcHMgPSAoYXdhaXQgUHJvbWlzZS5hbGwocHJvbWlzZXMpKSBhcyBUU2t5Ym94Qml0bWFwc1xuXG4gICAgICAgIHRoaXMuc2V0U2t5Qm94VGV4dHVyZShpbWFnZUJpdG1hcHMpXG4gICAgfVxuXG4gICAgcHVibGljIHNldFNreUJveFRleHR1cmUoYml0bWFwczogVFNreWJveEJpdG1hcHMpIHtcbiAgICAgICAgdGhpcy5fc2t5Ym94VGV4dHVyZSA9IHRoaXMuX2RldmljZS5jcmVhdGVUZXh0dXJlKHtcbiAgICAgICAgICAgIGRpbWVuc2lvbjogJzJkJyxcbiAgICAgICAgICAgIHNpemU6IFtiaXRtYXBzWzBdLndpZHRoLCBiaXRtYXBzWzBdLmhlaWdodCwgNl0sXG4gICAgICAgICAgICBmb3JtYXQ6ICdyZ2JhOHVub3JtJyxcbiAgICAgICAgICAgIHVzYWdlOlxuICAgICAgICAgICAgICAgIEdQVVRleHR1cmVVc2FnZS5URVhUVVJFX0JJTkRJTkcgfFxuICAgICAgICAgICAgICAgIEdQVVRleHR1cmVVc2FnZS5DT1BZX0RTVCB8XG4gICAgICAgICAgICAgICAgR1BVVGV4dHVyZVVzYWdlLlJFTkRFUl9BVFRBQ0hNRU5ULFxuICAgICAgICB9KVxuXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYml0bWFwcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgaW1hZ2VCaXRtYXAgPSBiaXRtYXBzW2ldXG4gICAgICAgICAgICB0aGlzLl9kZXZpY2UucXVldWUuY29weUV4dGVybmFsSW1hZ2VUb1RleHR1cmUoXG4gICAgICAgICAgICAgICAgeyBzb3VyY2U6IGltYWdlQml0bWFwIH0sXG4gICAgICAgICAgICAgICAgeyB0ZXh0dXJlOiB0aGlzLl9za3lib3hUZXh0dXJlLCBvcmlnaW46IFswLCAwLCBpXSB9LFxuICAgICAgICAgICAgICAgIFtpbWFnZUJpdG1hcC53aWR0aCwgaW1hZ2VCaXRtYXAuaGVpZ2h0XVxuICAgICAgICAgICAgKVxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fc2t5Qm94VW5pZm9ybUJpbmRHcm91cCA9IHRoaXMuX2RldmljZS5jcmVhdGVCaW5kR3JvdXAoe1xuICAgICAgICAgICAgbGFiZWw6ICdza3lib3ggdW5pZm9ybSBiaW5kZ3JvdXAnLFxuICAgICAgICAgICAgbGF5b3V0OiB0aGlzLl9za3lCb3hQaXBlbGluZS5nZXRCaW5kR3JvdXBMYXlvdXQoMCksXG4gICAgICAgICAgICBlbnRyaWVzOiBbXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBiaW5kaW5nOiAwLFxuICAgICAgICAgICAgICAgICAgICByZXNvdXJjZToge1xuICAgICAgICAgICAgICAgICAgICAgICAgYnVmZmVyOiB0aGlzLl9za3lCb3hVbmlmb3JtQnVmZmVyLFxuICAgICAgICAgICAgICAgICAgICAgICAgb2Zmc2V0OiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgc2l6ZTogc2t5Qm94VW5pZm9ybUJ1ZmZlclNpemUsXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGJpbmRpbmc6IDEsXG4gICAgICAgICAgICAgICAgICAgIHJlc291cmNlOiB0aGlzLl9za3lib3hTYW1wbGVyLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBiaW5kaW5nOiAyLFxuICAgICAgICAgICAgICAgICAgICByZXNvdXJjZTogdGhpcy5fc2t5Ym94VGV4dHVyZS5jcmVhdGVWaWV3KHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpbWVuc2lvbjogJ2N1YmUnLFxuICAgICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgXSxcbiAgICAgICAgfSlcbiAgICB9XG5cbiAgICBnZXQgZGV2aWNlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGV2aWNlXG4gICAgfVxuXG4gICAgZ2V0IGFkYXB0ZXIoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hZGFwdGVyXG4gICAgfVxuXG4gICAgZ2V0IGNvbnRleHQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jb250ZXh0XG4gICAgfVxuXG4gICAgZ2V0IHN3YXBDaGFpbkZvcm1hdCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3N3YXBDaGFpbkZvcm1hdFxuICAgIH1cblxuICAgIGdldCBkZXB0aFRleHR1cmVGb3JtYXQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kZXB0aFRleHR1cmVGb3JtYXRcbiAgICB9XG5cbiAgICBwcml2YXRlIF9pbml0aWFsaXplVmlld1BhcmFtcygpIHtcbiAgICAgICAgdGhpcy5fdmlld1BhcmFtc0J1ZmZlciA9IHRoaXMuZGV2aWNlLmNyZWF0ZUJ1ZmZlcih7XG4gICAgICAgICAgICBzaXplOiB0aGlzLl92aWV3UGFyYW1zQnVmZmVyU2l6ZSxcbiAgICAgICAgICAgIHVzYWdlOiBHUFVCdWZmZXJVc2FnZS5VTklGT1JNIHwgR1BVQnVmZmVyVXNhZ2UuQ09QWV9EU1QsXG4gICAgICAgIH0pXG5cbiAgICAgICAgdGhpcy5fZGVidWdQYXJhbXNCdWZmZXIgPSB0aGlzLmRldmljZS5jcmVhdGVCdWZmZXIoe1xuICAgICAgICAgICAgc2l6ZTogNCArIDQsXG4gICAgICAgICAgICB1c2FnZTogR1BVQnVmZmVyVXNhZ2UuVU5JRk9STSB8IEdQVUJ1ZmZlclVzYWdlLkNPUFlfRFNULFxuICAgICAgICB9KVxuXG4gICAgICAgIHRoaXMuX3ZpZXdQYXJhbXNCaW5kR3JvdXAgPSB0aGlzLmRldmljZS5jcmVhdGVCaW5kR3JvdXAoe1xuICAgICAgICAgICAgbGF5b3V0OiB0aGlzLl91bmlmb3Jtc0JHTGF5b3V0LFxuICAgICAgICAgICAgZW50cmllczogW1xuICAgICAgICAgICAgICAgIHsgYmluZGluZzogMCwgcmVzb3VyY2U6IHsgYnVmZmVyOiB0aGlzLl92aWV3UGFyYW1zQnVmZmVyIH0gfSxcbiAgICAgICAgICAgICAgICB7IGJpbmRpbmc6IDEsIHJlc291cmNlOiB7IGJ1ZmZlcjogdGhpcy5fZGVidWdQYXJhbXNCdWZmZXIgfSB9LFxuICAgICAgICAgICAgXSxcbiAgICAgICAgfSlcbiAgICB9XG5cbiAgICBwcml2YXRlIF9pbml0aWFsaXplQmluZEdyb3VwTGF5b3V0cygpIHtcbiAgICAgICAgdGhpcy5fdW5pZm9ybXNCR0xheW91dCA9IHRoaXMuZGV2aWNlLmNyZWF0ZUJpbmRHcm91cExheW91dCh7XG4gICAgICAgICAgICBlbnRyaWVzOiBbXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBiaW5kaW5nOiAwLFxuICAgICAgICAgICAgICAgICAgICB2aXNpYmlsaXR5OiBHUFVTaGFkZXJTdGFnZS5WRVJURVggfCBHUFVTaGFkZXJTdGFnZS5GUkFHTUVOVCxcbiAgICAgICAgICAgICAgICAgICAgYnVmZmVyOiB7IHR5cGU6ICd1bmlmb3JtJyB9LFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBiaW5kaW5nOiAxLFxuICAgICAgICAgICAgICAgICAgICB2aXNpYmlsaXR5OiBHUFVTaGFkZXJTdGFnZS5WRVJURVggfCBHUFVTaGFkZXJTdGFnZS5GUkFHTUVOVCxcbiAgICAgICAgICAgICAgICAgICAgYnVmZmVyOiB7IHR5cGU6ICd1bmlmb3JtJyB9LFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBdLFxuICAgICAgICB9KVxuXG4gICAgICAgIHRoaXMuX25vZGVQYXJhbXNCR0xheW91dCA9IHRoaXMuZGV2aWNlLmNyZWF0ZUJpbmRHcm91cExheW91dCh7XG4gICAgICAgICAgICBlbnRyaWVzOiBbXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBiaW5kaW5nOiAwLFxuICAgICAgICAgICAgICAgICAgICB2aXNpYmlsaXR5OiBHUFVTaGFkZXJTdGFnZS5WRVJURVggfCBHUFVTaGFkZXJTdGFnZS5GUkFHTUVOVCxcbiAgICAgICAgICAgICAgICAgICAgYnVmZmVyOiB7IHR5cGU6ICd1bmlmb3JtJyB9LFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBdLFxuICAgICAgICB9KVxuICAgIH1cblxuICAgIHByaXZhdGUgYXN5bmMgX2luaXRpYWxpemVDb250ZXh0KGNhbnZhczogSFRNTENhbnZhc0VsZW1lbnQpIHtcbiAgICAgICAgY29uc3QgYWRhcHRlciA9IGF3YWl0IG5hdmlnYXRvci5ncHUucmVxdWVzdEFkYXB0ZXIoKVxuXG4gICAgICAgIGlmICghYWRhcHRlcikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdHUFUgQWRhcHRlciBVbmF2YWlsYWJsZScpXG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBkZXZpY2UgPSBhd2FpdCBhZGFwdGVyLnJlcXVlc3REZXZpY2UoKVxuXG4gICAgICAgIHRoaXMuX2RldmljZSA9IGRldmljZVxuICAgICAgICB0aGlzLl9hZGFwdGVyID0gYWRhcHRlclxuXG4gICAgICAgIGNhbnZhcy53aWR0aCA9IGRvY3VtZW50LmJvZHkuY2xpZW50V2lkdGggKiB3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpb1xuICAgICAgICBjYW52YXMuaGVpZ2h0ID0gZG9jdW1lbnQuYm9keS5jbGllbnRIZWlnaHQgKiB3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpb1xuXG4gICAgICAgIHRoaXMuX2NvbnRleHQgPSBjYW52YXMuZ2V0Q29udGV4dCgnd2ViZ3B1JykgYXMgR1BVQ2FudmFzQ29udGV4dFxuXG4gICAgICAgIGlmICghdGhpcy5fY29udGV4dCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdGYWlsZWQgdG8gYWNxdWlyZSBHcHVDYW52YXNDb250ZXh0JylcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIHB1YmxpYyBidWlsZFJlbmRlclBpcGVsaW5lKCkge31cblxuICAgIHByaXZhdGUgX2NyZWF0ZU1lc2hCdWZmZXIoYWNjZXNzb3I6IEdMVEZBY2Nlc3Nvciwgc2NlbmU6IElTY2VuZSkge1xuICAgICAgICBjb25zdCB2aWV3ID0gbmV3IFVpbnQ4QXJyYXkoXG4gICAgICAgICAgICBzY2VuZS5idWZmZXJTdG9yYWdlLmJ1ZmZlcnMuZ2V0KGFjY2Vzc29yLmJ1ZmZlcklkKSBhcyBBcnJheUJ1ZmZlcixcbiAgICAgICAgICAgIGFjY2Vzc29yLmJ5dGVPZmZzZXQsXG4gICAgICAgICAgICBhY2Nlc3Nvci5ieXRlTGVuZ3RoXG4gICAgICAgIClcblxuICAgICAgICBjb25zdCBidWZmZXIgPSB0aGlzLmRldmljZS5jcmVhdGVCdWZmZXIoe1xuICAgICAgICAgICAgc2l6ZTogYWxpZ25UbyhhY2Nlc3Nvci5ieXRlTGVuZ3RoLCA0KSxcbiAgICAgICAgICAgIHVzYWdlOiBhY2Nlc3Nvci51c2FnZSxcbiAgICAgICAgICAgIG1hcHBlZEF0Q3JlYXRpb246IHRydWUsXG4gICAgICAgIH0pXG5cbiAgICAgICAgbmV3IFVpbnQ4QXJyYXkoYnVmZmVyLmdldE1hcHBlZFJhbmdlKCkpLnNldCh2aWV3KVxuICAgICAgICBidWZmZXIudW5tYXAoKVxuXG4gICAgICAgIHJldHVybiBidWZmZXJcbiAgICB9XG5cbiAgICBwdWJsaWMgYnVpbGRSZW5kZXJQaXBlbGluZShtZXNoOiBJTWVzaCwgc2NlbmU6IElTY2VuZSkge1xuICAgICAgICBjb25zdCBtZXNoRGF0YUVudHJ5ID0ge30gYXMgSU1lc2hSZW5kZXJEYXRhXG5cbiAgICAgICAgLy9GSVhNRTogUkVGQUNUT1IgVEhJUyBTSElUXG4gICAgICAgIG1lc2hEYXRhRW50cnkubWF0ZXJpYWxQYXJhbXNCdWZmZXIgPSB0aGlzLmRldmljZS5jcmVhdGVCdWZmZXIoe1xuICAgICAgICAgICAgc2l6ZTogOCAqIDQsXG4gICAgICAgICAgICB1c2FnZTogR1BVQnVmZmVyVXNhZ2UuQ09QWV9EU1QgfCBHUFVCdWZmZXJVc2FnZS5VTklGT1JNLFxuICAgICAgICAgICAgbWFwcGVkQXRDcmVhdGlvbjogdHJ1ZSxcbiAgICAgICAgfSlcblxuICAgICAgICBjb25zdCBwYXJhbXMgPSBuZXcgRmxvYXQzMkFycmF5KFxuICAgICAgICAgICAgbWVzaERhdGFFbnRyeS5tYXRlcmlhbFBhcmFtc0J1ZmZlci5nZXRNYXBwZWRSYW5nZSgpXG4gICAgICAgIClcbiAgICAgICAgcGFyYW1zLnNldChtZXNoLm1hdGVyaWFsLmJhc2VDb2xvckZhY3RvciwgMClcbiAgICAgICAgcGFyYW1zLnNldChcbiAgICAgICAgICAgIFttZXNoLm1hdGVyaWFsLm1ldGFsbGljRmFjdG9yLCBtZXNoLm1hdGVyaWFsLnJvdWdobmVzc0ZhY3Rvcl0sXG4gICAgICAgICAgICA0XG4gICAgICAgIClcblxuICAgICAgICBtZXNoRGF0YUVudHJ5Lm1hdGVyaWFsUGFyYW1zQnVmZmVyLnVubWFwKClcblxuICAgICAgICBjb25zdCBzYW1wbGVUeXBlID0gJ2Zsb2F0J1xuXG4gICAgICAgIGNvbnN0IHZlcnRleFN0YXRlOiBHUFVWZXJ0ZXhTdGF0ZSA9IHtcbiAgICAgICAgICAgIG1vZHVsZTogdGhpcy5fc2hhZGVyTW9kdWxlLFxuICAgICAgICAgICAgZW50cnlQb2ludDogJ3ZlcnRleF9tYWluJyxcbiAgICAgICAgICAgIGJ1ZmZlcnM6IFtcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIC8vVE9ETzogZmlndXJlIG91dCBhIHdheSB0byBtYWtlIGJ5dGVzdHJpZGVzIGNvbnN0YW50XG4gICAgICAgICAgICAgICAgICAgIGFycmF5U3RyaWRlOiBtZXNoLnBvc2l0aW9ucy5ieXRlU3RyaWRlLFxuICAgICAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9ybWF0OiBtZXNoLnBvc2l0aW9ucy5lbGVtZW50VHlwZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvZmZzZXQ6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2hhZGVyTG9jYXRpb246IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBhcnJheVN0cmlkZTogbWVzaC50ZXh0dXJlQ29vcmRpbmF0ZXMuYnl0ZVN0cmlkZSxcbiAgICAgICAgICAgICAgICAgICAgYXR0cmlidXRlczogW1xuICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvcm1hdDogbWVzaC50ZXh0dXJlQ29vcmRpbmF0ZXMuZWxlbWVudFR5cGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb2Zmc2V0OiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNoYWRlckxvY2F0aW9uOiAxLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgYXJyYXlTdHJpZGU6IG1lc2gubm9ybWFscy5ieXRlU3RyaWRlLFxuICAgICAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9ybWF0OiBtZXNoLm5vcm1hbHMuZWxlbWVudFR5cGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb2Zmc2V0OiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNoYWRlckxvY2F0aW9uOiAyLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgYXJyYXlTdHJpZGU6IG1lc2gudGFuZ2VudHMuYnl0ZVN0cmlkZSxcbiAgICAgICAgICAgICAgICAgICAgYXR0cmlidXRlczogW1xuICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvcm1hdDogbWVzaC50YW5nZW50cy5lbGVtZW50VHlwZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvZmZzZXQ6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2hhZGVyTG9jYXRpb246IDMsXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBdLFxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgZnJhZ21lbnRTdGF0ZTogR1BVRnJhZ21lbnRTdGF0ZSA9IHtcbiAgICAgICAgICAgIG1vZHVsZTogdGhpcy5fc2hhZGVyTW9kdWxlLFxuICAgICAgICAgICAgZW50cnlQb2ludDogJ2ZyYWdtZW50X21haW4nLFxuICAgICAgICAgICAgdGFyZ2V0czogW3sgZm9ybWF0OiB0aGlzLl9zd2FwQ2hhaW5Gb3JtYXQgfV0sXG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBwcmltaXRpdmU6IEdQVVByaW1pdGl2ZVN0YXRlID0ge1xuICAgICAgICAgICAgdG9wb2xvZ3k6ICd0cmlhbmdsZS1saXN0JyxcbiAgICAgICAgICAgIHN0cmlwSW5kZXhGb3JtYXQ6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIGN1bGxNb2RlOiAnYmFjaycsXG4gICAgICAgIH1cblxuICAgICAgICAvL1JFRkFDVE9SOiB0aGlzIGlzIGNvbnN0YW50IG5vd1xuICAgICAgICBjb25zdCBtYXRlcmlhbEJpbmRHcm91cExheW91dCA9IHRoaXMuZGV2aWNlLmNyZWF0ZUJpbmRHcm91cExheW91dCh7XG4gICAgICAgICAgICBsYWJlbDogJ21hdGVyaWFsQmluZEdyb3VwTGF5b3V0JyxcbiAgICAgICAgICAgIGVudHJpZXM6IFtcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGJpbmRpbmc6IDAsXG4gICAgICAgICAgICAgICAgICAgIHZpc2liaWxpdHk6IEdQVVNoYWRlclN0YWdlLkZSQUdNRU5ULFxuICAgICAgICAgICAgICAgICAgICBidWZmZXI6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICd1bmlmb3JtJyxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgYmluZGluZzogMSxcbiAgICAgICAgICAgICAgICAgICAgdmlzaWJpbGl0eTogR1BVU2hhZGVyU3RhZ2UuRlJBR01FTlQsXG4gICAgICAgICAgICAgICAgICAgIHRleHR1cmU6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNhbXBsZVR5cGUsXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGJpbmRpbmc6IDIsXG4gICAgICAgICAgICAgICAgICAgIHZpc2liaWxpdHk6IEdQVVNoYWRlclN0YWdlLkZSQUdNRU5ULFxuICAgICAgICAgICAgICAgICAgICB0ZXh0dXJlOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzYW1wbGVUeXBlLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBiaW5kaW5nOiAzLFxuICAgICAgICAgICAgICAgICAgICB2aXNpYmlsaXR5OiBHUFVTaGFkZXJTdGFnZS5GUkFHTUVOVCxcbiAgICAgICAgICAgICAgICAgICAgdGV4dHVyZToge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2FtcGxlVHlwZSxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgYmluZGluZzogNCxcbiAgICAgICAgICAgICAgICAgICAgdmlzaWJpbGl0eTogR1BVU2hhZGVyU3RhZ2UuRlJBR01FTlQsXG4gICAgICAgICAgICAgICAgICAgIHRleHR1cmU6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNhbXBsZVR5cGUsXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGJpbmRpbmc6IDUsXG4gICAgICAgICAgICAgICAgICAgIHZpc2liaWxpdHk6IEdQVVNoYWRlclN0YWdlLkZSQUdNRU5ULFxuICAgICAgICAgICAgICAgICAgICB0ZXh0dXJlOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzYW1wbGVUeXBlOiAnZGVwdGgnLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBiaW5kaW5nOiA2LFxuICAgICAgICAgICAgICAgICAgICB2aXNpYmlsaXR5OiBHUFVTaGFkZXJTdGFnZS5GUkFHTUVOVCxcbiAgICAgICAgICAgICAgICAgICAgdGV4dHVyZToge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2FtcGxlVHlwZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHZpZXdEaW1lbnNpb246ICdjdWJlJyxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgYmluZGluZzogNyxcbiAgICAgICAgICAgICAgICAgICAgdmlzaWJpbGl0eTogR1BVU2hhZGVyU3RhZ2UuRlJBR01FTlQsXG4gICAgICAgICAgICAgICAgICAgIHRleHR1cmU6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNhbXBsZVR5cGUsXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF0sXG4gICAgICAgIH0pXG5cbiAgICAgICAgY29uc3Qgc2FtcGxlckJpbmRHcm91cExheW91dCA9IHRoaXMuZGV2aWNlLmNyZWF0ZUJpbmRHcm91cExheW91dCh7XG4gICAgICAgICAgICBsYWJlbDogJ3NhbXBsZXJCaW5kR3JvdXBMYXlvdXQnLFxuICAgICAgICAgICAgZW50cmllczogW1xuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgYmluZGluZzogMSxcbiAgICAgICAgICAgICAgICAgICAgdmlzaWJpbGl0eTogR1BVU2hhZGVyU3RhZ2UuRlJBR01FTlQsXG4gICAgICAgICAgICAgICAgICAgIHNhbXBsZXI6IHt9LFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBiaW5kaW5nOiAyLFxuICAgICAgICAgICAgICAgICAgICB2aXNpYmlsaXR5OiBHUFVTaGFkZXJTdGFnZS5GUkFHTUVOVCxcbiAgICAgICAgICAgICAgICAgICAgc2FtcGxlcjoge30sXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGJpbmRpbmc6IDMsXG4gICAgICAgICAgICAgICAgICAgIHZpc2liaWxpdHk6IEdQVVNoYWRlclN0YWdlLkZSQUdNRU5ULFxuICAgICAgICAgICAgICAgICAgICBzYW1wbGVyOiB7fSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgYmluZGluZzogNCxcbiAgICAgICAgICAgICAgICAgICAgdmlzaWJpbGl0eTogR1BVU2hhZGVyU3RhZ2UuRlJBR01FTlQsXG4gICAgICAgICAgICAgICAgICAgIHNhbXBsZXI6IHt9LFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBiaW5kaW5nOiA1LFxuICAgICAgICAgICAgICAgICAgICB2aXNpYmlsaXR5OiBHUFVTaGFkZXJTdGFnZS5GUkFHTUVOVCxcbiAgICAgICAgICAgICAgICAgICAgc2FtcGxlcjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ2NvbXBhcmlzb24nLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBiaW5kaW5nOiA2LFxuICAgICAgICAgICAgICAgICAgICB2aXNpYmlsaXR5OiBHUFVTaGFkZXJTdGFnZS5GUkFHTUVOVCxcbiAgICAgICAgICAgICAgICAgICAgc2FtcGxlcjoge30sXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGJpbmRpbmc6IDcsXG4gICAgICAgICAgICAgICAgICAgIHZpc2liaWxpdHk6IEdQVVNoYWRlclN0YWdlLkZSQUdNRU5ULFxuICAgICAgICAgICAgICAgICAgICBzYW1wbGVyOiB7fSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgXSxcbiAgICAgICAgfSlcblxuICAgICAgICBtZXNoRGF0YUVudHJ5LnNhbXBsZXJCaW5kR3JvdXAgPSB0aGlzLmRldmljZS5jcmVhdGVCaW5kR3JvdXAoe1xuICAgICAgICAgICAgbGFiZWw6ICdzYW1wbGVyIGJpbmRncm91cCcsXG4gICAgICAgICAgICBsYXlvdXQ6IHNhbXBsZXJCaW5kR3JvdXBMYXlvdXQsXG4gICAgICAgICAgICBlbnRyaWVzOiBbXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBiaW5kaW5nOiAxLFxuICAgICAgICAgICAgICAgICAgICByZXNvdXJjZTogbWVzaC5tYXRlcmlhbC5iYXNlQ29sb3JUZXh0dXJlLnNhbXBsZXIsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGJpbmRpbmc6IDIsXG4gICAgICAgICAgICAgICAgICAgIHJlc291cmNlOiBtZXNoLm1hdGVyaWFsLm1ldGFsbGljUm91Z2huZXNzVGV4dHVyZS5zYW1wbGVyLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBiaW5kaW5nOiAzLFxuICAgICAgICAgICAgICAgICAgICByZXNvdXJjZTogbWVzaC5tYXRlcmlhbC5ub3JtYWxUZXh0dXJlLnNhbXBsZXIsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGJpbmRpbmc6IDQsXG4gICAgICAgICAgICAgICAgICAgIHJlc291cmNlOiBtZXNoLm1hdGVyaWFsLm9jY2x1c2lvblRleHR1cmUuc2FtcGxlcixcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgYmluZGluZzogNSxcbiAgICAgICAgICAgICAgICAgICAgcmVzb3VyY2U6IHRoaXMuX3NoYWRvd0RlcHRoU2FtcGxlcixcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgYmluZGluZzogNixcbiAgICAgICAgICAgICAgICAgICAgcmVzb3VyY2U6IHRoaXMuX3NreWJveFNhbXBsZXIsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGJpbmRpbmc6IDcsXG4gICAgICAgICAgICAgICAgICAgIHJlc291cmNlOiBtZXNoLm1hdGVyaWFsPy5lbWlzc2l2ZVRleHR1cmUuc2FtcGxlcixcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgXSxcbiAgICAgICAgfSlcblxuICAgICAgICBtZXNoRGF0YUVudHJ5Lm1hdGVyaWFsQmluZEdyb3VwID0gdGhpcy5kZXZpY2UuY3JlYXRlQmluZEdyb3VwKHtcbiAgICAgICAgICAgIGxhYmVsOiAnbWF0ZXJpYWwgYmluZGdyb3VwJyxcbiAgICAgICAgICAgIGxheW91dDogbWF0ZXJpYWxCaW5kR3JvdXBMYXlvdXQsXG4gICAgICAgICAgICBlbnRyaWVzOiBbXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBiaW5kaW5nOiAwLFxuICAgICAgICAgICAgICAgICAgICByZXNvdXJjZToge1xuICAgICAgICAgICAgICAgICAgICAgICAgYnVmZmVyOiBtZXNoRGF0YUVudHJ5Lm1hdGVyaWFsUGFyYW1zQnVmZmVyLFxuICAgICAgICAgICAgICAgICAgICAgICAgc2l6ZTogOCAqIDQsXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGJpbmRpbmc6IDEsXG4gICAgICAgICAgICAgICAgICAgIHJlc291cmNlOiBtZXNoLm1hdGVyaWFsLmJhc2VDb2xvclRleHR1cmUudmlldyxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgYmluZGluZzogMixcbiAgICAgICAgICAgICAgICAgICAgcmVzb3VyY2U6IG1lc2gubWF0ZXJpYWw/Lm1ldGFsbGljUm91Z2huZXNzVGV4dHVyZS52aWV3LFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBiaW5kaW5nOiAzLFxuICAgICAgICAgICAgICAgICAgICByZXNvdXJjZTogbWVzaC5tYXRlcmlhbD8ubm9ybWFsVGV4dHVyZS52aWV3LFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBiaW5kaW5nOiA0LFxuICAgICAgICAgICAgICAgICAgICByZXNvdXJjZTogbWVzaC5tYXRlcmlhbD8ub2NjbHVzaW9uVGV4dHVyZS52aWV3LFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBiaW5kaW5nOiA1LFxuICAgICAgICAgICAgICAgICAgICByZXNvdXJjZTogdGhpcy5fc2hhZG93RGVwdGhUZXh0dXJlVmlldyxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgYmluZGluZzogNixcbiAgICAgICAgICAgICAgICAgICAgcmVzb3VyY2U6IHRoaXMuX3NreWJveFRleHR1cmUuY3JlYXRlVmlldyh7XG4gICAgICAgICAgICAgICAgICAgICAgICBkaW1lbnNpb246ICdjdWJlJyxcbiAgICAgICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGJpbmRpbmc6IDcsXG4gICAgICAgICAgICAgICAgICAgIHJlc291cmNlOiBtZXNoLm1hdGVyaWFsPy5lbWlzc2l2ZVRleHR1cmUudmlldyxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgXSxcbiAgICAgICAgfSlcblxuICAgICAgICBjb25zdCBsYXlvdXQgPSB0aGlzLmRldmljZS5jcmVhdGVQaXBlbGluZUxheW91dCh7XG4gICAgICAgICAgICBiaW5kR3JvdXBMYXlvdXRzOiBbXG4gICAgICAgICAgICAgICAgdGhpcy5fdW5pZm9ybXNCR0xheW91dCxcbiAgICAgICAgICAgICAgICB0aGlzLl9ub2RlUGFyYW1zQkdMYXlvdXQsXG4gICAgICAgICAgICAgICAgbWF0ZXJpYWxCaW5kR3JvdXBMYXlvdXQsXG4gICAgICAgICAgICAgICAgc2FtcGxlckJpbmRHcm91cExheW91dCxcbiAgICAgICAgICAgIF0sXG4gICAgICAgIH0pXG5cbiAgICAgICAgLy9GSVhNRTogdGhpcyBzaG91bGQgbm90IGJlIGNyZWF0ZWQgcGVyIG1lc2ggd2hlbiBhbGwgc3R1ZmYgaXMgc3R1YmJlZFxuICAgICAgICBtZXNoRGF0YUVudHJ5LnNoYWRvd1JlbmRlclBpcGVsaW5lID0gdGhpcy5kZXZpY2UuY3JlYXRlUmVuZGVyUGlwZWxpbmUoe1xuICAgICAgICAgICAgbGFiZWw6ICdzaGFkb3cgcmVuZGVyIHBpcGVsaW5lJyxcbiAgICAgICAgICAgIGxheW91dDogdGhpcy5kZXZpY2UuY3JlYXRlUGlwZWxpbmVMYXlvdXQoe1xuICAgICAgICAgICAgICAgIGxhYmVsOiAnc2hhZG93IHJlbmRlciBwaXBlbGluZSBsYXlvdXQnLFxuICAgICAgICAgICAgICAgIGJpbmRHcm91cExheW91dHM6IFtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fdW5pZm9ybXNCR0xheW91dCxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fbm9kZVBhcmFtc0JHTGF5b3V0LFxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIHZlcnRleDoge1xuICAgICAgICAgICAgICAgIG1vZHVsZTogdGhpcy5kZXZpY2UuY3JlYXRlU2hhZGVyTW9kdWxlKHtcbiAgICAgICAgICAgICAgICAgICAgbGFiZWw6ICdzaGFkb3cgc2hhZGVyIG1vZHVsZScsXG4gICAgICAgICAgICAgICAgICAgIGNvZGU6IHNoYWRvd1NoYWRlckNvZGUsXG4gICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgYnVmZmVyczogW1xuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhcnJheVN0cmlkZTogbWVzaC5wb3NpdGlvbnMuYnl0ZVN0cmlkZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXM6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvcm1hdDogbWVzaC5wb3NpdGlvbnMuZWxlbWVudFR5cGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9mZnNldDogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2hhZGVyTG9jYXRpb246IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBkZXB0aFN0ZW5jaWw6IHtcbiAgICAgICAgICAgICAgICBkZXB0aFdyaXRlRW5hYmxlZDogdHJ1ZSxcbiAgICAgICAgICAgICAgICBkZXB0aENvbXBhcmU6ICdsZXNzJyxcbiAgICAgICAgICAgICAgICBmb3JtYXQ6ICdkZXB0aDMyZmxvYXQnLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHByaW1pdGl2ZSxcbiAgICAgICAgfSlcblxuICAgICAgICBtZXNoRGF0YUVudHJ5LnJlbmRlclBpcGVsaW5lID0gdGhpcy5kZXZpY2UuY3JlYXRlUmVuZGVyUGlwZWxpbmUoe1xuICAgICAgICAgICAgbGFiZWw6ICdtYWluIHJlbmRlciBwaXBlbGluZScsXG4gICAgICAgICAgICBsYXlvdXQ6IGxheW91dCxcbiAgICAgICAgICAgIHZlcnRleDogdmVydGV4U3RhdGUsXG4gICAgICAgICAgICBmcmFnbWVudDogZnJhZ21lbnRTdGF0ZSxcbiAgICAgICAgICAgIHByaW1pdGl2ZTogcHJpbWl0aXZlLFxuICAgICAgICAgICAgZGVwdGhTdGVuY2lsOiB7XG4gICAgICAgICAgICAgICAgZm9ybWF0OiB0aGlzLl9kZXB0aFRleHR1cmVGb3JtYXQsXG4gICAgICAgICAgICAgICAgZGVwdGhXcml0ZUVuYWJsZWQ6IHRydWUsXG4gICAgICAgICAgICAgICAgZGVwdGhDb21wYXJlOiAnbGVzcycsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbXVsdGlzYW1wbGU6IHtcbiAgICAgICAgICAgICAgICBjb3VudDogdGhpcy5fbXNhYVNhbXBsZUNvdW50LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSlcblxuICAgICAgICBtZXNoRGF0YUVudHJ5LnBvc2l0aW9uc0J1ZmZlciA9IHRoaXMuX2NyZWF0ZU1lc2hCdWZmZXIoXG4gICAgICAgICAgICBtZXNoLnBvc2l0aW9ucyxcbiAgICAgICAgICAgIHNjZW5lXG4gICAgICAgIClcblxuICAgICAgICBtZXNoRGF0YUVudHJ5LnRleHR1cmVDb29yZGluYXRlc0J1ZmZlciA9IHRoaXMuX2NyZWF0ZU1lc2hCdWZmZXIoXG4gICAgICAgICAgICBtZXNoLnRleHR1cmVDb29yZGluYXRlcyxcbiAgICAgICAgICAgIHNjZW5lXG4gICAgICAgIClcblxuICAgICAgICBtZXNoRGF0YUVudHJ5Lm5vcm1hbHNCdWZmZXIgPSB0aGlzLl9jcmVhdGVNZXNoQnVmZmVyKFxuICAgICAgICAgICAgbWVzaC5ub3JtYWxzLFxuICAgICAgICAgICAgc2NlbmVcbiAgICAgICAgKVxuXG4gICAgICAgIG1lc2hEYXRhRW50cnkudGFuZ2VudHNCdWZmZXIgPSB0aGlzLl9jcmVhdGVNZXNoQnVmZmVyKFxuICAgICAgICAgICAgbWVzaC50YW5nZW50cyxcbiAgICAgICAgICAgIHNjZW5lXG4gICAgICAgIClcblxuICAgICAgICBtZXNoRGF0YUVudHJ5LmluZGljZXNCdWZmZXIgPSB0aGlzLl9jcmVhdGVNZXNoQnVmZmVyKFxuICAgICAgICAgICAgbWVzaC5pbmRpY2VzLFxuICAgICAgICAgICAgc2NlbmVcbiAgICAgICAgKVxuXG4gICAgICAgIHNjZW5lLm1lc2hSZW5kZXJEYXRhU3RvcmFnZS5kYXRhLnNldChtZXNoLmlkLCBtZXNoRGF0YUVudHJ5KVxuICAgICAgICBtZXNoLmlzUGlwZWxpbmVCdWlsdCA9IHRydWVcbiAgICB9XG5cbiAgICBwcml2YXRlIHJlbmRlck1lc2goXG4gICAgICAgIG1lc2g6IElNZXNoLFxuICAgICAgICBzY2VuZTogSVNjZW5lLFxuICAgICAgICByZW5kZXJQYXNzRW5jb2RlcjogR1BVUmVuZGVyUGFzc0VuY29kZXJcbiAgICApIHtcbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgICAgcmVuZGVyUGlwZWxpbmUsXG4gICAgICAgICAgICBtYXRlcmlhbEJpbmRHcm91cCxcbiAgICAgICAgICAgIHNhbXBsZXJCaW5kR3JvdXAsXG4gICAgICAgICAgICBwb3NpdGlvbnNCdWZmZXIsXG4gICAgICAgICAgICB0ZXh0dXJlQ29vcmRpbmF0ZXNCdWZmZXIsXG4gICAgICAgICAgICB0YW5nZW50c0J1ZmZlcixcbiAgICAgICAgICAgIG5vcm1hbHNCdWZmZXIsXG4gICAgICAgICAgICBpbmRpY2VzQnVmZmVyLFxuICAgICAgICAgICAgbm9kZVBhcmFtc0JpbmRHcm91cCxcbiAgICAgICAgfSA9IHNjZW5lLm1lc2hSZW5kZXJEYXRhU3RvcmFnZS5kYXRhLmdldChtZXNoLmlkKSBhcyBJTWVzaFJlbmRlckRhdGFcblxuICAgICAgICByZW5kZXJQYXNzRW5jb2Rlci5zZXRCaW5kR3JvdXAoMSwgbm9kZVBhcmFtc0JpbmRHcm91cCBhcyBHUFVCaW5kR3JvdXApXG5cbiAgICAgICAgcmVuZGVyUGFzc0VuY29kZXIuc2V0UGlwZWxpbmUocmVuZGVyUGlwZWxpbmUgYXMgR1BVUmVuZGVyUGlwZWxpbmUpXG5cbiAgICAgICAgcmVuZGVyUGFzc0VuY29kZXIuc2V0QmluZEdyb3VwKDIsIG1hdGVyaWFsQmluZEdyb3VwKVxuXG4gICAgICAgIHJlbmRlclBhc3NFbmNvZGVyLnNldEJpbmRHcm91cCgzLCBzYW1wbGVyQmluZEdyb3VwKVxuXG4gICAgICAgIHJlbmRlclBhc3NFbmNvZGVyLnNldFZlcnRleEJ1ZmZlcihcbiAgICAgICAgICAgIDAsXG4gICAgICAgICAgICBwb3NpdGlvbnNCdWZmZXIgYXMgR1BVQnVmZmVyLFxuICAgICAgICAgICAgMCxcbiAgICAgICAgICAgIG1lc2gucG9zaXRpb25zLmJ5dGVMZW5ndGhcbiAgICAgICAgKVxuXG4gICAgICAgIHJlbmRlclBhc3NFbmNvZGVyLnNldFZlcnRleEJ1ZmZlcihcbiAgICAgICAgICAgIDEsXG4gICAgICAgICAgICB0ZXh0dXJlQ29vcmRpbmF0ZXNCdWZmZXIgYXMgR1BVQnVmZmVyLFxuICAgICAgICAgICAgMCxcbiAgICAgICAgICAgIG1lc2gudGV4dHVyZUNvb3JkaW5hdGVzLmJ5dGVMZW5ndGhcbiAgICAgICAgKVxuXG4gICAgICAgIHJlbmRlclBhc3NFbmNvZGVyLnNldFZlcnRleEJ1ZmZlcihcbiAgICAgICAgICAgIDIsXG4gICAgICAgICAgICBub3JtYWxzQnVmZmVyIGFzIEdQVUJ1ZmZlcixcbiAgICAgICAgICAgIDAsXG4gICAgICAgICAgICBtZXNoLm5vcm1hbHMuYnl0ZUxlbmd0aFxuICAgICAgICApXG5cbiAgICAgICAgcmVuZGVyUGFzc0VuY29kZXIuc2V0VmVydGV4QnVmZmVyKFxuICAgICAgICAgICAgMyxcbiAgICAgICAgICAgIHRhbmdlbnRzQnVmZmVyIGFzIEdQVUJ1ZmZlcixcbiAgICAgICAgICAgIDAsXG4gICAgICAgICAgICBtZXNoLnRhbmdlbnRzLmJ5dGVMZW5ndGhcbiAgICAgICAgKVxuXG4gICAgICAgIHJlbmRlclBhc3NFbmNvZGVyLnNldEluZGV4QnVmZmVyKFxuICAgICAgICAgICAgaW5kaWNlc0J1ZmZlciBhcyBHUFVCdWZmZXIsXG4gICAgICAgICAgICBtZXNoLmluZGljZXMuZWxlbWVudFR5cGUgYXMgR1BVSW5kZXhGb3JtYXQsXG4gICAgICAgICAgICAwLFxuICAgICAgICAgICAgbWVzaC5pbmRpY2VzLmJ5dGVMZW5ndGhcbiAgICAgICAgKVxuICAgICAgICByZW5kZXJQYXNzRW5jb2Rlci5kcmF3SW5kZXhlZChtZXNoLmluZGljZXMuY291bnQpXG4gICAgfVxuXG4gICAgcHJpdmF0ZSByZW5kZXJNZXNoU2hhZG93cyhcbiAgICAgICAgbWVzaDogSU1lc2gsXG4gICAgICAgIHNjZW5lOiBJU2NlbmUsXG4gICAgICAgIHJlbmRlclBhc3NFbmNvZGVyOiBHUFVSZW5kZXJQYXNzRW5jb2RlclxuICAgICkge1xuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgICBzaGFkb3dSZW5kZXJQaXBlbGluZSxcbiAgICAgICAgICAgIHBvc2l0aW9uc0J1ZmZlcixcbiAgICAgICAgICAgIGluZGljZXNCdWZmZXIsXG4gICAgICAgICAgICBub2RlUGFyYW1zQmluZEdyb3VwLFxuICAgICAgICB9ID0gc2NlbmUubWVzaFJlbmRlckRhdGFTdG9yYWdlLmRhdGEuZ2V0KG1lc2guaWQpIGFzIElNZXNoUmVuZGVyRGF0YVxuXG4gICAgICAgIHJlbmRlclBhc3NFbmNvZGVyLnNldEJpbmRHcm91cCgxLCBub2RlUGFyYW1zQmluZEdyb3VwIGFzIEdQVUJpbmRHcm91cClcblxuICAgICAgICByZW5kZXJQYXNzRW5jb2Rlci5zZXRQaXBlbGluZShzaGFkb3dSZW5kZXJQaXBlbGluZSBhcyBHUFVSZW5kZXJQaXBlbGluZSlcblxuICAgICAgICByZW5kZXJQYXNzRW5jb2Rlci5zZXRWZXJ0ZXhCdWZmZXIoXG4gICAgICAgICAgICAwLFxuICAgICAgICAgICAgcG9zaXRpb25zQnVmZmVyIGFzIEdQVUJ1ZmZlcixcbiAgICAgICAgICAgIDAsXG4gICAgICAgICAgICBtZXNoLnBvc2l0aW9ucy5ieXRlTGVuZ3RoXG4gICAgICAgIClcblxuICAgICAgICByZW5kZXJQYXNzRW5jb2Rlci5zZXRJbmRleEJ1ZmZlcihcbiAgICAgICAgICAgIGluZGljZXNCdWZmZXIgYXMgR1BVQnVmZmVyLFxuICAgICAgICAgICAgbWVzaC5pbmRpY2VzLmVsZW1lbnRUeXBlIGFzIEdQVUluZGV4Rm9ybWF0LFxuICAgICAgICAgICAgMCxcbiAgICAgICAgICAgIG1lc2guaW5kaWNlcy5ieXRlTGVuZ3RoXG4gICAgICAgIClcbiAgICAgICAgcmVuZGVyUGFzc0VuY29kZXIuZHJhd0luZGV4ZWQobWVzaC5pbmRpY2VzLmNvdW50KVxuICAgIH1cblxuICAgIHB1YmxpYyByZW5kZXIoZGVsdGFUaW1lOiBudW1iZXIsIHNjZW5lOiBJU2NlbmUpIHtcbiAgICAgICAgc2NlbmUub25SZW5kZXIoZGVsdGFUaW1lKVxuXG4gICAgICAgIGNvbnN0IG1lc2hlc1RvUmVuZGVyOiBJTWVzaFtdID0gW11cblxuICAgICAgICBjb25zdCBkZWJ1Z0luZm9BcnJheSA9IG5ldyBBcnJheUJ1ZmZlcig0ICsgNClcbiAgICAgICAgY29uc3QgZGVidWdJbmZvVmlldyA9IG5ldyBEYXRhVmlldyhcbiAgICAgICAgICAgIGRlYnVnSW5mb0FycmF5LFxuICAgICAgICAgICAgMCxcbiAgICAgICAgICAgIGRlYnVnSW5mb0FycmF5LmJ5dGVMZW5ndGhcbiAgICAgICAgKVxuXG4gICAgICAgIGRlYnVnSW5mb1ZpZXcuc2V0VWludDMyKDAsIHRoaXMub3V0cHV0U291cmNlLCB0cnVlKVxuICAgICAgICBkZWJ1Z0luZm9WaWV3LnNldFVpbnQzMig0LCB0aGlzLnJlbmRlcmluZ01vZGUsIHRydWUpXG5cbiAgICAgICAgY29uc3Qgdmlld1BhcmFtc1VwbG9hZEJ1ZmZlciA9IHRoaXMuZGV2aWNlLmNyZWF0ZUJ1ZmZlcih7XG4gICAgICAgICAgICBzaXplOiB0aGlzLl92aWV3UGFyYW1zQnVmZmVyU2l6ZSxcbiAgICAgICAgICAgIHVzYWdlOiBHUFVCdWZmZXJVc2FnZS5DT1BZX1NSQyxcbiAgICAgICAgICAgIG1hcHBlZEF0Q3JlYXRpb246IHRydWUsXG4gICAgICAgIH0pXG5cbiAgICAgICAgY29uc3Qgdmlld01hcCA9IG5ldyBGbG9hdDMyQXJyYXkoXG4gICAgICAgICAgICB2aWV3UGFyYW1zVXBsb2FkQnVmZmVyLmdldE1hcHBlZFJhbmdlKClcbiAgICAgICAgKVxuXG4gICAgICAgIHZpZXdNYXAuc2V0KHNjZW5lLmNhbWVyYS5wcm9qZWN0aW9uTWF0cml4KVxuICAgICAgICB2aWV3TWFwLnNldChzY2VuZS5jYW1lcmEudmlldywgMTYpXG4gICAgICAgIHZpZXdNYXAuc2V0KHNjZW5lLmNhbWVyYS5wb3NpdGlvbiwgMzIpXG4gICAgICAgIC8vRklYTUU6IHRoaXMgd2lsbCBiZSBhbiBhcnJheSBvZiBsaWdodHMgaW4gdGhlIHNjZW5lXG4gICAgICAgIHZpZXdNYXAuc2V0KHNjZW5lLmxpZ2h0LnByb2plY3Rpb25NYXRyaXgsIDM2KVxuICAgICAgICB2aWV3TWFwLnNldChzY2VuZS5saWdodC52aWV3TWF0cml4LCA1MilcbiAgICAgICAgdmlld01hcC5zZXQoc2NlbmUubGlnaHQucG9zaXRpb24sIDY4KVxuICAgICAgICB2aWV3TWFwLnNldChcbiAgICAgICAgICAgIHZlYzQuY3JlYXRlKC4uLnRoaXMuYW1iaWVudExpZ2h0Q29sb3IsIHRoaXMuYW1iaWVudExpZ2h0SW50ZW5zaXR5KSxcbiAgICAgICAgICAgIDcyXG4gICAgICAgIClcblxuICAgICAgICB2aWV3UGFyYW1zVXBsb2FkQnVmZmVyLnVubWFwKClcblxuICAgICAgICBjb25zdCBza3lCb3hWaWV3UGFyYW1zVXBsb2FkQnVmZmVyID0gdGhpcy5kZXZpY2UuY3JlYXRlQnVmZmVyKHtcbiAgICAgICAgICAgIHNpemU6IHRoaXMuX3NreUJveFVuaWZvcm1CdWZmZXJTaXplLFxuICAgICAgICAgICAgdXNhZ2U6IEdQVUJ1ZmZlclVzYWdlLkNPUFlfU1JDLFxuICAgICAgICAgICAgbWFwcGVkQXRDcmVhdGlvbjogdHJ1ZSxcbiAgICAgICAgfSlcblxuICAgICAgICBjb25zdCBza3lib3hWaWV3TWFwID0gbmV3IEZsb2F0MzJBcnJheShcbiAgICAgICAgICAgIHNreUJveFZpZXdQYXJhbXNVcGxvYWRCdWZmZXIuZ2V0TWFwcGVkUmFuZ2UoKVxuICAgICAgICApXG5cbiAgICAgICAgc2t5Ym94Vmlld01hcC5zZXQodGhpcy5fc2t5Qm94TW9kZWxNYXRyaXgpXG4gICAgICAgIHNreWJveFZpZXdNYXAuc2V0KHNjZW5lLmNhbWVyYS5wcm9qZWN0aW9uTWF0cml4LCAxNilcbiAgICAgICAgc2t5Ym94Vmlld01hcC5zZXQoc2NlbmUuY2FtZXJhLnZpZXcsIDMyKVxuICAgICAgICBza3lib3hWaWV3TWFwLnNldChzY2VuZS5jYW1lcmEucG9zaXRpb24sIDQ4KVxuXG4gICAgICAgIHNreUJveFZpZXdQYXJhbXNVcGxvYWRCdWZmZXIudW5tYXAoKVxuXG4gICAgICAgIGNvbnN0IGRlYnVnUGFyYW1zQXJyYXkgPSBuZXcgQXJyYXlCdWZmZXIodGhpcy5fZGVidWdQYXJhbXNCdWZmZXIuc2l6ZSlcbiAgICAgICAgY29uc3QgZGVidWdQYXJhbXNWaWV3ID0gbmV3IERhdGFWaWV3KFxuICAgICAgICAgICAgZGVidWdQYXJhbXNBcnJheSxcbiAgICAgICAgICAgIDAsXG4gICAgICAgICAgICBkZWJ1Z1BhcmFtc0FycmF5LmJ5dGVMZW5ndGhcbiAgICAgICAgKVxuICAgICAgICBkZWJ1Z1BhcmFtc1ZpZXcuc2V0VWludDMyKDAsIDApXG4gICAgICAgIGRlYnVnUGFyYW1zVmlldy5zZXRVaW50MzIoNCwgMClcblxuICAgICAgICB0aGlzLmRldmljZS5xdWV1ZS53cml0ZUJ1ZmZlcihcbiAgICAgICAgICAgIHRoaXMuX2RlYnVnUGFyYW1zQnVmZmVyLFxuICAgICAgICAgICAgMCxcbiAgICAgICAgICAgIGRlYnVnSW5mb0FycmF5XG4gICAgICAgIClcblxuICAgICAgICBjb25zdCBpdGVyYXRlTm9kZSA9IChub2RlOiBTY2VuZU5vZGVDb250ZW50LCB3b3JsZE1hdHJpeDogTWF0NCkgPT4ge1xuICAgICAgICAgICAgY29uc3Qgbm9kZVRyYW5zZm9ybSA9IG5vZGUuZ2FtZU9iamVjdC50cmFuc2Zvcm1cblxuICAgICAgICAgICAgY29uc3QgbWVzaE1hdHJpeCA9IG5vZGVUcmFuc2Zvcm1cbiAgICAgICAgICAgICAgICA/IG1hdDQubXVsKHdvcmxkTWF0cml4LCBub2RlVHJhbnNmb3JtLm1hdHJpeClcbiAgICAgICAgICAgICAgICA6IHdvcmxkTWF0cml4XG5cbiAgICAgICAgICAgIGNvbnN0IG5vZGVQYXJhbXNVcGxvYWRCdWZmZXIgPSB0aGlzLmRldmljZS5jcmVhdGVCdWZmZXIoe1xuICAgICAgICAgICAgICAgIHNpemU6IDE2ICogNCxcbiAgICAgICAgICAgICAgICB1c2FnZTogR1BVQnVmZmVyVXNhZ2UuVU5JRk9STSB8IEdQVUJ1ZmZlclVzYWdlLkNPUFlfRFNULFxuICAgICAgICAgICAgICAgIG1hcHBlZEF0Q3JlYXRpb246IHRydWUsXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgY29uc3Qgbm9kZVBhcmFtc01hcCA9IG5ldyBGbG9hdDMyQXJyYXkoXG4gICAgICAgICAgICAgICAgbm9kZVBhcmFtc1VwbG9hZEJ1ZmZlci5nZXRNYXBwZWRSYW5nZSgpXG4gICAgICAgICAgICApXG4gICAgICAgICAgICBub2RlUGFyYW1zTWFwLnNldChtZXNoTWF0cml4KVxuICAgICAgICAgICAgbm9kZVBhcmFtc1VwbG9hZEJ1ZmZlci51bm1hcCgpXG5cbiAgICAgICAgICAgIGNvbnN0IG5vZGVQYXJhbXNCaW5kR3JvdXAgPSB0aGlzLmRldmljZS5jcmVhdGVCaW5kR3JvdXAoe1xuICAgICAgICAgICAgICAgIGxheW91dDogdGhpcy5fbm9kZVBhcmFtc0JHTGF5b3V0LFxuICAgICAgICAgICAgICAgIGVudHJpZXM6IFtcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgYmluZGluZzogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc291cmNlOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnVmZmVyOiBub2RlUGFyYW1zVXBsb2FkQnVmZmVyLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgfSlcblxuICAgICAgICAgICAgbm9kZT8uZ2FtZU9iamVjdD8uY29tcG9uZW50cz8uZm9yRWFjaCgoY29tcG9uZW50OiBhbnkpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoY29tcG9uZW50LnR5cGUgPT09IEVudGl0eVR5cGVzLm1lc2gpIHtcbiAgICAgICAgICAgICAgICAgICAgLy9GSVhNRTogdHJhbnNmb3JtIGNhbGN1bGF0aW9ucyBhcmUgbm90IHBlcmZvcm1lZCBmb3IgdGhlIGxpZ2h0IHRyYW5zZm9ybSBhcyBvZiBub3dcbiAgICAgICAgICAgICAgICAgICAgbWVzaGVzVG9SZW5kZXIucHVzaChjb21wb25lbnQpXG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCEoY29tcG9uZW50IGFzIElNZXNoKS5pc1BpcGVsaW5lQnVpbHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYnVpbGRSZW5kZXJQaXBlbGluZShjb21wb25lbnQsIHNjZW5lKVxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgc2NlbmUubWVzaFJlbmRlckRhdGFTdG9yYWdlLmRhdGEuZ2V0KFxuICAgICAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50LmlkXG4gICAgICAgICAgICAgICAgICAgICkhLm5vZGVQYXJhbXNCaW5kR3JvdXAgPSBub2RlUGFyYW1zQmluZEdyb3VwXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSlcblxuICAgICAgICAgICAgbm9kZT8uY2hpbGRyZW4/LmZvckVhY2goKGNoaWxkOiBhbnkpID0+IHtcbiAgICAgICAgICAgICAgICBpdGVyYXRlTm9kZShjaGlsZCwgbWVzaE1hdHJpeClcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH1cblxuICAgICAgICBzY2VuZS5vYmplY3RNYW5hZ2VyLnNjZW5lVHJlZS5ub2Rlcy5mb3JFYWNoKChub2RlKSA9PiB7XG4gICAgICAgICAgICBpdGVyYXRlTm9kZShub2RlLCBtYXQ0LmlkZW50aXR5KCkpXG4gICAgICAgIH0pXG5cbiAgICAgICAgY29uc3QgY29tbWFuZEVuY29kZXIgPSB0aGlzLmRldmljZS5jcmVhdGVDb21tYW5kRW5jb2RlcigpXG5cbiAgICAgICAgY29tbWFuZEVuY29kZXIuY29weUJ1ZmZlclRvQnVmZmVyKFxuICAgICAgICAgICAgdmlld1BhcmFtc1VwbG9hZEJ1ZmZlcixcbiAgICAgICAgICAgIDAsXG4gICAgICAgICAgICB0aGlzLl92aWV3UGFyYW1zQnVmZmVyLFxuICAgICAgICAgICAgMCxcbiAgICAgICAgICAgIHRoaXMuX3ZpZXdQYXJhbXNCdWZmZXJTaXplXG4gICAgICAgIClcblxuICAgICAgICBjb21tYW5kRW5jb2Rlci5jb3B5QnVmZmVyVG9CdWZmZXIoXG4gICAgICAgICAgICBza3lCb3hWaWV3UGFyYW1zVXBsb2FkQnVmZmVyLFxuICAgICAgICAgICAgMCxcbiAgICAgICAgICAgIHRoaXMuX3NreUJveFVuaWZvcm1CdWZmZXIsXG4gICAgICAgICAgICAwLFxuICAgICAgICAgICAgdGhpcy5fc2t5Qm94VW5pZm9ybUJ1ZmZlclNpemVcbiAgICAgICAgKVxuICAgICAgICA7KHRoaXMuX3JlbmRlclBhc3NEZXNjcmlwdG9yIGFzIGFueSkuY29sb3JBdHRhY2htZW50c1swXS52aWV3ID1cbiAgICAgICAgICAgIHRoaXMuY29udGV4dC5nZXRDdXJyZW50VGV4dHVyZSgpLmNyZWF0ZVZpZXcoKVxuICAgICAgICBpZiAodGhpcy5fbXNhYVNhbXBsZUNvdW50ICE9PSAxKSB7XG4gICAgICAgICAgICA7KHRoaXMuX3JlbmRlclBhc3NEZXNjcmlwdG9yIGFzIGFueSkuY29sb3JBdHRhY2htZW50c1swXS52aWV3ID1cbiAgICAgICAgICAgICAgICB0aGlzLl9tdWx0aXNhbXBsZVRleHR1cmVWaWV3XG4gICAgICAgICAgICA7KFxuICAgICAgICAgICAgICAgIHRoaXMuX3JlbmRlclBhc3NEZXNjcmlwdG9yIGFzIGFueVxuICAgICAgICAgICAgKS5jb2xvckF0dGFjaG1lbnRzWzBdLnJlc29sdmVUYXJnZXQgPSB0aGlzLmNvbnRleHRcbiAgICAgICAgICAgICAgICAuZ2V0Q3VycmVudFRleHR1cmUoKVxuICAgICAgICAgICAgICAgIC5jcmVhdGVWaWV3KClcbiAgICAgICAgfVxuXG4gICAgICAgIDsodGhpcy5fc2t5Qm94UmVuZGVyUGFzc0Rlc2NyaXB0b3IgYXMgYW55KS5jb2xvckF0dGFjaG1lbnRzWzBdLnZpZXcgPVxuICAgICAgICAgICAgdGhpcy5jb250ZXh0LmdldEN1cnJlbnRUZXh0dXJlKCkuY3JlYXRlVmlldygpXG4gICAgICAgIGlmICh0aGlzLl9tc2FhU2FtcGxlQ291bnQgIT09IDEpIHtcbiAgICAgICAgICAgIDsoXG4gICAgICAgICAgICAgICAgdGhpcy5fc2t5Qm94UmVuZGVyUGFzc0Rlc2NyaXB0b3IgYXMgYW55XG4gICAgICAgICAgICApLmNvbG9yQXR0YWNobWVudHNbMF0udmlldyA9IHRoaXMuX211bHRpc2FtcGxlVGV4dHVyZVZpZXdcbiAgICAgICAgICAgIDsoXG4gICAgICAgICAgICAgICAgdGhpcy5fcmVuZGVyUGFzc0Rlc2NyaXB0b3IgYXMgYW55XG4gICAgICAgICAgICApLmNvbG9yQXR0YWNobWVudHNbMF0ucmVzb2x2ZVRhcmdldCA9IHRoaXMuY29udGV4dFxuICAgICAgICAgICAgICAgIC5nZXRDdXJyZW50VGV4dHVyZSgpXG4gICAgICAgICAgICAgICAgLmNyZWF0ZVZpZXcoKVxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3Qgc2t5Qm94UGFzcyA9IGNvbW1hbmRFbmNvZGVyLmJlZ2luUmVuZGVyUGFzcyhcbiAgICAgICAgICAgIHRoaXMuX3NreUJveFJlbmRlclBhc3NEZXNjcmlwdG9yXG4gICAgICAgIClcbiAgICAgICAgc2t5Qm94UGFzcy5zZXRQaXBlbGluZSh0aGlzLl9za3lCb3hQaXBlbGluZSlcbiAgICAgICAgc2t5Qm94UGFzcy5zZXRWZXJ0ZXhCdWZmZXIoMCwgdGhpcy5fc2t5Qm94VmVydGljZXNCdWZmZXIpXG4gICAgICAgIHNreUJveFBhc3Muc2V0QmluZEdyb3VwKDAsIHRoaXMuX3NreUJveFVuaWZvcm1CaW5kR3JvdXApXG4gICAgICAgIHNreUJveFBhc3MuZHJhdyhjdWJlVmVydGV4Q291bnQpXG4gICAgICAgIHNreUJveFBhc3MuZW5kKClcblxuICAgICAgICBjb25zdCBzaGFkb3dQYXNzID0gY29tbWFuZEVuY29kZXIuYmVnaW5SZW5kZXJQYXNzKFxuICAgICAgICAgICAgdGhpcy5fc2hhZG93UGFzc0Rlc2NyaXB0b3JcbiAgICAgICAgKVxuXG4gICAgICAgIHNoYWRvd1Bhc3Muc2V0QmluZEdyb3VwKDAsIHRoaXMuX3ZpZXdQYXJhbXNCaW5kR3JvdXApXG5cbiAgICAgICAgbWVzaGVzVG9SZW5kZXIuZm9yRWFjaCgobWVzaCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5yZW5kZXJNZXNoU2hhZG93cyhtZXNoLCBzY2VuZSwgc2hhZG93UGFzcylcbiAgICAgICAgfSlcblxuICAgICAgICBzaGFkb3dQYXNzLmVuZCgpXG5cbiAgICAgICAgY29uc3QgcmVuZGVyUGFzcyA9IGNvbW1hbmRFbmNvZGVyLmJlZ2luUmVuZGVyUGFzcyhcbiAgICAgICAgICAgIHRoaXMuX3JlbmRlclBhc3NEZXNjcmlwdG9yXG4gICAgICAgIClcblxuICAgICAgICByZW5kZXJQYXNzLnNldEJpbmRHcm91cCgwLCB0aGlzLl92aWV3UGFyYW1zQmluZEdyb3VwKVxuXG4gICAgICAgIC8vRklYTUU6IG1vdmUgc2FtcGxlcnMgYW5kIHRleHR1cmVzIGJhY2sgdG8gdGhlIHNhbWUgYmluZGdyb3VwXG4gICAgICAgIG1lc2hlc1RvUmVuZGVyLmZvckVhY2goKG1lc2gpID0+IHtcbiAgICAgICAgICAgIHRoaXMucmVuZGVyTWVzaChtZXNoLCBzY2VuZSwgcmVuZGVyUGFzcylcbiAgICAgICAgfSlcblxuICAgICAgICByZW5kZXJQYXNzLmVuZCgpXG5cbiAgICAgICAgdGhpcy5kZXZpY2UucXVldWUuc3VibWl0KFtjb21tYW5kRW5jb2Rlci5maW5pc2goKV0pXG4gICAgICAgIHZpZXdQYXJhbXNVcGxvYWRCdWZmZXIuZGVzdHJveSgpXG4gICAgICAgIHNreUJveFZpZXdQYXJhbXNVcGxvYWRCdWZmZXIuZGVzdHJveSgpXG4gICAgfVxufVxuIiwiZXhwb3J0IGNvbnN0IERFRkFVTFRfU1dBUF9DSEFJTl9GT1JNQVQ6IEdQVVRleHR1cmVGb3JtYXQgPSAncmdiYTh1bm9ybSdcbmV4cG9ydCBjb25zdCBERUZBVUxUX0RFUFRIX0ZPUk1BVDogR1BVVGV4dHVyZUZvcm1hdCA9ICdkZXB0aDI0cGx1cy1zdGVuY2lsOCdcbmV4cG9ydCBjb25zdCBERUZBVUxUX1NIQURPV19ERVBUSF9GT1JNQVQ6IEdQVVRleHR1cmVGb3JtYXQgPSAnZGVwdGgzMmZsb2F0J1xuZXhwb3J0IGNvbnN0IERFRlVMVF9TSEFET1dfVEVYVFVSRV9TSVpFOiBudW1iZXIgPSAxMDI0XG5leHBvcnQgY29uc3QgVklFV19QQVJBTVNfQlVGRkVSX1NJWkU6IG51bWJlciA9XG4gICAgMTYgKiA0ICsgMTYgKiA0ICsgNCAqIDQgKyA0ICogNCArIDE2ICogNCArIDE2ICogNCArIDE2ICsgMTYgKiAzICsgNCArIDRcbmV4cG9ydCBjb25zdCBNU0FBX1NBTVBMRV9DT1VOVDogbnVtYmVyID0gNFxuIiwiZXhwb3J0ICogZnJvbSAnLi9SZW5kZXJlcidcbiIsImltcG9ydCB7IERFRkFVTFRfU0FNUExFUl9JRFMsIElTYW1wbGVyU3RvcmFnZSB9IGZyb20gJy4uLy4uL3R5cGVzJ1xuXG5leHBvcnQgY2xhc3MgU2FtcGxlclN0b3JhZ2UgaW1wbGVtZW50cyBJU2FtcGxlclN0b3JhZ2Uge1xuICAgIF9zYW1wbGVyczogTWFwPHN0cmluZywgR1BVU2FtcGxlcj4gPSBuZXcgTWFwKClcblxuICAgIGNvbnN0cnVjdG9yKGRldmljZTogR1BVRGV2aWNlKSB7XG4gICAgICAgIGNvbnN0IHNhbXBsZXIgPSBkZXZpY2UuY3JlYXRlU2FtcGxlcih7XG4gICAgICAgICAgICBtYWdGaWx0ZXI6ICdsaW5lYXInLFxuICAgICAgICAgICAgbWluRmlsdGVyOiAnbGluZWFyJyxcbiAgICAgICAgICAgIGFkZHJlc3NNb2RlVTogJ3JlcGVhdCcsXG4gICAgICAgICAgICBhZGRyZXNzTW9kZVY6ICdyZXBlYXQnLFxuICAgICAgICAgICAgbWlwbWFwRmlsdGVyOiAnbmVhcmVzdCcsXG4gICAgICAgIH0pXG5cbiAgICAgICAgdGhpcy5zYW1wbGVycy5zZXQoREVGQVVMVF9TQU1QTEVSX0lEUy5iYXNlQ29sb3IsIHNhbXBsZXIpXG4gICAgICAgIHRoaXMuc2FtcGxlcnMuc2V0KERFRkFVTFRfU0FNUExFUl9JRFMuZW1pc3Npb24sIHNhbXBsZXIpXG4gICAgICAgIHRoaXMuc2FtcGxlcnMuc2V0KERFRkFVTFRfU0FNUExFUl9JRFMubWV0YWxsaWNSb3VnaG5lc3MsIHNhbXBsZXIpXG4gICAgICAgIHRoaXMuc2FtcGxlcnMuc2V0KERFRkFVTFRfU0FNUExFUl9JRFMubm9ybWFsLCBzYW1wbGVyKVxuICAgICAgICB0aGlzLnNhbXBsZXJzLnNldChERUZBVUxUX1NBTVBMRVJfSURTLm9jY2x1c2lvbiwgc2FtcGxlcilcbiAgICB9XG5cbiAgICBnZXQgc2FtcGxlcnMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zYW1wbGVyc1xuICAgIH1cbn1cbiIsImV4cG9ydCAqIGZyb20gJy4vU2FtcGxlclN0b3JhZ2UnXG4iLCJpbXBvcnQgeyB2ZWMzIH0gZnJvbSAnd2dwdS1tYXRyaXgnXG5pbXBvcnQge1xuICAgIElCdWZmZXJTdG9yYWdlLFxuICAgIElFbmdpbmUsXG4gICAgSUdhbWVPYmplY3QsXG4gICAgSUltYWdlU3RvcmFnZSxcbiAgICBJT2JqZWN0TWFuYWdlcixcbiAgICBJU2FtcGxlclN0b3JhZ2UsXG4gICAgSVNjZW5lLFxuICAgIElTY2VuZVByb3BzLFxuICAgIElTY2VuZVVwbG9hZE1vZGVsUHJvcHMsXG59IGZyb20gJy4uLy4uL3R5cGVzJ1xuaW1wb3J0IHsgSUNhbWVyYSB9IGZyb20gJy4uLy4uL3R5cGVzL2NvcmUvQ2FtZXJhJ1xuaW1wb3J0IHsgQnVmZmVyU3RvcmFnZSB9IGZyb20gJy4uL0J1ZmZlclN0b3JhZ2UnXG5pbXBvcnQgeyBBcmNCYWxsQ2FtZXJhIH0gZnJvbSAnLi4vY2FtZXJhcy9BcmNCYWxsQ2FtZXJhJ1xuaW1wb3J0IHsgSW1hZ2VTdG9yYWdlIH0gZnJvbSAnLi4vSW1hZ2VTdG9yYWdlJ1xuaW1wb3J0IHsgTWF0ZXJpYWxTdG9yYWdlIH0gZnJvbSAnLi4vTWF0ZXJpYWxTdG9yYWdlJ1xuaW1wb3J0IHsgTW9kZWxVcGxvYWRlciB9IGZyb20gJy4uL01vZGVsVXBsb2FkZXInXG5pbXBvcnQgeyBPYmplY3RNYW5hZ2VyIH0gZnJvbSAnLi4vT2JqZWN0TWFuYWdlcidcbmltcG9ydCB7IFNhbXBsZXJTdG9yYWdlIH0gZnJvbSAnLi4vU2FtcGxlclN0b3JhZ2UnXG5pbXBvcnQgeyBUZXh0dXJlU3RvcmFnZSB9IGZyb20gJy4uL1RleHR1cmVTdG9yYWdlJ1xuaW1wb3J0IHsgR2FtZU9iamVjdCB9IGZyb20gJy4uL0dhbWVPYmplY3QnXG5pbXBvcnQgeyBNZXNoUmVuZGVyRGF0YVN0b3JhZ2UgfSBmcm9tICcuLi9NZXNoUmVuZGVyRGF0YVN0b3JhZ2UnXG5pbXBvcnQgeyBEaXJlY3Rpb25hbExpZ2h0IH0gZnJvbSAnLi4vbGlnaHRzJ1xuXG5leHBvcnQgY2xhc3MgU2NlbmUgaW1wbGVtZW50cyBJU2NlbmUge1xuICAgIHByaXZhdGUgX29iamVjdE1hbmFnZXI6IElPYmplY3RNYW5hZ2VyID0gbmV3IE9iamVjdE1hbmFnZXIoKVxuICAgIHByaXZhdGUgX2J1ZmZlclN0b3JhZ2U6IElCdWZmZXJTdG9yYWdlID0gbmV3IEJ1ZmZlclN0b3JhZ2UoKVxuICAgIHByaXZhdGUgX2ltYWdlU3RvcmFnZTogSUltYWdlU3RvcmFnZSA9IG5ldyBJbWFnZVN0b3JhZ2UoKVxuICAgIHByaXZhdGUgX3NhbXBsZXJTdG9yYWdlOiBJU2FtcGxlclN0b3JhZ2VcbiAgICBwcml2YXRlIF90ZXh0dXJlU3RvcmFnZSA9IG5ldyBUZXh0dXJlU3RvcmFnZSgpXG4gICAgcHJpdmF0ZSBfbWF0ZXJpYWxTdG9yYWdlID0gbmV3IE1hdGVyaWFsU3RvcmFnZSgpXG4gICAgcHJpdmF0ZSBfbWVzaFJlbmRlckRhdGFTdG9yYWdlID0gbmV3IE1lc2hSZW5kZXJEYXRhU3RvcmFnZSgpXG5cbiAgICBwcml2YXRlIF9jYW1lcmEhOiBJQ2FtZXJhXG5cbiAgICBwcm90ZWN0ZWQgX2VuZ2luZT86IElFbmdpbmVcblxuICAgIHByaXZhdGUgX3Jvb3Q6IElHYW1lT2JqZWN0XG5cbiAgICAvL2ZpeG1lOiBtb2NrXG4gICAgbGlnaHQhOiBEaXJlY3Rpb25hbExpZ2h0XG5cbiAgICBjb25zdHJ1Y3Rvcihwcm9wcz86IElTY2VuZVByb3BzKSB7XG4gICAgICAgIGNvbnN0IHsgY2FtZXJhIH0gPSBwcm9wcyA/PyB7fVxuICAgICAgICAvL0ZJWE1FOiB0eXBlc1xuICAgICAgICB0aGlzLl9lbmdpbmUgPSAod2luZG93IGFzIGFueSkuV2hlZXp5RW5naW5lIGFzIElFbmdpbmUgfCB1bmRlZmluZWRcblxuICAgICAgICBpZiAoIXRoaXMuX2VuZ2luZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgICAgICdGYWlsZWQgdG8gaW5pdGlhbGl6ZSBzY2VuZSBhcyBubyBpbnN0YW5jZSBvZiBXaGVlenkgRW5naW5lIGlzIGZvdW5kJ1xuICAgICAgICAgICAgKVxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fc2FtcGxlclN0b3JhZ2UgPSBuZXcgU2FtcGxlclN0b3JhZ2UodGhpcy5fZW5naW5lLnJlbmRlcmVyLmRldmljZSlcblxuICAgICAgICB0aGlzLl9yb290ID0gbmV3IEdhbWVPYmplY3QoKVxuXG4gICAgICAgIHRoaXMuX29iamVjdE1hbmFnZXIuYWRkT2JqZWN0KHRoaXMuX3Jvb3QpXG5cbiAgICAgICAgdGhpcy5jYW1lcmEgPVxuICAgICAgICAgICAgY2FtZXJhID8/XG4gICAgICAgICAgICBuZXcgQXJjQmFsbENhbWVyYSh7XG4gICAgICAgICAgICAgICAgekZhcjogMTAwMCxcbiAgICAgICAgICAgICAgICB6TmVhcjogMC4xLFxuICAgICAgICAgICAgICAgIGNhbnZhc1dpZHRoOiB0aGlzLl9lbmdpbmUucmVuZGVyZXIuY29udGV4dC5jYW52YXMud2lkdGgsXG4gICAgICAgICAgICAgICAgY2FudmFzSGVpZ2h0OiB0aGlzLl9lbmdpbmUucmVuZGVyZXIuY29udGV4dC5jYW52YXMuaGVpZ2h0LFxuICAgICAgICAgICAgICAgIHBvc2l0aW9uOiB2ZWMzLmNyZWF0ZSgwLCAwLCA1KSxcbiAgICAgICAgICAgIH0pXG4gICAgfVxuXG4gICAgcHVibGljIGFzeW5jIGluaXQoKSB7XG4gICAgICAgIGF3YWl0IHRoaXMuaW1hZ2VTdG9yYWdlLmNyZWF0ZURlZmF1bHRzKClcbiAgICB9XG5cbiAgICBnZXQgb2JqZWN0TWFuYWdlcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX29iamVjdE1hbmFnZXJcbiAgICB9XG5cbiAgICBnZXQgcm9vdCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3Jvb3RcbiAgICB9XG5cbiAgICBnZXQgdGV4dHVyZVN0b3JhZ2UoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl90ZXh0dXJlU3RvcmFnZVxuICAgIH1cblxuICAgIGdldCBtZXNoUmVuZGVyRGF0YVN0b3JhZ2UoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9tZXNoUmVuZGVyRGF0YVN0b3JhZ2VcbiAgICB9XG5cbiAgICBnZXQgbWF0ZXJpYWxTdG9yYWdlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbWF0ZXJpYWxTdG9yYWdlXG4gICAgfVxuXG4gICAgZ2V0IGJ1ZmZlclN0b3JhZ2UoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9idWZmZXJTdG9yYWdlXG4gICAgfVxuXG4gICAgZ2V0IGltYWdlU3RvcmFnZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ltYWdlU3RvcmFnZVxuICAgIH1cblxuICAgIGdldCBzYW1wbGVyU3RvcmFnZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3NhbXBsZXJTdG9yYWdlXG4gICAgfVxuXG4gICAgZ2V0IGNhbWVyYSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NhbWVyYVxuICAgIH1cblxuICAgIHNldCBjYW1lcmEodmFsdWUpIHtcbiAgICAgICAgdGhpcy5fY2FtZXJhID0gdmFsdWVcbiAgICB9XG5cbiAgICBnZXQgZW5naW5lKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZW5naW5lIGFzIElFbmdpbmVcbiAgICB9XG5cbiAgICBwdWJsaWMgYXN5bmMgdXBsb2FkTW9kZWwoXG4gICAgICAgIHByb3BzOiBJU2NlbmVVcGxvYWRNb2RlbFByb3BzXG4gICAgKTogUHJvbWlzZTxJR2FtZU9iamVjdD4ge1xuICAgICAgICBpZiAoIXRoaXMuX2VuZ2luZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgICAgICdGYWlsZWQgdG8gdXBsb2FkIG1vZGVsIGFzIG5vIGluc3RhbmNlIG9mIFdoZWV6eSBFbmdpbmUgaXMgZm91bmQnXG4gICAgICAgICAgICApXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gTW9kZWxVcGxvYWRlci51cGxvYWRNb2RlbChcbiAgICAgICAgICAgIHByb3BzLm1vZGVsRGF0YSxcbiAgICAgICAgICAgIHRoaXMuX29iamVjdE1hbmFnZXIsXG4gICAgICAgICAgICB0aGlzLl9idWZmZXJTdG9yYWdlLFxuICAgICAgICAgICAgdGhpcy5faW1hZ2VTdG9yYWdlLFxuICAgICAgICAgICAgdGhpcy5fc2FtcGxlclN0b3JhZ2UsXG4gICAgICAgICAgICB0aGlzLl9tYXRlcmlhbFN0b3JhZ2UsXG4gICAgICAgICAgICB0aGlzLl90ZXh0dXJlU3RvcmFnZSxcbiAgICAgICAgICAgIHRoaXMuX3Jvb3QsXG4gICAgICAgICAgICB0aGlzLl9lbmdpbmUucmVuZGVyZXIuZGV2aWNlXG4gICAgICAgIClcbiAgICB9XG5cbiAgICBwdWJsaWMgb25SZW5kZXIoXzogbnVtYmVyKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgICdvblJlbmRlciBtZXRob2Qgc2hvdWxkIGJlIHJlZGVmaW5lZCBpbiBleHRlbmRpbmcgY2xhc3MnXG4gICAgICAgIClcbiAgICB9XG59XG4iLCJleHBvcnQgKiBmcm9tICcuL1NjZW5lJ1xuIiwiaW1wb3J0IHtcbiAgICBFbnRpdHlJRCxcbiAgICBJU2NlbmVUcmVlLFxuICAgIFNjZW5lTm9kZSxcbiAgICBTY2VuZU5vZGVDb250ZW50LFxuICAgIFNjZW5lVHJlZVBvc2l0aW9uLFxufSBmcm9tICcuLi8uLi90eXBlcydcblxuZXhwb3J0IGNsYXNzIFNjZW5lVHJlZSBpbXBsZW1lbnRzIElTY2VuZVRyZWUge1xuICAgIF9ub2RlczogU2NlbmVOb2RlID0gbmV3IE1hcCgpXG5cbiAgICBwdWJsaWMgZ2V0Tm9kZUNvbnRlbnRBdChwb3NpdGlvbjogU2NlbmVUcmVlUG9zaXRpb24pIHtcbiAgICAgICAgbGV0IGN1cnJlbnRUcmVlTm9kZSA9IHRoaXMuX25vZGVzLmdldChwb3NpdGlvblswXSlcblxuICAgICAgICBmb3IgKGxldCBpID0gMTsgaSA8IHBvc2l0aW9uLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjdXJyZW50VHJlZU5vZGUgPSBjdXJyZW50VHJlZU5vZGU/LmNoaWxkcmVuPy5nZXQocG9zaXRpb25baV0pXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gY3VycmVudFRyZWVOb2RlID8/IG51bGxcbiAgICB9XG5cbiAgICBwdWJsaWMgYWRkTm9kZUF0KFxuICAgICAgICBwb3NpdGlvbjogU2NlbmVUcmVlUG9zaXRpb24gfCBudWxsLFxuICAgICAgICBub2RlQ29udGVudDogU2NlbmVOb2RlQ29udGVudFxuICAgICk6IFNjZW5lVHJlZVBvc2l0aW9uIHtcbiAgICAgICAgaWYgKCFwb3NpdGlvbikge1xuICAgICAgICAgICAgdGhpcy5fbm9kZXMuc2V0KG5vZGVDb250ZW50LmdhbWVPYmplY3QuaWQsIG5vZGVDb250ZW50KVxuXG4gICAgICAgICAgICByZXR1cm4gW25vZGVDb250ZW50LmdhbWVPYmplY3QuaWRdXG4gICAgICAgIH1cblxuICAgICAgICBsZXQgY3VycmVudFRyZWVOb2RlID0gdGhpcy5nZXROb2RlQ29udGVudEF0KHBvc2l0aW9uKVxuXG4gICAgICAgIGN1cnJlbnRUcmVlTm9kZT8uY2hpbGRyZW4/LnNldChub2RlQ29udGVudC5nYW1lT2JqZWN0LmlkLCBub2RlQ29udGVudClcblxuICAgICAgICByZXR1cm4gWy4uLnBvc2l0aW9uLCBub2RlQ29udGVudC5nYW1lT2JqZWN0LmlkXVxuICAgIH1cblxuICAgIHB1YmxpYyByZXBhcmVudE5vZGUoXG4gICAgICAgIHRhcmdldDogU2NlbmVUcmVlUG9zaXRpb24gfCBudWxsLFxuICAgICAgICBjaGlsZDogU2NlbmVUcmVlUG9zaXRpb25cbiAgICApOiBTY2VuZVRyZWVQb3NpdGlvbiB7XG4gICAgICAgIGNvbnN0IG5vZGVDb250ZW50ID0gdGhpcy5nZXROb2RlQ29udGVudEF0KGNoaWxkKVxuXG4gICAgICAgIGlmICghbm9kZUNvbnRlbnQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgTm8gbm9kZSBmb3VuZCBhdCBwb3NpdGlvbiAke2NoaWxkLmpvaW4oKX1gKVxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgbmV3UG9zaXRpb24gPSB0aGlzLmFkZE5vZGVBdCh0YXJnZXQsIG5vZGVDb250ZW50KVxuICAgICAgICB0aGlzLnJlbW92ZU5vZGUoY2hpbGQpXG5cbiAgICAgICAgcmV0dXJuIG5ld1Bvc2l0aW9uXG4gICAgfVxuXG4gICAgcHVibGljIHJlbW92ZU5vZGUodGFyZ2V0UG9zaXRpb246IFNjZW5lVHJlZVBvc2l0aW9uKTogRW50aXR5SURbXSB7XG4gICAgICAgIGNvbnN0IHBhcmVudFBvc2l0aW9uID0gdGFyZ2V0UG9zaXRpb24uc2xpY2UoXG4gICAgICAgICAgICAwLFxuICAgICAgICAgICAgdGFyZ2V0UG9zaXRpb24ubGVuZ3RoIC0gMVxuICAgICAgICApXG5cbiAgICAgICAgY29uc3QgcGFyZW50Tm9kZSA9IHRoaXMuZ2V0Tm9kZUNvbnRlbnRBdChwYXJlbnRQb3NpdGlvbilcblxuICAgICAgICBjb25zdCBjaGlsZHJlbklkczogRW50aXR5SURbXSA9IFtdXG4gICAgICAgIHRoaXMudHJhdmVyc2VOb2RlKHBhcmVudE5vZGU/LmNoaWxkcmVuLCAobm9kZUlkKSA9PiB7XG4gICAgICAgICAgICBjaGlsZHJlbklkcy5wdXNoKG5vZGVJZClcbiAgICAgICAgfSlcblxuICAgICAgICBwYXJlbnROb2RlPy5jaGlsZHJlbj8uZGVsZXRlKHRhcmdldFBvc2l0aW9uW3RhcmdldFBvc2l0aW9uLmxlbmd0aCAtIDFdKVxuXG4gICAgICAgIHJldHVybiBjaGlsZHJlbklkc1xuICAgIH1cblxuICAgIHByaXZhdGUgdHJhdmVyc2VOb2RlKFxuICAgICAgICBub2RlOiBTY2VuZU5vZGUgfCBudWxsIHwgdW5kZWZpbmVkLFxuICAgICAgICBjYWxsYmFjazogKG5vZGVJZDogRW50aXR5SUQsIG5vZGVDb250ZW50OiBTY2VuZU5vZGVDb250ZW50KSA9PiB2b2lkXG4gICAgKSB7XG4gICAgICAgIGNvbnN0IGl0ZXJhdGUgPSAoc2NlbmVOb2RlPzogU2NlbmVOb2RlIHwgbnVsbCkgPT4ge1xuICAgICAgICAgICAgaWYgKCFzY2VuZU5vZGUpIHJldHVyblxuXG4gICAgICAgICAgICBzY2VuZU5vZGUuZm9yRWFjaCgodmFsdWUsIGtleSkgPT4ge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKGtleSwgdmFsdWUpXG4gICAgICAgICAgICAgICAgaXRlcmF0ZSh2YWx1ZS5jaGlsZHJlbilcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH1cblxuICAgICAgICBpdGVyYXRlKG5vZGUpXG4gICAgfVxuXG4gICAgZ2V0IG5vZGVzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbm9kZXNcbiAgICB9XG59XG4iLCJleHBvcnQgKiBmcm9tICcuL1NjZW5lVHJlZSdcbiIsImltcG9ydCB7IERFRkFVTFRfSU1BR0VfSURTLCBERUZBVUxUX1NBTVBMRVJfSURTIH0gZnJvbSAnLi4vLi4vdHlwZXMnXG5pbXBvcnQgeyBJVGV4dHVyZSwgSVRleHR1cmVTdG9yYWdlIH0gZnJvbSAnLi4vLi4vdHlwZXMvY29yZS9UZXh0dXJlU3RvcmFnZSdcblxuZXhwb3J0IGNsYXNzIFRleHR1cmVTdG9yYWdlIGltcGxlbWVudHMgSVRleHR1cmVTdG9yYWdlIHtcbiAgICBfdGV4dHVyZXM6IE1hcDxzdHJpbmcsIElUZXh0dXJlPiA9IG5ldyBNYXAoKVxuXG4gICAgZ2V0IHRleHR1cmVzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fdGV4dHVyZXNcbiAgICB9XG5cbiAgICBnZXQgZGVmYXVsdEJhc2VDb2xvcigpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHNhbXBsZXJJZDogREVGQVVMVF9TQU1QTEVSX0lEUy5iYXNlQ29sb3IsXG4gICAgICAgICAgICBpbWFnZUlkOiBERUZBVUxUX0lNQUdFX0lEUy5iYXNlQ29sb3IsXG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0IGRlZmF1bHRNZXRhbGxpY1JvdWdobmVzcygpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHNhbXBsZXJJZDogREVGQVVMVF9TQU1QTEVSX0lEUy5tZXRhbGxpY1JvdWdobmVzcyxcbiAgICAgICAgICAgIGltYWdlSWQ6IERFRkFVTFRfSU1BR0VfSURTLm1ldGFsbGljUm91Z2huZXNzLFxuICAgICAgICB9XG4gICAgfVxuICAgIGdldCBkZWZhdWx0RW1pc3Npb24oKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBzYW1wbGVySWQ6IERFRkFVTFRfU0FNUExFUl9JRFMuZW1pc3Npb24sXG4gICAgICAgICAgICBpbWFnZUlkOiBERUZBVUxUX0lNQUdFX0lEUy5lbWlzc2lvbixcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXQgZGVmYXVsdE5vcm1hbCgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHNhbXBsZXJJZDogREVGQVVMVF9TQU1QTEVSX0lEUy5ub3JtYWwsXG4gICAgICAgICAgICBpbWFnZUlkOiBERUZBVUxUX0lNQUdFX0lEUy5ub3JtYWwsXG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0IGRlZmF1bHRPY2NsdXNpb24oKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBzYW1wbGVySWQ6IERFRkFVTFRfU0FNUExFUl9JRFMub2NjbHVzaW9uLFxuICAgICAgICAgICAgaW1hZ2VJZDogREVGQVVMVF9JTUFHRV9JRFMuYmFzZUNvbG9yLFxuICAgICAgICB9XG4gICAgfVxufVxuIiwiZXhwb3J0ICogZnJvbSAnLi9UZXh0dXJlU3RvcmFnZSdcbiIsImltcG9ydCB7IG1hdDQsIHZlYzMsIFZlYzMsIHZlYzQsIFZlYzQgfSBmcm9tICd3Z3B1LW1hdHJpeCdcbmltcG9ydCB7XG4gICAgRW50aXR5VHlwZXMsXG4gICAgSUdhbWVPYmplY3QsXG4gICAgSVJvdGF0ZVJhZGlhbnNQcm9wcyxcbiAgICBUcmFuc2Zvcm1hdGlvbk1hdHJpeCxcbn0gZnJvbSAnLi4vLi4vdHlwZXMnXG5pbXBvcnQgeyBJVHJhbnNmb3JtIH0gZnJvbSAnLi4vLi4vdHlwZXMnXG5pbXBvcnQgeyBDb21wb25lbnQgfSBmcm9tICcuLi9Db21wb25lbnQnXG5cbmV4cG9ydCBjbGFzcyBUcmFuc2Zvcm1cbiAgICBleHRlbmRzIENvbXBvbmVudDxFbnRpdHlUeXBlcy50cmFuc2Zvcm0+XG4gICAgaW1wbGVtZW50cyBJVHJhbnNmb3JtXG57XG4gICAgbWF0cml4OiBUcmFuc2Zvcm1hdGlvbk1hdHJpeFxuXG4gICAgcHJpdmF0ZSBfcG9zaXRpb246IEZsb2F0MzJBcnJheVxuXG4gICAgY29uc3RydWN0b3IocGFyZW50OiBJR2FtZU9iamVjdCwgbWF0cml4PzogVHJhbnNmb3JtYXRpb25NYXRyaXgpIHtcbiAgICAgICAgc3VwZXIocGFyZW50LCBFbnRpdHlUeXBlcy50cmFuc2Zvcm0pXG4gICAgICAgIHRoaXMubWF0cml4ID0gbWF0cml4ID8gbWF0NC5jb3B5KG1hdHJpeCkgOiBtYXQ0LmlkZW50aXR5KClcbiAgICAgICAgdGhpcy5fcG9zaXRpb24gPSBuZXcgRmxvYXQzMkFycmF5KHRoaXMubWF0cml4LmJ1ZmZlciwgNCAqIDEyLCA0KVxuICAgIH1cblxuICAgIGdldCBwb3NpdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3Bvc2l0aW9uXG4gICAgfVxuXG4gICAgc2V0IHBvc2l0aW9uKHZhbHVlOiBWZWM0KSB7XG4gICAgICAgIHZlYzQuY29weSh2YWx1ZSwgdGhpcy5fcG9zaXRpb24pXG4gICAgfVxuXG4gICAgc2NhbGUodmFsdWU6IFZlYzMpIHtcbiAgICAgICAgbWF0NC5zY2FsZSh0aGlzLm1hdHJpeCwgdmFsdWUsIHRoaXMubWF0cml4KVxuICAgIH1cblxuICAgIHRyYW5zbGF0ZSh2YWx1ZTogVmVjMykge1xuICAgICAgICB0aGlzLl9wb3NpdGlvbiA9IHZlYzMuY29weSh2YWx1ZSwgdGhpcy5fcG9zaXRpb24pXG4gICAgfVxuXG4gICAgcm90YXRlUmFkaWFucyh7IHgsIHksIHogfTogSVJvdGF0ZVJhZGlhbnNQcm9wcykge1xuICAgICAgICBjb25zdCBuZXdNYXRyaXggPSBtYXQ0LmNvcHkodGhpcy5tYXRyaXgpXG5cbiAgICAgICAgeCAmJiBtYXQ0LnJvdGF0ZVgobmV3TWF0cml4LCB4LCBuZXdNYXRyaXgpXG4gICAgICAgIHkgJiYgbWF0NC5yb3RhdGVZKG5ld01hdHJpeCwgeSwgbmV3TWF0cml4KVxuICAgICAgICB6ICYmIG1hdDQucm90YXRlWihuZXdNYXRyaXgsIHosIG5ld01hdHJpeClcblxuICAgICAgICBtYXQ0LmNvcHkobmV3TWF0cml4LCB0aGlzLm1hdHJpeClcbiAgICB9XG5cbiAgICByb3RhdGVEZWdyZWVzRXVsZXIoeyB4LCB5LCB6IH06IElSb3RhdGVSYWRpYW5zUHJvcHMpIHtcbiAgICAgICAgY29uc3QgZGVncmVlVG9SYWQgPSAwLjAxNzQ1MzI5MjUyXG4gICAgICAgIHRoaXMucm90YXRlUmFkaWFucyh7XG4gICAgICAgICAgICB4OiAoeCA/PyAwKSAqIGRlZ3JlZVRvUmFkLFxuICAgICAgICAgICAgeTogKHkgPz8gMCkgKiBkZWdyZWVUb1JhZCxcbiAgICAgICAgICAgIHo6ICh6ID8/IDApICogZGVncmVlVG9SYWQsXG4gICAgICAgIH0pXG4gICAgfVxufVxuIiwiZXhwb3J0ICogZnJvbSAnLi9UcmFuc2Zvcm0nXG4iLCJpbXBvcnQgeyBtYXQ0LCBNYXQ0LCBWZWMzLCB2ZWMzIH0gZnJvbSAnd2dwdS1tYXRyaXgnXG5pbXBvcnQgeyBJQXJjQmFsbENhbWVyYSB9IGZyb20gJy4uLy4uLy4uL3R5cGVzL2NvcmUvQ2FtZXJhJ1xuaW1wb3J0IHsgQ2FtZXJhLCBJQ2FtZXJhUHJvcHMgfSBmcm9tICcuLi9DYW1lcmEnXG5cbmV4cG9ydCBpbnRlcmZhY2UgQXJjQmFsbENhbWVyYVByb3BzIGV4dGVuZHMgSUNhbWVyYVByb3BzIHt9XG5cbmV4cG9ydCBjbGFzcyBBcmNCYWxsQ2FtZXJhIGV4dGVuZHMgQ2FtZXJhIGltcGxlbWVudHMgSUFyY0JhbGxDYW1lcmEge1xuICAgIHByaXZhdGUgX2Rpc3RhbmNlID0gMFxuICAgIHByaXZhdGUgX2F4aXMgPSB2ZWMzLmNyZWF0ZSgpXG5cbiAgICBjb25zdHJ1Y3Rvcihwcm9wczogQXJjQmFsbENhbWVyYVByb3BzKSB7XG4gICAgICAgIHN1cGVyKHByb3BzKVxuXG4gICAgICAgIGNvbnN0IHBvc2l0aW9uVmVjID0gcHJvcHM/LnBvc2l0aW9uID8/IHZlYzMuY3JlYXRlKDAsIDAsIDApXG4gICAgICAgIHN1cGVyLnBvc2l0aW9uID0gcG9zaXRpb25WZWNcbiAgICAgICAgdGhpcy5fZGlzdGFuY2UgPSB2ZWMzLmxlbihzdXBlci5wb3NpdGlvbilcbiAgICAgICAgc3VwZXIuYmFjayA9IHZlYzMubm9ybWFsaXplKHN1cGVyLnBvc2l0aW9uKVxuICAgICAgICB0aGlzLnJlY2FsY3VsYXRlUmlnaHQoKVxuICAgICAgICB0aGlzLnJlY2FsY3VsYXRlVXAoKVxuICAgICAgICBzdXBlci52aWV3ID0gbWF0NC5pbnZlcnQoc3VwZXIubWF0cml4KVxuICAgIH1cblxuICAgIGdldCBheGlzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYXhpc1xuICAgIH1cblxuICAgIHNldCBheGlzKHZlYzogVmVjMykge1xuICAgICAgICB2ZWMzLmNvcHkodmVjLCB0aGlzLl9heGlzKVxuICAgIH1cblxuICAgIGdldCBkaXN0YW5jZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2Rpc3RhbmNlXG4gICAgfVxuXG4gICAgc2V0IGRpc3RhbmNlKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuX2Rpc3RhbmNlID0gdmFsdWVcbiAgICB9XG5cbiAgICBnZXQgbWF0cml4KCkge1xuICAgICAgICByZXR1cm4gc3VwZXIubWF0cml4XG4gICAgfVxuXG4gICAgc2V0IG1hdHJpeChtYXQ6IE1hdDQpIHtcbiAgICAgICAgc3VwZXIubWF0cml4ID0gbWF0XG4gICAgICAgIHRoaXMuX2Rpc3RhbmNlID0gdmVjMy5sZW4oc3VwZXIucG9zaXRpb24pXG4gICAgfVxuXG4gICAgcmVjYWxjdWxhdGVSaWdodCgpIHtcbiAgICAgICAgc3VwZXIucmlnaHQgPSB2ZWMzLm5vcm1hbGl6ZSh2ZWMzLmNyb3NzKHN1cGVyLnVwLCBzdXBlci5iYWNrKSlcbiAgICB9XG5cbiAgICByZWNhbGN1bGF0ZVVwKCkge1xuICAgICAgICBzdXBlci51cCA9IHZlYzMubm9ybWFsaXplKHZlYzMuY3Jvc3Moc3VwZXIuYmFjaywgc3VwZXIucmlnaHQpKVxuICAgIH1cbn1cbiIsImV4cG9ydCAqIGZyb20gJy4vQXJjQmFsbENhbWVyYSdcbiIsImltcG9ydCB7IE1hdDQsIG1hdDQsIHZlYzMsIFZlYzMgfSBmcm9tICd3Z3B1LW1hdHJpeCdcbmltcG9ydCB7IEVudGl0eVR5cGVzIH0gZnJvbSAnLi4vLi4vLi4vdHlwZXMnXG5pbXBvcnQgeyBFbnRpdHkgfSBmcm9tICcuLi8uLi9FbnRpdHknXG5pbXBvcnQgeyBJQ2FtZXJhIH0gZnJvbSAnLi4vLi4vLi4vdHlwZXMvY29yZS9DYW1lcmEnXG5cbmV4cG9ydCBpbnRlcmZhY2UgSUNhbWVyYVByb3BzIHtcbiAgICB6RmFyPzogbnVtYmVyXG4gICAgek5lYXI/OiBudW1iZXJcbiAgICBwb3NpdGlvbj86IFZlYzNcbiAgICB0YXJnZXQ/OiBWZWMzXG4gICAgY2FudmFzV2lkdGg6IG51bWJlclxuICAgIGNhbnZhc0hlaWdodDogbnVtYmVyXG59XG5cbmV4cG9ydCBjbGFzcyBDYW1lcmEgZXh0ZW5kcyBFbnRpdHk8RW50aXR5VHlwZXMuY2FtZXJhPiBpbXBsZW1lbnRzIElDYW1lcmEge1xuICAgIHByaXZhdGUgcmVhZG9ubHkgX3ZpZXcgPSBtYXQ0LmNyZWF0ZSgpXG5cbiAgICBwcml2YXRlIF9tYXRyaXggPSBuZXcgRmxvYXQzMkFycmF5KFtcbiAgICAgICAgMSwgMCwgMCwgMCwgMCwgMSwgMCwgMCwgMCwgMCwgMSwgMCwgMCwgMCwgMCwgMSxcbiAgICBdKVxuICAgIHByaXZhdGUgX3JpZ2h0ID0gbmV3IEZsb2F0MzJBcnJheSh0aGlzLl9tYXRyaXguYnVmZmVyLCA0ICogMCwgNClcbiAgICBwcml2YXRlIF91cCA9IG5ldyBGbG9hdDMyQXJyYXkodGhpcy5fbWF0cml4LmJ1ZmZlciwgNCAqIDQsIDQpXG4gICAgcHJpdmF0ZSBfYmFjayA9IG5ldyBGbG9hdDMyQXJyYXkodGhpcy5fbWF0cml4LmJ1ZmZlciwgNCAqIDgsIDQpXG4gICAgcHJpdmF0ZSBfcG9zaXRpb24gPSBuZXcgRmxvYXQzMkFycmF5KHRoaXMuX21hdHJpeC5idWZmZXIsIDQgKiAxMiwgNClcblxuICAgIHByaXZhdGUgX3pGYXI6IG51bWJlclxuICAgIHByaXZhdGUgX3pOZWFyOiBudW1iZXJcbiAgICBwcml2YXRlIF9hc3BlY3RSYXRpbzogbnVtYmVyXG4gICAgcHJpdmF0ZSBfcHJvamVjdGlvbk1hdHJpeFxuXG4gICAgY29uc3RydWN0b3IocHJvcHM6IElDYW1lcmFQcm9wcykge1xuICAgICAgICBzdXBlcihFbnRpdHlUeXBlcy5jYW1lcmEpXG5cbiAgICAgICAgdGhpcy5fekZhciA9IHByb3BzPy56RmFyID8/IDEwMDBcbiAgICAgICAgdGhpcy5fek5lYXIgPSBwcm9wcz8uek5lYXIgPz8gMC4xXG4gICAgICAgIHRoaXMuX2FzcGVjdFJhdGlvID0gcHJvcHMuY2FudmFzV2lkdGggLyBwcm9wcy5jYW52YXNIZWlnaHRcbiAgICAgICAgdGhpcy5fcHJvamVjdGlvbk1hdHJpeCA9IG1hdDQucGVyc3BlY3RpdmUoXG4gICAgICAgICAgICAoMiAqIE1hdGguUEkpIC8gNSxcbiAgICAgICAgICAgIHRoaXMuX2FzcGVjdFJhdGlvLFxuICAgICAgICAgICAgdGhpcy5fek5lYXIsXG4gICAgICAgICAgICB0aGlzLl96RmFyXG4gICAgICAgIClcbiAgICB9XG5cbiAgICBnZXQgYXNwZWN0UmF0aW8oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hc3BlY3RSYXRpb1xuICAgIH1cblxuICAgIGdldCB6RmFyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fekZhclxuICAgIH1cblxuICAgIGdldCB6TmVhcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3pOZWFyXG4gICAgfVxuXG4gICAgZ2V0IHByb2plY3Rpb25NYXRyaXgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wcm9qZWN0aW9uTWF0cml4XG4gICAgfVxuXG4gICAgZ2V0IHZpZXcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl92aWV3XG4gICAgfVxuXG4gICAgc2V0IHZpZXcobWF0OiBNYXQ0KSB7XG4gICAgICAgIG1hdDQuY29weShtYXQsIHRoaXMuX3ZpZXcpXG4gICAgfVxuXG4gICAgZ2V0IHJpZ2h0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcmlnaHRcbiAgICB9XG5cbiAgICBzZXQgcmlnaHQodmVjOiBWZWMzKSB7XG4gICAgICAgIHZlYzMuY29weSh2ZWMsIHRoaXMuX3JpZ2h0KVxuICAgIH1cblxuICAgIGdldCB1cCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3VwXG4gICAgfVxuXG4gICAgc2V0IHVwKHZlYzogVmVjMykge1xuICAgICAgICB2ZWMzLmNvcHkodmVjLCB0aGlzLl91cClcbiAgICB9XG5cbiAgICBnZXQgYmFjaygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2JhY2tcbiAgICB9XG5cbiAgICBzZXQgYmFjayh2ZWM6IFZlYzMpIHtcbiAgICAgICAgdmVjMy5jb3B5KHZlYywgdGhpcy5fYmFjaylcbiAgICB9XG5cbiAgICBnZXQgbWF0cml4KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbWF0cml4XG4gICAgfVxuXG4gICAgc2V0IG1hdHJpeCh2YWx1ZTogTWF0NCkge1xuICAgICAgICB0aGlzLl9tYXRyaXggPSBtYXQ0LmNvcHkodmFsdWUsIHRoaXMuX21hdHJpeClcbiAgICB9XG5cbiAgICBnZXQgcG9zaXRpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wb3NpdGlvblxuICAgIH1cblxuICAgIHNldCBwb3NpdGlvbih2YWx1ZTogVmVjMykge1xuICAgICAgICB2ZWMzLmNvcHkodmFsdWUsIHRoaXMuX3Bvc2l0aW9uKVxuICAgIH1cbn1cbiIsImV4cG9ydCAqIGZyb20gJy4vQ2FtZXJhJ1xuIiwiaW1wb3J0IHsgTWF0NCwgbWF0NCwgdmVjMywgVmVjMywgdmVjNCB9IGZyb20gJ3dncHUtbWF0cml4J1xuaW1wb3J0IHsgU3R1ZmYgfSBmcm9tICcuLi8uLi8uLi8uLi91dGlscy9TdHVmZidcbmltcG9ydCB7IENhbWVyYSwgSUNhbWVyYVByb3BzIH0gZnJvbSAnLi4vQ2FtZXJhL0NhbWVyYSdcbmltcG9ydCB7IElQZXJzcGVjdGl2ZUNhbWVyYSB9IGZyb20gJy4uLy4uLy4uL3R5cGVzL2NvcmUvQ2FtZXJhJ1xuXG5leHBvcnQgaW50ZXJmYWNlIFBlcnNwZWN0aXZlQ2FtZXJhUHJvcHMgZXh0ZW5kcyBJQ2FtZXJhUHJvcHMge31cblxuZXhwb3J0IGNsYXNzIFBlcnNwZWN0aXZlQ2FtZXJhIGV4dGVuZHMgQ2FtZXJhIGltcGxlbWVudHMgSVBlcnNwZWN0aXZlQ2FtZXJhIHtcbiAgICBwdWJsaWMgcGl0Y2ggPSAwXG4gICAgcHVibGljIHlhdyA9IDBcblxuICAgIGNvbnN0cnVjdG9yKHByb3BzOiBQZXJzcGVjdGl2ZUNhbWVyYVByb3BzKSB7XG4gICAgICAgIHN1cGVyKHByb3BzKVxuXG4gICAgICAgIGNvbnN0IHBvc2l0aW9uVmVjID0gcHJvcHM/LnBvc2l0aW9uID8/IHZlYzMuY3JlYXRlKDAsIDAsIDApXG4gICAgICAgIGNvbnN0IHRhcmdldFZlYyA9IHByb3BzPy50YXJnZXQgPz8gdmVjMy5jb3B5KHBvc2l0aW9uVmVjKVxuICAgICAgICBjb25zdCBiYWNrID0gdmVjMy5ub3JtYWxpemUodmVjMy5zdWIocG9zaXRpb25WZWMsIHRhcmdldFZlYykpXG4gICAgICAgIHRoaXMuX3JlY2FsY3VsYXRlQW5nbGVzKGJhY2spXG4gICAgICAgIHN1cGVyLnBvc2l0aW9uID0gcG9zaXRpb25WZWNcbiAgICB9XG5cbiAgICBwcml2YXRlIF9yZWNhbGN1bGF0ZUFuZ2xlcyhkaXJlY3Rpb246IFZlYzMpIHtcbiAgICAgICAgdGhpcy55YXcgPSBNYXRoLmF0YW4yKGRpcmVjdGlvblswXSwgZGlyZWN0aW9uWzJdKVxuICAgICAgICB0aGlzLnBpdGNoID0gLU1hdGguYXNpbihkaXJlY3Rpb25bMV0pXG4gICAgfVxuXG4gICAgdXBkYXRlKCk6IE1hdDQge1xuICAgICAgICB0aGlzLnlhdyA9IFN0dWZmLm1vZCh0aGlzLnlhdywgTWF0aC5QSSAqIDIpXG4gICAgICAgIHRoaXMucGl0Y2ggPSBTdHVmZi5jbGFtcCh0aGlzLnBpdGNoLCAtTWF0aC5QSSAvIDIsIE1hdGguUEkgLyAyKVxuXG4gICAgICAgIGNvbnN0IHBvc2l0aW9uID0gdmVjMy5jb3B5KHN1cGVyLnBvc2l0aW9uKVxuICAgICAgICBzdXBlci5tYXRyaXggPSBtYXQ0LnJvdGF0ZVgobWF0NC5yb3RhdGlvblkodGhpcy55YXcpLCB0aGlzLnBpdGNoKVxuICAgICAgICBzdXBlci5wb3NpdGlvbiA9IHBvc2l0aW9uXG5cbiAgICAgICAgc3VwZXIudmlldyA9IG1hdDQuaW52ZXJ0KHN1cGVyLm1hdHJpeClcblxuICAgICAgICByZXR1cm4gc3VwZXIudmlld1xuICAgIH1cbn1cbiIsImV4cG9ydCAqIGZyb20gJy4vUGVyc3BlY3RpdmVDYW1lcmEnXG4iLCJleHBvcnQgKiBmcm9tICcuL0NvbXBvbmVudCdcbmV4cG9ydCAqIGZyb20gJy4vRW50aXR5J1xuZXhwb3J0ICogZnJvbSAnLi9HYW1lT2JqZWN0J1xuZXhwb3J0ICogZnJvbSAnLi9PYmplY3RNYW5hZ2VyJ1xuZXhwb3J0ICogZnJvbSAnLi9TY2VuZVRyZWUnXG5leHBvcnQgKiBmcm9tICcuL1RyYW5zZm9ybSdcbmV4cG9ydCAqIGZyb20gJy4vTWVzaCdcbmV4cG9ydCAqIGZyb20gJy4vQnVmZmVyU3RvcmFnZSdcbmV4cG9ydCAqIGZyb20gJy4vSW1hZ2VTdG9yYWdlJ1xuZXhwb3J0ICogZnJvbSAnLi9TYW1wbGVyU3RvcmFnZSdcbmV4cG9ydCAqIGZyb20gJy4vVGV4dHVyZVN0b3JhZ2UnXG5leHBvcnQgKiBmcm9tICcuL01hdGVyaWFsU3RvcmFnZSdcbmV4cG9ydCAqIGZyb20gJy4vY2FtZXJhcy9DYW1lcmEnXG5leHBvcnQgKiBmcm9tICcuL2NhbWVyYXMvUGVyc3BlY3RpdmVDYW1lcmEnXG5leHBvcnQgKiBmcm9tICcuL0VuZ2luZSdcbmV4cG9ydCAqIGZyb20gJy4vU2NlbmUnXG5leHBvcnQgKiBmcm9tICcuL1JlbmRlcmVyJ1xuZXhwb3J0ICogZnJvbSAnLi9saWdodHMnXG4iLCJpbXBvcnQgeyBNYXQ0LCBtYXQ0LCB2ZWMzLCBWZWMzLCB2ZWM0LCBWZWM0IH0gZnJvbSAnd2dwdS1tYXRyaXgnXG5pbXBvcnQge1xuICAgIEVudGl0eVR5cGVzLFxuICAgIElMaWdodFNvdXJjZSxcbiAgICBJTGlnaHRTb3VyY2VQcm9wcyxcbiAgICBJVHJhbnNmb3JtLFxuICAgIFRMaWdodFNvdXJjZVR5cGUsXG59IGZyb20gJy4uLy4uLy4uL3R5cGVzJ1xuaW1wb3J0IHsgQ29tcG9uZW50IH0gZnJvbSAnLi4vLi4vQ29tcG9uZW50J1xuaW1wb3J0IHsgVHJhbnNmb3JtIH0gZnJvbSAnLi4vLi4vVHJhbnNmb3JtJ1xuXG5leHBvcnQgaW50ZXJmYWNlIElCYXNlTGlnaHRQcm9wcyBleHRlbmRzIElMaWdodFNvdXJjZVByb3BzIHtcbiAgICBsaWdodFNvdXJjZVR5cGU6IFRMaWdodFNvdXJjZVR5cGVcbiAgICBwb3NpdGlvbj86IFZlYzRcbiAgICB0YXJnZXQ/OiBWZWMzXG59XG5cbmNvbnN0IGxlZnQgPSAtMlxuY29uc3QgcmlnaHQgPSAyXG5jb25zdCBib3R0b20gPSAtMlxuY29uc3QgdG9wID0gMlxuY29uc3QgbmVhciA9IDAuMVxuY29uc3QgZmFyID0gNTBcblxuZXhwb3J0IGNsYXNzIEJhc2VMaWdodFxuICAgIGV4dGVuZHMgQ29tcG9uZW50PEVudGl0eVR5cGVzLmxpZ2h0PlxuICAgIGltcGxlbWVudHMgSUxpZ2h0U291cmNlXG57XG4gICAgcHVibGljIGNvbG9yOiBWZWMzID0gdmVjMy5jcmVhdGUoMSwgMSwgMSlcblxuICAgIHByaXZhdGUgX2xpZ2h0U291cmNlVHlwZTogVExpZ2h0U291cmNlVHlwZVxuICAgIHByaXZhdGUgX3RyYW5zZm9ybTogSVRyYW5zZm9ybVxuICAgIHByaXZhdGUgX3ZpZXdNYXRyaXg6IE1hdDQgPSBtYXQ0LmlkZW50aXR5KClcbiAgICBwcml2YXRlIF9wcm9qZWN0aW9uTWF0cml4OiBNYXQ0ID0gbWF0NC5vcnRobyhcbiAgICAgICAgbGVmdCxcbiAgICAgICAgcmlnaHQsXG4gICAgICAgIGJvdHRvbSxcbiAgICAgICAgdG9wLFxuICAgICAgICBuZWFyLFxuICAgICAgICBmYXJcbiAgICApXG5cbiAgICBwcml2YXRlIF9yaWdodDogVmVjNFxuICAgIHByaXZhdGUgX3VwOiBWZWM0XG4gICAgcHJpdmF0ZSBfYmFjazogVmVjNFxuICAgIHByaXZhdGUgX3Bvc2l0aW9uOiBWZWM0XG5cbiAgICBwcml2YXRlIF90YXJnZXQ6IFZlYzNcblxuICAgIGNvbnN0cnVjdG9yKHByb3BzOiBJQmFzZUxpZ2h0UHJvcHMpIHtcbiAgICAgICAgc3VwZXIocHJvcHMucGFyZW50LCBFbnRpdHlUeXBlcy5saWdodClcbiAgICAgICAgdGhpcy5fbGlnaHRTb3VyY2VUeXBlID0gcHJvcHMubGlnaHRTb3VyY2VUeXBlXG5cbiAgICAgICAgdGhpcy5fdHJhbnNmb3JtID0gbmV3IFRyYW5zZm9ybShwcm9wcy5wYXJlbnQpXG5cbiAgICAgICAgdGhpcy5fcmlnaHQgPSBuZXcgRmxvYXQzMkFycmF5KHRoaXMuX3ZpZXdNYXRyaXguYnVmZmVyLCA0ICogMCwgNClcbiAgICAgICAgdGhpcy5fdXAgPSBuZXcgRmxvYXQzMkFycmF5KHRoaXMuX3ZpZXdNYXRyaXguYnVmZmVyLCA0ICogNCwgNClcbiAgICAgICAgdGhpcy5fYmFjayA9IG5ldyBGbG9hdDMyQXJyYXkodGhpcy5fdmlld01hdHJpeC5idWZmZXIsIDQgKiA4LCA0KVxuICAgICAgICB0aGlzLl9wb3NpdGlvbiA9IG5ldyBGbG9hdDMyQXJyYXkodGhpcy5fdmlld01hdHJpeC5idWZmZXIsIDQgKiAxMiwgNClcblxuICAgICAgICB0aGlzLl90YXJnZXQgPSBwcm9wcz8udGFyZ2V0ID8/IHZlYzMuY29weSh0aGlzLnBvc2l0aW9uKVxuICAgICAgICB0aGlzLl9iYWNrID0gdmVjMy5ub3JtYWxpemUodmVjMy5zdWIodGhpcy5wb3NpdGlvbiwgdGhpcy50YXJnZXQpKVxuXG4gICAgICAgIHZlYzQuY29weShwcm9wcz8ucG9zaXRpb24gPz8gdmVjNC5jcmVhdGUoMCwgMCwgMTAsIDEpLCB0aGlzLnBvc2l0aW9uKVxuXG4gICAgICAgIHRoaXMuX3ZpZXdNYXRyaXggPSBtYXQ0Lmxvb2tBdCh0aGlzLnBvc2l0aW9uLCB0aGlzLnRhcmdldCwgdGhpcy51cClcbiAgICB9XG5cbiAgICBwcml2YXRlIF9yZWNhbGN1bGF0ZVJpZ2h0KCkge1xuICAgICAgICB0aGlzLl9yaWdodCA9IHZlYzMubm9ybWFsaXplKHZlYzMuY3Jvc3ModGhpcy51cCwgdGhpcy5iYWNrKSlcbiAgICB9XG5cbiAgICBwcml2YXRlIF9yZWNhbGN1bGF0ZVVwKCkge1xuICAgICAgICB0aGlzLl91cCA9IHZlYzMubm9ybWFsaXplKHZlYzMuY3Jvc3ModGhpcy5iYWNrLCB0aGlzLnJpZ2h0KSlcbiAgICB9XG5cbiAgICBwcml2YXRlIF9yZWNhbGN1bGF0ZUJhY2soKSB7XG4gICAgICAgIHRoaXMuX2JhY2sgPSB2ZWMzLm5vcm1hbGl6ZSh2ZWMzLnN1Yih0aGlzLnBvc2l0aW9uLCB0aGlzLnRhcmdldCkpXG4gICAgfVxuXG4gICAgZ2V0IHRyYW5zZm9ybSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3RyYW5zZm9ybVxuICAgIH1cblxuICAgIGdldCB0YXJnZXQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl90YXJnZXRcbiAgICB9XG5cbiAgICBzZXQgdGFyZ2V0KHZhbHVlKSB7XG4gICAgICAgIHZlYzMuY29weSh2YWx1ZSwgdGhpcy5fdGFyZ2V0KVxuICAgICAgICB0aGlzLl9yZWNhbGN1bGF0ZUJhY2soKVxuICAgIH1cblxuICAgIGdldCBwb3NpdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3Bvc2l0aW9uXG4gICAgfVxuXG4gICAgc2V0IHBvc2l0aW9uKHZhbHVlKSB7XG4gICAgICAgIC8vRklYTUU6IHRoYXQgZG9lc250IHdvcmtcbiAgICAgICAgdGhpcy5fdHJhbnNmb3JtLnBvc2l0aW9uID0gdmFsdWVcbiAgICAgICAgdGhpcy5fcmVjYWxjdWxhdGVCYWNrKClcbiAgICB9XG5cbiAgICBnZXQgcmlnaHQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9yaWdodFxuICAgIH1cblxuICAgIGdldCBiYWNrKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYmFja1xuICAgIH1cblxuICAgIGdldCB1cCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3VwXG4gICAgfVxuXG4gICAgZ2V0IGxpZ2h0U291cmNlVHlwZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2xpZ2h0U291cmNlVHlwZVxuICAgIH1cblxuICAgIGdldCB2aWV3TWF0cml4KCkge1xuICAgICAgICByZXR1cm4gbWF0NC5tdWx0aXBseSh0aGlzLl90cmFuc2Zvcm0ubWF0cml4LCB0aGlzLl92aWV3TWF0cml4KVxuICAgIH1cblxuICAgIGdldCBwcm9qZWN0aW9uTWF0cml4KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcHJvamVjdGlvbk1hdHJpeFxuICAgIH1cbn1cbiIsImV4cG9ydCAqIGZyb20gJy4vQmFzZUxpZ2h0J1xuIiwiaW1wb3J0IHsgTElHSFRfU09VUkNFX1RZUEVTIH0gZnJvbSAnLi4vLi4vLi4vdHlwZXMnXG5pbXBvcnQgeyBCYXNlTGlnaHQsIElCYXNlTGlnaHRQcm9wcyB9IGZyb20gJy4uL0Jhc2VMaWdodCdcblxuZXhwb3J0IGludGVyZmFjZSBJRGlyZWN0aW9uYWxMaWdodFByb3BzXG4gICAgZXh0ZW5kcyBPbWl0PElCYXNlTGlnaHRQcm9wcywgJ2xpZ2h0U291cmNlVHlwZSc+IHt9XG5cbmV4cG9ydCBjbGFzcyBEaXJlY3Rpb25hbExpZ2h0IGV4dGVuZHMgQmFzZUxpZ2h0IHtcbiAgICBjb25zdHJ1Y3Rvcihwcm9wczogSURpcmVjdGlvbmFsTGlnaHRQcm9wcykge1xuICAgICAgICBzdXBlcih7IC4uLnByb3BzLCBsaWdodFNvdXJjZVR5cGU6IExJR0hUX1NPVVJDRV9UWVBFUy5kaXJlY3Rpb25hbCB9KVxuICAgIH1cbn1cbiIsImV4cG9ydCAqIGZyb20gJy4vRGlyZWN0aW9uYWxMaWdodCdcbiIsImV4cG9ydCAqIGZyb20gJy4vRGlyZWN0aW9uYWxMaWdodCdcbiIsImV4cG9ydCBjb25zdCBjdWJlVmVydGV4U2l6ZSA9IDQgKiAxMCAvLyBCeXRlIHNpemUgb2Ygb25lIGN1YmUgdmVydGV4LlxuZXhwb3J0IGNvbnN0IGN1YmVQb3NpdGlvbk9mZnNldCA9IDBcbmV4cG9ydCBjb25zdCBjdWJlQ29sb3JPZmZzZXQgPSA0ICogNCAvLyBCeXRlIG9mZnNldCBvZiBjdWJlIHZlcnRleCBjb2xvciBhdHRyaWJ1dGUuXG5leHBvcnQgY29uc3QgY3ViZVVWT2Zmc2V0ID0gNCAqIDhcbmV4cG9ydCBjb25zdCBjdWJlVmVydGV4Q291bnQgPSAzNlxuXG4vLyBwcmV0dGllci1pZ25vcmVcbmV4cG9ydCBjb25zdCBjdWJlVmVydGV4QXJyYXkgPSBuZXcgRmxvYXQzMkFycmF5KFtcbiAgLy8gZmxvYXQ0IHBvc2l0aW9uLCBmbG9hdDQgY29sb3IsIGZsb2F0MiB1dixcbiAgMSwgLTEsIDEsIDEsICAgMSwgMCwgMSwgMSwgIDAsIDEsXG4gIC0xLCAtMSwgMSwgMSwgIDAsIDAsIDEsIDEsICAxLCAxLFxuICAtMSwgLTEsIC0xLCAxLCAwLCAwLCAwLCAxLCAgMSwgMCxcbiAgMSwgLTEsIC0xLCAxLCAgMSwgMCwgMCwgMSwgIDAsIDAsXG4gIDEsIC0xLCAxLCAxLCAgIDEsIDAsIDEsIDEsICAwLCAxLFxuICAtMSwgLTEsIC0xLCAxLCAwLCAwLCAwLCAxLCAgMSwgMCxcblxuICAxLCAxLCAxLCAxLCAgICAxLCAxLCAxLCAxLCAgMCwgMSxcbiAgMSwgLTEsIDEsIDEsICAgMSwgMCwgMSwgMSwgIDEsIDEsXG4gIDEsIC0xLCAtMSwgMSwgIDEsIDAsIDAsIDEsICAxLCAwLFxuICAxLCAxLCAtMSwgMSwgICAxLCAxLCAwLCAxLCAgMCwgMCxcbiAgMSwgMSwgMSwgMSwgICAgMSwgMSwgMSwgMSwgIDAsIDEsXG4gIDEsIC0xLCAtMSwgMSwgIDEsIDAsIDAsIDEsICAxLCAwLFxuXG4gIC0xLCAxLCAxLCAxLCAgIDAsIDEsIDEsIDEsICAwLCAxLFxuICAxLCAxLCAxLCAxLCAgICAxLCAxLCAxLCAxLCAgMSwgMSxcbiAgMSwgMSwgLTEsIDEsICAgMSwgMSwgMCwgMSwgIDEsIDAsXG4gIC0xLCAxLCAtMSwgMSwgIDAsIDEsIDAsIDEsICAwLCAwLFxuICAtMSwgMSwgMSwgMSwgICAwLCAxLCAxLCAxLCAgMCwgMSxcbiAgMSwgMSwgLTEsIDEsICAgMSwgMSwgMCwgMSwgIDEsIDAsXG5cbiAgLTEsIC0xLCAxLCAxLCAgMCwgMCwgMSwgMSwgIDAsIDEsXG4gIC0xLCAxLCAxLCAxLCAgIDAsIDEsIDEsIDEsICAxLCAxLFxuICAtMSwgMSwgLTEsIDEsICAwLCAxLCAwLCAxLCAgMSwgMCxcbiAgLTEsIC0xLCAtMSwgMSwgMCwgMCwgMCwgMSwgIDAsIDAsXG4gIC0xLCAtMSwgMSwgMSwgIDAsIDAsIDEsIDEsICAwLCAxLFxuICAtMSwgMSwgLTEsIDEsICAwLCAxLCAwLCAxLCAgMSwgMCxcblxuICAxLCAxLCAxLCAxLCAgICAxLCAxLCAxLCAxLCAgMCwgMSxcbiAgLTEsIDEsIDEsIDEsICAgMCwgMSwgMSwgMSwgIDEsIDEsXG4gIC0xLCAtMSwgMSwgMSwgIDAsIDAsIDEsIDEsICAxLCAwLFxuICAtMSwgLTEsIDEsIDEsICAwLCAwLCAxLCAxLCAgMSwgMCxcbiAgMSwgLTEsIDEsIDEsICAgMSwgMCwgMSwgMSwgIDAsIDAsXG4gIDEsIDEsIDEsIDEsICAgIDEsIDEsIDEsIDEsICAwLCAxLFxuXG4gIDEsIC0xLCAtMSwgMSwgIDEsIDAsIDAsIDEsICAwLCAxLFxuICAtMSwgLTEsIC0xLCAxLCAwLCAwLCAwLCAxLCAgMSwgMSxcbiAgLTEsIDEsIC0xLCAxLCAgMCwgMSwgMCwgMSwgIDEsIDAsXG4gIDEsIDEsIC0xLCAxLCAgIDEsIDEsIDAsIDEsICAwLCAwLFxuICAxLCAtMSwgLTEsIDEsICAxLCAwLCAwLCAxLCAgMCwgMSxcbiAgLTEsIDEsIC0xLCAxLCAgMCwgMSwgMCwgMSwgIDEsIDAsXG5dKTtcbiIsImV4cG9ydCBpbnRlcmZhY2UgSUJ1ZmZlclN0b3JhZ2Uge1xuICAgIGJ1ZmZlcnM6IE1hcDxzdHJpbmcsIEFycmF5QnVmZmVyPlxufVxuIiwiaW1wb3J0IHsgRW50aXR5VHlwZSwgSUVudGl0eSB9IGZyb20gJy4uL0VudGl0eSdcbmltcG9ydCB7IElHYW1lT2JqZWN0IH0gZnJvbSAnLi4vR2FtZU9iamVjdCdcblxuZXhwb3J0IGludGVyZmFjZSBJQ29tcG9uZW50PFQgZXh0ZW5kcyBFbnRpdHlUeXBlPiBleHRlbmRzIElFbnRpdHk8VD4ge1xuICAgIHBhcmVudDogSUdhbWVPYmplY3Rcbn1cbiIsImltcG9ydCB7IElSZW5kZXJlciB9IGZyb20gJy4uL1JlbmRlcmVyJ1xuaW1wb3J0IHsgSVNjZW5lIH0gZnJvbSAnLi4vU2NlbmUnXG5cbmV4cG9ydCBpbnRlcmZhY2UgSUVuZ2luZSB7XG4gICAgc2NlbmU/OiBJU2NlbmVcbiAgICByZW5kZXJlcjogSVJlbmRlcmVyXG5cbiAgICByZW5kZXI6ICh0aW1lPzogbnVtYmVyKSA9PiB2b2lkXG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgSUVuZ2luZVByb3BzIHtcbiAgICBjYW52YXM6IEhUTUxDYW52YXNFbGVtZW50XG59XG4iLCJleHBvcnQgZW51bSBFbnRpdHlUeXBlcyB7XG4gICAgZ2FtZU9iamVjdCA9ICdnYW1lT2JqZWN0JyxcbiAgICBtZXNoID0gJ21lc2gnLFxuICAgIG1hdGVyaWFsID0gJ21hdGVyaWFsJyxcbiAgICB0cmFuc2Zvcm0gPSAndHJhbnNmb3JtJyxcbiAgICBjYW1lcmEgPSAnY2FtZXJhJyxcbiAgICBjb2xsaWRlciA9ICdjb2xsaWRlcicsXG4gICAgcGh5c2ljc09iamVjdCA9ICdwaHlzaWNzT2JqZWN0JyxcbiAgICBsaWdodCA9ICdsaWdodCcsXG59XG5cbmV4cG9ydCB0eXBlIEVudGl0eVR5cGUgPSBrZXlvZiB0eXBlb2YgRW50aXR5VHlwZXNcblxuZXhwb3J0IHR5cGUgRW50aXR5SUQgPSBzdHJpbmdcblxuZXhwb3J0IGludGVyZmFjZSBJRW50aXR5PFQgZXh0ZW5kcyBQYXJ0aWFsPEVudGl0eVR5cGU+PiB7XG4gICAgaWQ6IEVudGl0eUlEXG4gICAgdHlwZTogVFxufVxuIiwiaW1wb3J0IHsgSUNvbXBvbmVudCB9IGZyb20gJy4uL0NvbXBvbmVudCdcbmltcG9ydCB7IEVudGl0eUlELCBFbnRpdHlUeXBlcywgSUVudGl0eSB9IGZyb20gJy4uL0VudGl0eSdcbmltcG9ydCB7IElUcmFuc2Zvcm0gfSBmcm9tICcuLi9UcmFuc2Zvcm0nXG5cbmV4cG9ydCBpbnRlcmZhY2UgSUdhbWVPYmplY3QgZXh0ZW5kcyBJRW50aXR5PEVudGl0eVR5cGVzLmdhbWVPYmplY3Q+IHtcbiAgICBuYW1lOiBzdHJpbmdcbiAgICB0cmFuc2Zvcm06IElUcmFuc2Zvcm1cbiAgICBvblVwZGF0ZT86IChkdDogbnVtYmVyKSA9PiB2b2lkXG4gICAgLy9GSVhNRTogdHlwZSBpbmNsdWRlcyBnYW1lT2JqZWN0XG4gICAgY29tcG9uZW50czogTWFwPEVudGl0eUlELCBJQ29tcG9uZW50PEVudGl0eVR5cGVzPj5cbiAgICBhZGRDb21wb25lbnQ6IChjb21wb25lbnQ6IElDb21wb25lbnQ8RW50aXR5VHlwZXM+KSA9PiB2b2lkXG4gICAgcmVtb3ZlQ29tcG9uZW50OiAoaWQ6IEVudGl0eUlEKSA9PiB2b2lkXG59XG4iLCJleHBvcnQgaW50ZXJmYWNlIElJbWFnZVN0b3JhZ2Uge1xuICAgIGltYWdlczogTWFwPHN0cmluZywgSW1hZ2VCaXRtYXA+XG4gICAgY3JlYXRlRGVmYXVsdHM6ICgpID0+IFByb21pc2U8dm9pZD5cbn1cblxuZXhwb3J0IGVudW0gREVGQVVMVF9JTUFHRV9JRFMge1xuICAgIGJhc2VDb2xvciA9ICdkZWZhdWx0QmFzZUNvbG9yJyxcbiAgICBtZXRhbGxpY1JvdWdobmVzcyA9ICdkZWZhdWx0TWV0YWxsaWNSb3VnaG5lc3MnLFxuICAgIGVtaXNzaW9uID0gJ2RlZmF1bHRFbWlzc2lvbicsXG4gICAgbm9ybWFsID0gJ2RlZmF1bHROb3JtYWwnLFxuICAgIG9jY2x1c2lvbiA9ICdkZWZhdWx0T2NjbHVzaW9uJyxcbn1cbiIsImltcG9ydCB7IE1hdDQsIFZlYzMsIFZlYzQgfSBmcm9tICd3Z3B1LW1hdHJpeCdcbmltcG9ydCB7IElDb21wb25lbnQgfSBmcm9tICcuLi9Db21wb25lbnQnXG5pbXBvcnQgeyBFbnRpdHlUeXBlcyB9IGZyb20gJy4uL0VudGl0eSdcbmltcG9ydCB7IElHYW1lT2JqZWN0IH0gZnJvbSAnLi4vR2FtZU9iamVjdCdcbmltcG9ydCB7IElUcmFuc2Zvcm0gfSBmcm9tICcuLi9UcmFuc2Zvcm0nXG5cbmV4cG9ydCBlbnVtIExJR0hUX1NPVVJDRV9UWVBFUyB7XG4gICAgZGlyZWN0aW9uYWwgPSAnZGlyZWN0aW9uYWwnLFxuICAgIHBvaW50ID0gJ3BvaW50JyxcbiAgICBzcG90ID0gJ3Nwb3QnLFxufVxuXG5leHBvcnQgdHlwZSBUTGlnaHRTb3VyY2VUeXBlID0ga2V5b2YgdHlwZW9mIExJR0hUX1NPVVJDRV9UWVBFU1xuXG5leHBvcnQgaW50ZXJmYWNlIElMaWdodFNvdXJjZSBleHRlbmRzIElDb21wb25lbnQ8RW50aXR5VHlwZXMubGlnaHQ+IHtcbiAgICBsaWdodFNvdXJjZVR5cGU6IFRMaWdodFNvdXJjZVR5cGVcbiAgICB0cmFuc2Zvcm06IElUcmFuc2Zvcm1cbiAgICBwb3NpdGlvbjogVmVjNFxuICAgIHJpZ2h0OiBWZWM0XG4gICAgdXA6IFZlYzRcbiAgICBiYWNrOiBWZWM0XG4gICAgdmlld01hdHJpeDogTWF0NFxuICAgIHByb2plY3Rpb25NYXRyaXg6IE1hdDRcbiAgICBjb2xvcjogVmVjM1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIElMaWdodFNvdXJjZVByb3BzIHtcbiAgICBwYXJlbnQ6IElHYW1lT2JqZWN0XG59XG4iLCJpbXBvcnQgeyBJQ29tcG9uZW50IH0gZnJvbSAnLi4vQ29tcG9uZW50J1xuaW1wb3J0IHsgRW50aXR5VHlwZXMgfSBmcm9tICcuLi9FbnRpdHknXG5pbXBvcnQgeyBWZWMzLCBWZWM0IH0gZnJvbSAnd2dwdS1tYXRyaXgnXG5cbmV4cG9ydCBpbnRlcmZhY2UgR0xURkJ1ZmZlckRhdGEge1xuICAgIGlkOiBzdHJpbmdcbiAgICBidWZmZXI6IEdQVUJ1ZmZlclxufVxuXG5leHBvcnQgaW50ZXJmYWNlIElNYXRlcmlhbFRleHR1cmUge1xuICAgIHZpZXc6IEdQVVRleHR1cmVWaWV3XG4gICAgc2FtcGxlcjogR1BVU2FtcGxlclxufVxuXG5leHBvcnQgaW50ZXJmYWNlIElNYXRlcmlhbCB7XG4gICAgbmFtZT86IHN0cmluZ1xuXG4gICAgYmFzZUNvbG9yVGV4dHVyZTogSU1hdGVyaWFsVGV4dHVyZVxuICAgIG1ldGFsbGljUm91Z2huZXNzVGV4dHVyZTogSU1hdGVyaWFsVGV4dHVyZVxuICAgIG5vcm1hbFRleHR1cmU6IElNYXRlcmlhbFRleHR1cmVcbiAgICBlbWlzc2l2ZVRleHR1cmU6IElNYXRlcmlhbFRleHR1cmVcbiAgICBvY2NsdXNpb25UZXh0dXJlOiBJTWF0ZXJpYWxUZXh0dXJlXG5cbiAgICBtZXRhbGxpY0ZhY3RvcjogbnVtYmVyXG4gICAgcm91Z2huZXNzRmFjdG9yOiBudW1iZXJcblxuICAgIGVtaXNzaXZlRmFjdG9yOiBWZWMzXG4gICAgYmFzZUNvbG9yRmFjdG9yOiBWZWM0XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgR0xURkFjY2Vzc29yIHtcbiAgICBieXRlU3RyaWRlOiBudW1iZXJcbiAgICBjb3VudDogbnVtYmVyXG4gICAgY29tcG9uZW50VHlwZTogbnVtYmVyXG4gICAgZWxlbWVudFR5cGU6IEdQVVZlcnRleEZvcm1hdCAvL0ZJWE1FOiBjb3VsZCBiZSBHUFVJbmRleEZvcm1hdFxuICAgIGJ5dGVPZmZzZXQ6IG51bWJlclxuICAgIGJ5dGVMZW5ndGg6IG51bWJlclxuICAgIGJ1ZmZlcklkOiBHTFRGQnVmZmVyRGF0YVsnaWQnXVxuICAgIG1pbj86IG51bWJlcltdXG4gICAgbWF4PzogbnVtYmVyW11cbiAgICB1c2FnZTogR1BVQnVmZmVyVXNhZ2VGbGFnc1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIElNZXNoIGV4dGVuZHMgSUNvbXBvbmVudDxFbnRpdHlUeXBlcy5tZXNoPiB7XG4gICAgLy9odHRwczovL3JlZ2lzdHJ5Lmtocm9ub3Mub3JnL2dsVEYvc3BlY3MvMi4wL2dsVEYtMi4wLmh0bWwjcmVmZXJlbmNlLW1lc2gtcHJpbWl0aXZlXG4gICAgbm9ybWFsczogR0xURkFjY2Vzc29yXG4gICAgdGFuZ2VudHM6IEdMVEZBY2Nlc3NvclxuICAgIGluZGljZXM6IEdMVEZBY2Nlc3NvclxuICAgIHRleHR1cmVDb29yZGluYXRlczogR0xURkFjY2Vzc29yXG4gICAgLy9GSVhNRTogaW1wbGVtZW50IGRlZmF1bHQgbWF0ZXJpYWwgYWNjb3JkaW5nIHRvIGRlZmF1bHRzIGh0dHBzOi8vcmVnaXN0cnkua2hyb25vcy5vcmcvZ2xURi9zcGVjcy8yLjAvZ2xURi0yLjAuaHRtbCNyZWZlcmVuY2UtbWF0ZXJpYWxcbiAgICBtYXRlcmlhbDogSU1hdGVyaWFsIC8vaWYgbm90IHByZXNlbnQgaW4gdGhlIGZpbGUsIGEgZGVmYXVsdCBtYXRlcmlhbCBzaG91bGQgYmUgdXNlZFxuICAgIHBvc2l0aW9uczogR0xURkFjY2Vzc29yXG4gICAgbW9kZTogbnVtYmVyIC8vZ3B1IHRvcG9sb2d5IC0gZGVmYXVsdCBpcyA0ICh0cmlhbmdsZXMpXG4gICAgaXNQaXBlbGluZUJ1aWx0OiBib29sZWFuXG59XG4iLCJpbXBvcnQgeyBJR2FtZU9iamVjdCB9IGZyb20gJy4uL0dhbWVPYmplY3QnXG5pbXBvcnQgeyBJU2NlbmVUcmVlIH0gZnJvbSAnLi4vU2NlbmVUcmVlJ1xuXG5leHBvcnQgaW50ZXJmYWNlIElPYmplY3RNYW5hZ2VyIHtcbiAgICBhZGRPYmplY3Q6IChjaGlsZDogSUdhbWVPYmplY3QsIHRhcmdldD86IElHYW1lT2JqZWN0KSA9PiB2b2lkXG4gICAgcmVwYXJlbnRPYmplY3Q6IChjaGlsZDogSUdhbWVPYmplY3QsIHRhcmdldD86IElHYW1lT2JqZWN0KSA9PiB2b2lkXG4gICAgZGVzdHJveU9iamVjdDogKGdhbWVPYmplY3Q6IElHYW1lT2JqZWN0KSA9PiB2b2lkXG4gICAgc2NlbmVUcmVlOiBJU2NlbmVUcmVlXG59XG4iLCJpbXBvcnQgeyBWZWMzIH0gZnJvbSAnd2dwdS1tYXRyaXgnXG5pbXBvcnQgeyBJTWVzaCB9IGZyb20gJy4uL01lc2gnXG5pbXBvcnQgeyBJU2NlbmUgfSBmcm9tICcuLi9TY2VuZSdcblxuZXhwb3J0IGVudW0gUkVOREVSX09VVFBVVF9TT1VSQ0VTIHtcbiAgICBERUZBVUxULFxuICAgIFZfTk9STUFMLFxuICAgIEFNQklFTlQsXG4gICAgRElGRlVTRSxcbiAgICBNRVRBTExJQyxcbiAgICBST1VHSE5FU1MsXG4gICAgRl9OT1JNQUwsXG4gICAgVl9UQU5HRU5ULFxufVxuXG5leHBvcnQgdHlwZSBUUmVuZGVyT3V0cHV0U291cmNlID0gbnVtYmVyXG5cbmV4cG9ydCB0eXBlIFRTa3lib3hCaXRtYXBzID0gW1xuICAgIEltYWdlQml0bWFwLFxuICAgIEltYWdlQml0bWFwLFxuICAgIEltYWdlQml0bWFwLFxuICAgIEltYWdlQml0bWFwLFxuICAgIEltYWdlQml0bWFwLFxuICAgIEltYWdlQml0bWFwLFxuXVxuXG5leHBvcnQgZW51bSBSRU5ERVJfTU9ERVMge1xuICAgIFVTRV9WX05PUk1BTCxcbiAgICBVU0VfRl9OT1JNQUwsXG59XG5cbmV4cG9ydCB0eXBlIFRSZW5kZXJNb2RlID0gbnVtYmVyXG5cbmV4cG9ydCBpbnRlcmZhY2UgSVJlbmRlcmVyIHtcbiAgICBhZGFwdGVyOiBHUFVBZGFwdGVyXG4gICAgZGV2aWNlOiBHUFVEZXZpY2VcbiAgICBjb250ZXh0OiBHUFVDYW52YXNDb250ZXh0XG4gICAgc3dhcENoYWluRm9ybWF0OiBHUFVUZXh0dXJlRm9ybWF0XG4gICAgZGVwdGhUZXh0dXJlRm9ybWF0OiBHUFVUZXh0dXJlRm9ybWF0XG4gICAgYW1iaWVudExpZ2h0SW50ZW5zaXR5OiBudW1iZXJcbiAgICBhbWJpZW50TGlnaHRDb2xvcjogVmVjM1xuXG4gICAgb3V0cHV0U291cmNlOiBUUmVuZGVyT3V0cHV0U291cmNlXG4gICAgcmVuZGVyaW5nTW9kZTogVFJlbmRlck1vZGVcblxuICAgIGluaXQ6ICgpID0+IFByb21pc2U8dm9pZD5cbiAgICByZW5kZXI6IChkdDogbnVtYmVyLCBzY2VuZTogSVNjZW5lKSA9PiB2b2lkXG4gICAgYnVpbGRSZW5kZXJQaXBlbGluZTogKG1lc2g6IElNZXNoLCBzY2VuZTogSVNjZW5lKSA9PiB2b2lkXG4gICAgc2V0U2t5Qm94VGV4dHVyZTogKGJpdG1hcHM6IFRTa3lib3hCaXRtYXBzKSA9PiB2b2lkXG4gICAgc2V0RGVmYXVsdFNreUJveFRleHR1cmU6ICgpID0+IFByb21pc2U8dm9pZD5cbn1cblxuZXhwb3J0IGludGVyZmFjZSBJUmVuZGVyZXJQcm9wcyB7XG4gICAgY2FudmFzOiBIVE1MQ2FudmFzRWxlbWVudFxufVxuIiwiZXhwb3J0IGludGVyZmFjZSBJU2FtcGxlclN0b3JhZ2Uge1xuICAgIHNhbXBsZXJzOiBNYXA8c3RyaW5nLCBHUFVTYW1wbGVyPlxufVxuXG5leHBvcnQgZW51bSBERUZBVUxUX1NBTVBMRVJfSURTIHtcbiAgICBiYXNlQ29sb3IgPSAnZGVmYXVsdEJhc2VDb2xvcicsXG4gICAgbWV0YWxsaWNSb3VnaG5lc3MgPSAnZGVmYXVsdE1ldGFsbGljUm91Z2huZXNzJyxcbiAgICBlbWlzc2lvbiA9ICdkZWZhdWx0RW1pc3Npb24nLFxuICAgIG5vcm1hbCA9ICdkZWZhdWx0Tm9ybWFsJyxcbiAgICBvY2NsdXNpb24gPSAnZGVmYXVsdE9jY2x1c2lvbicsXG59XG4iLCJpbXBvcnQgeyBJRW5naW5lLCBJTW9kZWxQcmVsb2FkRGF0YSB9IGZyb20gJy4uLy4uJ1xuaW1wb3J0IHsgRGlyZWN0aW9uYWxMaWdodCB9IGZyb20gJy4uLy4uLy4uL2NvcmUnXG5pbXBvcnQgeyBJQnVmZmVyU3RvcmFnZSB9IGZyb20gJy4uL0J1ZmZlclN0b3JhZ2UnXG5pbXBvcnQgeyBJQ2FtZXJhIH0gZnJvbSAnLi4vQ2FtZXJhJ1xuaW1wb3J0IHsgSUdhbWVPYmplY3QgfSBmcm9tICcuLi9HYW1lT2JqZWN0J1xuaW1wb3J0IHsgSUltYWdlU3RvcmFnZSB9IGZyb20gJy4uL0ltYWdlU3RvcmFnZSdcbmltcG9ydCB7IElNYXRlcmlhbFN0b3JhZ2UgfSBmcm9tICcuLi9NYXRlcmlhbFN0b3JhZ2UnXG5pbXBvcnQgeyBJTWVzaFJlbmRlckRhdGFTdG9yYWdlIH0gZnJvbSAnLi4vTWVzaFJlbmRlckRhdGFTdG9yYWdlJ1xuaW1wb3J0IHsgSU9iamVjdE1hbmFnZXIgfSBmcm9tICcuLi9PYmplY3RNYW5hZ2VyJ1xuaW1wb3J0IHsgSVNhbXBsZXJTdG9yYWdlIH0gZnJvbSAnLi4vU2FtcGxlclN0b3JhZ2UnXG5pbXBvcnQgeyBJVGV4dHVyZVN0b3JhZ2UgfSBmcm9tICcuLi9UZXh0dXJlU3RvcmFnZSdcblxuZXhwb3J0IGludGVyZmFjZSBJU2NlbmVVcGxvYWRNb2RlbFByb3BzIHtcbiAgICBtb2RlbERhdGE6IElNb2RlbFByZWxvYWREYXRhXG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgSVNjZW5lIHtcbiAgICBjYW1lcmE6IElDYW1lcmFcbiAgICBvYmplY3RNYW5hZ2VyOiBJT2JqZWN0TWFuYWdlclxuICAgIGJ1ZmZlclN0b3JhZ2U6IElCdWZmZXJTdG9yYWdlXG4gICAgaW1hZ2VTdG9yYWdlOiBJSW1hZ2VTdG9yYWdlXG4gICAgc2FtcGxlclN0b3JhZ2U6IElTYW1wbGVyU3RvcmFnZVxuICAgIHRleHR1cmVTdG9yYWdlOiBJVGV4dHVyZVN0b3JhZ2VcbiAgICBtYXRlcmlhbFN0b3JhZ2U6IElNYXRlcmlhbFN0b3JhZ2VcbiAgICBtZXNoUmVuZGVyRGF0YVN0b3JhZ2U6IElNZXNoUmVuZGVyRGF0YVN0b3JhZ2VcbiAgICBlbmdpbmU6IElFbmdpbmVcbiAgICByb290OiBJR2FtZU9iamVjdFxuICAgIC8vZml4bWU6IG1vY2tcbiAgICBsaWdodDogRGlyZWN0aW9uYWxMaWdodFxuXG4gICAgaW5pdDogKCkgPT4gUHJvbWlzZTx2b2lkPlxuICAgIHVwbG9hZE1vZGVsOiAocHJvcHM6IElTY2VuZVVwbG9hZE1vZGVsUHJvcHMpID0+IFByb21pc2U8SUdhbWVPYmplY3Q+XG4gICAgb25SZW5kZXI6IChkdDogbnVtYmVyKSA9PiB2b2lkXG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgSVNjZW5lUHJvcHMge1xuICAgIGNhbWVyYT86IElDYW1lcmFcbn1cbiIsImV4cG9ydCAqIGZyb20gJy4vU2NlbmUnXG4iLCJpbXBvcnQgeyBFbnRpdHlJRCB9IGZyb20gJy4uL0VudGl0eSdcbmltcG9ydCB7IElHYW1lT2JqZWN0IH0gZnJvbSAnLi4vR2FtZU9iamVjdCdcblxuZXhwb3J0IHR5cGUgU2NlbmVOb2RlID0gTWFwPEVudGl0eUlELCBTY2VuZU5vZGVDb250ZW50PlxuXG5leHBvcnQgdHlwZSBTY2VuZU5vZGVDb250ZW50ID0ge1xuICAgIGdhbWVPYmplY3Q6IElHYW1lT2JqZWN0XG4gICAgY2hpbGRyZW46IFNjZW5lTm9kZSB8IG51bGxcbn1cblxuZXhwb3J0IHR5cGUgU2NlbmVUcmVlUG9zaXRpb24gPSBFbnRpdHlJRFtdXG5cbmV4cG9ydCBpbnRlcmZhY2UgSVNjZW5lVHJlZSB7XG4gICAgbm9kZXM6IFNjZW5lTm9kZVxuICAgIGFkZE5vZGVBdDogKFxuICAgICAgICBwb3NpdGlvbjogU2NlbmVUcmVlUG9zaXRpb24gfCBudWxsLFxuICAgICAgICBub2RlOiBTY2VuZU5vZGVDb250ZW50XG4gICAgKSA9PiBTY2VuZVRyZWVQb3NpdGlvblxuICAgIHJlcGFyZW50Tm9kZTogKFxuICAgICAgICB0YXJnZXQ6IFNjZW5lVHJlZVBvc2l0aW9uIHwgbnVsbCxcbiAgICAgICAgY2hpbGQ6IFNjZW5lVHJlZVBvc2l0aW9uXG4gICAgKSA9PiBTY2VuZVRyZWVQb3NpdGlvblxuICAgIC8vcmV0dXJucyBhbiBhcnJheSBvZiBnYW1lT2JqZWN0IGlkcyB0byBiZSBjbGVhcmVkIGZyb20gT2JqZWN0TWFuYWdlclxuICAgIHJlbW92ZU5vZGU6ICh0YXJnZXRQb3NpdGlvbjogU2NlbmVUcmVlUG9zaXRpb24pID0+IEVudGl0eUlEW11cbiAgICBnZXROb2RlQ29udGVudEF0OiAocG9zaXRpb246IFNjZW5lVHJlZVBvc2l0aW9uKSA9PiBTY2VuZU5vZGVDb250ZW50IHwgbnVsbFxufVxuIiwiZXhwb3J0IGludGVyZmFjZSBJVGV4dHVyZVN0b3JhZ2Uge1xuICAgIHRleHR1cmVzOiBNYXA8c3RyaW5nLCBJVGV4dHVyZT5cbiAgICBkZWZhdWx0QmFzZUNvbG9yOiBJVGV4dHVyZVxuICAgIGRlZmF1bHRNZXRhbGxpY1JvdWdobmVzczogSVRleHR1cmVcbiAgICBkZWZhdWx0RW1pc3Npb246IElUZXh0dXJlXG4gICAgZGVmYXVsdE5vcm1hbDogSVRleHR1cmVcbiAgICBkZWZhdWx0T2NjbHVzaW9uOiBJVGV4dHVyZVxufVxuXG5leHBvcnQgaW50ZXJmYWNlIElUZXh0dXJlIHtcbiAgICBzYW1wbGVySWQ6IHN0cmluZ1xuICAgIGltYWdlSWQ6IHN0cmluZ1xufVxuIiwiaW1wb3J0IHsgVmVjMywgVmVjNCB9IGZyb20gJ3dncHUtbWF0cml4J1xuaW1wb3J0IHsgSUNvbXBvbmVudCB9IGZyb20gJy4uL0NvbXBvbmVudCdcbmltcG9ydCB7IEVudGl0eVR5cGVzIH0gZnJvbSAnLi4vRW50aXR5J1xuXG5leHBvcnQgdHlwZSBUcmFuc2Zvcm1hdGlvbk1hdHJpeCA9IEZsb2F0MzJBcnJheVxuXG5leHBvcnQgaW50ZXJmYWNlIElSb3RhdGVSYWRpYW5zUHJvcHMge1xuICAgIHg/OiBudW1iZXJcbiAgICB5PzogbnVtYmVyXG4gICAgej86IG51bWJlclxufVxuXG5leHBvcnQgaW50ZXJmYWNlIElUcmFuc2Zvcm0gZXh0ZW5kcyBJQ29tcG9uZW50PEVudGl0eVR5cGVzLnRyYW5zZm9ybT4ge1xuICAgIG1hdHJpeDogVHJhbnNmb3JtYXRpb25NYXRyaXhcbiAgICBwb3NpdGlvbjogVmVjNFxuICAgIHJvdGF0ZVJhZGlhbnM6IChwcm9wczogSVJvdGF0ZVJhZGlhbnNQcm9wcykgPT4gdm9pZFxuICAgIHJvdGF0ZURlZ3JlZXNFdWxlcjogKHByb3BzOiBJUm90YXRlUmFkaWFuc1Byb3BzKSA9PiB2b2lkXG4gICAgdHJhbnNsYXRlOiAodmVjOiBWZWMzKSA9PiB2b2lkXG4gICAgc2NhbGU6ICh2ZWM6IFZlYzMpID0+IHZvaWRcbn1cbiIsImltcG9ydCB7IE1hdDQsIFZlYzMsIFZlYzQgfSBmcm9tICd3Z3B1LW1hdHJpeCdcbmltcG9ydCB7IEdMVEZBY2Nlc3NvciB9IGZyb20gJy4vY29yZS9NZXNoJ1xuXG5leHBvcnQgKiBmcm9tICcuL2NvcmUvRW50aXR5J1xuZXhwb3J0ICogZnJvbSAnLi9jb3JlL0dhbWVPYmplY3QnXG5leHBvcnQgKiBmcm9tICcuL2NvcmUvQ29tcG9uZW50J1xuZXhwb3J0ICogZnJvbSAnLi9jb3JlL1NjZW5lVHJlZSdcbmV4cG9ydCAqIGZyb20gJy4vY29yZS9PYmplY3RNYW5hZ2VyJ1xuZXhwb3J0ICogZnJvbSAnLi9jb3JlL01lc2gnXG5leHBvcnQgKiBmcm9tICcuL2NvcmUvVHJhbnNmb3JtJ1xuZXhwb3J0ICogZnJvbSAnLi9jb3JlL0J1ZmZlclN0b3JhZ2UnXG5leHBvcnQgKiBmcm9tICcuL2NvcmUvSW1hZ2VTdG9yYWdlJ1xuZXhwb3J0ICogZnJvbSAnLi9jb3JlL1NhbXBsZXJTdG9yYWdlJ1xuZXhwb3J0ICogZnJvbSAnLi9jb3JlL1RleHR1cmVTdG9yYWdlJ1xuZXhwb3J0ICogZnJvbSAnLi9jb3JlL1NjZW5lJ1xuZXhwb3J0ICogZnJvbSAnLi9jb3JlL0VuZ2luZSdcbmV4cG9ydCAqIGZyb20gJy4vY29yZS9SZW5kZXJlcidcbmV4cG9ydCAqIGZyb20gJy4vY29yZS9MaWdodFNvdXJjZSdcblxuLy9GSVhNRTogbW92ZSB0aGlzIHNvbWV3aGVyZSBlbHNlXG5leHBvcnQgaW50ZXJmYWNlIElQcmVsb2FkTWVzaCB7XG4gICAgcG9zaXRpb25zOiBHTFRGQWNjZXNzb3JcbiAgICBpbmRpY2VzOiBHTFRGQWNjZXNzb3JcbiAgICBub3JtYWxzOiBHTFRGQWNjZXNzb3JcbiAgICB0YW5nZW50czogR0xURkFjY2Vzc29yXG4gICAgdGV4dHVyZUNvb3JkaW5hdGVzOiBHTFRGQWNjZXNzb3JcbiAgICBtYXRlcmlhbElkOiBzdHJpbmdcbiAgICBtb2RlOiBudW1iZXJcbn1cblxuZXhwb3J0IGludGVyZmFjZSBJUHJlbG9hZEVudGl0eSB7XG4gICAgdHJzTWF0cml4OiBNYXQ0XG4gICAgbWVzaGVzOiBJUHJlbG9hZE1lc2hbXVxuICAgIG5hbWU/OiBzdHJpbmdcbiAgICBjaGlsZHJlbjogSVByZWxvYWRFbnRpdHlbXVxufVxuXG5leHBvcnQgaW50ZXJmYWNlIElNb2RlbFByZWxvYWREYXRhIHtcbiAgICBidWZmZXJzOiBCdWZmZXJNYXBcbiAgICBpbWFnZXM6IEltYWdlTWFwXG4gICAgc2FtcGxlcnM6IFNhbXBsZXJNYXBcbiAgICB0ZXh0dXJlczogVGV4dHVyZU1hcFxuICAgIG1hdGVyaWFsczogTWF0ZXJpYWxNYXBcbiAgICBtb2RlbDogSVByZWxvYWRFbnRpdHlcbn1cblxuZXhwb3J0IGludGVyZmFjZSBJTWF0ZXJpYWxQcmVsb2FkRGF0YSB7XG4gICAgbmFtZT86IHN0cmluZ1xuICAgIGJhc2VDb2xvckZhY3Rvcj86IFZlYzQgLy9bMSwgMSwgMSwgMV1cbiAgICBlbWlzc2l2ZUZhY3Rvcj86IFZlYzNcbiAgICBtZXRhbGxpY0ZhY3Rvcj86IG51bWJlciAvLyAxXG4gICAgcm91Z2huZXNzRmFjdG9yPzogbnVtYmVyIC8vIDFcbiAgICBiYXNlQ29sb3JUZXh0dXJlSWQ/OiBzdHJpbmdcbiAgICBtZXRhbGxpY1JvdWdobmVzc1RleHR1cmVJZD86IHN0cmluZ1xuICAgIG5vcm1hbFRleHR1cmVJZD86IHN0cmluZ1xuICAgIG9jY2x1c2lvblRleHR1cmVJZD86IHN0cmluZ1xuICAgIGVtaXNzaXZlVGV4dHVyZUlkPzogc3RyaW5nXG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgSVRleHR1cmVQcmVsb2FkRGF0YSB7XG4gICAgc2FtcGxlcklkOiBzdHJpbmdcbiAgICBpbWFnZUlkOiBzdHJpbmdcbiAgICAvLyB1c2FnZTogR1BVVGV4dHVyZVVzYWdlRmxhZ3Ncbn1cblxuZXhwb3J0IGVudW0gR0xURlRleHR1cmVGaWx0ZXIge1xuICAgIE5FQVJFU1QgPSA5NzI4LFxuICAgIExJTkVBUiA9IDk3MjksXG4gICAgTkVBUkVTVF9NSVBNQVBfTkVBUkVTVCA9IDk5ODQsXG4gICAgTElORUFSX01JUE1BUF9ORUFSRVNUID0gOTk4NSxcbiAgICBORUFSRVNUX01JUE1BUF9MSU5FQVIgPSA5OTg2LFxuICAgIExJTkVBUl9NSVBNQVBfTElORUFSID0gOTk4Nyxcbn1cblxuZXhwb3J0IGVudW0gR0xURlRleHR1cmVXcmFwIHtcbiAgICBSRVBFQVQgPSAxMDQ5NyxcbiAgICBDTEFNUF9UT19FREdFID0gMzMwNzEsXG4gICAgTUlSUk9SRURfUkVQRUFUID0gMzM2NDgsXG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgSVNhbXBsZXJQcmVsb2FkRGF0YSB7XG4gICAgbWFnRmlsdGVyPzogR0xURlRleHR1cmVGaWx0ZXJcbiAgICBtaW5GaWx0ZXI/OiBHTFRGVGV4dHVyZUZpbHRlclxuICAgIHdyYXBTPzogR0xURlRleHR1cmVXcmFwXG4gICAgd3JhcFQ/OiBHTFRGVGV4dHVyZVdyYXBcbn1cblxuZXhwb3J0IGludGVyZmFjZSBJSW1hZ2VQcmVsb2FkRGF0YSB7XG4gICAgYnVmZmVyVmlldzoge1xuICAgICAgICBidWZmZXI6IHN0cmluZ1xuICAgICAgICBieXRlTGVuZ3RoOiBudW1iZXJcbiAgICAgICAgYnl0ZU9mZnNldDogbnVtYmVyXG4gICAgICAgIGJ5dGVTdHJpZGU6IG51bWJlclxuICAgICAgICB0YXJnZXQ6IG51bWJlclxuICAgIH1cbiAgICBtaW1lVHlwZTogc3RyaW5nXG59XG5cbmV4cG9ydCB0eXBlIEJ1ZmZlck1hcCA9IE1hcDxzdHJpbmcsIEFycmF5QnVmZmVyPlxuZXhwb3J0IHR5cGUgSW1hZ2VNYXAgPSBNYXA8c3RyaW5nLCBJSW1hZ2VQcmVsb2FkRGF0YT5cbmV4cG9ydCB0eXBlIFNhbXBsZXJNYXAgPSBNYXA8c3RyaW5nLCBJU2FtcGxlclByZWxvYWREYXRhPlxuZXhwb3J0IHR5cGUgVGV4dHVyZU1hcCA9IE1hcDxzdHJpbmcsIElUZXh0dXJlUHJlbG9hZERhdGE+XG5leHBvcnQgdHlwZSBNYXRlcmlhbE1hcCA9IE1hcDxzdHJpbmcsIElNYXRlcmlhbFByZWxvYWREYXRhPlxuIiwiaW1wb3J0IHsgQ29tcG9uZW50IH0gZnJvbSAnLi4vLi4vZW5naW5lL2NvcmUnXG5pbXBvcnQgeyBFbnRpdHlUeXBlcywgSUdhbWVPYmplY3QgfSBmcm9tICcuLi8uLi9lbmdpbmUvdHlwZXMnXG5cbmV4cG9ydCBjbGFzcyBDb2xsaWRlciBleHRlbmRzIENvbXBvbmVudDxFbnRpdHlUeXBlcy5jb2xsaWRlcj4ge1xuICAgIGNvbnN0cnVjdG9yKHBhcmVudDogSUdhbWVPYmplY3QpIHtcbiAgICAgICAgc3VwZXIocGFyZW50LCBFbnRpdHlUeXBlcy5jb2xsaWRlcilcbiAgICB9XG59XG4iLCJpbXBvcnQgeyB2ZWMzLCBWZWMzIH0gZnJvbSAnd2dwdS1tYXRyaXgnXG5pbXBvcnQgeyBDb21wb25lbnQgfSBmcm9tICcuLi8uLi9lbmdpbmUvY29yZSdcbmltcG9ydCB7IEVudGl0eVR5cGVzLCBJR2FtZU9iamVjdCB9IGZyb20gJy4uLy4uL2VuZ2luZS90eXBlcydcbmltcG9ydCB7IElQaHlzaWNzT2JqZWN0IH0gZnJvbSAnLi4vLi4vZW5naW5lL3R5cGVzL3BoeXNpY3MvUGh5c2ljc09iamVjdCdcblxuZXhwb3J0IGNsYXNzIFBoeXNpY3NPYmplY3RcbiAgICBleHRlbmRzIENvbXBvbmVudDxFbnRpdHlUeXBlcy5waHlzaWNzT2JqZWN0PlxuICAgIGltcGxlbWVudHMgSVBoeXNpY3NPYmplY3RcbntcbiAgICB2ZWxvY2l0eTogVmVjMyA9IHZlYzMuY3JlYXRlKDApXG5cbiAgICBjb25zdHJ1Y3RvcihwYXJlbnQ6IElHYW1lT2JqZWN0KSB7XG4gICAgICAgIHN1cGVyKHBhcmVudCwgRW50aXR5VHlwZXMucGh5c2ljc09iamVjdClcbiAgICB9XG59XG4iLCJleHBvcnQgKiBmcm9tICcuL0NvbGxpZGVyJ1xuZXhwb3J0ICogZnJvbSAnLi9QaHlzaWNzT2JqZWN0J1xuIiwiaW1wb3J0IHsgbWF0NCwgdmVjMyB9IGZyb20gJ3dncHUtbWF0cml4J1xuaW1wb3J0IHsgSUFyY0JhbGxDYW1lcmEgfSBmcm9tICcuLi8uLi9lbmdpbmUvdHlwZXMvY29yZS9DYW1lcmEnXG5pbXBvcnQgeyBTdHVmZiB9IGZyb20gJy4uL1N0dWZmJ1xuXG5leHBvcnQgaW50ZXJmYWNlIEFyY0JhbGxDb250cm9sbGVyUHJvcHMge1xuICAgIGNhbWVyYTogSUFyY0JhbGxDYW1lcmFcbiAgICBjYW52YXM6IEhUTUxDYW52YXNFbGVtZW50XG59XG5cbmV4cG9ydCBjbGFzcyBBcmNCYWxsQ29udHJvbGxlciB7XG4gICAgcm90YXRpb25TcGVlZCA9IDAuM1xuICAgIHpvb21TcGVlZCA9IDAuMVxuICAgIGZyaWN0aW9uQ29lZmZpY2llbnQgPSAwLjk5OVxuICAgIHByaXZhdGUgX2FuZ3VsYXJWZWxvY2l0eSA9IDBcbiAgICBwcml2YXRlIF9pc1RvdWNoaW5nID0gZmFsc2VcblxuICAgIGFuYWxvZ1ggPSAwXG4gICAgYW5hbG9nWSA9IDBcblxuICAgIHRvdWNoWCA9IDBcbiAgICB0b3VjaFkgPSAwXG5cbiAgICBjYW1lcmE6IElBcmNCYWxsQ2FtZXJhXG4gICAgY2FudmFzOiBIVE1MQ2FudmFzRWxlbWVudFxuXG4gICAgY29uc3RydWN0b3IoeyBjYW1lcmEsIGNhbnZhcyB9OiBBcmNCYWxsQ29udHJvbGxlclByb3BzKSB7XG4gICAgICAgIHRoaXMuY2FtZXJhID0gY2FtZXJhXG4gICAgICAgIHRoaXMuY2FudmFzID0gY2FudmFzXG5cbiAgICAgICAgdGhpcy5jYW52YXMuYWRkRXZlbnRMaXN0ZW5lcigncG9pbnRlcmRvd24nLCAoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLl9pc1RvdWNoaW5nID0gdHJ1ZVxuICAgICAgICB9KVxuXG4gICAgICAgIHRoaXMuY2FudmFzLmFkZEV2ZW50TGlzdGVuZXIoJ3BvaW50ZXJ1cCcsICgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuX2lzVG91Y2hpbmcgPSBmYWxzZVxuICAgICAgICAgICAgLy8gdGhpcy50b3VjaFggPSAwXG4gICAgICAgICAgICAvLyB0aGlzLnRvdWNoWSA9IDBcbiAgICAgICAgfSlcblxuICAgICAgICB0aGlzLmNhbnZhcy5hZGRFdmVudExpc3RlbmVyKCdwb2ludGVybW92ZScsIChldnQpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IG1vdXNlRG93biA9XG4gICAgICAgICAgICAgICAgZXZ0LnBvaW50ZXJUeXBlID09ICdtb3VzZScgPyAoZXZ0LmJ1dHRvbnMgJiAxKSAhPT0gMCA6IHRydWVcblxuICAgICAgICAgICAgaWYgKG1vdXNlRG93bikge1xuICAgICAgICAgICAgICAgIHRoaXMuYW5hbG9nWCArPSBldnQubW92ZW1lbnRYXG4gICAgICAgICAgICAgICAgdGhpcy5hbmFsb2dZICs9IGV2dC5tb3ZlbWVudFlcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSlcblxuICAgICAgICB0aGlzLmNhbnZhcy5hZGRFdmVudExpc3RlbmVyKCd0b3VjaHN0YXJ0JywgKGV2dCkgPT4ge1xuICAgICAgICAgICAgdGhpcy50b3VjaFggPSBldnQuY2hhbmdlZFRvdWNoZXNbMF0uY2xpZW50WFxuICAgICAgICAgICAgdGhpcy50b3VjaFkgPSBldnQuY2hhbmdlZFRvdWNoZXNbMF0uY2xpZW50WVxuICAgICAgICB9KVxuXG4gICAgICAgIHRoaXMuY2FudmFzLmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNobW92ZScsIChldnQpID0+IHtcbiAgICAgICAgICAgIHRoaXMuYW5hbG9nWCArPSBldnQuY2hhbmdlZFRvdWNoZXNbMF0uY2xpZW50WCAtIHRoaXMudG91Y2hYXG4gICAgICAgICAgICB0aGlzLmFuYWxvZ1kgKz0gZXZ0LmNoYW5nZWRUb3VjaGVzWzBdLmNsaWVudFkgLSB0aGlzLnRvdWNoWVxuICAgICAgICAgICAgdGhpcy50b3VjaFggPSBldnQuY2hhbmdlZFRvdWNoZXNbMF0uY2xpZW50WFxuICAgICAgICAgICAgdGhpcy50b3VjaFkgPSBldnQuY2hhbmdlZFRvdWNoZXNbMF0uY2xpZW50WVxuICAgICAgICB9KVxuICAgIH1cblxuICAgIHVwZGF0ZShkZWx0YVRpbWU6IG51bWJlcikge1xuICAgICAgICBjb25zdCBlcHNpbG9uID0gMC4wMDAwMDAxXG5cbiAgICAgICAgaWYgKHRoaXMuX2lzVG91Y2hpbmcpIHtcbiAgICAgICAgICAgIHRoaXMuX2FuZ3VsYXJWZWxvY2l0eSA9IDBcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX2FuZ3VsYXJWZWxvY2l0eSAqPSBNYXRoLnBvdyhcbiAgICAgICAgICAgICAgICAxIC0gdGhpcy5mcmljdGlvbkNvZWZmaWNpZW50LFxuICAgICAgICAgICAgICAgIGRlbHRhVGltZVxuICAgICAgICAgICAgKVxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgbW92ZW1lbnQgPSB2ZWMzLmNyZWF0ZSgpXG4gICAgICAgIHZlYzMuYWRkU2NhbGVkKG1vdmVtZW50LCB0aGlzLmNhbWVyYS5yaWdodCwgdGhpcy5hbmFsb2dYLCBtb3ZlbWVudClcbiAgICAgICAgdmVjMy5hZGRTY2FsZWQobW92ZW1lbnQsIHRoaXMuY2FtZXJhLnVwLCAtdGhpcy5hbmFsb2dZLCBtb3ZlbWVudClcblxuICAgICAgICB0aGlzLmFuYWxvZ1ggPSAwXG4gICAgICAgIHRoaXMuYW5hbG9nWSA9IDBcblxuICAgICAgICBjb25zdCBjcm9zc1Byb2R1Y3QgPSB2ZWMzLmNyb3NzKG1vdmVtZW50LCB0aGlzLmNhbWVyYS5iYWNrKVxuICAgICAgICBjb25zdCBtYWduaXR1ZGUgPSB2ZWMzLmxlbihjcm9zc1Byb2R1Y3QpXG5cbiAgICAgICAgaWYgKG1hZ25pdHVkZSA+IGVwc2lsb24pIHtcbiAgICAgICAgICAgIHRoaXMuY2FtZXJhLmF4aXMgPSB2ZWMzLnNjYWxlKGNyb3NzUHJvZHVjdCwgMSAvIG1hZ25pdHVkZSlcbiAgICAgICAgICAgIHRoaXMuX2FuZ3VsYXJWZWxvY2l0eSA9IG1hZ25pdHVkZSAqIHRoaXMucm90YXRpb25TcGVlZFxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3Qgcm90YXRpb25BbmdsZSA9IHRoaXMuX2FuZ3VsYXJWZWxvY2l0eSAqIGRlbHRhVGltZVxuXG4gICAgICAgIGlmIChyb3RhdGlvbkFuZ2xlID4gZXBzaWxvbikge1xuICAgICAgICAgICAgdGhpcy5jYW1lcmEuYmFjayA9IHZlYzMubm9ybWFsaXplKFxuICAgICAgICAgICAgICAgIFN0dWZmLnJvdGF0ZSh0aGlzLmNhbWVyYS5iYWNrLCB0aGlzLmNhbWVyYS5heGlzLCByb3RhdGlvbkFuZ2xlKVxuICAgICAgICAgICAgKVxuICAgICAgICAgICAgdGhpcy5jYW1lcmEucmVjYWxjdWxhdGVSaWdodCgpXG4gICAgICAgICAgICB0aGlzLmNhbWVyYS5yZWNhbGN1bGF0ZVVwKClcbiAgICAgICAgfVxuXG4gICAgICAgIC8vVE9ET1xuICAgICAgICAvLyBpZiAodGhpcy5hbmFsb2dab29tICE9PSAwKSB7XG4gICAgICAgIC8vICAgICB0aGlzLmRpc3RhbmNlICo9IDEgKyBhbmFsb2dab29tICogdGhpcy56b29tU3BlZWRcbiAgICAgICAgLy8gfVxuXG4gICAgICAgIHRoaXMuY2FtZXJhLnBvc2l0aW9uID0gdmVjMy5zY2FsZShcbiAgICAgICAgICAgIHRoaXMuY2FtZXJhLmJhY2ssXG4gICAgICAgICAgICB0aGlzLmNhbWVyYS5kaXN0YW5jZVxuICAgICAgICApXG5cbiAgICAgICAgdGhpcy5jYW1lcmEudmlldyA9IG1hdDQuaW52ZXJ0KHRoaXMuY2FtZXJhLm1hdHJpeClcbiAgICB9XG59XG4iLCJleHBvcnQgKiBmcm9tICcuL0FyY0JhbGxDb250cm9sbGVyJ1xuIiwiaW1wb3J0IHsgbWF0NCwgTWF0NCwgdmVjMywgVmVjMyB9IGZyb20gJ3dncHUtbWF0cml4J1xuXG5leHBvcnQgY2xhc3MgU3R1ZmYge1xuICAgIHN0YXRpYyBjbGFtcCh4OiBudW1iZXIsIG1pbjogbnVtYmVyLCBtYXg6IG51bWJlcik6IG51bWJlciB7XG4gICAgICAgIHJldHVybiBNYXRoLm1pbihNYXRoLm1heCh4LCBtaW4pLCBtYXgpXG4gICAgfVxuXG4gICAgc3RhdGljIG1vZCh4OiBudW1iZXIsIGRpdjogbnVtYmVyKTogbnVtYmVyIHtcbiAgICAgICAgcmV0dXJuIHggLSBNYXRoLmZsb29yKE1hdGguYWJzKHgpIC8gZGl2KSAqIGRpdiAqIE1hdGguc2lnbih4KVxuICAgIH1cblxuICAgIHN0YXRpYyBsZXJwKGE6IFZlYzMsIGI6IFZlYzMsIHM6IG51bWJlcik6IFZlYzMge1xuICAgICAgICByZXR1cm4gdmVjMy5hZGRTY2FsZWQoYSwgdmVjMy5zdWIoYiwgYSksIHMpXG4gICAgfVxuXG4gICAgc3RhdGljIHJvdGF0ZSh2ZWM6IFZlYzMsIGF4aXM6IFZlYzMsIGFuZ2xlOiBudW1iZXIpOiBWZWMzIHtcbiAgICAgICAgcmV0dXJuIHZlYzMudHJhbnNmb3JtTWF0NFVwcGVyM3gzKHZlYywgbWF0NC5yb3RhdGlvbihheGlzLCBhbmdsZSkpXG4gICAgfVxuXG4gICAgc3RhdGljIGV4dHJhY3RFdWxlclJvdGF0aW9uKG1hdDogTWF0NCk6IFZlYzMge1xuICAgICAgICAvLyBbXG4gICAgICAgIC8vICAgICB4MSwgeDIsIHgzLCB4NCwgIC8vIDwtIGNvbHVtbiAwXG4gICAgICAgIC8vICAgICB5MSwgeTIsIHkzLCB5NCwgIC8vIDwtIGNvbHVtbiAxXG4gICAgICAgIC8vICAgICB6MSwgejIsIHozLCB6NCwgIC8vIDwtIGNvbHVtbiAyXG4gICAgICAgIC8vICAgICB3MSwgdzIsIHczLCB3NCwgIC8vIDwtIGNvbHVtbiAzXG4gICAgICAgIC8vICAgXVxuICAgICAgICBjb25zdCByb3RYYW5nbGUgPSBNYXRoLmF0YW4yKC1tYXRbOV0sIG1hdFsxMF0pXG4gICAgICAgIGNvbnN0IGNvc1lhbmdsZSA9IE1hdGguc3FydChNYXRoLnBvdyhtYXRbMF0sIDIpICsgTWF0aC5wb3cobWF0WzRdLCAyKSlcbiAgICAgICAgY29uc3Qgcm90WWFuZ2xlID0gTWF0aC5hdGFuMihtYXRbOF0sIGNvc1lhbmdsZSlcbiAgICAgICAgY29uc3Qgc2luWGFuZ2xlID0gTWF0aC5zaW4ocm90WGFuZ2xlKVxuICAgICAgICBjb25zdCBjb3NYYW5nbGUgPSBNYXRoLmNvcyhyb3RYYW5nbGUpXG4gICAgICAgIGNvbnN0IHJvdFphbmdsZSA9IE1hdGguYXRhbjIoXG4gICAgICAgICAgICBjb3NYYW5nbGUgKiBtYXRbMV0gKyBzaW5YYW5nbGUgKiBtYXRbMl0sXG4gICAgICAgICAgICBjb3NYYW5nbGUgKiBtYXRbNV0gKyBzaW5YYW5nbGUgKiBtYXRbNl1cbiAgICAgICAgKVxuXG4gICAgICAgIHJldHVybiB2ZWMzLmNyZWF0ZShyb3RYYW5nbGUsIHJvdFlhbmdsZSwgcm90WmFuZ2xlKVxuICAgIH1cbn1cbiIsImltcG9ydCB7IGxvYWQgfSBmcm9tICdAbG9hZGVycy5nbC9jb3JlJ1xuaW1wb3J0IHsgR0xCLCBHTEJMb2FkZXIgfSBmcm9tICdAbG9hZGVycy5nbC9nbHRmJ1xuaW1wb3J0IHtcbiAgICBCdWZmZXJNYXAsXG4gICAgREVGQVVMVF9TQU1QTEVSX0lEUyxcbiAgICBHTFRGQWNjZXNzb3IsXG4gICAgSW1hZ2VNYXAsXG4gICAgSU1hdGVyaWFsUHJlbG9hZERhdGEsXG4gICAgSU1vZGVsUHJlbG9hZERhdGEsXG4gICAgSVByZWxvYWRFbnRpdHksXG4gICAgSVByZWxvYWRNZXNoLFxuICAgIElTYW1wbGVyUHJlbG9hZERhdGEsXG4gICAgSVRleHR1cmVQcmVsb2FkRGF0YSxcbiAgICBNYXRlcmlhbE1hcCxcbiAgICBTYW1wbGVyTWFwLFxuICAgIFRleHR1cmVNYXAsXG59IGZyb20gJy4uLy4uL2VuZ2luZS90eXBlcydcbmltcG9ydCB7IGdldFR5cGVTaXplLCBnZXRWZXJ0ZXhUeXBlLCBHTFRGQ29tcG9uZW50VHlwZSB9IGZyb20gJy4vaGVscGVycydcbmltcG9ydCB7IG1hdDQsIHZlYzIsIHZlYzMsIFZlYzMsIFZlYzQgfSBmcm9tICd3Z3B1LW1hdHJpeCdcblxudHlwZSBJbmRleE1hcCA9IE1hcDxudW1iZXIsIHN0cmluZz5cblxuY29uc3QgZ2VuZXJhdGVJZCA9ICgpID0+IHtcbiAgICByZXR1cm4gU3RyaW5nKE1hdGgucmFuZG9tKCkpXG59XG5cbmV4cG9ydCBjbGFzcyBXaGVlenlHTEJMb2FkZXIge1xuICAgIHByaXZhdGUgc3RhdGljIGxvYWRJbWFnZXMoXG4gICAgICAgIG1vZGVsRGF0YTogR0xCLFxuICAgICAgICBidWZmZXJJbmRleE1hcDogSW5kZXhNYXBcbiAgICApOiB7XG4gICAgICAgIGltYWdlc0luZGV4TWFwOiBJbmRleE1hcFxuICAgICAgICBpbWFnZXNNYXA6IEltYWdlTWFwXG4gICAgfSB7XG4gICAgICAgIGNvbnN0IGltYWdlc0luZGV4TWFwOiBJbmRleE1hcCA9IG5ldyBNYXAoKVxuICAgICAgICBjb25zdCBpbWFnZXNNYXA6IEltYWdlTWFwID0gbmV3IE1hcCgpXG5cbiAgICAgICAgbW9kZWxEYXRhLmpzb24/LmltYWdlcz8uZm9yRWFjaChcbiAgICAgICAgICAgIChcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGJ1ZmZlclZpZXcsXG4gICAgICAgICAgICAgICAgICAgIG1pbWVUeXBlLFxuICAgICAgICAgICAgICAgIH06IHtcbiAgICAgICAgICAgICAgICAgICAgYnVmZmVyVmlldzogbnVtYmVyXG4gICAgICAgICAgICAgICAgICAgIG1pbWVUeXBlOiBzdHJpbmdcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGluZGV4OiBudW1iZXJcbiAgICAgICAgICAgICkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGJ1ZmZlclZpZXdEYXRhID0gbW9kZWxEYXRhLmpzb24uYnVmZmVyVmlld3NbYnVmZmVyVmlld11cbiAgICAgICAgICAgICAgICBjb25zdCBidWZmZXJJZCA9IGJ1ZmZlckluZGV4TWFwLmdldChidWZmZXJWaWV3RGF0YS5idWZmZXIpXG5cbiAgICAgICAgICAgICAgICBpZiAoIWJ1ZmZlclZpZXdEYXRhLmJ5dGVPZmZzZXQpIHtcbiAgICAgICAgICAgICAgICAgICAgYnVmZmVyVmlld0RhdGEuYnl0ZU9mZnNldCA9IDBcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBjb25zdCBidWZmZXJPZmZzZXQgPVxuICAgICAgICAgICAgICAgICAgICBtb2RlbERhdGEuYmluQ2h1bmtzW2J1ZmZlclZpZXdEYXRhLmJ1ZmZlcl0uYnl0ZU9mZnNldCA/PyAwXG4gICAgICAgICAgICAgICAgYnVmZmVyVmlld0RhdGEuYnVmZmVyID0gYnVmZmVySWRcbiAgICAgICAgICAgICAgICBidWZmZXJWaWV3RGF0YS5ieXRlT2Zmc2V0ICs9IGJ1ZmZlck9mZnNldFxuXG4gICAgICAgICAgICAgICAgY29uc3QgaWQgPSBnZW5lcmF0ZUlkKClcbiAgICAgICAgICAgICAgICBpbWFnZXNJbmRleE1hcC5zZXQoaW5kZXgsIGlkKVxuICAgICAgICAgICAgICAgIGltYWdlc01hcC5zZXQoaWQsIHsgYnVmZmVyVmlldzogYnVmZmVyVmlld0RhdGEsIG1pbWVUeXBlIH0pXG4gICAgICAgICAgICB9XG4gICAgICAgIClcblxuICAgICAgICByZXR1cm4geyBpbWFnZXNJbmRleE1hcCwgaW1hZ2VzTWFwIH1cbiAgICB9XG5cbiAgICBwcml2YXRlIHN0YXRpYyBsb2FkU2FtcGxlcnMgPSAoXG4gICAgICAgIG1vZGVsRGF0YTogR0xCXG4gICAgKToge1xuICAgICAgICBzYW1wbGVyc0luZGV4TWFwOiBJbmRleE1hcFxuICAgICAgICBzYW1wbGVyc01hcDogU2FtcGxlck1hcFxuICAgIH0gPT4ge1xuICAgICAgICBjb25zdCBzYW1wbGVyc0luZGV4TWFwOiBJbmRleE1hcCA9IG5ldyBNYXAoKVxuICAgICAgICBjb25zdCBzYW1wbGVyc01hcDogU2FtcGxlck1hcCA9IG5ldyBNYXAoKVxuXG4gICAgICAgIG1vZGVsRGF0YS5qc29uPy5zYW1wbGVycz8uZm9yRWFjaChcbiAgICAgICAgICAgIChzYW1wbGVyOiBJU2FtcGxlclByZWxvYWREYXRhLCBpbmRleDogbnVtYmVyKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgaWQgPSBnZW5lcmF0ZUlkKClcbiAgICAgICAgICAgICAgICBzYW1wbGVyc0luZGV4TWFwLnNldChpbmRleCwgaWQpXG4gICAgICAgICAgICAgICAgc2FtcGxlcnNNYXAuc2V0KGlkLCBzYW1wbGVyKVxuICAgICAgICAgICAgfVxuICAgICAgICApXG5cbiAgICAgICAgcmV0dXJuIHsgc2FtcGxlcnNJbmRleE1hcCwgc2FtcGxlcnNNYXAgfVxuICAgIH1cblxuICAgIHByaXZhdGUgc3RhdGljIGxvYWRUZXh0dXJlcyA9IChcbiAgICAgICAgbW9kZWxEYXRhOiBHTEIsXG4gICAgICAgIHNhbXBsZXJzSW5kZXhNYXA6IEluZGV4TWFwLFxuICAgICAgICBpbWFnZXNJbmRleE1hcDogSW5kZXhNYXBcbiAgICApOiB7XG4gICAgICAgIHRleHR1cmVzSW5kZXhNYXA6IEluZGV4TWFwXG4gICAgICAgIHRleHR1cmVzTWFwOiBUZXh0dXJlTWFwXG4gICAgfSA9PiB7XG4gICAgICAgIGNvbnN0IHRleHR1cmVzSW5kZXhNYXA6IEluZGV4TWFwID0gbmV3IE1hcCgpXG4gICAgICAgIGNvbnN0IHRleHR1cmVzTWFwOiBUZXh0dXJlTWFwID0gbmV3IE1hcCgpXG5cbiAgICAgICAgbW9kZWxEYXRhLmpzb24/LnRleHR1cmVzPy5mb3JFYWNoKFxuICAgICAgICAgICAgKFxuICAgICAgICAgICAgICAgIHRleHR1cmVEYXRhOiB7IHNvdXJjZTogbnVtYmVyOyBzYW1wbGVyOiBudW1iZXIgfSxcbiAgICAgICAgICAgICAgICBpbmRleDogbnVtYmVyXG4gICAgICAgICAgICApID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBpZCA9IGdlbmVyYXRlSWQoKVxuICAgICAgICAgICAgICAgIGNvbnN0IHRleHR1cmU6IElUZXh0dXJlUHJlbG9hZERhdGEgPSB7XG4gICAgICAgICAgICAgICAgICAgIHNhbXBsZXJJZDpcbiAgICAgICAgICAgICAgICAgICAgICAgIHNhbXBsZXJzSW5kZXhNYXAuZ2V0KHRleHR1cmVEYXRhLnNhbXBsZXIpID8/XG4gICAgICAgICAgICAgICAgICAgICAgICBERUZBVUxUX1NBTVBMRVJfSURTLmJhc2VDb2xvcixcbiAgICAgICAgICAgICAgICAgICAgaW1hZ2VJZDogaW1hZ2VzSW5kZXhNYXAuZ2V0KHRleHR1cmVEYXRhLnNvdXJjZSkgYXMgc3RyaW5nLFxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHRleHR1cmVzSW5kZXhNYXAuc2V0KGluZGV4LCBpZClcbiAgICAgICAgICAgICAgICB0ZXh0dXJlc01hcC5zZXQoaWQsIHRleHR1cmUpXG4gICAgICAgICAgICB9XG4gICAgICAgIClcblxuICAgICAgICByZXR1cm4geyB0ZXh0dXJlc0luZGV4TWFwLCB0ZXh0dXJlc01hcCB9XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBzdGF0aWMgbG9hZE1hdGVyaWFscyA9IChcbiAgICAgICAgbW9kZWxEYXRhOiBHTEIsXG4gICAgICAgIHRleHR1cmVzSW5kZXhNYXA6IEluZGV4TWFwXG4gICAgKToge1xuICAgICAgICBtYXRlcmlhbHNJbmRleE1hcDogSW5kZXhNYXBcbiAgICAgICAgbWF0ZXJpYWxzTWFwOiBNYXRlcmlhbE1hcFxuICAgIH0gPT4ge1xuICAgICAgICBjb25zdCBtYXRlcmlhbHNJbmRleE1hcDogSW5kZXhNYXAgPSBuZXcgTWFwKClcbiAgICAgICAgY29uc3QgbWF0ZXJpYWxzTWFwOiBNYXRlcmlhbE1hcCA9IG5ldyBNYXAoKVxuXG4gICAgICAgIG1vZGVsRGF0YS5qc29uPy5tYXRlcmlhbHM/LmZvckVhY2goXG4gICAgICAgICAgICAoXG4gICAgICAgICAgICAgICAgLy9GSVhNRTogY2hlY2sgdHlwZXNcbiAgICAgICAgICAgICAgICBtYXRlcmlhbERhdGE6IHtcbiAgICAgICAgICAgICAgICAgICAgcGJyTWV0YWxsaWNSb3VnaG5lc3M/OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBiYXNlQ29sb3JUZXh0dXJlPzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4OiBudW1iZXJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIG1ldGFsbGljUm91Z2huZXNzVGV4dHVyZT86IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbmRleDogbnVtYmVyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBiYXNlQ29sb3JGYWN0b3I/OiBWZWM0XG4gICAgICAgICAgICAgICAgICAgICAgICBtZXRhbGxpY0ZhY3Rvcj86IG51bWJlclxuICAgICAgICAgICAgICAgICAgICAgICAgcm91Z2huZXNzRmFjdG9yPzogbnVtYmVyXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgbm9ybWFsVGV4dHVyZT86IHsgaW5kZXg6IG51bWJlciB9XG4gICAgICAgICAgICAgICAgICAgIGVtaXNzaXZlVGV4dHVyZT86IHsgaW5kZXg6IG51bWJlciB9XG4gICAgICAgICAgICAgICAgICAgIG9jY2x1c2lvblRleHR1cmU/OiB7IGluZGV4OiBudW1iZXIgfVxuICAgICAgICAgICAgICAgICAgICBlbWlzc2l2ZUZhY3Rvcj86IFZlYzNcbiAgICAgICAgICAgICAgICAgICAgbmFtZT86IHN0cmluZ1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgaW5kZXg6IG51bWJlclxuICAgICAgICAgICAgKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgbWF0ZXJpYWw6IElNYXRlcmlhbFByZWxvYWREYXRhID0ge1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiBtYXRlcmlhbERhdGEubmFtZSxcbiAgICAgICAgICAgICAgICAgICAgYmFzZUNvbG9yRmFjdG9yOlxuICAgICAgICAgICAgICAgICAgICAgICAgbWF0ZXJpYWxEYXRhPy5wYnJNZXRhbGxpY1JvdWdobmVzcz8uYmFzZUNvbG9yRmFjdG9yLFxuICAgICAgICAgICAgICAgICAgICBlbWlzc2l2ZUZhY3RvcjogbWF0ZXJpYWxEYXRhLmVtaXNzaXZlRmFjdG9yLFxuICAgICAgICAgICAgICAgICAgICBtZXRhbGxpY0ZhY3RvcjpcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hdGVyaWFsRGF0YT8ucGJyTWV0YWxsaWNSb3VnaG5lc3M/Lm1ldGFsbGljRmFjdG9yLFxuICAgICAgICAgICAgICAgICAgICByb3VnaG5lc3NGYWN0b3I6XG4gICAgICAgICAgICAgICAgICAgICAgICBtYXRlcmlhbERhdGE/LnBick1ldGFsbGljUm91Z2huZXNzPy5yb3VnaG5lc3NGYWN0b3IsXG4gICAgICAgICAgICAgICAgICAgIGJhc2VDb2xvclRleHR1cmVJZDpcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hdGVyaWFsRGF0YT8ucGJyTWV0YWxsaWNSb3VnaG5lc3M/LmJhc2VDb2xvclRleHR1cmVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA/LmluZGV4ICE9PSB1bmRlZmluZWRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IHRleHR1cmVzSW5kZXhNYXAuZ2V0KFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hdGVyaWFsRGF0YT8ucGJyTWV0YWxsaWNSb3VnaG5lc3NcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPy5iYXNlQ29sb3JUZXh0dXJlPy5pbmRleFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgICAgICBtZXRhbGxpY1JvdWdobmVzc1RleHR1cmVJZDpcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hdGVyaWFsRGF0YT8ucGJyTWV0YWxsaWNSb3VnaG5lc3NcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA/Lm1ldGFsbGljUm91Z2huZXNzVGV4dHVyZT8uaW5kZXggIT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gdGV4dHVyZXNJbmRleE1hcC5nZXQoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF0ZXJpYWxEYXRhPy5wYnJNZXRhbGxpY1JvdWdobmVzc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA/Lm1ldGFsbGljUm91Z2huZXNzVGV4dHVyZT8uaW5kZXhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICAgICAgbm9ybWFsVGV4dHVyZUlkOlxuICAgICAgICAgICAgICAgICAgICAgICAgbWF0ZXJpYWxEYXRhPy5ub3JtYWxUZXh0dXJlPy5pbmRleCAhPT0gdW5kZWZpbmVkXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPyB0ZXh0dXJlc0luZGV4TWFwLmdldChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXRlcmlhbERhdGE/Lm5vcm1hbFRleHR1cmU/LmluZGV4XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgICAgIG9jY2x1c2lvblRleHR1cmVJZDpcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hdGVyaWFsRGF0YT8ub2NjbHVzaW9uVGV4dHVyZT8uaW5kZXggIT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gdGV4dHVyZXNJbmRleE1hcC5nZXQoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF0ZXJpYWxEYXRhPy5vY2NsdXNpb25UZXh0dXJlPy5pbmRleFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgICAgICBlbWlzc2l2ZVRleHR1cmVJZDpcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hdGVyaWFsRGF0YT8uZW1pc3NpdmVUZXh0dXJlPy5pbmRleCAhPT0gdW5kZWZpbmVkXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPyB0ZXh0dXJlc0luZGV4TWFwLmdldChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXRlcmlhbERhdGE/LmVtaXNzaXZlVGV4dHVyZT8uaW5kZXhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBjb25zdCBpZCA9IGdlbmVyYXRlSWQoKVxuICAgICAgICAgICAgICAgIG1hdGVyaWFsc0luZGV4TWFwLnNldChpbmRleCwgaWQpXG4gICAgICAgICAgICAgICAgbWF0ZXJpYWxzTWFwLnNldChpZCwgbWF0ZXJpYWwpXG4gICAgICAgICAgICB9XG4gICAgICAgIClcblxuICAgICAgICByZXR1cm4geyBtYXRlcmlhbHNJbmRleE1hcCwgbWF0ZXJpYWxzTWFwIH1cbiAgICB9XG5cbiAgICBwcml2YXRlIHN0YXRpYyBsb2FkQnVmZmVycyA9IChtb2RlbERhdGE6IEdMQikgPT4ge1xuICAgICAgICBjb25zdCBidWZmZXJJbmRleE1hcDogSW5kZXhNYXAgPSBuZXcgTWFwKClcbiAgICAgICAgY29uc3QgYnVmZmVyTWFwOiBCdWZmZXJNYXAgPSBuZXcgTWFwKClcblxuICAgICAgICBtb2RlbERhdGEuYmluQ2h1bmtzLmZvckVhY2goKGNodW5rLCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgaWYgKGNodW5rLmFycmF5QnVmZmVyKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgaWQgPSBnZW5lcmF0ZUlkKClcbiAgICAgICAgICAgICAgICBidWZmZXJJbmRleE1hcC5zZXQoaW5kZXgsIGlkKVxuICAgICAgICAgICAgICAgIGJ1ZmZlck1hcC5zZXQoaWQsIGNodW5rLmFycmF5QnVmZmVyKVxuICAgICAgICAgICAgfVxuICAgICAgICB9KVxuXG4gICAgICAgIHJldHVybiB7IGJ1ZmZlckluZGV4TWFwLCBidWZmZXJNYXAgfVxuICAgIH1cblxuICAgIHB1YmxpYyBzdGF0aWMgYXN5bmMgbG9hZEZyb21VcmwodXJsOiBzdHJpbmcpOiBQcm9taXNlPElNb2RlbFByZWxvYWREYXRhPiB7XG4gICAgICAgIGNvbnN0IG1vZGVsRGF0YSA9IGF3YWl0IGxvYWQodXJsLCBHTEJMb2FkZXIpXG5cbiAgICAgICAgY29uc29sZS5sb2cobW9kZWxEYXRhKVxuXG4gICAgICAgIGNvbnN0IHsgYnVmZmVySW5kZXhNYXAsIGJ1ZmZlck1hcCB9ID0gdGhpcy5sb2FkQnVmZmVycyhtb2RlbERhdGEpXG5cbiAgICAgICAgY29uc3QgeyBpbWFnZXNJbmRleE1hcCwgaW1hZ2VzTWFwIH0gPSB0aGlzLmxvYWRJbWFnZXMoXG4gICAgICAgICAgICBtb2RlbERhdGEsXG4gICAgICAgICAgICBidWZmZXJJbmRleE1hcFxuICAgICAgICApXG5cbiAgICAgICAgY29uc3QgeyBzYW1wbGVyc0luZGV4TWFwLCBzYW1wbGVyc01hcCB9ID0gdGhpcy5sb2FkU2FtcGxlcnMobW9kZWxEYXRhKVxuXG4gICAgICAgIGNvbnN0IHsgdGV4dHVyZXNJbmRleE1hcCwgdGV4dHVyZXNNYXAgfSA9IHRoaXMubG9hZFRleHR1cmVzKFxuICAgICAgICAgICAgbW9kZWxEYXRhLFxuICAgICAgICAgICAgc2FtcGxlcnNJbmRleE1hcCxcbiAgICAgICAgICAgIGltYWdlc0luZGV4TWFwXG4gICAgICAgIClcblxuICAgICAgICBjb25zdCB7IG1hdGVyaWFsc0luZGV4TWFwLCBtYXRlcmlhbHNNYXAgfSA9IHRoaXMubG9hZE1hdGVyaWFscyhcbiAgICAgICAgICAgIG1vZGVsRGF0YSxcbiAgICAgICAgICAgIHRleHR1cmVzSW5kZXhNYXBcbiAgICAgICAgKVxuXG4gICAgICAgIGNvbnN0IG1vZGVsUHJlbG9hZDogSVByZWxvYWRFbnRpdHkgPSB7XG4gICAgICAgICAgICB0cnNNYXRyaXg6IG1hdDQuaWRlbnRpdHkoKSxcbiAgICAgICAgICAgIG1lc2hlczogW10sXG4gICAgICAgICAgICBjaGlsZHJlbjogW10sXG4gICAgICAgIH1cblxuICAgICAgICBtb2RlbERhdGE/Lmpzb24/LnNjZW5lcz8uZm9yRWFjaCgoc2NlbmU6IHsgbm9kZXM/OiBudW1iZXJbXSB9KSA9PiB7XG4gICAgICAgICAgICBzY2VuZT8ubm9kZXM/LmZvckVhY2goKG5vZGVJbmRleCkgPT4ge1xuICAgICAgICAgICAgICAgIG1vZGVsUHJlbG9hZC5jaGlsZHJlbi5wdXNoKFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmxvYWROb2RlKFxuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZUluZGV4LFxuICAgICAgICAgICAgICAgICAgICAgICAgbW9kZWxEYXRhLFxuICAgICAgICAgICAgICAgICAgICAgICAgYnVmZmVySW5kZXhNYXAsXG4gICAgICAgICAgICAgICAgICAgICAgICBtYXRlcmlhbHNJbmRleE1hcCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGJ1ZmZlck1hcFxuICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgfSlcbiAgICAgICAgfSlcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbW9kZWw6IG1vZGVsUHJlbG9hZCxcbiAgICAgICAgICAgIGJ1ZmZlcnM6IGJ1ZmZlck1hcCxcbiAgICAgICAgICAgIGltYWdlczogaW1hZ2VzTWFwLFxuICAgICAgICAgICAgc2FtcGxlcnM6IHNhbXBsZXJzTWFwLFxuICAgICAgICAgICAgdGV4dHVyZXM6IHRleHR1cmVzTWFwLFxuICAgICAgICAgICAgbWF0ZXJpYWxzOiBtYXRlcmlhbHNNYXAsXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwcml2YXRlIHN0YXRpYyBjcmVhdGVOb3JtYWxzQnVmZmVyID0gKFxuICAgICAgICBtZXNoRGF0YTogSVByZWxvYWRNZXNoLFxuICAgICAgICBidWZmZXJJbmRleE1hcDogSW5kZXhNYXAsXG4gICAgICAgIGJ1ZmZlck1hcDogQnVmZmVyTWFwXG4gICAgKSA9PiB7XG4gICAgICAgIGNvbnN0IHBvc2l0aW9uc0J1ZmZlciA9IGJ1ZmZlck1hcC5nZXQoXG4gICAgICAgICAgICBtZXNoRGF0YS5wb3NpdGlvbnMuYnVmZmVySWRcbiAgICAgICAgKSBhcyBBcnJheUJ1ZmZlclxuXG4gICAgICAgIGNvbnN0IGluZGV4QnVmZmVyID0gYnVmZmVyTWFwLmdldChcbiAgICAgICAgICAgIG1lc2hEYXRhLmluZGljZXMuYnVmZmVySWRcbiAgICAgICAgKSBhcyBBcnJheUJ1ZmZlclxuXG4gICAgICAgIGNvbnN0IHZlcnRpY2VzID0gbmV3IEZsb2F0MzJBcnJheShcbiAgICAgICAgICAgIHBvc2l0aW9uc0J1ZmZlcixcbiAgICAgICAgICAgIG1lc2hEYXRhLnBvc2l0aW9ucz8uYnl0ZU9mZnNldCxcbiAgICAgICAgICAgIG1lc2hEYXRhLnBvc2l0aW9ucz8uYnl0ZUxlbmd0aCAvIDRcbiAgICAgICAgKVxuXG4gICAgICAgIGNvbnN0IGluZGljZXMgPSBuZXcgVWludDE2QXJyYXkoXG4gICAgICAgICAgICBpbmRleEJ1ZmZlcixcbiAgICAgICAgICAgIG1lc2hEYXRhLmluZGljZXM/LmJ5dGVPZmZzZXQsXG4gICAgICAgICAgICBtZXNoRGF0YS5pbmRpY2VzPy5ieXRlTGVuZ3RoIC8gMlxuICAgICAgICApXG5cbiAgICAgICAgY29uc3Qgbm9ybWFscyA9IG5ldyBGbG9hdDMyQXJyYXkodmVydGljZXMubGVuZ3RoKVxuXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaW5kaWNlcy5sZW5ndGg7IGkgKz0gMykge1xuICAgICAgICAgICAgY29uc3QgdmVydDAgPSB2ZWMzLmNyZWF0ZShcbiAgICAgICAgICAgICAgICB2ZXJ0aWNlc1tpbmRpY2VzW2ldICogM10sXG4gICAgICAgICAgICAgICAgdmVydGljZXNbaW5kaWNlc1tpXSAqIDMgKyAxXSxcbiAgICAgICAgICAgICAgICB2ZXJ0aWNlc1tpbmRpY2VzW2ldICogMyArIDJdXG4gICAgICAgICAgICApXG4gICAgICAgICAgICBjb25zdCB2ZXJ0MSA9IHZlYzMuY3JlYXRlKFxuICAgICAgICAgICAgICAgIHZlcnRpY2VzW2luZGljZXNbaSArIDFdICogM10sXG4gICAgICAgICAgICAgICAgdmVydGljZXNbaW5kaWNlc1tpICsgMV0gKiAzICsgMV0sXG4gICAgICAgICAgICAgICAgdmVydGljZXNbaW5kaWNlc1tpICsgMV0gKiAzICsgMl1cbiAgICAgICAgICAgIClcblxuICAgICAgICAgICAgY29uc3QgdmVydDIgPSB2ZWMzLmNyZWF0ZShcbiAgICAgICAgICAgICAgICB2ZXJ0aWNlc1tpbmRpY2VzW2kgKyAyXSAqIDNdLFxuICAgICAgICAgICAgICAgIHZlcnRpY2VzW2luZGljZXNbaSArIDJdICogMyArIDFdLFxuICAgICAgICAgICAgICAgIHZlcnRpY2VzW2luZGljZXNbaSArIDJdICogMyArIDJdXG4gICAgICAgICAgICApXG5cbiAgICAgICAgICAgIC8vIHAgPSBjcm9zcyhCLUEsIEMtQSlcbiAgICAgICAgICAgIGNvbnN0IG5vcm1hbCA9IHZlYzMuY3Jvc3MoXG4gICAgICAgICAgICAgICAgdmVjMy5zdWJ0cmFjdCh2ZXJ0MSwgdmVydDApLFxuICAgICAgICAgICAgICAgIHZlYzMuc3VidHJhY3QodmVydDIsIHZlcnQwKVxuICAgICAgICAgICAgKVxuXG4gICAgICAgICAgICBub3JtYWxzW2luZGljZXNbaV0gKiAzXSArPSBub3JtYWxbMF1cbiAgICAgICAgICAgIG5vcm1hbHNbaW5kaWNlc1tpXSAqIDMgKyAxXSArPSBub3JtYWxbMV1cbiAgICAgICAgICAgIG5vcm1hbHNbaW5kaWNlc1tpXSAqIDMgKyAyXSArPSBub3JtYWxbMl1cblxuICAgICAgICAgICAgbm9ybWFsc1tpbmRpY2VzW2kgKyAxXSAqIDNdICs9IG5vcm1hbFswXVxuICAgICAgICAgICAgbm9ybWFsc1tpbmRpY2VzW2kgKyAxXSAqIDMgKyAxXSArPSBub3JtYWxbMV1cbiAgICAgICAgICAgIG5vcm1hbHNbaW5kaWNlc1tpICsgMV0gKiAzICsgMl0gKz0gbm9ybWFsWzJdXG5cbiAgICAgICAgICAgIG5vcm1hbHNbaW5kaWNlc1tpICsgMl0gKiAzXSArPSBub3JtYWxbMF1cbiAgICAgICAgICAgIG5vcm1hbHNbaW5kaWNlc1tpICsgMl0gKiAzICsgMV0gKz0gbm9ybWFsWzFdXG4gICAgICAgICAgICBub3JtYWxzW2luZGljZXNbaSArIDJdICogMyArIDJdICs9IG5vcm1hbFsyXVxuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpbmRpY2VzLmxlbmd0aDsgaSArPSAzKSB7XG4gICAgICAgICAgICBjb25zdCBub3JtYWxpemVkTm9ybWFsID0gdmVjMy5ub3JtYWxpemUoXG4gICAgICAgICAgICAgICAgdmVjMy5jcmVhdGUoXG4gICAgICAgICAgICAgICAgICAgIG5vcm1hbHNbaW5kaWNlc1tpXSAqIDNdLFxuICAgICAgICAgICAgICAgICAgICBub3JtYWxzW2luZGljZXNbaV0gKiAzICsgMV0sXG4gICAgICAgICAgICAgICAgICAgIG5vcm1hbHNbaW5kaWNlc1tpXSAqIDMgKyAyXVxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgIClcblxuICAgICAgICAgICAgbm9ybWFsc1tpbmRpY2VzW2ldICogM10gPSBub3JtYWxpemVkTm9ybWFsWzBdXG4gICAgICAgICAgICBub3JtYWxzW2luZGljZXNbaV0gKiAzICsgMV0gPSBub3JtYWxpemVkTm9ybWFsWzFdXG4gICAgICAgICAgICBub3JtYWxzW2luZGljZXNbaV0gKiAzICsgMl0gPSBub3JtYWxpemVkTm9ybWFsWzJdXG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBpZCA9IGdlbmVyYXRlSWQoKVxuICAgICAgICBidWZmZXJJbmRleE1hcC5zZXQoTWF0aC5yYW5kb20oKSwgaWQpXG4gICAgICAgIGJ1ZmZlck1hcC5zZXQoaWQsIG5vcm1hbHMuYnVmZmVyKVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBidWZmZXJJZDogaWQsXG4gICAgICAgICAgICBieXRlU3RyaWRlOiAxMixcbiAgICAgICAgICAgIGJ5dGVMZW5ndGg6IG5vcm1hbHMuYnl0ZUxlbmd0aCxcbiAgICAgICAgICAgIGJ5dGVPZmZzZXQ6IDAsXG4gICAgICAgICAgICBjb3VudDogbm9ybWFscy5ieXRlTGVuZ3RoIC8gKDQgKiAzKSxcbiAgICAgICAgICAgIGNvbXBvbmVudFR5cGU6IEdMVEZDb21wb25lbnRUeXBlLkZMT0FULFxuICAgICAgICAgICAgZWxlbWVudFR5cGU6ICdmbG9hdDMyeDMnLFxuICAgICAgICAgICAgdXNhZ2U6IEdQVUJ1ZmZlclVzYWdlLlZFUlRFWCxcbiAgICAgICAgfSBhcyBHTFRGQWNjZXNzb3JcbiAgICB9XG5cbiAgICBwcml2YXRlIHN0YXRpYyBjcmVhdGVUZXh0dXJlQ29vcmRpbmF0ZXNCdWZmZXIgPSAoXG4gICAgICAgIGJ1ZmZlckluZGV4TWFwOiBJbmRleE1hcCxcbiAgICAgICAgYnVmZmVyTWFwOiBCdWZmZXJNYXBcbiAgICApID0+IHtcbiAgICAgICAgY29uc3QgdGV4Q29vcmRzID0gbmV3IFVpbnQzMkFycmF5KClcbiAgICAgICAgY29uc3QgaWQgPSBnZW5lcmF0ZUlkKClcbiAgICAgICAgYnVmZmVySW5kZXhNYXAuc2V0KE1hdGgucmFuZG9tKCksIGlkKVxuICAgICAgICBidWZmZXJNYXAuc2V0KGlkLCB0ZXhDb29yZHMuYnVmZmVyKVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBidWZmZXJJZDogaWQsXG4gICAgICAgICAgICBieXRlU3RyaWRlOiA4LFxuICAgICAgICAgICAgYnl0ZUxlbmd0aDogdGV4Q29vcmRzLmJ5dGVMZW5ndGgsXG4gICAgICAgICAgICBieXRlT2Zmc2V0OiAwLFxuICAgICAgICAgICAgY291bnQ6IHRleENvb3Jkcy5ieXRlTGVuZ3RoIC8gKDQgKiAyKSxcbiAgICAgICAgICAgIGNvbXBvbmVudFR5cGU6IEdMVEZDb21wb25lbnRUeXBlLkZMT0FULFxuICAgICAgICAgICAgZWxlbWVudFR5cGU6ICdmbG9hdDMyeDInLFxuICAgICAgICAgICAgdXNhZ2U6IDMyLFxuICAgICAgICB9IGFzIEdMVEZBY2Nlc3NvclxuICAgIH1cblxuICAgIHByaXZhdGUgc3RhdGljIGNyZWF0ZVRhbmdlbnRzQnVmZmVyID0gKFxuICAgICAgICBtZXNoRGF0YTogSVByZWxvYWRNZXNoLFxuICAgICAgICBidWZmZXJJbmRleE1hcDogSW5kZXhNYXAsXG4gICAgICAgIGJ1ZmZlck1hcDogQnVmZmVyTWFwXG4gICAgKSA9PiB7XG4gICAgICAgIGNvbnN0IHBvc2l0aW9uc0J1ZmZlciA9IGJ1ZmZlck1hcC5nZXQoXG4gICAgICAgICAgICBtZXNoRGF0YS5wb3NpdGlvbnMuYnVmZmVySWRcbiAgICAgICAgKSBhcyBBcnJheUJ1ZmZlclxuXG4gICAgICAgIGNvbnN0IHRleHR1cmVDb29yZGluYXRlc0J1ZmZlciA9IGJ1ZmZlck1hcC5nZXQoXG4gICAgICAgICAgICBtZXNoRGF0YS50ZXh0dXJlQ29vcmRpbmF0ZXMuYnVmZmVySWRcbiAgICAgICAgKSBhcyBBcnJheUJ1ZmZlclxuXG4gICAgICAgIGNvbnN0IGluZGV4QnVmZmVyID0gYnVmZmVyTWFwLmdldChcbiAgICAgICAgICAgIG1lc2hEYXRhLmluZGljZXMuYnVmZmVySWRcbiAgICAgICAgKSBhcyBBcnJheUJ1ZmZlclxuXG4gICAgICAgIGNvbnN0IHZlcnRpY2VzID0gbmV3IEZsb2F0MzJBcnJheShcbiAgICAgICAgICAgIHBvc2l0aW9uc0J1ZmZlcixcbiAgICAgICAgICAgIG1lc2hEYXRhLnBvc2l0aW9ucz8uYnl0ZU9mZnNldCxcbiAgICAgICAgICAgIG1lc2hEYXRhLnBvc2l0aW9ucz8uYnl0ZUxlbmd0aCAvIDRcbiAgICAgICAgKVxuXG4gICAgICAgIGNvbnN0IHRleHR1cmVDb29yZGluYXRlcyA9IG5ldyBVaW50MzJBcnJheShcbiAgICAgICAgICAgIHRleHR1cmVDb29yZGluYXRlc0J1ZmZlcixcbiAgICAgICAgICAgIG1lc2hEYXRhLnRleHR1cmVDb29yZGluYXRlcz8uYnl0ZU9mZnNldCxcbiAgICAgICAgICAgIG1lc2hEYXRhLnRleHR1cmVDb29yZGluYXRlcz8uYnl0ZUxlbmd0aCAvIDRcbiAgICAgICAgKVxuXG4gICAgICAgIGNvbnN0IGluZGljZXMgPVxuICAgICAgICAgICAgLy9GSVhNRTogdGhpcyBjb3VsZCBiZSBzb21ldGhpbmcgb3RoZXIgdGhhbiBVaW50MTZcbiAgICAgICAgICAgIG5ldyBVaW50MTZBcnJheShcbiAgICAgICAgICAgICAgICBpbmRleEJ1ZmZlcixcbiAgICAgICAgICAgICAgICBtZXNoRGF0YS5pbmRpY2VzPy5ieXRlT2Zmc2V0LFxuICAgICAgICAgICAgICAgIG1lc2hEYXRhLmluZGljZXM/LmJ5dGVMZW5ndGggLyAyXG4gICAgICAgICAgICApXG5cbiAgICAgICAgY29uc3QgdGFuZ2VudHMgPSBuZXcgRmxvYXQzMkFycmF5KHZlcnRpY2VzLmxlbmd0aClcblxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGluZGljZXMubGVuZ3RoOyBpICs9IDkpIHtcbiAgICAgICAgICAgIGNvbnN0IHZlcnQwID0gdmVjMy5jcmVhdGUoXG4gICAgICAgICAgICAgICAgdmVydGljZXNbaW5kaWNlc1tpXV0sXG4gICAgICAgICAgICAgICAgdmVydGljZXNbaW5kaWNlc1tpICsgMV1dLFxuICAgICAgICAgICAgICAgIHZlcnRpY2VzW2luZGljZXNbaSArIDJdXVxuICAgICAgICAgICAgKVxuICAgICAgICAgICAgY29uc3QgdmVydDEgPSB2ZWMzLmNyZWF0ZShcbiAgICAgICAgICAgICAgICB2ZXJ0aWNlc1tpbmRpY2VzW2kgKyAzXV0sXG4gICAgICAgICAgICAgICAgdmVydGljZXNbaW5kaWNlc1tpICsgNF1dLFxuICAgICAgICAgICAgICAgIHZlcnRpY2VzW2luZGljZXNbaSArIDVdXVxuICAgICAgICAgICAgKVxuXG4gICAgICAgICAgICBjb25zdCB2ZXJ0MiA9IHZlYzMuY3JlYXRlKFxuICAgICAgICAgICAgICAgIHZlcnRpY2VzW2luZGljZXNbaSArIDZdXSxcbiAgICAgICAgICAgICAgICB2ZXJ0aWNlc1tpbmRpY2VzW2kgKyA3XV0sXG4gICAgICAgICAgICAgICAgdmVydGljZXNbaW5kaWNlc1tpICsgOF1dXG4gICAgICAgICAgICApXG5cbiAgICAgICAgICAgIGNvbnN0IHV2MCA9IHZlYzIuY3JlYXRlKFxuICAgICAgICAgICAgICAgIHRleHR1cmVDb29yZGluYXRlc1tpbmRpY2VzW2ldXSxcbiAgICAgICAgICAgICAgICB0ZXh0dXJlQ29vcmRpbmF0ZXNbaW5kaWNlc1tpICsgMV1dXG4gICAgICAgICAgICApXG5cbiAgICAgICAgICAgIGNvbnN0IHV2MSA9IHZlYzIuY3JlYXRlKFxuICAgICAgICAgICAgICAgIHRleHR1cmVDb29yZGluYXRlc1tpbmRpY2VzW2kgKyAyXV0sXG4gICAgICAgICAgICAgICAgdGV4dHVyZUNvb3JkaW5hdGVzW2luZGljZXNbaSArIDNdXVxuICAgICAgICAgICAgKVxuXG4gICAgICAgICAgICBjb25zdCB1djIgPSB2ZWMyLmNyZWF0ZShcbiAgICAgICAgICAgICAgICB0ZXh0dXJlQ29vcmRpbmF0ZXNbaW5kaWNlc1tpICsgNF1dLFxuICAgICAgICAgICAgICAgIHRleHR1cmVDb29yZGluYXRlc1tpbmRpY2VzW2kgKyA1XV1cbiAgICAgICAgICAgIClcblxuICAgICAgICAgICAgY29uc3QgZWRnZTEgPSB2ZWMzLnN1YnRyYWN0KHZlcnQxLCB2ZXJ0MClcbiAgICAgICAgICAgIGNvbnN0IGVkZ2UyID0gdmVjMy5zdWJ0cmFjdCh2ZXJ0MiwgdmVydDApXG5cbiAgICAgICAgICAgIGNvbnN0IGRlbHRhVTEgPSB1djFbMF0gLSB1djBbMF1cbiAgICAgICAgICAgIGNvbnN0IGRlbHRhVjEgPSB1djFbMV0gLSB1djBbMV1cbiAgICAgICAgICAgIGNvbnN0IGRlbHRhVTIgPSB1djJbMF0gLSB1djBbMF1cbiAgICAgICAgICAgIGNvbnN0IGRlbHRhVjIgPSB1djJbMV0gLSB1djBbMV1cblxuICAgICAgICAgICAgbGV0IGYgPSAxIC8gKGRlbHRhVTEgKiBkZWx0YVYyIC0gZGVsdGFVMiAqIGRlbHRhVjEpXG5cbiAgICAgICAgICAgIC8vRklYTUU6IGltIG5vdCBzdXJlIGl0IHNob3VsZCBiZSB0aGF0XG4gICAgICAgICAgICBpZiAoIWlzRmluaXRlKGYpKSB7XG4gICAgICAgICAgICAgICAgZiA9IDAuMFxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgdGFuZ2VudCA9IHZlYzMuY3JlYXRlKFxuICAgICAgICAgICAgICAgIGYgKiAoZGVsdGFWMiAqIGVkZ2UxWzBdIC0gZGVsdGFWMSAqIGVkZ2UyWzBdKSxcbiAgICAgICAgICAgICAgICBmICogKGRlbHRhVjIgKiBlZGdlMVsxXSAtIGRlbHRhVjEgKiBlZGdlMlsxXSksXG4gICAgICAgICAgICAgICAgZiAqIChkZWx0YVYyICogZWRnZTFbMl0gLSBkZWx0YVYxICogZWRnZTJbMl0pXG4gICAgICAgICAgICApXG5cbiAgICAgICAgICAgIHRhbmdlbnRzW2luZGljZXNbaV1dICs9IHRhbmdlbnRbMF1cbiAgICAgICAgICAgIHRhbmdlbnRzW2luZGljZXNbaSArIDFdXSArPSB0YW5nZW50WzFdXG4gICAgICAgICAgICB0YW5nZW50c1tpbmRpY2VzW2kgKyAyXV0gKz0gdGFuZ2VudFsyXVxuXG4gICAgICAgICAgICB0YW5nZW50c1tpbmRpY2VzW2kgKyAzXV0gKz0gdGFuZ2VudFswXVxuICAgICAgICAgICAgdGFuZ2VudHNbaW5kaWNlc1tpICsgNF1dICs9IHRhbmdlbnRbMV1cbiAgICAgICAgICAgIHRhbmdlbnRzW2luZGljZXNbaSArIDVdXSArPSB0YW5nZW50WzJdXG5cbiAgICAgICAgICAgIHRhbmdlbnRzW2luZGljZXNbaSArIDZdXSArPSB0YW5nZW50WzBdXG4gICAgICAgICAgICB0YW5nZW50c1tpbmRpY2VzW2kgKyA3XV0gKz0gdGFuZ2VudFsxXVxuICAgICAgICAgICAgdGFuZ2VudHNbaW5kaWNlc1tpICsgOF1dICs9IHRhbmdlbnRbMl1cbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGlkID0gZ2VuZXJhdGVJZCgpXG4gICAgICAgIGJ1ZmZlckluZGV4TWFwLnNldChNYXRoLnJhbmRvbSgpLCBpZClcbiAgICAgICAgYnVmZmVyTWFwLnNldChpZCwgdGFuZ2VudHMuYnVmZmVyKVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBidWZmZXJJZDogaWQsXG4gICAgICAgICAgICBieXRlU3RyaWRlOiAxMixcbiAgICAgICAgICAgIGJ5dGVMZW5ndGg6IHRhbmdlbnRzLmJ5dGVMZW5ndGgsXG4gICAgICAgICAgICBieXRlT2Zmc2V0OiAwLFxuICAgICAgICAgICAgY291bnQ6IHRhbmdlbnRzLmJ5dGVMZW5ndGggLyAoNCAqIDMpLFxuICAgICAgICAgICAgY29tcG9uZW50VHlwZTogR0xURkNvbXBvbmVudFR5cGUuRkxPQVQsXG4gICAgICAgICAgICBlbGVtZW50VHlwZTogJ2Zsb2F0MzJ4MycsXG4gICAgICAgICAgICB1c2FnZTogMzIsXG4gICAgICAgIH0gYXMgR0xURkFjY2Vzc29yXG4gICAgfVxuXG4gICAgcHJpdmF0ZSBzdGF0aWMgcGFyc2VBY2Nlc3NvciA9IChcbiAgICAgICAgbW9kZWxEYXRhOiBSZWNvcmQ8c3RyaW5nLCBhbnk+LFxuICAgICAgICBhY2Nlc3NvcklkOiBudW1iZXIsXG4gICAgICAgIHVzYWdlOiBHUFVCdWZmZXJVc2FnZUZsYWdzLFxuICAgICAgICBidWZmZXJJbmRleE1hcDogSW5kZXhNYXBcbiAgICApOiBHTFRGQWNjZXNzb3IgfCB1bmRlZmluZWQgPT4ge1xuICAgICAgICBpZiAoYWNjZXNzb3JJZCAhPT0gMCAmJiAhYWNjZXNzb3JJZCkge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZFxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgcmF3QWNjZXNzb3IgPSBtb2RlbERhdGEuanNvbi5hY2Nlc3NvcnNbYWNjZXNzb3JJZF1cbiAgICAgICAgY29uc3QgcmF3QnVmZmVyVmlldyA9IG1vZGVsRGF0YS5qc29uLmJ1ZmZlclZpZXdzW3Jhd0FjY2Vzc29yLmJ1ZmZlclZpZXddXG4gICAgICAgIGNvbnN0IGJ1ZmZlciA9IG1vZGVsRGF0YS5iaW5DaHVua3NbcmF3QnVmZmVyVmlldy5idWZmZXJdXG5cbiAgICAgICAgY29uc3QgZWxlbWVudFNpemUgPSBnZXRUeXBlU2l6ZShcbiAgICAgICAgICAgIHJhd0FjY2Vzc29yLmNvbXBvbmVudFR5cGUsXG4gICAgICAgICAgICByYXdBY2Nlc3Nvci50eXBlXG4gICAgICAgIClcbiAgICAgICAgY29uc3QgYnl0ZVN0cmlkZSA9IE1hdGgubWF4KGVsZW1lbnRTaXplLCByYXdCdWZmZXJWaWV3LmJ5dGVTdHJpZGUgPz8gMClcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgYnVmZmVySWQ6IGJ1ZmZlckluZGV4TWFwLmdldChyYXdCdWZmZXJWaWV3LmJ1ZmZlcikgYXMgc3RyaW5nLFxuICAgICAgICAgICAgYnl0ZVN0cmlkZTogYnl0ZVN0cmlkZSxcbiAgICAgICAgICAgIGJ5dGVMZW5ndGg6IHJhd0FjY2Vzc29yLmNvdW50ICogKGJ5dGVTdHJpZGUgPz8gMSksXG4gICAgICAgICAgICBieXRlT2Zmc2V0OlxuICAgICAgICAgICAgICAgIChyYXdBY2Nlc3Nvcj8uYnl0ZU9mZnNldCA/PyAwKSArXG4gICAgICAgICAgICAgICAgKHJhd0J1ZmZlclZpZXc/LmJ5dGVPZmZzZXQgPz8gMCkgK1xuICAgICAgICAgICAgICAgIChidWZmZXI/LmJ5dGVPZmZzZXQgPz8gMCksXG4gICAgICAgICAgICBjb3VudDogcmF3QWNjZXNzb3IuY291bnQsXG4gICAgICAgICAgICBjb21wb25lbnRUeXBlOiByYXdBY2Nlc3Nvci5jb21wb25lbnRUeXBlLFxuICAgICAgICAgICAgZWxlbWVudFR5cGU6IGdldFZlcnRleFR5cGUoXG4gICAgICAgICAgICAgICAgcmF3QWNjZXNzb3IuY29tcG9uZW50VHlwZSxcbiAgICAgICAgICAgICAgICByYXdBY2Nlc3Nvci50eXBlXG4gICAgICAgICAgICApLFxuICAgICAgICAgICAgbWluOiByYXdBY2Nlc3Nvci5taW4sXG4gICAgICAgICAgICBtYXg6IHJhd0FjY2Vzc29yLm1heCxcbiAgICAgICAgICAgIHVzYWdlOiB1c2FnZSxcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHByaXZhdGUgc3RhdGljIGxvYWROb2RlKFxuICAgICAgICBub2RlSW5kZXg6IG51bWJlcixcbiAgICAgICAgbW9kZWxEYXRhOiBSZWNvcmQ8c3RyaW5nLCBhbnk+LFxuICAgICAgICBidWZmZXJJbmRleE1hcDogSW5kZXhNYXAsXG4gICAgICAgIG1hdGVyaWFsc0luZGV4TWFwOiBJbmRleE1hcCxcbiAgICAgICAgYnVmZmVyTWFwOiBCdWZmZXJNYXBcbiAgICApIHtcbiAgICAgICAgY29uc3Qgbm9kZUpzb25EYXRhID0gbW9kZWxEYXRhPy5qc29uPy5ub2Rlc1tub2RlSW5kZXhdXG4gICAgICAgIGNvbnN0IGRhdGFTdHJ1Y3RFbnRyeTogSVByZWxvYWRFbnRpdHkgPSB7XG4gICAgICAgICAgICB0cnNNYXRyaXg6IG5vZGVKc29uRGF0YS5tYXRyaXggPz8gbWF0NC5pZGVudGl0eSgpLFxuICAgICAgICAgICAgbWVzaGVzOiBbXSxcbiAgICAgICAgICAgIGNoaWxkcmVuOiBbXSxcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChub2RlSnNvbkRhdGEubWVzaCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjb25zdCBtZXNoSnNvbkRhdGEgPSBtb2RlbERhdGEuanNvbi5tZXNoZXNbbm9kZUpzb25EYXRhLm1lc2hdXG5cbiAgICAgICAgICAgIG1lc2hKc29uRGF0YS5wcmltaXRpdmVzLmZvckVhY2goXG4gICAgICAgICAgICAgICAgKHByaW1pdGl2ZToge1xuICAgICAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBOT1JNQUw6IG51bWJlclxuICAgICAgICAgICAgICAgICAgICAgICAgUE9TSVRJT046IG51bWJlclxuICAgICAgICAgICAgICAgICAgICAgICAgVEVYQ09PUkRfMDogbnVtYmVyXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaW5kaWNlczogbnVtYmVyXG4gICAgICAgICAgICAgICAgICAgIG1vZGU6IG51bWJlclxuICAgICAgICAgICAgICAgICAgICBtYXRlcmlhbD86IG51bWJlclxuICAgICAgICAgICAgICAgIH0pID0+IHtcbiAgICAgICAgICAgICAgICAgICAgLy9GSVhNRTogZ2VuZXJhdGUgYWxsIG9mIGl0XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG1lc2hEYXRhOiBQYXJ0aWFsPElQcmVsb2FkTWVzaD4gPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbnM6IFdoZWV6eUdMQkxvYWRlci5wYXJzZUFjY2Vzc29yKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1vZGVsRGF0YSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcmltaXRpdmUuYXR0cmlidXRlcy5QT1NJVElPTixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBHUFVCdWZmZXJVc2FnZS5WRVJURVgsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnVmZmVySW5kZXhNYXBcbiAgICAgICAgICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgICAgICAgICBpbmRpY2VzOiBXaGVlenlHTEJMb2FkZXIucGFyc2VBY2Nlc3NvcihcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtb2RlbERhdGEsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJpbWl0aXZlLmluZGljZXMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgR1BVQnVmZmVyVXNhZ2UuSU5ERVgsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnVmZmVySW5kZXhNYXBcbiAgICAgICAgICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgICAgICAgICBub3JtYWxzOiBXaGVlenlHTEJMb2FkZXIucGFyc2VBY2Nlc3NvcihcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtb2RlbERhdGEsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJpbWl0aXZlLmF0dHJpYnV0ZXMuTk9STUFMLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIEdQVUJ1ZmZlclVzYWdlLlZFUlRFWCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBidWZmZXJJbmRleE1hcFxuICAgICAgICAgICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRleHR1cmVDb29yZGluYXRlczogV2hlZXp5R0xCTG9hZGVyLnBhcnNlQWNjZXNzb3IoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbW9kZWxEYXRhLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByaW1pdGl2ZS5hdHRyaWJ1dGVzLlRFWENPT1JEXzAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgR1BVQnVmZmVyVXNhZ2UuVkVSVEVYLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJ1ZmZlckluZGV4TWFwXG4gICAgICAgICAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWF0ZXJpYWxJZDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcmltaXRpdmUubWF0ZXJpYWwgIT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IG1hdGVyaWFsc0luZGV4TWFwLmdldChwcmltaXRpdmUubWF0ZXJpYWwpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogJ2RlZmF1bHQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgbW9kZTogcHJpbWl0aXZlLm1vZGUgPz8gNCxcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGlmICghbWVzaERhdGEubm9ybWFscykge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWVzaERhdGEubm9ybWFscyA9IHRoaXMuY3JlYXRlTm9ybWFsc0J1ZmZlcihcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXNoRGF0YSBhcyBJUHJlbG9hZE1lc2gsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnVmZmVySW5kZXhNYXAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnVmZmVyTWFwXG4gICAgICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBpZiAoIW1lc2hEYXRhLnRleHR1cmVDb29yZGluYXRlcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWVzaERhdGEudGV4dHVyZUNvb3JkaW5hdGVzID1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNyZWF0ZVRleHR1cmVDb29yZGluYXRlc0J1ZmZlcihcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnVmZmVySW5kZXhNYXAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJ1ZmZlck1hcFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIG1lc2hEYXRhLnRhbmdlbnRzID0gdGhpcy5jcmVhdGVUYW5nZW50c0J1ZmZlcihcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc2hEYXRhIGFzIElQcmVsb2FkTWVzaCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGJ1ZmZlckluZGV4TWFwLFxuICAgICAgICAgICAgICAgICAgICAgICAgYnVmZmVyTWFwXG4gICAgICAgICAgICAgICAgICAgIClcblxuICAgICAgICAgICAgICAgICAgICBkYXRhU3RydWN0RW50cnkubWVzaGVzLnB1c2gobWVzaERhdGEgYXMgSVByZWxvYWRNZXNoKVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIClcbiAgICAgICAgfVxuXG4gICAgICAgIG5vZGVKc29uRGF0YT8uY2hpbGRyZW4/LmZvckVhY2goKGNoaWxkSW5kZXg6IG51bWJlcikgPT4ge1xuICAgICAgICAgICAgZGF0YVN0cnVjdEVudHJ5LmNoaWxkcmVuLnB1c2goXG4gICAgICAgICAgICAgICAgdGhpcy5sb2FkTm9kZShcbiAgICAgICAgICAgICAgICAgICAgY2hpbGRJbmRleCxcbiAgICAgICAgICAgICAgICAgICAgbW9kZWxEYXRhLFxuICAgICAgICAgICAgICAgICAgICBidWZmZXJJbmRleE1hcCxcbiAgICAgICAgICAgICAgICAgICAgbWF0ZXJpYWxzSW5kZXhNYXAsXG4gICAgICAgICAgICAgICAgICAgIGJ1ZmZlck1hcFxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgIClcbiAgICAgICAgfSlcblxuICAgICAgICByZXR1cm4gZGF0YVN0cnVjdEVudHJ5XG4gICAgfVxufVxuIiwiZXhwb3J0IGVudW0gR0xURkNvbXBvbmVudFR5cGUge1xuICAgIEJZVEUgPSA1MTIwLFxuICAgIFVOU0lHTkVEX0JZVEUgPSA1MTIxLFxuICAgIFNIT1JUID0gNTEyMixcbiAgICBVTlNJR05FRF9TSE9SVCA9IDUxMjMsXG4gICAgSU5UID0gNTEyNCxcbiAgICBVTlNJR05FRF9JTlQgPSA1MTI1LFxuICAgIEZMT0FUID0gNTEyNixcbiAgICBET1VCTEUgPSA1MTMwLFxufVxuXG5leHBvcnQgY29uc3QgZ2V0VHlwZUNvbXBvbmVudHNBbW91bnQgPSAodHlwZTogc3RyaW5nKSA9PiB7XG4gICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgIGNhc2UgJ1NDQUxBUic6XG4gICAgICAgICAgICByZXR1cm4gMVxuICAgICAgICBjYXNlICdWRUMyJzpcbiAgICAgICAgICAgIHJldHVybiAyXG4gICAgICAgIGNhc2UgJ1ZFQzMnOlxuICAgICAgICAgICAgcmV0dXJuIDNcbiAgICAgICAgY2FzZSAnVkVDNCc6XG4gICAgICAgICAgICByZXR1cm4gNFxuICAgICAgICBjYXNlICdNQVQyJzpcbiAgICAgICAgICAgIHJldHVybiA0XG4gICAgICAgIGNhc2UgJ01BVDMnOlxuICAgICAgICAgICAgcmV0dXJuIDlcbiAgICAgICAgY2FzZSAnTUFUNCc6XG4gICAgICAgICAgICByZXR1cm4gMTZcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHRocm93IEVycm9yKGBJbnZhbGlkIGdsdGYgdHlwZSAke3R5cGV9YClcbiAgICB9XG59XG5cbmV4cG9ydCBjb25zdCBnZXRWZXJ0ZXhUeXBlID0gKFxuICAgIGNvbXBvbmVudFR5cGU6IG51bWJlcixcbiAgICB0eXBlOiBzdHJpbmdcbik6IEdQVVZlcnRleEZvcm1hdCA9PiB7XG4gICAgbGV0IHR5cGVTdHI6IHN0cmluZyB8IG51bGwgPSBudWxsXG4gICAgc3dpdGNoIChjb21wb25lbnRUeXBlKSB7XG4gICAgICAgIGNhc2UgR0xURkNvbXBvbmVudFR5cGUuQllURTpcbiAgICAgICAgICAgIHR5cGVTdHIgPSAnc2ludDgnXG4gICAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlIEdMVEZDb21wb25lbnRUeXBlLlVOU0lHTkVEX0JZVEU6XG4gICAgICAgICAgICB0eXBlU3RyID0gJ3VpbnQ4J1xuICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSBHTFRGQ29tcG9uZW50VHlwZS5TSE9SVDpcbiAgICAgICAgICAgIHR5cGVTdHIgPSAnc2ludDE2J1xuICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSBHTFRGQ29tcG9uZW50VHlwZS5VTlNJR05FRF9TSE9SVDpcbiAgICAgICAgICAgIHR5cGVTdHIgPSAndWludDE2J1xuICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSBHTFRGQ29tcG9uZW50VHlwZS5JTlQ6XG4gICAgICAgICAgICB0eXBlU3RyID0gJ2ludDMyJ1xuICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSBHTFRGQ29tcG9uZW50VHlwZS5VTlNJR05FRF9JTlQ6XG4gICAgICAgICAgICB0eXBlU3RyID0gJ3VpbnQzMidcbiAgICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgR0xURkNvbXBvbmVudFR5cGUuRkxPQVQ6XG4gICAgICAgICAgICB0eXBlU3RyID0gJ2Zsb2F0MzInXG4gICAgICAgICAgICBicmVha1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgICAgICAgICAgYFVucmVjb2duaXplZCBvciB1bnN1cHBvcnRlZCBnbHRmIHR5cGUgJHtjb21wb25lbnRUeXBlfWBcbiAgICAgICAgICAgIClcbiAgICB9XG5cbiAgICBzd2l0Y2ggKGdldFR5cGVDb21wb25lbnRzQW1vdW50KHR5cGUpKSB7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgIHR5cGVTdHIgKz0gJ3gyJ1xuICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgdHlwZVN0ciArPSAneDMnXG4gICAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICB0eXBlU3RyICs9ICd4NCdcbiAgICAgICAgICAgIGJyZWFrXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB0aHJvdyBFcnJvcihgSW52YWxpZCBudW1iZXIgb2YgY29tcG9uZW50cyBmb3IgZ2x0ZiB0eXBlOiAke3R5cGV9YClcbiAgICB9XG5cbiAgICByZXR1cm4gdHlwZVN0ciBhcyBHUFVWZXJ0ZXhGb3JtYXRcbn1cblxuZXhwb3J0IGNvbnN0IGdldFR5cGVTaXplID0gKGNvbXBvbmVudFR5cGU6IEdMVEZDb21wb25lbnRUeXBlLCB0eXBlOiBzdHJpbmcpID0+IHtcbiAgICBsZXQgY29tcG9uZW50U2l6ZSA9IDBcbiAgICBzd2l0Y2ggKGNvbXBvbmVudFR5cGUpIHtcbiAgICAgICAgY2FzZSBHTFRGQ29tcG9uZW50VHlwZS5CWVRFOlxuICAgICAgICAgICAgY29tcG9uZW50U2l6ZSA9IDFcbiAgICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgR0xURkNvbXBvbmVudFR5cGUuVU5TSUdORURfQllURTpcbiAgICAgICAgICAgIGNvbXBvbmVudFNpemUgPSAxXG4gICAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlIEdMVEZDb21wb25lbnRUeXBlLlNIT1JUOlxuICAgICAgICAgICAgY29tcG9uZW50U2l6ZSA9IDJcbiAgICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgR0xURkNvbXBvbmVudFR5cGUuVU5TSUdORURfU0hPUlQ6XG4gICAgICAgICAgICBjb21wb25lbnRTaXplID0gMlxuICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSBHTFRGQ29tcG9uZW50VHlwZS5JTlQ6XG4gICAgICAgICAgICBjb21wb25lbnRTaXplID0gNFxuICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSBHTFRGQ29tcG9uZW50VHlwZS5VTlNJR05FRF9JTlQ6XG4gICAgICAgICAgICBjb21wb25lbnRTaXplID0gNFxuICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSBHTFRGQ29tcG9uZW50VHlwZS5GTE9BVDpcbiAgICAgICAgICAgIGNvbXBvbmVudFNpemUgPSA0XG4gICAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlIEdMVEZDb21wb25lbnRUeXBlLkRPVUJMRTpcbiAgICAgICAgICAgIGNvbXBvbmVudFNpemUgPSA4XG4gICAgICAgICAgICBicmVha1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdGhyb3cgRXJyb3IoJ1VucmVjb2duaXplZCBHTFRGIENvbXBvbmVudCBUeXBlPycpXG4gICAgfVxuICAgIHJldHVybiBnZXRUeXBlQ29tcG9uZW50c0Ftb3VudCh0eXBlKSAqIGNvbXBvbmVudFNpemVcbn1cblxuZXhwb3J0IGVudW0gSW1hZ2VVc2FnZSB7XG4gICAgQkFTRV9DT0xPUixcbiAgICBNRVRBTExJQ19ST1VHSE5FU1MsXG4gICAgTk9STUFMLFxuICAgIE9DQ0xVU0lPTixcbiAgICBFTUlTU0lPTixcbn1cbiIsImV4cG9ydCAqIGZyb20gJy4vV2hlZXp5R0xCTG9hZGVyL1doZWV6eUdMQkxvYWRlcidcbiIsImNvbnN0IERFRkFVTFRfQ0hVTktfU0laRSA9IDI1NiAqIDEwMjQ7XG5leHBvcnQgZnVuY3Rpb24gbWFrZUFycmF5QnVmZmVySXRlcmF0b3IoYXJyYXlCdWZmZXIpIHtcbiAgbGV0IG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICByZXR1cm4gZnVuY3Rpb24qICgpIHtcbiAgICBjb25zdCB7XG4gICAgICBjaHVua1NpemUgPSBERUZBVUxUX0NIVU5LX1NJWkVcbiAgICB9ID0gb3B0aW9ucztcbiAgICBsZXQgYnl0ZU9mZnNldCA9IDA7XG4gICAgd2hpbGUgKGJ5dGVPZmZzZXQgPCBhcnJheUJ1ZmZlci5ieXRlTGVuZ3RoKSB7XG4gICAgICBjb25zdCBjaHVua0J5dGVMZW5ndGggPSBNYXRoLm1pbihhcnJheUJ1ZmZlci5ieXRlTGVuZ3RoIC0gYnl0ZU9mZnNldCwgY2h1bmtTaXplKTtcbiAgICAgIGNvbnN0IGNodW5rID0gbmV3IEFycmF5QnVmZmVyKGNodW5rQnl0ZUxlbmd0aCk7XG4gICAgICBjb25zdCBzb3VyY2VBcnJheSA9IG5ldyBVaW50OEFycmF5KGFycmF5QnVmZmVyLCBieXRlT2Zmc2V0LCBjaHVua0J5dGVMZW5ndGgpO1xuICAgICAgY29uc3QgY2h1bmtBcnJheSA9IG5ldyBVaW50OEFycmF5KGNodW5rKTtcbiAgICAgIGNodW5rQXJyYXkuc2V0KHNvdXJjZUFycmF5KTtcbiAgICAgIGJ5dGVPZmZzZXQgKz0gY2h1bmtCeXRlTGVuZ3RoO1xuICAgICAgeWllbGQgY2h1bms7XG4gICAgfVxuICB9KCk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tYWtlLWFycmF5LWJ1ZmZlci1pdGVyYXRvci5qcy5tYXAiLCJjb25zdCBERUZBVUxUX0NIVU5LX1NJWkUgPSAxMDI0ICogMTAyNDtcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiogbWFrZUJsb2JJdGVyYXRvcihibG9iLCBvcHRpb25zKSB7XG4gIGNvbnN0IGNodW5rU2l6ZSA9IChvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuY2h1bmtTaXplKSB8fCBERUZBVUxUX0NIVU5LX1NJWkU7XG4gIGxldCBvZmZzZXQgPSAwO1xuICB3aGlsZSAob2Zmc2V0IDwgYmxvYi5zaXplKSB7XG4gICAgY29uc3QgZW5kID0gb2Zmc2V0ICsgY2h1bmtTaXplO1xuICAgIGNvbnN0IGNodW5rID0gYXdhaXQgYmxvYi5zbGljZShvZmZzZXQsIGVuZCkuYXJyYXlCdWZmZXIoKTtcbiAgICBvZmZzZXQgPSBlbmQ7XG4gICAgeWllbGQgY2h1bms7XG4gIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1ha2UtYmxvYi1pdGVyYXRvci5qcy5tYXAiLCJpbXBvcnQgeyBtYWtlU3RyaW5nSXRlcmF0b3IgfSBmcm9tIFwiLi9tYWtlLXN0cmluZy1pdGVyYXRvci5qc1wiO1xuaW1wb3J0IHsgbWFrZUFycmF5QnVmZmVySXRlcmF0b3IgfSBmcm9tIFwiLi9tYWtlLWFycmF5LWJ1ZmZlci1pdGVyYXRvci5qc1wiO1xuaW1wb3J0IHsgbWFrZUJsb2JJdGVyYXRvciB9IGZyb20gXCIuL21ha2UtYmxvYi1pdGVyYXRvci5qc1wiO1xuaW1wb3J0IHsgbWFrZVN0cmVhbUl0ZXJhdG9yIH0gZnJvbSBcIi4vbWFrZS1zdHJlYW0taXRlcmF0b3IuanNcIjtcbmltcG9ydCB7IGlzQmxvYiwgaXNSZWFkYWJsZVN0cmVhbSwgaXNSZXNwb25zZSB9IGZyb20gXCIuLi8uLi9qYXZhc2NyaXB0LXV0aWxzL2lzLXR5cGUuanNcIjtcbmV4cG9ydCBmdW5jdGlvbiBtYWtlSXRlcmF0b3IoZGF0YSwgb3B0aW9ucykge1xuICBpZiAodHlwZW9mIGRhdGEgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIG1ha2VTdHJpbmdJdGVyYXRvcihkYXRhLCBvcHRpb25zKTtcbiAgfVxuICBpZiAoZGF0YSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB7XG4gICAgcmV0dXJuIG1ha2VBcnJheUJ1ZmZlckl0ZXJhdG9yKGRhdGEsIG9wdGlvbnMpO1xuICB9XG4gIGlmIChpc0Jsb2IoZGF0YSkpIHtcbiAgICByZXR1cm4gbWFrZUJsb2JJdGVyYXRvcihkYXRhLCBvcHRpb25zKTtcbiAgfVxuICBpZiAoaXNSZWFkYWJsZVN0cmVhbShkYXRhKSkge1xuICAgIHJldHVybiBtYWtlU3RyZWFtSXRlcmF0b3IoZGF0YSwgb3B0aW9ucyk7XG4gIH1cbiAgaWYgKGlzUmVzcG9uc2UoZGF0YSkpIHtcbiAgICBjb25zdCByZXNwb25zZSA9IGRhdGE7XG4gICAgcmV0dXJuIG1ha2VTdHJlYW1JdGVyYXRvcihyZXNwb25zZS5ib2R5LCBvcHRpb25zKTtcbiAgfVxuICB0aHJvdyBuZXcgRXJyb3IoJ21ha2VJdGVyYXRvcicpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bWFrZS1pdGVyYXRvci5qcy5tYXAiLCJpbXBvcnQgeyBpc0Jyb3dzZXIsIHRvQXJyYXlCdWZmZXIgfSBmcm9tICdAbG9hZGVycy5nbC9sb2FkZXItdXRpbHMnO1xuZXhwb3J0IGZ1bmN0aW9uIG1ha2VTdHJlYW1JdGVyYXRvcihzdHJlYW0sIG9wdGlvbnMpIHtcbiAgcmV0dXJuIGlzQnJvd3NlciA/IG1ha2VCcm93c2VyU3RyZWFtSXRlcmF0b3Ioc3RyZWFtLCBvcHRpb25zKSA6IG1ha2VOb2RlU3RyZWFtSXRlcmF0b3Ioc3RyZWFtLCBvcHRpb25zKTtcbn1cbmFzeW5jIGZ1bmN0aW9uKiBtYWtlQnJvd3NlclN0cmVhbUl0ZXJhdG9yKHN0cmVhbSwgb3B0aW9ucykge1xuICBjb25zdCByZWFkZXIgPSBzdHJlYW0uZ2V0UmVhZGVyKCk7XG4gIGxldCBuZXh0QmF0Y2hQcm9taXNlO1xuICB0cnkge1xuICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICBjb25zdCBjdXJyZW50QmF0Y2hQcm9taXNlID0gbmV4dEJhdGNoUHJvbWlzZSB8fCByZWFkZXIucmVhZCgpO1xuICAgICAgaWYgKG9wdGlvbnMgIT09IG51bGwgJiYgb3B0aW9ucyAhPT0gdm9pZCAwICYmIG9wdGlvbnMuX3N0cmVhbVJlYWRBaGVhZCkge1xuICAgICAgICBuZXh0QmF0Y2hQcm9taXNlID0gcmVhZGVyLnJlYWQoKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHtcbiAgICAgICAgZG9uZSxcbiAgICAgICAgdmFsdWVcbiAgICAgIH0gPSBhd2FpdCBjdXJyZW50QmF0Y2hQcm9taXNlO1xuICAgICAgaWYgKGRvbmUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgeWllbGQgdG9BcnJheUJ1ZmZlcih2YWx1ZSk7XG4gICAgfVxuICB9IGNhdGNoIChlcnJvcikge1xuICAgIHJlYWRlci5yZWxlYXNlTG9jaygpO1xuICB9XG59XG5hc3luYyBmdW5jdGlvbiogbWFrZU5vZGVTdHJlYW1JdGVyYXRvcihzdHJlYW0sIG9wdGlvbnMpIHtcbiAgZm9yIGF3YWl0IChjb25zdCBjaHVuayBvZiBzdHJlYW0pIHtcbiAgICB5aWVsZCB0b0FycmF5QnVmZmVyKGNodW5rKTtcbiAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bWFrZS1zdHJlYW0taXRlcmF0b3IuanMubWFwIiwiY29uc3QgREVGQVVMVF9DSFVOS19TSVpFID0gMjU2ICogMTAyNDtcbmV4cG9ydCBmdW5jdGlvbiogbWFrZVN0cmluZ0l0ZXJhdG9yKHN0cmluZywgb3B0aW9ucykge1xuICBjb25zdCBjaHVua1NpemUgPSAob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmNodW5rU2l6ZSkgfHwgREVGQVVMVF9DSFVOS19TSVpFO1xuICBsZXQgb2Zmc2V0ID0gMDtcbiAgY29uc3QgdGV4dEVuY29kZXIgPSBuZXcgVGV4dEVuY29kZXIoKTtcbiAgd2hpbGUgKG9mZnNldCA8IHN0cmluZy5sZW5ndGgpIHtcbiAgICBjb25zdCBjaHVua0xlbmd0aCA9IE1hdGgubWluKHN0cmluZy5sZW5ndGggLSBvZmZzZXQsIGNodW5rU2l6ZSk7XG4gICAgY29uc3QgY2h1bmsgPSBzdHJpbmcuc2xpY2Uob2Zmc2V0LCBvZmZzZXQgKyBjaHVua0xlbmd0aCk7XG4gICAgb2Zmc2V0ICs9IGNodW5rTGVuZ3RoO1xuICAgIHlpZWxkIHRleHRFbmNvZGVyLmVuY29kZShjaHVuayk7XG4gIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1ha2Utc3RyaW5nLWl0ZXJhdG9yLmpzLm1hcCIsImNvbnN0IGlzQm9vbGVhbiA9IHggPT4gdHlwZW9mIHggPT09ICdib29sZWFuJztcbmNvbnN0IGlzRnVuY3Rpb24gPSB4ID0+IHR5cGVvZiB4ID09PSAnZnVuY3Rpb24nO1xuZXhwb3J0IGNvbnN0IGlzT2JqZWN0ID0geCA9PiB4ICE9PSBudWxsICYmIHR5cGVvZiB4ID09PSAnb2JqZWN0JztcbmV4cG9ydCBjb25zdCBpc1B1cmVPYmplY3QgPSB4ID0+IGlzT2JqZWN0KHgpICYmIHguY29uc3RydWN0b3IgPT09IHt9LmNvbnN0cnVjdG9yO1xuZXhwb3J0IGNvbnN0IGlzUHJvbWlzZSA9IHggPT4gaXNPYmplY3QoeCkgJiYgaXNGdW5jdGlvbih4LnRoZW4pO1xuZXhwb3J0IGNvbnN0IGlzSXRlcmFibGUgPSB4ID0+IEJvb2xlYW4oeCkgJiYgdHlwZW9mIHhbU3ltYm9sLml0ZXJhdG9yXSA9PT0gJ2Z1bmN0aW9uJztcbmV4cG9ydCBjb25zdCBpc0FzeW5jSXRlcmFibGUgPSB4ID0+IHggJiYgdHlwZW9mIHhbU3ltYm9sLmFzeW5jSXRlcmF0b3JdID09PSAnZnVuY3Rpb24nO1xuZXhwb3J0IGNvbnN0IGlzSXRlcmF0b3IgPSB4ID0+IHggJiYgaXNGdW5jdGlvbih4Lm5leHQpO1xuZXhwb3J0IGNvbnN0IGlzUmVzcG9uc2UgPSB4ID0+IHR5cGVvZiBSZXNwb25zZSAhPT0gJ3VuZGVmaW5lZCcgJiYgeCBpbnN0YW5jZW9mIFJlc3BvbnNlIHx8IHggJiYgeC5hcnJheUJ1ZmZlciAmJiB4LnRleHQgJiYgeC5qc29uO1xuZXhwb3J0IGNvbnN0IGlzRmlsZSA9IHggPT4gdHlwZW9mIEZpbGUgIT09ICd1bmRlZmluZWQnICYmIHggaW5zdGFuY2VvZiBGaWxlO1xuZXhwb3J0IGNvbnN0IGlzQmxvYiA9IHggPT4gdHlwZW9mIEJsb2IgIT09ICd1bmRlZmluZWQnICYmIHggaW5zdGFuY2VvZiBCbG9iO1xuZXhwb3J0IGNvbnN0IGlzQnVmZmVyID0geCA9PiB4ICYmIHR5cGVvZiB4ID09PSAnb2JqZWN0JyAmJiB4LmlzQnVmZmVyO1xuZXhwb3J0IGNvbnN0IGlzV3JpdGFibGVET01TdHJlYW0gPSB4ID0+IGlzT2JqZWN0KHgpICYmIGlzRnVuY3Rpb24oeC5hYm9ydCkgJiYgaXNGdW5jdGlvbih4LmdldFdyaXRlcik7XG5leHBvcnQgY29uc3QgaXNSZWFkYWJsZURPTVN0cmVhbSA9IHggPT4gdHlwZW9mIFJlYWRhYmxlU3RyZWFtICE9PSAndW5kZWZpbmVkJyAmJiB4IGluc3RhbmNlb2YgUmVhZGFibGVTdHJlYW0gfHwgaXNPYmplY3QoeCkgJiYgaXNGdW5jdGlvbih4LnRlZSkgJiYgaXNGdW5jdGlvbih4LmNhbmNlbCkgJiYgaXNGdW5jdGlvbih4LmdldFJlYWRlcik7XG5leHBvcnQgY29uc3QgaXNXcml0YWJsZU5vZGVTdHJlYW0gPSB4ID0+IGlzT2JqZWN0KHgpICYmIGlzRnVuY3Rpb24oeC5lbmQpICYmIGlzRnVuY3Rpb24oeC53cml0ZSkgJiYgaXNCb29sZWFuKHgud3JpdGFibGUpO1xuZXhwb3J0IGNvbnN0IGlzUmVhZGFibGVOb2RlU3RyZWFtID0geCA9PiBpc09iamVjdCh4KSAmJiBpc0Z1bmN0aW9uKHgucmVhZCkgJiYgaXNGdW5jdGlvbih4LnBpcGUpICYmIGlzQm9vbGVhbih4LnJlYWRhYmxlKTtcbmV4cG9ydCBjb25zdCBpc1JlYWRhYmxlU3RyZWFtID0geCA9PiBpc1JlYWRhYmxlRE9NU3RyZWFtKHgpIHx8IGlzUmVhZGFibGVOb2RlU3RyZWFtKHgpO1xuZXhwb3J0IGNvbnN0IGlzV3JpdGFibGVTdHJlYW0gPSB4ID0+IGlzV3JpdGFibGVET01TdHJlYW0oeCkgfHwgaXNXcml0YWJsZU5vZGVTdHJlYW0oeCk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pcy10eXBlLmpzLm1hcCIsImltcG9ydCB7IGlzQmxvYiB9IGZyb20gXCIuLi8uLi9qYXZhc2NyaXB0LXV0aWxzL2lzLXR5cGUuanNcIjtcbmltcG9ydCB7IGlzTG9hZGVyT2JqZWN0IH0gZnJvbSBcIi4uL2xvYWRlci11dGlscy9ub3JtYWxpemUtbG9hZGVyLmpzXCI7XG5pbXBvcnQgeyBnZXRGZXRjaEZ1bmN0aW9uIH0gZnJvbSBcIi4uL2xvYWRlci11dGlscy9nZXQtZmV0Y2gtZnVuY3Rpb24uanNcIjtcbmltcG9ydCB7IHBhcnNlIH0gZnJvbSBcIi4vcGFyc2UuanNcIjtcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBsb2FkKHVybCwgbG9hZGVycywgb3B0aW9ucywgY29udGV4dCkge1xuICBsZXQgcmVzb2x2ZWRMb2FkZXJzO1xuICBsZXQgcmVzb2x2ZWRPcHRpb25zO1xuICBpZiAoIUFycmF5LmlzQXJyYXkobG9hZGVycykgJiYgIWlzTG9hZGVyT2JqZWN0KGxvYWRlcnMpKSB7XG4gICAgcmVzb2x2ZWRMb2FkZXJzID0gW107XG4gICAgcmVzb2x2ZWRPcHRpb25zID0gbG9hZGVycztcbiAgICBjb250ZXh0ID0gdW5kZWZpbmVkO1xuICB9IGVsc2Uge1xuICAgIHJlc29sdmVkTG9hZGVycyA9IGxvYWRlcnM7XG4gICAgcmVzb2x2ZWRPcHRpb25zID0gb3B0aW9ucztcbiAgfVxuICBjb25zdCBmZXRjaCA9IGdldEZldGNoRnVuY3Rpb24ocmVzb2x2ZWRPcHRpb25zKTtcbiAgbGV0IGRhdGEgPSB1cmw7XG4gIGlmICh0eXBlb2YgdXJsID09PSAnc3RyaW5nJykge1xuICAgIGRhdGEgPSBhd2FpdCBmZXRjaCh1cmwpO1xuICB9XG4gIGlmIChpc0Jsb2IodXJsKSkge1xuICAgIGRhdGEgPSBhd2FpdCBmZXRjaCh1cmwpO1xuICB9XG4gIHJldHVybiBBcnJheS5pc0FycmF5KHJlc29sdmVkTG9hZGVycykgPyBhd2FpdCBwYXJzZShkYXRhLCByZXNvbHZlZExvYWRlcnMsIHJlc29sdmVkT3B0aW9ucykgOiBhd2FpdCBwYXJzZShkYXRhLCByZXNvbHZlZExvYWRlcnMsIHJlc29sdmVkT3B0aW9ucyk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1sb2FkLmpzLm1hcCIsImltcG9ydCB7IHBhcnNlV2l0aFdvcmtlciwgY2FuUGFyc2VXaXRoV29ya2VyIH0gZnJvbSAnQGxvYWRlcnMuZ2wvbG9hZGVyLXV0aWxzJztcbmltcG9ydCB7IGFzc2VydCwgdmFsaWRhdGVXb3JrZXJWZXJzaW9uIH0gZnJvbSAnQGxvYWRlcnMuZ2wvd29ya2VyLXV0aWxzJztcbmltcG9ydCB7IGlzTG9hZGVyT2JqZWN0IH0gZnJvbSBcIi4uL2xvYWRlci11dGlscy9ub3JtYWxpemUtbG9hZGVyLmpzXCI7XG5pbXBvcnQgeyBpc1Jlc3BvbnNlIH0gZnJvbSBcIi4uLy4uL2phdmFzY3JpcHQtdXRpbHMvaXMtdHlwZS5qc1wiO1xuaW1wb3J0IHsgbm9ybWFsaXplT3B0aW9ucyB9IGZyb20gXCIuLi9sb2FkZXItdXRpbHMvb3B0aW9uLXV0aWxzLmpzXCI7XG5pbXBvcnQgeyBtZXJnZUxvYWRlck9wdGlvbnMgfSBmcm9tICdAbG9hZGVycy5nbC9sb2FkZXItdXRpbHMnO1xuaW1wb3J0IHsgZ2V0QXJyYXlCdWZmZXJPclN0cmluZ0Zyb21EYXRhIH0gZnJvbSBcIi4uL2xvYWRlci11dGlscy9nZXQtZGF0YS5qc1wiO1xuaW1wb3J0IHsgZ2V0TG9hZGVyQ29udGV4dCwgZ2V0TG9hZGVyc0Zyb21Db250ZXh0IH0gZnJvbSBcIi4uL2xvYWRlci11dGlscy9sb2FkZXItY29udGV4dC5qc1wiO1xuaW1wb3J0IHsgZ2V0UmVzb3VyY2VVcmwgfSBmcm9tIFwiLi4vdXRpbHMvcmVzb3VyY2UtdXRpbHMuanNcIjtcbmltcG9ydCB7IHNlbGVjdExvYWRlciB9IGZyb20gXCIuL3NlbGVjdC1sb2FkZXIuanNcIjtcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBwYXJzZShkYXRhLCBsb2FkZXJzLCBvcHRpb25zLCBjb250ZXh0KSB7XG4gIGlmIChsb2FkZXJzICYmICFBcnJheS5pc0FycmF5KGxvYWRlcnMpICYmICFpc0xvYWRlck9iamVjdChsb2FkZXJzKSkge1xuICAgIGNvbnRleHQgPSB1bmRlZmluZWQ7XG4gICAgb3B0aW9ucyA9IGxvYWRlcnM7XG4gICAgbG9hZGVycyA9IHVuZGVmaW5lZDtcbiAgfVxuICBkYXRhID0gYXdhaXQgZGF0YTtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIGNvbnN0IHVybCA9IGdldFJlc291cmNlVXJsKGRhdGEpO1xuICBjb25zdCB0eXBlZExvYWRlcnMgPSBsb2FkZXJzO1xuICBjb25zdCBjYW5kaWRhdGVMb2FkZXJzID0gZ2V0TG9hZGVyc0Zyb21Db250ZXh0KHR5cGVkTG9hZGVycywgY29udGV4dCk7XG4gIGNvbnN0IGxvYWRlciA9IGF3YWl0IHNlbGVjdExvYWRlcihkYXRhLCBjYW5kaWRhdGVMb2FkZXJzLCBvcHRpb25zKTtcbiAgaWYgKCFsb2FkZXIpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBvcHRpb25zID0gbm9ybWFsaXplT3B0aW9ucyhvcHRpb25zLCBsb2FkZXIsIGNhbmRpZGF0ZUxvYWRlcnMsIHVybCk7XG4gIGNvbnRleHQgPSBnZXRMb2FkZXJDb250ZXh0KHtcbiAgICB1cmwsXG4gICAgX3BhcnNlOiBwYXJzZSxcbiAgICBsb2FkZXJzOiBjYW5kaWRhdGVMb2FkZXJzXG4gIH0sIG9wdGlvbnMsIGNvbnRleHQgfHwgbnVsbCk7XG4gIHJldHVybiBhd2FpdCBwYXJzZVdpdGhMb2FkZXIobG9hZGVyLCBkYXRhLCBvcHRpb25zLCBjb250ZXh0KTtcbn1cbmFzeW5jIGZ1bmN0aW9uIHBhcnNlV2l0aExvYWRlcihsb2FkZXIsIGRhdGEsIG9wdGlvbnMsIGNvbnRleHQpIHtcbiAgdmFsaWRhdGVXb3JrZXJWZXJzaW9uKGxvYWRlcik7XG4gIG9wdGlvbnMgPSBtZXJnZUxvYWRlck9wdGlvbnMobG9hZGVyLm9wdGlvbnMsIG9wdGlvbnMpO1xuICBpZiAoaXNSZXNwb25zZShkYXRhKSkge1xuICAgIGNvbnN0IHJlc3BvbnNlID0gZGF0YTtcbiAgICBjb25zdCB7XG4gICAgICBvayxcbiAgICAgIHJlZGlyZWN0ZWQsXG4gICAgICBzdGF0dXMsXG4gICAgICBzdGF0dXNUZXh0LFxuICAgICAgdHlwZSxcbiAgICAgIHVybFxuICAgIH0gPSByZXNwb25zZTtcbiAgICBjb25zdCBoZWFkZXJzID0gT2JqZWN0LmZyb21FbnRyaWVzKHJlc3BvbnNlLmhlYWRlcnMuZW50cmllcygpKTtcbiAgICBjb250ZXh0LnJlc3BvbnNlID0ge1xuICAgICAgaGVhZGVycyxcbiAgICAgIG9rLFxuICAgICAgcmVkaXJlY3RlZCxcbiAgICAgIHN0YXR1cyxcbiAgICAgIHN0YXR1c1RleHQsXG4gICAgICB0eXBlLFxuICAgICAgdXJsXG4gICAgfTtcbiAgfVxuICBkYXRhID0gYXdhaXQgZ2V0QXJyYXlCdWZmZXJPclN0cmluZ0Zyb21EYXRhKGRhdGEsIGxvYWRlciwgb3B0aW9ucyk7XG4gIGNvbnN0IGxvYWRlcldpdGhQYXJzZXIgPSBsb2FkZXI7XG4gIGlmIChsb2FkZXJXaXRoUGFyc2VyLnBhcnNlVGV4dFN5bmMgJiYgdHlwZW9mIGRhdGEgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIGxvYWRlcldpdGhQYXJzZXIucGFyc2VUZXh0U3luYyhkYXRhLCBvcHRpb25zLCBjb250ZXh0KTtcbiAgfVxuICBpZiAoY2FuUGFyc2VXaXRoV29ya2VyKGxvYWRlciwgb3B0aW9ucykpIHtcbiAgICByZXR1cm4gYXdhaXQgcGFyc2VXaXRoV29ya2VyKGxvYWRlciwgZGF0YSwgb3B0aW9ucywgY29udGV4dCwgcGFyc2UpO1xuICB9XG4gIGlmIChsb2FkZXJXaXRoUGFyc2VyLnBhcnNlVGV4dCAmJiB0eXBlb2YgZGF0YSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gYXdhaXQgbG9hZGVyV2l0aFBhcnNlci5wYXJzZVRleHQoZGF0YSwgb3B0aW9ucywgY29udGV4dCk7XG4gIH1cbiAgaWYgKGxvYWRlcldpdGhQYXJzZXIucGFyc2UpIHtcbiAgICByZXR1cm4gYXdhaXQgbG9hZGVyV2l0aFBhcnNlci5wYXJzZShkYXRhLCBvcHRpb25zLCBjb250ZXh0KTtcbiAgfVxuICBhc3NlcnQoIWxvYWRlcldpdGhQYXJzZXIucGFyc2VTeW5jKTtcbiAgdGhyb3cgbmV3IEVycm9yKGAke2xvYWRlci5pZH0gbG9hZGVyIC0gbm8gcGFyc2VyIGZvdW5kIGFuZCB3b3JrZXIgaXMgZGlzYWJsZWRgKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXBhcnNlLmpzLm1hcCIsImltcG9ydCB7IG5vcm1hbGl6ZUxvYWRlciB9IGZyb20gXCIuLi9sb2FkZXItdXRpbHMvbm9ybWFsaXplLWxvYWRlci5qc1wiO1xuaW1wb3J0IHsgZ2V0R2xvYmFsTG9hZGVyU3RhdGUgfSBmcm9tIFwiLi4vbG9hZGVyLXV0aWxzL29wdGlvbi11dGlscy5qc1wiO1xuY29uc3QgZ2V0R2xvYmFsTG9hZGVyUmVnaXN0cnkgPSAoKSA9PiB7XG4gIGNvbnN0IHN0YXRlID0gZ2V0R2xvYmFsTG9hZGVyU3RhdGUoKTtcbiAgc3RhdGUubG9hZGVyUmVnaXN0cnkgPSBzdGF0ZS5sb2FkZXJSZWdpc3RyeSB8fCBbXTtcbiAgcmV0dXJuIHN0YXRlLmxvYWRlclJlZ2lzdHJ5O1xufTtcbmV4cG9ydCBmdW5jdGlvbiByZWdpc3RlckxvYWRlcnMobG9hZGVycykge1xuICBjb25zdCBsb2FkZXJSZWdpc3RyeSA9IGdldEdsb2JhbExvYWRlclJlZ2lzdHJ5KCk7XG4gIGxvYWRlcnMgPSBBcnJheS5pc0FycmF5KGxvYWRlcnMpID8gbG9hZGVycyA6IFtsb2FkZXJzXTtcbiAgZm9yIChjb25zdCBsb2FkZXIgb2YgbG9hZGVycykge1xuICAgIGNvbnN0IG5vcm1hbGl6ZWRMb2FkZXIgPSBub3JtYWxpemVMb2FkZXIobG9hZGVyKTtcbiAgICBpZiAoIWxvYWRlclJlZ2lzdHJ5LmZpbmQocmVnaXN0ZXJlZExvYWRlciA9PiBub3JtYWxpemVkTG9hZGVyID09PSByZWdpc3RlcmVkTG9hZGVyKSkge1xuICAgICAgbG9hZGVyUmVnaXN0cnkudW5zaGlmdChub3JtYWxpemVkTG9hZGVyKTtcbiAgICB9XG4gIH1cbn1cbmV4cG9ydCBmdW5jdGlvbiBnZXRSZWdpc3RlcmVkTG9hZGVycygpIHtcbiAgcmV0dXJuIGdldEdsb2JhbExvYWRlclJlZ2lzdHJ5KCk7XG59XG5leHBvcnQgZnVuY3Rpb24gX3VucmVnaXN0ZXJMb2FkZXJzKCkge1xuICBjb25zdCBzdGF0ZSA9IGdldEdsb2JhbExvYWRlclN0YXRlKCk7XG4gIHN0YXRlLmxvYWRlclJlZ2lzdHJ5ID0gW107XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1yZWdpc3Rlci1sb2FkZXJzLmpzLm1hcCIsImltcG9ydCB7IGNvbXBhcmVBcnJheUJ1ZmZlcnMsIHBhdGggfSBmcm9tICdAbG9hZGVycy5nbC9sb2FkZXItdXRpbHMnO1xuaW1wb3J0IHsgbm9ybWFsaXplTG9hZGVyIH0gZnJvbSBcIi4uL2xvYWRlci11dGlscy9ub3JtYWxpemUtbG9hZGVyLmpzXCI7XG5pbXBvcnQgeyBsb2cgfSBmcm9tIFwiLi4vdXRpbHMvbG9nLmpzXCI7XG5pbXBvcnQgeyBnZXRSZXNvdXJjZVVybCwgZ2V0UmVzb3VyY2VNSU1FVHlwZSB9IGZyb20gXCIuLi91dGlscy9yZXNvdXJjZS11dGlscy5qc1wiO1xuaW1wb3J0IHsgZ2V0UmVnaXN0ZXJlZExvYWRlcnMgfSBmcm9tIFwiLi9yZWdpc3Rlci1sb2FkZXJzLmpzXCI7XG5pbXBvcnQgeyBpc0Jsb2IgfSBmcm9tIFwiLi4vLi4vamF2YXNjcmlwdC11dGlscy9pcy10eXBlLmpzXCI7XG5pbXBvcnQgeyBzdHJpcFF1ZXJ5U3RyaW5nIH0gZnJvbSBcIi4uL3V0aWxzL3VybC11dGlscy5qc1wiO1xuY29uc3QgRVhUX1BBVFRFUk4gPSAvXFwuKFteLl0rKSQvO1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHNlbGVjdExvYWRlcihkYXRhKSB7XG4gIGxldCBsb2FkZXJzID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBbXTtcbiAgbGV0IG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiA/IGFyZ3VtZW50c1syXSA6IHVuZGVmaW5lZDtcbiAgbGV0IGNvbnRleHQgPSBhcmd1bWVudHMubGVuZ3RoID4gMyA/IGFyZ3VtZW50c1szXSA6IHVuZGVmaW5lZDtcbiAgaWYgKCF2YWxpZEhUVFBSZXNwb25zZShkYXRhKSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGxldCBsb2FkZXIgPSBzZWxlY3RMb2FkZXJTeW5jKGRhdGEsIGxvYWRlcnMsIHtcbiAgICAuLi5vcHRpb25zLFxuICAgIG5vdGhyb3c6IHRydWVcbiAgfSwgY29udGV4dCk7XG4gIGlmIChsb2FkZXIpIHtcbiAgICByZXR1cm4gbG9hZGVyO1xuICB9XG4gIGlmIChpc0Jsb2IoZGF0YSkpIHtcbiAgICBkYXRhID0gYXdhaXQgZGF0YS5zbGljZSgwLCAxMCkuYXJyYXlCdWZmZXIoKTtcbiAgICBsb2FkZXIgPSBzZWxlY3RMb2FkZXJTeW5jKGRhdGEsIGxvYWRlcnMsIG9wdGlvbnMsIGNvbnRleHQpO1xuICB9XG4gIGlmICghbG9hZGVyICYmICEob3B0aW9ucyAhPT0gbnVsbCAmJiBvcHRpb25zICE9PSB2b2lkIDAgJiYgb3B0aW9ucy5ub3Rocm93KSkge1xuICAgIHRocm93IG5ldyBFcnJvcihnZXROb1ZhbGlkTG9hZGVyTWVzc2FnZShkYXRhKSk7XG4gIH1cbiAgcmV0dXJuIGxvYWRlcjtcbn1cbmV4cG9ydCBmdW5jdGlvbiBzZWxlY3RMb2FkZXJTeW5jKGRhdGEpIHtcbiAgbGV0IGxvYWRlcnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IFtdO1xuICBsZXQgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyID8gYXJndW1lbnRzWzJdIDogdW5kZWZpbmVkO1xuICBsZXQgY29udGV4dCA9IGFyZ3VtZW50cy5sZW5ndGggPiAzID8gYXJndW1lbnRzWzNdIDogdW5kZWZpbmVkO1xuICBpZiAoIXZhbGlkSFRUUFJlc3BvbnNlKGRhdGEpKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgaWYgKGxvYWRlcnMgJiYgIUFycmF5LmlzQXJyYXkobG9hZGVycykpIHtcbiAgICByZXR1cm4gbm9ybWFsaXplTG9hZGVyKGxvYWRlcnMpO1xuICB9XG4gIGxldCBjYW5kaWRhdGVMb2FkZXJzID0gW107XG4gIGlmIChsb2FkZXJzKSB7XG4gICAgY2FuZGlkYXRlTG9hZGVycyA9IGNhbmRpZGF0ZUxvYWRlcnMuY29uY2F0KGxvYWRlcnMpO1xuICB9XG4gIGlmICghKG9wdGlvbnMgIT09IG51bGwgJiYgb3B0aW9ucyAhPT0gdm9pZCAwICYmIG9wdGlvbnMuaWdub3JlUmVnaXN0ZXJlZExvYWRlcnMpKSB7XG4gICAgY2FuZGlkYXRlTG9hZGVycy5wdXNoKC4uLmdldFJlZ2lzdGVyZWRMb2FkZXJzKCkpO1xuICB9XG4gIG5vcm1hbGl6ZUxvYWRlcnMoY2FuZGlkYXRlTG9hZGVycyk7XG4gIGNvbnN0IGxvYWRlciA9IHNlbGVjdExvYWRlckludGVybmFsKGRhdGEsIGNhbmRpZGF0ZUxvYWRlcnMsIG9wdGlvbnMsIGNvbnRleHQpO1xuICBpZiAoIWxvYWRlciAmJiAhKG9wdGlvbnMgIT09IG51bGwgJiYgb3B0aW9ucyAhPT0gdm9pZCAwICYmIG9wdGlvbnMubm90aHJvdykpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoZ2V0Tm9WYWxpZExvYWRlck1lc3NhZ2UoZGF0YSkpO1xuICB9XG4gIHJldHVybiBsb2FkZXI7XG59XG5mdW5jdGlvbiBzZWxlY3RMb2FkZXJJbnRlcm5hbChkYXRhLCBsb2FkZXJzLCBvcHRpb25zLCBjb250ZXh0KSB7XG4gIGNvbnN0IHVybCA9IGdldFJlc291cmNlVXJsKGRhdGEpO1xuICBjb25zdCB0eXBlID0gZ2V0UmVzb3VyY2VNSU1FVHlwZShkYXRhKTtcbiAgY29uc3QgdGVzdFVybCA9IHN0cmlwUXVlcnlTdHJpbmcodXJsKSB8fCAoY29udGV4dCA9PT0gbnVsbCB8fCBjb250ZXh0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjb250ZXh0LnVybCk7XG4gIGxldCBsb2FkZXIgPSBudWxsO1xuICBsZXQgcmVhc29uID0gJyc7XG4gIGlmIChvcHRpb25zICE9PSBudWxsICYmIG9wdGlvbnMgIT09IHZvaWQgMCAmJiBvcHRpb25zLm1pbWVUeXBlKSB7XG4gICAgbG9hZGVyID0gZmluZExvYWRlckJ5TUlNRVR5cGUobG9hZGVycywgb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLm1pbWVUeXBlKTtcbiAgICByZWFzb24gPSBgbWF0Y2ggZm9yY2VkIGJ5IHN1cHBsaWVkIE1JTUUgdHlwZSAke29wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5taW1lVHlwZX1gO1xuICB9XG4gIGxvYWRlciA9IGxvYWRlciB8fCBmaW5kTG9hZGVyQnlVcmwobG9hZGVycywgdGVzdFVybCk7XG4gIHJlYXNvbiA9IHJlYXNvbiB8fCAobG9hZGVyID8gYG1hdGNoZWQgdXJsICR7dGVzdFVybH1gIDogJycpO1xuICBsb2FkZXIgPSBsb2FkZXIgfHwgZmluZExvYWRlckJ5TUlNRVR5cGUobG9hZGVycywgdHlwZSk7XG4gIHJlYXNvbiA9IHJlYXNvbiB8fCAobG9hZGVyID8gYG1hdGNoZWQgTUlNRSB0eXBlICR7dHlwZX1gIDogJycpO1xuICBsb2FkZXIgPSBsb2FkZXIgfHwgZmluZExvYWRlckJ5SW5pdGlhbEJ5dGVzKGxvYWRlcnMsIGRhdGEpO1xuICByZWFzb24gPSByZWFzb24gfHwgKGxvYWRlciA/IGBtYXRjaGVkIGluaXRpYWwgZGF0YSAke2dldEZpcnN0Q2hhcmFjdGVycyhkYXRhKX1gIDogJycpO1xuICBpZiAob3B0aW9ucyAhPT0gbnVsbCAmJiBvcHRpb25zICE9PSB2b2lkIDAgJiYgb3B0aW9ucy5mYWxsYmFja01pbWVUeXBlKSB7XG4gICAgbG9hZGVyID0gbG9hZGVyIHx8IGZpbmRMb2FkZXJCeU1JTUVUeXBlKGxvYWRlcnMsIG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5mYWxsYmFja01pbWVUeXBlKTtcbiAgICByZWFzb24gPSByZWFzb24gfHwgKGxvYWRlciA/IGBtYXRjaGVkIGZhbGxiYWNrIE1JTUUgdHlwZSAke3R5cGV9YCA6ICcnKTtcbiAgfVxuICBpZiAocmVhc29uKSB7XG4gICAgdmFyIF9sb2FkZXI7XG4gICAgbG9nLmxvZygxLCBgc2VsZWN0TG9hZGVyIHNlbGVjdGVkICR7KF9sb2FkZXIgPSBsb2FkZXIpID09PSBudWxsIHx8IF9sb2FkZXIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9sb2FkZXIubmFtZX06ICR7cmVhc29ufS5gKTtcbiAgfVxuICByZXR1cm4gbG9hZGVyO1xufVxuZnVuY3Rpb24gdmFsaWRIVFRQUmVzcG9uc2UoZGF0YSkge1xuICBpZiAoZGF0YSBpbnN0YW5jZW9mIFJlc3BvbnNlKSB7XG4gICAgaWYgKGRhdGEuc3RhdHVzID09PSAyMDQpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5mdW5jdGlvbiBnZXROb1ZhbGlkTG9hZGVyTWVzc2FnZShkYXRhKSB7XG4gIGNvbnN0IHVybCA9IGdldFJlc291cmNlVXJsKGRhdGEpO1xuICBjb25zdCB0eXBlID0gZ2V0UmVzb3VyY2VNSU1FVHlwZShkYXRhKTtcbiAgbGV0IG1lc3NhZ2UgPSAnTm8gdmFsaWQgbG9hZGVyIGZvdW5kICgnO1xuICBtZXNzYWdlICs9IHVybCA/IGAke3BhdGguZmlsZW5hbWUodXJsKX0sIGAgOiAnbm8gdXJsIHByb3ZpZGVkLCAnO1xuICBtZXNzYWdlICs9IGBNSU1FIHR5cGU6ICR7dHlwZSA/IGBcIiR7dHlwZX1cImAgOiAnbm90IHByb3ZpZGVkJ30sIGA7XG4gIGNvbnN0IGZpcnN0Q2hhcmFjdGVycyA9IGRhdGEgPyBnZXRGaXJzdENoYXJhY3RlcnMoZGF0YSkgOiAnJztcbiAgbWVzc2FnZSArPSBmaXJzdENoYXJhY3RlcnMgPyBgIGZpcnN0IGJ5dGVzOiBcIiR7Zmlyc3RDaGFyYWN0ZXJzfVwiYCA6ICdmaXJzdCBieXRlczogbm90IGF2YWlsYWJsZSc7XG4gIG1lc3NhZ2UgKz0gJyknO1xuICByZXR1cm4gbWVzc2FnZTtcbn1cbmZ1bmN0aW9uIG5vcm1hbGl6ZUxvYWRlcnMobG9hZGVycykge1xuICBmb3IgKGNvbnN0IGxvYWRlciBvZiBsb2FkZXJzKSB7XG4gICAgbm9ybWFsaXplTG9hZGVyKGxvYWRlcik7XG4gIH1cbn1cbmZ1bmN0aW9uIGZpbmRMb2FkZXJCeVVybChsb2FkZXJzLCB1cmwpIHtcbiAgY29uc3QgbWF0Y2ggPSB1cmwgJiYgRVhUX1BBVFRFUk4uZXhlYyh1cmwpO1xuICBjb25zdCBleHRlbnNpb24gPSBtYXRjaCAmJiBtYXRjaFsxXTtcbiAgcmV0dXJuIGV4dGVuc2lvbiA/IGZpbmRMb2FkZXJCeUV4dGVuc2lvbihsb2FkZXJzLCBleHRlbnNpb24pIDogbnVsbDtcbn1cbmZ1bmN0aW9uIGZpbmRMb2FkZXJCeUV4dGVuc2lvbihsb2FkZXJzLCBleHRlbnNpb24pIHtcbiAgZXh0ZW5zaW9uID0gZXh0ZW5zaW9uLnRvTG93ZXJDYXNlKCk7XG4gIGZvciAoY29uc3QgbG9hZGVyIG9mIGxvYWRlcnMpIHtcbiAgICBmb3IgKGNvbnN0IGxvYWRlckV4dGVuc2lvbiBvZiBsb2FkZXIuZXh0ZW5zaW9ucykge1xuICAgICAgaWYgKGxvYWRlckV4dGVuc2lvbi50b0xvd2VyQ2FzZSgpID09PSBleHRlbnNpb24pIHtcbiAgICAgICAgcmV0dXJuIGxvYWRlcjtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiBmaW5kTG9hZGVyQnlNSU1FVHlwZShsb2FkZXJzLCBtaW1lVHlwZSkge1xuICBmb3IgKGNvbnN0IGxvYWRlciBvZiBsb2FkZXJzKSB7XG4gICAgaWYgKGxvYWRlci5taW1lVHlwZXMgJiYgbG9hZGVyLm1pbWVUeXBlcy5pbmNsdWRlcyhtaW1lVHlwZSkpIHtcbiAgICAgIHJldHVybiBsb2FkZXI7XG4gICAgfVxuICAgIGlmIChtaW1lVHlwZSA9PT0gYGFwcGxpY2F0aW9uL3guJHtsb2FkZXIuaWR9YCkge1xuICAgICAgcmV0dXJuIGxvYWRlcjtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiBmaW5kTG9hZGVyQnlJbml0aWFsQnl0ZXMobG9hZGVycywgZGF0YSkge1xuICBpZiAoIWRhdGEpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBmb3IgKGNvbnN0IGxvYWRlciBvZiBsb2FkZXJzKSB7XG4gICAgaWYgKHR5cGVvZiBkYXRhID09PSAnc3RyaW5nJykge1xuICAgICAgaWYgKHRlc3REYXRhQWdhaW5zdFRleHQoZGF0YSwgbG9hZGVyKSkge1xuICAgICAgICByZXR1cm4gbG9hZGVyO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoQXJyYXlCdWZmZXIuaXNWaWV3KGRhdGEpKSB7XG4gICAgICBpZiAodGVzdERhdGFBZ2FpbnN0QmluYXJ5KGRhdGEuYnVmZmVyLCBkYXRhLmJ5dGVPZmZzZXQsIGxvYWRlcikpIHtcbiAgICAgICAgcmV0dXJuIGxvYWRlcjtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGRhdGEgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikge1xuICAgICAgY29uc3QgYnl0ZU9mZnNldCA9IDA7XG4gICAgICBpZiAodGVzdERhdGFBZ2FpbnN0QmluYXJ5KGRhdGEsIGJ5dGVPZmZzZXQsIGxvYWRlcikpIHtcbiAgICAgICAgcmV0dXJuIGxvYWRlcjtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiB0ZXN0RGF0YUFnYWluc3RUZXh0KGRhdGEsIGxvYWRlcikge1xuICBpZiAobG9hZGVyLnRlc3RUZXh0KSB7XG4gICAgcmV0dXJuIGxvYWRlci50ZXN0VGV4dChkYXRhKTtcbiAgfVxuICBjb25zdCB0ZXN0cyA9IEFycmF5LmlzQXJyYXkobG9hZGVyLnRlc3RzKSA/IGxvYWRlci50ZXN0cyA6IFtsb2FkZXIudGVzdHNdO1xuICByZXR1cm4gdGVzdHMuc29tZSh0ZXN0ID0+IGRhdGEuc3RhcnRzV2l0aCh0ZXN0KSk7XG59XG5mdW5jdGlvbiB0ZXN0RGF0YUFnYWluc3RCaW5hcnkoZGF0YSwgYnl0ZU9mZnNldCwgbG9hZGVyKSB7XG4gIGNvbnN0IHRlc3RzID0gQXJyYXkuaXNBcnJheShsb2FkZXIudGVzdHMpID8gbG9hZGVyLnRlc3RzIDogW2xvYWRlci50ZXN0c107XG4gIHJldHVybiB0ZXN0cy5zb21lKHRlc3QgPT4gdGVzdEJpbmFyeShkYXRhLCBieXRlT2Zmc2V0LCBsb2FkZXIsIHRlc3QpKTtcbn1cbmZ1bmN0aW9uIHRlc3RCaW5hcnkoZGF0YSwgYnl0ZU9mZnNldCwgbG9hZGVyLCB0ZXN0KSB7XG4gIGlmICh0ZXN0IGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHtcbiAgICByZXR1cm4gY29tcGFyZUFycmF5QnVmZmVycyh0ZXN0LCBkYXRhLCB0ZXN0LmJ5dGVMZW5ndGgpO1xuICB9XG4gIHN3aXRjaCAodHlwZW9mIHRlc3QpIHtcbiAgICBjYXNlICdmdW5jdGlvbic6XG4gICAgICByZXR1cm4gdGVzdChkYXRhKTtcbiAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgY29uc3QgbWFnaWMgPSBnZXRNYWdpY1N0cmluZyhkYXRhLCBieXRlT2Zmc2V0LCB0ZXN0Lmxlbmd0aCk7XG4gICAgICByZXR1cm4gdGVzdCA9PT0gbWFnaWM7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuZnVuY3Rpb24gZ2V0Rmlyc3RDaGFyYWN0ZXJzKGRhdGEpIHtcbiAgbGV0IGxlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogNTtcbiAgaWYgKHR5cGVvZiBkYXRhID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBkYXRhLnNsaWNlKDAsIGxlbmd0aCk7XG4gIH0gZWxzZSBpZiAoQXJyYXlCdWZmZXIuaXNWaWV3KGRhdGEpKSB7XG4gICAgcmV0dXJuIGdldE1hZ2ljU3RyaW5nKGRhdGEuYnVmZmVyLCBkYXRhLmJ5dGVPZmZzZXQsIGxlbmd0aCk7XG4gIH0gZWxzZSBpZiAoZGF0YSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB7XG4gICAgY29uc3QgYnl0ZU9mZnNldCA9IDA7XG4gICAgcmV0dXJuIGdldE1hZ2ljU3RyaW5nKGRhdGEsIGJ5dGVPZmZzZXQsIGxlbmd0aCk7XG4gIH1cbiAgcmV0dXJuICcnO1xufVxuZnVuY3Rpb24gZ2V0TWFnaWNTdHJpbmcoYXJyYXlCdWZmZXIsIGJ5dGVPZmZzZXQsIGxlbmd0aCkge1xuICBpZiAoYXJyYXlCdWZmZXIuYnl0ZUxlbmd0aCA8IGJ5dGVPZmZzZXQgKyBsZW5ndGgpIHtcbiAgICByZXR1cm4gJyc7XG4gIH1cbiAgY29uc3QgZGF0YVZpZXcgPSBuZXcgRGF0YVZpZXcoYXJyYXlCdWZmZXIpO1xuICBsZXQgbWFnaWMgPSAnJztcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgIG1hZ2ljICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoZGF0YVZpZXcuZ2V0VWludDgoYnl0ZU9mZnNldCArIGkpKTtcbiAgfVxuICByZXR1cm4gbWFnaWM7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zZWxlY3QtbG9hZGVyLmpzLm1hcCIsImltcG9ydCB7IHJlc29sdmVQYXRoIH0gZnJvbSAnQGxvYWRlcnMuZ2wvbG9hZGVyLXV0aWxzJztcbmltcG9ydCB7IG1ha2VSZXNwb25zZSB9IGZyb20gXCIuLi91dGlscy9yZXNwb25zZS11dGlscy5qc1wiO1xuZXhwb3J0IGZ1bmN0aW9uIGlzTm9kZVBhdGgodXJsKSB7XG4gIHJldHVybiAhaXNSZXF1ZXN0VVJMKHVybCkgJiYgIWlzRGF0YVVSTCh1cmwpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGlzUmVxdWVzdFVSTCh1cmwpIHtcbiAgcmV0dXJuIHVybC5zdGFydHNXaXRoKCdodHRwOicpIHx8IHVybC5zdGFydHNXaXRoKCdodHRwczonKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBpc0RhdGFVUkwodXJsKSB7XG4gIHJldHVybiB1cmwuc3RhcnRzV2l0aCgnZGF0YTonKTtcbn1cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBmZXRjaEZpbGUodXJsT3JEYXRhLCBmZXRjaE9wdGlvbnMpIHtcbiAgaWYgKHR5cGVvZiB1cmxPckRhdGEgPT09ICdzdHJpbmcnKSB7XG4gICAgY29uc3QgdXJsID0gcmVzb2x2ZVBhdGgodXJsT3JEYXRhKTtcbiAgICBpZiAoaXNOb2RlUGF0aCh1cmwpKSB7XG4gICAgICB2YXIgX2dsb2JhbFRoaXMkbG9hZGVycztcbiAgICAgIGlmICgoX2dsb2JhbFRoaXMkbG9hZGVycyA9IGdsb2JhbFRoaXMubG9hZGVycykgIT09IG51bGwgJiYgX2dsb2JhbFRoaXMkbG9hZGVycyAhPT0gdm9pZCAwICYmIF9nbG9iYWxUaGlzJGxvYWRlcnMuZmV0Y2hOb2RlKSB7XG4gICAgICAgIHZhciBfZ2xvYmFsVGhpcyRsb2FkZXJzMjtcbiAgICAgICAgcmV0dXJuIChfZ2xvYmFsVGhpcyRsb2FkZXJzMiA9IGdsb2JhbFRoaXMubG9hZGVycykgPT09IG51bGwgfHwgX2dsb2JhbFRoaXMkbG9hZGVyczIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9nbG9iYWxUaGlzJGxvYWRlcnMyLmZldGNoTm9kZSh1cmwsIGZldGNoT3B0aW9ucyk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBhd2FpdCBmZXRjaCh1cmwsIGZldGNoT3B0aW9ucyk7XG4gIH1cbiAgcmV0dXJuIGF3YWl0IG1ha2VSZXNwb25zZSh1cmxPckRhdGEpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZmV0Y2gtZmlsZS5qcy5tYXAiLCJpbXBvcnQgeyBjb25jYXRlbmF0ZUFycmF5QnVmZmVyc0FzeW5jIH0gZnJvbSAnQGxvYWRlcnMuZ2wvbG9hZGVyLXV0aWxzJztcbmltcG9ydCB7IGlzUmVzcG9uc2UsIGlzUmVhZGFibGVTdHJlYW0sIGlzQXN5bmNJdGVyYWJsZSwgaXNJdGVyYWJsZSwgaXNJdGVyYXRvciwgaXNCbG9iLCBpc0J1ZmZlciB9IGZyb20gXCIuLi8uLi9qYXZhc2NyaXB0LXV0aWxzL2lzLXR5cGUuanNcIjtcbmltcG9ydCB7IG1ha2VJdGVyYXRvciB9IGZyb20gXCIuLi8uLi9pdGVyYXRvcnMvbWFrZS1pdGVyYXRvci9tYWtlLWl0ZXJhdG9yLmpzXCI7XG5pbXBvcnQgeyBjaGVja1Jlc3BvbnNlLCBtYWtlUmVzcG9uc2UgfSBmcm9tIFwiLi4vdXRpbHMvcmVzcG9uc2UtdXRpbHMuanNcIjtcbmNvbnN0IEVSUl9EQVRBID0gJ0Nhbm5vdCBjb252ZXJ0IHN1cHBsaWVkIGRhdGEgdHlwZSc7XG5leHBvcnQgZnVuY3Rpb24gZ2V0QXJyYXlCdWZmZXJPclN0cmluZ0Zyb21EYXRhU3luYyhkYXRhLCBsb2FkZXIsIG9wdGlvbnMpIHtcbiAgaWYgKGxvYWRlci50ZXh0ICYmIHR5cGVvZiBkYXRhID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBkYXRhO1xuICB9XG4gIGlmIChpc0J1ZmZlcihkYXRhKSkge1xuICAgIGRhdGEgPSBkYXRhLmJ1ZmZlcjtcbiAgfVxuICBpZiAoZGF0YSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB7XG4gICAgY29uc3QgYXJyYXlCdWZmZXIgPSBkYXRhO1xuICAgIGlmIChsb2FkZXIudGV4dCAmJiAhbG9hZGVyLmJpbmFyeSkge1xuICAgICAgY29uc3QgdGV4dERlY29kZXIgPSBuZXcgVGV4dERlY29kZXIoJ3V0ZjgnKTtcbiAgICAgIHJldHVybiB0ZXh0RGVjb2Rlci5kZWNvZGUoYXJyYXlCdWZmZXIpO1xuICAgIH1cbiAgICByZXR1cm4gYXJyYXlCdWZmZXI7XG4gIH1cbiAgaWYgKEFycmF5QnVmZmVyLmlzVmlldyhkYXRhKSkge1xuICAgIGlmIChsb2FkZXIudGV4dCAmJiAhbG9hZGVyLmJpbmFyeSkge1xuICAgICAgY29uc3QgdGV4dERlY29kZXIgPSBuZXcgVGV4dERlY29kZXIoJ3V0ZjgnKTtcbiAgICAgIHJldHVybiB0ZXh0RGVjb2Rlci5kZWNvZGUoZGF0YSk7XG4gICAgfVxuICAgIGxldCBhcnJheUJ1ZmZlciA9IGRhdGEuYnVmZmVyO1xuICAgIGNvbnN0IGJ5dGVMZW5ndGggPSBkYXRhLmJ5dGVMZW5ndGggfHwgZGF0YS5sZW5ndGg7XG4gICAgaWYgKGRhdGEuYnl0ZU9mZnNldCAhPT0gMCB8fCBieXRlTGVuZ3RoICE9PSBhcnJheUJ1ZmZlci5ieXRlTGVuZ3RoKSB7XG4gICAgICBhcnJheUJ1ZmZlciA9IGFycmF5QnVmZmVyLnNsaWNlKGRhdGEuYnl0ZU9mZnNldCwgZGF0YS5ieXRlT2Zmc2V0ICsgYnl0ZUxlbmd0aCk7XG4gICAgfVxuICAgIHJldHVybiBhcnJheUJ1ZmZlcjtcbiAgfVxuICB0aHJvdyBuZXcgRXJyb3IoRVJSX0RBVEEpO1xufVxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldEFycmF5QnVmZmVyT3JTdHJpbmdGcm9tRGF0YShkYXRhLCBsb2FkZXIsIG9wdGlvbnMpIHtcbiAgY29uc3QgaXNBcnJheUJ1ZmZlciA9IGRhdGEgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlciB8fCBBcnJheUJ1ZmZlci5pc1ZpZXcoZGF0YSk7XG4gIGlmICh0eXBlb2YgZGF0YSA9PT0gJ3N0cmluZycgfHwgaXNBcnJheUJ1ZmZlcikge1xuICAgIHJldHVybiBnZXRBcnJheUJ1ZmZlck9yU3RyaW5nRnJvbURhdGFTeW5jKGRhdGEsIGxvYWRlciwgb3B0aW9ucyk7XG4gIH1cbiAgaWYgKGlzQmxvYihkYXRhKSkge1xuICAgIGRhdGEgPSBhd2FpdCBtYWtlUmVzcG9uc2UoZGF0YSk7XG4gIH1cbiAgaWYgKGlzUmVzcG9uc2UoZGF0YSkpIHtcbiAgICBjb25zdCByZXNwb25zZSA9IGRhdGE7XG4gICAgYXdhaXQgY2hlY2tSZXNwb25zZShyZXNwb25zZSk7XG4gICAgcmV0dXJuIGxvYWRlci5iaW5hcnkgPyBhd2FpdCByZXNwb25zZS5hcnJheUJ1ZmZlcigpIDogYXdhaXQgcmVzcG9uc2UudGV4dCgpO1xuICB9XG4gIGlmIChpc1JlYWRhYmxlU3RyZWFtKGRhdGEpKSB7XG4gICAgZGF0YSA9IG1ha2VJdGVyYXRvcihkYXRhLCBvcHRpb25zKTtcbiAgfVxuICBpZiAoaXNJdGVyYWJsZShkYXRhKSB8fCBpc0FzeW5jSXRlcmFibGUoZGF0YSkpIHtcbiAgICByZXR1cm4gY29uY2F0ZW5hdGVBcnJheUJ1ZmZlcnNBc3luYyhkYXRhKTtcbiAgfVxuICB0aHJvdyBuZXcgRXJyb3IoRVJSX0RBVEEpO1xufVxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldEFzeW5jSXRlcmFibGVGcm9tRGF0YShkYXRhLCBvcHRpb25zKSB7XG4gIGlmIChpc0l0ZXJhdG9yKGRhdGEpKSB7XG4gICAgcmV0dXJuIGRhdGE7XG4gIH1cbiAgaWYgKGlzUmVzcG9uc2UoZGF0YSkpIHtcbiAgICBjb25zdCByZXNwb25zZSA9IGRhdGE7XG4gICAgYXdhaXQgY2hlY2tSZXNwb25zZShyZXNwb25zZSk7XG4gICAgY29uc3QgYm9keSA9IGF3YWl0IHJlc3BvbnNlLmJvZHk7XG4gICAgcmV0dXJuIG1ha2VJdGVyYXRvcihib2R5LCBvcHRpb25zKTtcbiAgfVxuICBpZiAoaXNCbG9iKGRhdGEpIHx8IGlzUmVhZGFibGVTdHJlYW0oZGF0YSkpIHtcbiAgICByZXR1cm4gbWFrZUl0ZXJhdG9yKGRhdGEsIG9wdGlvbnMpO1xuICB9XG4gIGlmIChpc0FzeW5jSXRlcmFibGUoZGF0YSkpIHtcbiAgICByZXR1cm4gZGF0YTtcbiAgfVxuICByZXR1cm4gZ2V0SXRlcmFibGVGcm9tRGF0YShkYXRhKTtcbn1cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRSZWFkYWJsZVN0cmVhbShkYXRhKSB7XG4gIGlmIChpc1JlYWRhYmxlU3RyZWFtKGRhdGEpKSB7XG4gICAgcmV0dXJuIGRhdGE7XG4gIH1cbiAgaWYgKGlzUmVzcG9uc2UoZGF0YSkpIHtcbiAgICByZXR1cm4gZGF0YS5ib2R5O1xuICB9XG4gIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgbWFrZVJlc3BvbnNlKGRhdGEpO1xuICByZXR1cm4gcmVzcG9uc2UuYm9keTtcbn1cbmZ1bmN0aW9uIGdldEl0ZXJhYmxlRnJvbURhdGEoZGF0YSkge1xuICBpZiAoQXJyYXlCdWZmZXIuaXNWaWV3KGRhdGEpKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKiBvbmVDaHVuaygpIHtcbiAgICAgIHlpZWxkIGRhdGEuYnVmZmVyO1xuICAgIH0oKTtcbiAgfVxuICBpZiAoZGF0YSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKiBvbmVDaHVuaygpIHtcbiAgICAgIHlpZWxkIGRhdGE7XG4gICAgfSgpO1xuICB9XG4gIGlmIChpc0l0ZXJhdG9yKGRhdGEpKSB7XG4gICAgcmV0dXJuIGRhdGE7XG4gIH1cbiAgaWYgKGlzSXRlcmFibGUoZGF0YSkpIHtcbiAgICByZXR1cm4gZGF0YVtTeW1ib2wuaXRlcmF0b3JdKCk7XG4gIH1cbiAgdGhyb3cgbmV3IEVycm9yKEVSUl9EQVRBKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWdldC1kYXRhLmpzLm1hcCIsImltcG9ydCB7IGlzT2JqZWN0IH0gZnJvbSBcIi4uLy4uL2phdmFzY3JpcHQtdXRpbHMvaXMtdHlwZS5qc1wiO1xuaW1wb3J0IHsgZmV0Y2hGaWxlIH0gZnJvbSBcIi4uL2ZldGNoL2ZldGNoLWZpbGUuanNcIjtcbmltcG9ydCB7IGdldEdsb2JhbExvYWRlck9wdGlvbnMgfSBmcm9tIFwiLi9vcHRpb24tdXRpbHMuanNcIjtcbmV4cG9ydCBmdW5jdGlvbiBnZXRGZXRjaEZ1bmN0aW9uKG9wdGlvbnMsIGNvbnRleHQpIHtcbiAgY29uc3QgZ2xvYmFsT3B0aW9ucyA9IGdldEdsb2JhbExvYWRlck9wdGlvbnMoKTtcbiAgY29uc3QgbG9hZGVyT3B0aW9ucyA9IG9wdGlvbnMgfHwgZ2xvYmFsT3B0aW9ucztcbiAgaWYgKHR5cGVvZiBsb2FkZXJPcHRpb25zLmZldGNoID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIGxvYWRlck9wdGlvbnMuZmV0Y2g7XG4gIH1cbiAgaWYgKGlzT2JqZWN0KGxvYWRlck9wdGlvbnMuZmV0Y2gpKSB7XG4gICAgcmV0dXJuIHVybCA9PiBmZXRjaEZpbGUodXJsLCBsb2FkZXJPcHRpb25zLmZldGNoKTtcbiAgfVxuICBpZiAoY29udGV4dCAhPT0gbnVsbCAmJiBjb250ZXh0ICE9PSB2b2lkIDAgJiYgY29udGV4dC5mZXRjaCkge1xuICAgIHJldHVybiBjb250ZXh0ID09PSBudWxsIHx8IGNvbnRleHQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNvbnRleHQuZmV0Y2g7XG4gIH1cbiAgcmV0dXJuIGZldGNoRmlsZTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWdldC1mZXRjaC1mdW5jdGlvbi5qcy5tYXAiLCJpbXBvcnQgeyBnZXRGZXRjaEZ1bmN0aW9uIH0gZnJvbSBcIi4vZ2V0LWZldGNoLWZ1bmN0aW9uLmpzXCI7XG5pbXBvcnQgeyBleHRyYWN0UXVlcnlTdHJpbmcsIHN0cmlwUXVlcnlTdHJpbmcgfSBmcm9tIFwiLi4vdXRpbHMvdXJsLXV0aWxzLmpzXCI7XG5pbXBvcnQgeyBwYXRoIH0gZnJvbSAnQGxvYWRlcnMuZ2wvbG9hZGVyLXV0aWxzJztcbmV4cG9ydCBmdW5jdGlvbiBnZXRMb2FkZXJDb250ZXh0KGNvbnRleHQsIG9wdGlvbnMsIHBhcmVudENvbnRleHQpIHtcbiAgaWYgKHBhcmVudENvbnRleHQpIHtcbiAgICByZXR1cm4gcGFyZW50Q29udGV4dDtcbiAgfVxuICBjb25zdCBuZXdDb250ZXh0ID0ge1xuICAgIGZldGNoOiBnZXRGZXRjaEZ1bmN0aW9uKG9wdGlvbnMsIGNvbnRleHQpLFxuICAgIC4uLmNvbnRleHRcbiAgfTtcbiAgaWYgKG5ld0NvbnRleHQudXJsKSB7XG4gICAgY29uc3QgYmFzZVVybCA9IHN0cmlwUXVlcnlTdHJpbmcobmV3Q29udGV4dC51cmwpO1xuICAgIG5ld0NvbnRleHQuYmFzZVVybCA9IGJhc2VVcmw7XG4gICAgbmV3Q29udGV4dC5xdWVyeVN0cmluZyA9IGV4dHJhY3RRdWVyeVN0cmluZyhuZXdDb250ZXh0LnVybCk7XG4gICAgbmV3Q29udGV4dC5maWxlbmFtZSA9IHBhdGguZmlsZW5hbWUoYmFzZVVybCk7XG4gICAgbmV3Q29udGV4dC5iYXNlVXJsID0gcGF0aC5kaXJuYW1lKGJhc2VVcmwpO1xuICB9XG4gIGlmICghQXJyYXkuaXNBcnJheShuZXdDb250ZXh0LmxvYWRlcnMpKSB7XG4gICAgbmV3Q29udGV4dC5sb2FkZXJzID0gbnVsbDtcbiAgfVxuICByZXR1cm4gbmV3Q29udGV4dDtcbn1cbmV4cG9ydCBmdW5jdGlvbiBnZXRMb2FkZXJzRnJvbUNvbnRleHQobG9hZGVycywgY29udGV4dCkge1xuICBpZiAobG9hZGVycyAmJiAhQXJyYXkuaXNBcnJheShsb2FkZXJzKSkge1xuICAgIHJldHVybiBsb2FkZXJzO1xuICB9XG4gIGxldCBjYW5kaWRhdGVMb2FkZXJzO1xuICBpZiAobG9hZGVycykge1xuICAgIGNhbmRpZGF0ZUxvYWRlcnMgPSBBcnJheS5pc0FycmF5KGxvYWRlcnMpID8gbG9hZGVycyA6IFtsb2FkZXJzXTtcbiAgfVxuICBpZiAoY29udGV4dCAmJiBjb250ZXh0LmxvYWRlcnMpIHtcbiAgICBjb25zdCBjb250ZXh0TG9hZGVycyA9IEFycmF5LmlzQXJyYXkoY29udGV4dC5sb2FkZXJzKSA/IGNvbnRleHQubG9hZGVycyA6IFtjb250ZXh0LmxvYWRlcnNdO1xuICAgIGNhbmRpZGF0ZUxvYWRlcnMgPSBjYW5kaWRhdGVMb2FkZXJzID8gWy4uLmNhbmRpZGF0ZUxvYWRlcnMsIC4uLmNvbnRleHRMb2FkZXJzXSA6IGNvbnRleHRMb2FkZXJzO1xuICB9XG4gIHJldHVybiBjYW5kaWRhdGVMb2FkZXJzICYmIGNhbmRpZGF0ZUxvYWRlcnMubGVuZ3RoID8gY2FuZGlkYXRlTG9hZGVycyA6IHVuZGVmaW5lZDtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWxvYWRlci1jb250ZXh0LmpzLm1hcCIsImltcG9ydCB7IExvZyB9IGZyb20gJ0Bwcm9iZS5nbC9sb2cnO1xuZXhwb3J0IGNvbnN0IHByb2JlTG9nID0gbmV3IExvZyh7XG4gIGlkOiAnbG9hZGVycy5nbCdcbn0pO1xuZXhwb3J0IGNsYXNzIE51bGxMb2cge1xuICBsb2coKSB7XG4gICAgcmV0dXJuICgpID0+IHt9O1xuICB9XG4gIGluZm8oKSB7XG4gICAgcmV0dXJuICgpID0+IHt9O1xuICB9XG4gIHdhcm4oKSB7XG4gICAgcmV0dXJuICgpID0+IHt9O1xuICB9XG4gIGVycm9yKCkge1xuICAgIHJldHVybiAoKSA9PiB7fTtcbiAgfVxufVxuZXhwb3J0IGNsYXNzIENvbnNvbGVMb2cge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLmNvbnNvbGUgPSB2b2lkIDA7XG4gICAgdGhpcy5jb25zb2xlID0gY29uc29sZTtcbiAgfVxuICBsb2coKSB7XG4gICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5jb25zb2xlLmxvZy5iaW5kKHRoaXMuY29uc29sZSwgLi4uYXJncyk7XG4gIH1cbiAgaW5mbygpIHtcbiAgICBmb3IgKHZhciBfbGVuMiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjIpLCBfa2V5MiA9IDA7IF9rZXkyIDwgX2xlbjI7IF9rZXkyKyspIHtcbiAgICAgIGFyZ3NbX2tleTJdID0gYXJndW1lbnRzW19rZXkyXTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuY29uc29sZS5pbmZvLmJpbmQodGhpcy5jb25zb2xlLCAuLi5hcmdzKTtcbiAgfVxuICB3YXJuKCkge1xuICAgIGZvciAodmFyIF9sZW4zID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuMyksIF9rZXkzID0gMDsgX2tleTMgPCBfbGVuMzsgX2tleTMrKykge1xuICAgICAgYXJnc1tfa2V5M10gPSBhcmd1bWVudHNbX2tleTNdO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5jb25zb2xlLndhcm4uYmluZCh0aGlzLmNvbnNvbGUsIC4uLmFyZ3MpO1xuICB9XG4gIGVycm9yKCkge1xuICAgIGZvciAodmFyIF9sZW40ID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuNCksIF9rZXk0ID0gMDsgX2tleTQgPCBfbGVuNDsgX2tleTQrKykge1xuICAgICAgYXJnc1tfa2V5NF0gPSBhcmd1bWVudHNbX2tleTRdO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5jb25zb2xlLmVycm9yLmJpbmQodGhpcy5jb25zb2xlLCAuLi5hcmdzKTtcbiAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bG9nZ2Vycy5qcy5tYXAiLCJpbXBvcnQgeyBhc3NlcnQgfSBmcm9tICdAbG9hZGVycy5nbC9sb2FkZXItdXRpbHMnO1xuZXhwb3J0IGZ1bmN0aW9uIGlzTG9hZGVyT2JqZWN0KGxvYWRlcikge1xuICB2YXIgX2xvYWRlcjtcbiAgaWYgKCFsb2FkZXIpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKEFycmF5LmlzQXJyYXkobG9hZGVyKSkge1xuICAgIGxvYWRlciA9IGxvYWRlclswXTtcbiAgfVxuICBjb25zdCBoYXNFeHRlbnNpb25zID0gQXJyYXkuaXNBcnJheSgoX2xvYWRlciA9IGxvYWRlcikgPT09IG51bGwgfHwgX2xvYWRlciA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2xvYWRlci5leHRlbnNpb25zKTtcbiAgcmV0dXJuIGhhc0V4dGVuc2lvbnM7XG59XG5leHBvcnQgZnVuY3Rpb24gbm9ybWFsaXplTG9hZGVyKGxvYWRlcikge1xuICB2YXIgX2xvYWRlcjIsIF9sb2FkZXIzO1xuICBhc3NlcnQobG9hZGVyLCAnbnVsbCBsb2FkZXInKTtcbiAgYXNzZXJ0KGlzTG9hZGVyT2JqZWN0KGxvYWRlciksICdpbnZhbGlkIGxvYWRlcicpO1xuICBsZXQgb3B0aW9ucztcbiAgaWYgKEFycmF5LmlzQXJyYXkobG9hZGVyKSkge1xuICAgIG9wdGlvbnMgPSBsb2FkZXJbMV07XG4gICAgbG9hZGVyID0gbG9hZGVyWzBdO1xuICAgIGxvYWRlciA9IHtcbiAgICAgIC4uLmxvYWRlcixcbiAgICAgIG9wdGlvbnM6IHtcbiAgICAgICAgLi4ubG9hZGVyLm9wdGlvbnMsXG4gICAgICAgIC4uLm9wdGlvbnNcbiAgICAgIH1cbiAgICB9O1xuICB9XG4gIGlmICgoX2xvYWRlcjIgPSBsb2FkZXIpICE9PSBudWxsICYmIF9sb2FkZXIyICE9PSB2b2lkIDAgJiYgX2xvYWRlcjIucGFyc2VUZXh0U3luYyB8fCAoX2xvYWRlcjMgPSBsb2FkZXIpICE9PSBudWxsICYmIF9sb2FkZXIzICE9PSB2b2lkIDAgJiYgX2xvYWRlcjMucGFyc2VUZXh0KSB7XG4gICAgbG9hZGVyLnRleHQgPSB0cnVlO1xuICB9XG4gIGlmICghbG9hZGVyLnRleHQpIHtcbiAgICBsb2FkZXIuYmluYXJ5ID0gdHJ1ZTtcbiAgfVxuICByZXR1cm4gbG9hZGVyO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bm9ybWFsaXplLWxvYWRlci5qcy5tYXAiLCJpbXBvcnQgeyBpc0Jyb3dzZXIgfSBmcm9tICdAbG9hZGVycy5nbC9sb2FkZXItdXRpbHMnO1xuaW1wb3J0IHsgQ29uc29sZUxvZyB9IGZyb20gXCIuL2xvZ2dlcnMuanNcIjtcbmV4cG9ydCBjb25zdCBERUZBVUxUX0xPQURFUl9PUFRJT05TID0ge1xuICBmZXRjaDogbnVsbCxcbiAgbWltZVR5cGU6IHVuZGVmaW5lZCxcbiAgbm90aHJvdzogZmFsc2UsXG4gIGxvZzogbmV3IENvbnNvbGVMb2coKSxcbiAgdXNlTG9jYWxMaWJyYXJpZXM6IGZhbHNlLFxuICBDRE46ICdodHRwczovL3VucGtnLmNvbS9AbG9hZGVycy5nbCcsXG4gIHdvcmtlcjogdHJ1ZSxcbiAgbWF4Q29uY3VycmVuY3k6IDMsXG4gIG1heE1vYmlsZUNvbmN1cnJlbmN5OiAxLFxuICByZXVzZVdvcmtlcnM6IGlzQnJvd3NlcixcbiAgX25vZGVXb3JrZXJzOiBmYWxzZSxcbiAgX3dvcmtlclR5cGU6ICcnLFxuICBsaW1pdDogMCxcbiAgX2xpbWl0TUI6IDAsXG4gIGJhdGNoU2l6ZTogJ2F1dG8nLFxuICBiYXRjaERlYm91bmNlTXM6IDAsXG4gIG1ldGFkYXRhOiBmYWxzZSxcbiAgdHJhbnNmb3JtczogW11cbn07XG5leHBvcnQgY29uc3QgUkVNT1ZFRF9MT0FERVJfT1BUSU9OUyA9IHtcbiAgdGhyb3dzOiAnbm90aHJvdycsXG4gIGRhdGFUeXBlOiAnKG5vIGxvbmdlciB1c2VkKScsXG4gIHVyaTogJ2Jhc2VVcmknLFxuICBtZXRob2Q6ICdmZXRjaC5tZXRob2QnLFxuICBoZWFkZXJzOiAnZmV0Y2guaGVhZGVycycsXG4gIGJvZHk6ICdmZXRjaC5ib2R5JyxcbiAgbW9kZTogJ2ZldGNoLm1vZGUnLFxuICBjcmVkZW50aWFsczogJ2ZldGNoLmNyZWRlbnRpYWxzJyxcbiAgY2FjaGU6ICdmZXRjaC5jYWNoZScsXG4gIHJlZGlyZWN0OiAnZmV0Y2gucmVkaXJlY3QnLFxuICByZWZlcnJlcjogJ2ZldGNoLnJlZmVycmVyJyxcbiAgcmVmZXJyZXJQb2xpY3k6ICdmZXRjaC5yZWZlcnJlclBvbGljeScsXG4gIGludGVncml0eTogJ2ZldGNoLmludGVncml0eScsXG4gIGtlZXBhbGl2ZTogJ2ZldGNoLmtlZXBhbGl2ZScsXG4gIHNpZ25hbDogJ2ZldGNoLnNpZ25hbCdcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1vcHRpb24tZGVmYXVsdHMuanMubWFwIiwiaW1wb3J0IHsgaXNQdXJlT2JqZWN0LCBpc09iamVjdCB9IGZyb20gXCIuLi8uLi9qYXZhc2NyaXB0LXV0aWxzL2lzLXR5cGUuanNcIjtcbmltcG9ydCB7IHByb2JlTG9nLCBOdWxsTG9nIH0gZnJvbSBcIi4vbG9nZ2Vycy5qc1wiO1xuaW1wb3J0IHsgREVGQVVMVF9MT0FERVJfT1BUSU9OUywgUkVNT1ZFRF9MT0FERVJfT1BUSU9OUyB9IGZyb20gXCIuL29wdGlvbi1kZWZhdWx0cy5qc1wiO1xuZXhwb3J0IGZ1bmN0aW9uIGdldEdsb2JhbExvYWRlclN0YXRlKCkge1xuICBnbG9iYWxUaGlzLmxvYWRlcnMgPSBnbG9iYWxUaGlzLmxvYWRlcnMgfHwge307XG4gIGNvbnN0IHtcbiAgICBsb2FkZXJzXG4gIH0gPSBnbG9iYWxUaGlzO1xuICBsb2FkZXJzLl9zdGF0ZSA9IGxvYWRlcnMuX3N0YXRlIHx8IHt9O1xuICByZXR1cm4gbG9hZGVycy5fc3RhdGU7XG59XG5leHBvcnQgZnVuY3Rpb24gZ2V0R2xvYmFsTG9hZGVyT3B0aW9ucygpIHtcbiAgY29uc3Qgc3RhdGUgPSBnZXRHbG9iYWxMb2FkZXJTdGF0ZSgpO1xuICBzdGF0ZS5nbG9iYWxPcHRpb25zID0gc3RhdGUuZ2xvYmFsT3B0aW9ucyB8fCB7XG4gICAgLi4uREVGQVVMVF9MT0FERVJfT1BUSU9OU1xuICB9O1xuICByZXR1cm4gc3RhdGUuZ2xvYmFsT3B0aW9ucztcbn1cbmV4cG9ydCBmdW5jdGlvbiBzZXRHbG9iYWxPcHRpb25zKG9wdGlvbnMpIHtcbiAgY29uc3Qgc3RhdGUgPSBnZXRHbG9iYWxMb2FkZXJTdGF0ZSgpO1xuICBjb25zdCBnbG9iYWxPcHRpb25zID0gZ2V0R2xvYmFsTG9hZGVyT3B0aW9ucygpO1xuICBzdGF0ZS5nbG9iYWxPcHRpb25zID0gbm9ybWFsaXplT3B0aW9uc0ludGVybmFsKGdsb2JhbE9wdGlvbnMsIG9wdGlvbnMpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIG5vcm1hbGl6ZU9wdGlvbnMob3B0aW9ucywgbG9hZGVyLCBsb2FkZXJzLCB1cmwpIHtcbiAgbG9hZGVycyA9IGxvYWRlcnMgfHwgW107XG4gIGxvYWRlcnMgPSBBcnJheS5pc0FycmF5KGxvYWRlcnMpID8gbG9hZGVycyA6IFtsb2FkZXJzXTtcbiAgdmFsaWRhdGVPcHRpb25zKG9wdGlvbnMsIGxvYWRlcnMpO1xuICByZXR1cm4gbm9ybWFsaXplT3B0aW9uc0ludGVybmFsKGxvYWRlciwgb3B0aW9ucywgdXJsKTtcbn1cbmZ1bmN0aW9uIHZhbGlkYXRlT3B0aW9ucyhvcHRpb25zLCBsb2FkZXJzKSB7XG4gIHZhbGlkYXRlT3B0aW9uc09iamVjdChvcHRpb25zLCBudWxsLCBERUZBVUxUX0xPQURFUl9PUFRJT05TLCBSRU1PVkVEX0xPQURFUl9PUFRJT05TLCBsb2FkZXJzKTtcbiAgZm9yIChjb25zdCBsb2FkZXIgb2YgbG9hZGVycykge1xuICAgIGNvbnN0IGlkT3B0aW9ucyA9IG9wdGlvbnMgJiYgb3B0aW9uc1tsb2FkZXIuaWRdIHx8IHt9O1xuICAgIGNvbnN0IGxvYWRlck9wdGlvbnMgPSBsb2FkZXIub3B0aW9ucyAmJiBsb2FkZXIub3B0aW9uc1tsb2FkZXIuaWRdIHx8IHt9O1xuICAgIGNvbnN0IGRlcHJlY2F0ZWRPcHRpb25zID0gbG9hZGVyLmRlcHJlY2F0ZWRPcHRpb25zICYmIGxvYWRlci5kZXByZWNhdGVkT3B0aW9uc1tsb2FkZXIuaWRdIHx8IHt9O1xuICAgIHZhbGlkYXRlT3B0aW9uc09iamVjdChpZE9wdGlvbnMsIGxvYWRlci5pZCwgbG9hZGVyT3B0aW9ucywgZGVwcmVjYXRlZE9wdGlvbnMsIGxvYWRlcnMpO1xuICB9XG59XG5mdW5jdGlvbiB2YWxpZGF0ZU9wdGlvbnNPYmplY3Qob3B0aW9ucywgaWQsIGRlZmF1bHRPcHRpb25zLCBkZXByZWNhdGVkT3B0aW9ucywgbG9hZGVycykge1xuICBjb25zdCBsb2FkZXJOYW1lID0gaWQgfHwgJ1RvcCBsZXZlbCc7XG4gIGNvbnN0IHByZWZpeCA9IGlkID8gYCR7aWR9LmAgOiAnJztcbiAgZm9yIChjb25zdCBrZXkgaW4gb3B0aW9ucykge1xuICAgIGNvbnN0IGlzU3ViT3B0aW9ucyA9ICFpZCAmJiBpc09iamVjdChvcHRpb25zW2tleV0pO1xuICAgIGNvbnN0IGlzQmFzZVVyaU9wdGlvbiA9IGtleSA9PT0gJ2Jhc2VVcmknICYmICFpZDtcbiAgICBjb25zdCBpc1dvcmtlclVybE9wdGlvbiA9IGtleSA9PT0gJ3dvcmtlclVybCcgJiYgaWQ7XG4gICAgaWYgKCEoa2V5IGluIGRlZmF1bHRPcHRpb25zKSAmJiAhaXNCYXNlVXJpT3B0aW9uICYmICFpc1dvcmtlclVybE9wdGlvbikge1xuICAgICAgaWYgKGtleSBpbiBkZXByZWNhdGVkT3B0aW9ucykge1xuICAgICAgICBwcm9iZUxvZy53YXJuKGAke2xvYWRlck5hbWV9IGxvYWRlciBvcHRpb24gXFwnJHtwcmVmaXh9JHtrZXl9XFwnIG5vIGxvbmdlciBzdXBwb3J0ZWQsIHVzZSBcXCcke2RlcHJlY2F0ZWRPcHRpb25zW2tleV19XFwnYCkoKTtcbiAgICAgIH0gZWxzZSBpZiAoIWlzU3ViT3B0aW9ucykge1xuICAgICAgICBjb25zdCBzdWdnZXN0aW9uID0gZmluZFNpbWlsYXJPcHRpb24oa2V5LCBsb2FkZXJzKTtcbiAgICAgICAgcHJvYmVMb2cud2FybihgJHtsb2FkZXJOYW1lfSBsb2FkZXIgb3B0aW9uIFxcJyR7cHJlZml4fSR7a2V5fVxcJyBub3QgcmVjb2duaXplZC4gJHtzdWdnZXN0aW9ufWApKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBmaW5kU2ltaWxhck9wdGlvbihvcHRpb25LZXksIGxvYWRlcnMpIHtcbiAgY29uc3QgbG93ZXJDYXNlT3B0aW9uS2V5ID0gb3B0aW9uS2V5LnRvTG93ZXJDYXNlKCk7XG4gIGxldCBiZXN0U3VnZ2VzdGlvbiA9ICcnO1xuICBmb3IgKGNvbnN0IGxvYWRlciBvZiBsb2FkZXJzKSB7XG4gICAgZm9yIChjb25zdCBrZXkgaW4gbG9hZGVyLm9wdGlvbnMpIHtcbiAgICAgIGlmIChvcHRpb25LZXkgPT09IGtleSkge1xuICAgICAgICByZXR1cm4gYERpZCB5b3UgbWVhbiBcXCcke2xvYWRlci5pZH0uJHtrZXl9XFwnP2A7XG4gICAgICB9XG4gICAgICBjb25zdCBsb3dlckNhc2VLZXkgPSBrZXkudG9Mb3dlckNhc2UoKTtcbiAgICAgIGNvbnN0IGlzUGFydGlhbE1hdGNoID0gbG93ZXJDYXNlT3B0aW9uS2V5LnN0YXJ0c1dpdGgobG93ZXJDYXNlS2V5KSB8fCBsb3dlckNhc2VLZXkuc3RhcnRzV2l0aChsb3dlckNhc2VPcHRpb25LZXkpO1xuICAgICAgaWYgKGlzUGFydGlhbE1hdGNoKSB7XG4gICAgICAgIGJlc3RTdWdnZXN0aW9uID0gYmVzdFN1Z2dlc3Rpb24gfHwgYERpZCB5b3UgbWVhbiBcXCcke2xvYWRlci5pZH0uJHtrZXl9XFwnP2A7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBiZXN0U3VnZ2VzdGlvbjtcbn1cbmZ1bmN0aW9uIG5vcm1hbGl6ZU9wdGlvbnNJbnRlcm5hbChsb2FkZXIsIG9wdGlvbnMsIHVybCkge1xuICBjb25zdCBsb2FkZXJEZWZhdWx0T3B0aW9ucyA9IGxvYWRlci5vcHRpb25zIHx8IHt9O1xuICBjb25zdCBtZXJnZWRPcHRpb25zID0ge1xuICAgIC4uLmxvYWRlckRlZmF1bHRPcHRpb25zXG4gIH07XG4gIGFkZFVybE9wdGlvbnMobWVyZ2VkT3B0aW9ucywgdXJsKTtcbiAgaWYgKG1lcmdlZE9wdGlvbnMubG9nID09PSBudWxsKSB7XG4gICAgbWVyZ2VkT3B0aW9ucy5sb2cgPSBuZXcgTnVsbExvZygpO1xuICB9XG4gIG1lcmdlTmVzdGVkRmllbGRzKG1lcmdlZE9wdGlvbnMsIGdldEdsb2JhbExvYWRlck9wdGlvbnMoKSk7XG4gIG1lcmdlTmVzdGVkRmllbGRzKG1lcmdlZE9wdGlvbnMsIG9wdGlvbnMpO1xuICByZXR1cm4gbWVyZ2VkT3B0aW9ucztcbn1cbmZ1bmN0aW9uIG1lcmdlTmVzdGVkRmllbGRzKG1lcmdlZE9wdGlvbnMsIG9wdGlvbnMpIHtcbiAgZm9yIChjb25zdCBrZXkgaW4gb3B0aW9ucykge1xuICAgIGlmIChrZXkgaW4gb3B0aW9ucykge1xuICAgICAgY29uc3QgdmFsdWUgPSBvcHRpb25zW2tleV07XG4gICAgICBpZiAoaXNQdXJlT2JqZWN0KHZhbHVlKSAmJiBpc1B1cmVPYmplY3QobWVyZ2VkT3B0aW9uc1trZXldKSkge1xuICAgICAgICBtZXJnZWRPcHRpb25zW2tleV0gPSB7XG4gICAgICAgICAgLi4ubWVyZ2VkT3B0aW9uc1trZXldLFxuICAgICAgICAgIC4uLm9wdGlvbnNba2V5XVxuICAgICAgICB9O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbWVyZ2VkT3B0aW9uc1trZXldID0gb3B0aW9uc1trZXldO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gYWRkVXJsT3B0aW9ucyhvcHRpb25zLCB1cmwpIHtcbiAgaWYgKHVybCAmJiAhKCdiYXNlVXJpJyBpbiBvcHRpb25zKSkge1xuICAgIG9wdGlvbnMuYmFzZVVyaSA9IHVybDtcbiAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9b3B0aW9uLXV0aWxzLmpzLm1hcCIsImltcG9ydCB7IExvZyB9IGZyb20gJ0Bwcm9iZS5nbC9sb2cnO1xuZXhwb3J0IGNvbnN0IGxvZyA9IG5ldyBMb2coe1xuICBpZDogJ2xvYWRlcnMuZ2wnXG59KTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWxvZy5qcy5tYXAiLCJjb25zdCBEQVRBX1VSTF9QQVRURVJOID0gL15kYXRhOihbLVxcdy5dK1xcL1stXFx3LitdKykoO3wsKS87XG5jb25zdCBNSU1FX1RZUEVfUEFUVEVSTiA9IC9eKFstXFx3Ll0rXFwvWy1cXHcuK10rKS87XG5leHBvcnQgZnVuY3Rpb24gcGFyc2VNSU1FVHlwZShtaW1lU3RyaW5nKSB7XG4gIGNvbnN0IG1hdGNoZXMgPSBNSU1FX1RZUEVfUEFUVEVSTi5leGVjKG1pbWVTdHJpbmcpO1xuICBpZiAobWF0Y2hlcykge1xuICAgIHJldHVybiBtYXRjaGVzWzFdO1xuICB9XG4gIHJldHVybiBtaW1lU3RyaW5nO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlTUlNRVR5cGVGcm9tVVJMKHVybCkge1xuICBjb25zdCBtYXRjaGVzID0gREFUQV9VUkxfUEFUVEVSTi5leGVjKHVybCk7XG4gIGlmIChtYXRjaGVzKSB7XG4gICAgcmV0dXJuIG1hdGNoZXNbMV07XG4gIH1cbiAgcmV0dXJuICcnO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bWltZS10eXBlLXV0aWxzLmpzLm1hcCIsImltcG9ydCB7IGlzUmVzcG9uc2UsIGlzQmxvYiB9IGZyb20gXCIuLi8uLi9qYXZhc2NyaXB0LXV0aWxzL2lzLXR5cGUuanNcIjtcbmltcG9ydCB7IHBhcnNlTUlNRVR5cGUsIHBhcnNlTUlNRVR5cGVGcm9tVVJMIH0gZnJvbSBcIi4vbWltZS10eXBlLXV0aWxzLmpzXCI7XG5pbXBvcnQgeyBzdHJpcFF1ZXJ5U3RyaW5nIH0gZnJvbSBcIi4vdXJsLXV0aWxzLmpzXCI7XG5leHBvcnQgZnVuY3Rpb24gZ2V0UmVzb3VyY2VVcmwocmVzb3VyY2UpIHtcbiAgaWYgKGlzUmVzcG9uc2UocmVzb3VyY2UpKSB7XG4gICAgY29uc3QgcmVzcG9uc2UgPSByZXNvdXJjZTtcbiAgICByZXR1cm4gcmVzcG9uc2UudXJsO1xuICB9XG4gIGlmIChpc0Jsb2IocmVzb3VyY2UpKSB7XG4gICAgY29uc3QgYmxvYiA9IHJlc291cmNlO1xuICAgIHJldHVybiBibG9iLm5hbWUgfHwgJyc7XG4gIH1cbiAgaWYgKHR5cGVvZiByZXNvdXJjZSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gcmVzb3VyY2U7XG4gIH1cbiAgcmV0dXJuICcnO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGdldFJlc291cmNlTUlNRVR5cGUocmVzb3VyY2UpIHtcbiAgaWYgKGlzUmVzcG9uc2UocmVzb3VyY2UpKSB7XG4gICAgY29uc3QgcmVzcG9uc2UgPSByZXNvdXJjZTtcbiAgICBjb25zdCBjb250ZW50VHlwZUhlYWRlciA9IHJlc3BvbnNlLmhlYWRlcnMuZ2V0KCdjb250ZW50LXR5cGUnKSB8fCAnJztcbiAgICBjb25zdCBub1F1ZXJ5VXJsID0gc3RyaXBRdWVyeVN0cmluZyhyZXNwb25zZS51cmwpO1xuICAgIHJldHVybiBwYXJzZU1JTUVUeXBlKGNvbnRlbnRUeXBlSGVhZGVyKSB8fCBwYXJzZU1JTUVUeXBlRnJvbVVSTChub1F1ZXJ5VXJsKTtcbiAgfVxuICBpZiAoaXNCbG9iKHJlc291cmNlKSkge1xuICAgIGNvbnN0IGJsb2IgPSByZXNvdXJjZTtcbiAgICByZXR1cm4gYmxvYi50eXBlIHx8ICcnO1xuICB9XG4gIGlmICh0eXBlb2YgcmVzb3VyY2UgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIHBhcnNlTUlNRVR5cGVGcm9tVVJMKHJlc291cmNlKTtcbiAgfVxuICByZXR1cm4gJyc7XG59XG5leHBvcnQgZnVuY3Rpb24gZ2V0UmVzb3VyY2VDb250ZW50TGVuZ3RoKHJlc291cmNlKSB7XG4gIGlmIChpc1Jlc3BvbnNlKHJlc291cmNlKSkge1xuICAgIGNvbnN0IHJlc3BvbnNlID0gcmVzb3VyY2U7XG4gICAgcmV0dXJuIHJlc3BvbnNlLmhlYWRlcnNbJ2NvbnRlbnQtbGVuZ3RoJ10gfHwgLTE7XG4gIH1cbiAgaWYgKGlzQmxvYihyZXNvdXJjZSkpIHtcbiAgICBjb25zdCBibG9iID0gcmVzb3VyY2U7XG4gICAgcmV0dXJuIGJsb2Iuc2l6ZTtcbiAgfVxuICBpZiAodHlwZW9mIHJlc291cmNlID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiByZXNvdXJjZS5sZW5ndGg7XG4gIH1cbiAgaWYgKHJlc291cmNlIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHtcbiAgICByZXR1cm4gcmVzb3VyY2UuYnl0ZUxlbmd0aDtcbiAgfVxuICBpZiAoQXJyYXlCdWZmZXIuaXNWaWV3KHJlc291cmNlKSkge1xuICAgIHJldHVybiByZXNvdXJjZS5ieXRlTGVuZ3RoO1xuICB9XG4gIHJldHVybiAtMTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJlc291cmNlLXV0aWxzLmpzLm1hcCIsImltcG9ydCB7IGlzUmVzcG9uc2UgfSBmcm9tIFwiLi4vLi4vamF2YXNjcmlwdC11dGlscy9pcy10eXBlLmpzXCI7XG5pbXBvcnQgeyBnZXRSZXNvdXJjZUNvbnRlbnRMZW5ndGgsIGdldFJlc291cmNlVXJsLCBnZXRSZXNvdXJjZU1JTUVUeXBlIH0gZnJvbSBcIi4vcmVzb3VyY2UtdXRpbHMuanNcIjtcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBtYWtlUmVzcG9uc2UocmVzb3VyY2UpIHtcbiAgaWYgKGlzUmVzcG9uc2UocmVzb3VyY2UpKSB7XG4gICAgcmV0dXJuIHJlc291cmNlO1xuICB9XG4gIGNvbnN0IGhlYWRlcnMgPSB7fTtcbiAgY29uc3QgY29udGVudExlbmd0aCA9IGdldFJlc291cmNlQ29udGVudExlbmd0aChyZXNvdXJjZSk7XG4gIGlmIChjb250ZW50TGVuZ3RoID49IDApIHtcbiAgICBoZWFkZXJzWydjb250ZW50LWxlbmd0aCddID0gU3RyaW5nKGNvbnRlbnRMZW5ndGgpO1xuICB9XG4gIGNvbnN0IHVybCA9IGdldFJlc291cmNlVXJsKHJlc291cmNlKTtcbiAgY29uc3QgdHlwZSA9IGdldFJlc291cmNlTUlNRVR5cGUocmVzb3VyY2UpO1xuICBpZiAodHlwZSkge1xuICAgIGhlYWRlcnNbJ2NvbnRlbnQtdHlwZSddID0gdHlwZTtcbiAgfVxuICBjb25zdCBpbml0aWFsRGF0YVVybCA9IGF3YWl0IGdldEluaXRpYWxEYXRhVXJsKHJlc291cmNlKTtcbiAgaWYgKGluaXRpYWxEYXRhVXJsKSB7XG4gICAgaGVhZGVyc1sneC1maXJzdC1ieXRlcyddID0gaW5pdGlhbERhdGFVcmw7XG4gIH1cbiAgaWYgKHR5cGVvZiByZXNvdXJjZSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXNvdXJjZSA9IG5ldyBUZXh0RW5jb2RlcigpLmVuY29kZShyZXNvdXJjZSk7XG4gIH1cbiAgY29uc3QgcmVzcG9uc2UgPSBuZXcgUmVzcG9uc2UocmVzb3VyY2UsIHtcbiAgICBoZWFkZXJzXG4gIH0pO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkocmVzcG9uc2UsICd1cmwnLCB7XG4gICAgdmFsdWU6IHVybFxuICB9KTtcbiAgcmV0dXJuIHJlc3BvbnNlO1xufVxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGNoZWNrUmVzcG9uc2UocmVzcG9uc2UpIHtcbiAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgIGNvbnN0IG1lc3NhZ2UgPSBhd2FpdCBnZXRSZXNwb25zZUVycm9yKHJlc3BvbnNlKTtcbiAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSk7XG4gIH1cbn1cbmV4cG9ydCBmdW5jdGlvbiBjaGVja1Jlc3BvbnNlU3luYyhyZXNwb25zZSkge1xuICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgbGV0IG1lc3NhZ2UgPSBgJHtyZXNwb25zZS5zdGF0dXN9ICR7cmVzcG9uc2Uuc3RhdHVzVGV4dH1gO1xuICAgIG1lc3NhZ2UgPSBtZXNzYWdlLmxlbmd0aCA+IDYwID8gYCR7bWVzc2FnZS5zbGljZSgwLCA2MCl9Li4uYCA6IG1lc3NhZ2U7XG4gICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UpO1xuICB9XG59XG5hc3luYyBmdW5jdGlvbiBnZXRSZXNwb25zZUVycm9yKHJlc3BvbnNlKSB7XG4gIGxldCBtZXNzYWdlID0gYEZhaWxlZCB0byBmZXRjaCByZXNvdXJjZSAke3Jlc3BvbnNlLnVybH0gKCR7cmVzcG9uc2Uuc3RhdHVzfSk6IGA7XG4gIHRyeSB7XG4gICAgY29uc3QgY29udGVudFR5cGUgPSByZXNwb25zZS5oZWFkZXJzLmdldCgnQ29udGVudC1UeXBlJyk7XG4gICAgbGV0IHRleHQgPSByZXNwb25zZS5zdGF0dXNUZXh0O1xuICAgIGlmIChjb250ZW50VHlwZSAhPT0gbnVsbCAmJiBjb250ZW50VHlwZSAhPT0gdm9pZCAwICYmIGNvbnRlbnRUeXBlLmluY2x1ZGVzKCdhcHBsaWNhdGlvbi9qc29uJykpIHtcbiAgICAgIHRleHQgKz0gYCAke2F3YWl0IHJlc3BvbnNlLnRleHQoKX1gO1xuICAgIH1cbiAgICBtZXNzYWdlICs9IHRleHQ7XG4gICAgbWVzc2FnZSA9IG1lc3NhZ2UubGVuZ3RoID4gNjAgPyBgJHttZXNzYWdlLnNsaWNlKDAsIDYwKX0uLi5gIDogbWVzc2FnZTtcbiAgfSBjYXRjaCAoZXJyb3IpIHt9XG4gIHJldHVybiBtZXNzYWdlO1xufVxuYXN5bmMgZnVuY3Rpb24gZ2V0SW5pdGlhbERhdGFVcmwocmVzb3VyY2UpIHtcbiAgY29uc3QgSU5JVElBTF9EQVRBX0xFTkdUSCA9IDU7XG4gIGlmICh0eXBlb2YgcmVzb3VyY2UgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIGBkYXRhOiwke3Jlc291cmNlLnNsaWNlKDAsIElOSVRJQUxfREFUQV9MRU5HVEgpfWA7XG4gIH1cbiAgaWYgKHJlc291cmNlIGluc3RhbmNlb2YgQmxvYikge1xuICAgIGNvbnN0IGJsb2JTbGljZSA9IHJlc291cmNlLnNsaWNlKDAsIDUpO1xuICAgIHJldHVybiBhd2FpdCBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHtcbiAgICAgIGNvbnN0IHJlYWRlciA9IG5ldyBGaWxlUmVhZGVyKCk7XG4gICAgICByZWFkZXIub25sb2FkID0gZXZlbnQgPT4ge1xuICAgICAgICB2YXIgX2V2ZW50JHRhcmdldDtcbiAgICAgICAgcmV0dXJuIHJlc29sdmUoZXZlbnQgPT09IG51bGwgfHwgZXZlbnQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IChfZXZlbnQkdGFyZ2V0ID0gZXZlbnQudGFyZ2V0KSA9PT0gbnVsbCB8fCBfZXZlbnQkdGFyZ2V0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZXZlbnQkdGFyZ2V0LnJlc3VsdCk7XG4gICAgICB9O1xuICAgICAgcmVhZGVyLnJlYWRBc0RhdGFVUkwoYmxvYlNsaWNlKTtcbiAgICB9KTtcbiAgfVxuICBpZiAocmVzb3VyY2UgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikge1xuICAgIGNvbnN0IHNsaWNlID0gcmVzb3VyY2Uuc2xpY2UoMCwgSU5JVElBTF9EQVRBX0xFTkdUSCk7XG4gICAgY29uc3QgYmFzZTY0ID0gYXJyYXlCdWZmZXJUb0Jhc2U2NChzbGljZSk7XG4gICAgcmV0dXJuIGBkYXRhOmJhc2U2NCwke2Jhc2U2NH1gO1xuICB9XG4gIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gYXJyYXlCdWZmZXJUb0Jhc2U2NChidWZmZXIpIHtcbiAgbGV0IGJpbmFyeSA9ICcnO1xuICBjb25zdCBieXRlcyA9IG5ldyBVaW50OEFycmF5KGJ1ZmZlcik7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgYnl0ZXMuYnl0ZUxlbmd0aDsgaSsrKSB7XG4gICAgYmluYXJ5ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnl0ZXNbaV0pO1xuICB9XG4gIHJldHVybiBidG9hKGJpbmFyeSk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1yZXNwb25zZS11dGlscy5qcy5tYXAiLCJjb25zdCBRVUVSWV9TVFJJTkdfUEFUVEVSTiA9IC9cXD8uKi87XG5leHBvcnQgZnVuY3Rpb24gZXh0cmFjdFF1ZXJ5U3RyaW5nKHVybCkge1xuICBjb25zdCBtYXRjaGVzID0gdXJsLm1hdGNoKFFVRVJZX1NUUklOR19QQVRURVJOKTtcbiAgcmV0dXJuIG1hdGNoZXMgJiYgbWF0Y2hlc1swXTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBzdHJpcFF1ZXJ5U3RyaW5nKHVybCkge1xuICByZXR1cm4gdXJsLnJlcGxhY2UoUVVFUllfU1RSSU5HX1BBVFRFUk4sICcnKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXVybC11dGlscy5qcy5tYXAiLCJpbXBvcnQgeyBWRVJTSU9OIH0gZnJvbSBcIi4vbGliL3V0aWxzL3ZlcnNpb24uanNcIjtcbmltcG9ydCB7IHBhcnNlR0xCU3luYyB9IGZyb20gXCIuL2xpYi9wYXJzZXJzL3BhcnNlLWdsYi5qc1wiO1xuZXhwb3J0IGNvbnN0IEdMQkxvYWRlciA9IHtcbiAgbmFtZTogJ0dMQicsXG4gIGlkOiAnZ2xiJyxcbiAgbW9kdWxlOiAnZ2x0ZicsXG4gIHZlcnNpb246IFZFUlNJT04sXG4gIGV4dGVuc2lvbnM6IFsnZ2xiJ10sXG4gIG1pbWVUeXBlczogWydtb2RlbC9nbHRmLWJpbmFyeSddLFxuICBiaW5hcnk6IHRydWUsXG4gIHBhcnNlLFxuICBwYXJzZVN5bmMsXG4gIG9wdGlvbnM6IHtcbiAgICBnbGI6IHtcbiAgICAgIHN0cmljdDogZmFsc2VcbiAgICB9XG4gIH1cbn07XG5hc3luYyBmdW5jdGlvbiBwYXJzZShhcnJheUJ1ZmZlciwgb3B0aW9ucykge1xuICByZXR1cm4gcGFyc2VTeW5jKGFycmF5QnVmZmVyLCBvcHRpb25zKTtcbn1cbmZ1bmN0aW9uIHBhcnNlU3luYyhhcnJheUJ1ZmZlciwgb3B0aW9ucykge1xuICBjb25zdCB7XG4gICAgYnl0ZU9mZnNldCA9IDBcbiAgfSA9IG9wdGlvbnMgfHwge307XG4gIGNvbnN0IGdsYiA9IHt9O1xuICBwYXJzZUdMQlN5bmMoZ2xiLCBhcnJheUJ1ZmZlciwgYnl0ZU9mZnNldCwgb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmdsYik7XG4gIHJldHVybiBnbGI7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1nbGItbG9hZGVyLmpzLm1hcCIsImltcG9ydCB7IHBhZFRvTkJ5dGVzLCBhc3NlcnQgfSBmcm9tICdAbG9hZGVycy5nbC9sb2FkZXItdXRpbHMnO1xuY29uc3QgTElUVExFX0VORElBTiA9IHRydWU7XG5jb25zdCBNQUdJQ19nbFRGID0gMHg2NzZjNTQ0NjtcbmNvbnN0IEdMQl9GSUxFX0hFQURFUl9TSVpFID0gMTI7XG5jb25zdCBHTEJfQ0hVTktfSEVBREVSX1NJWkUgPSA4O1xuY29uc3QgR0xCX0NIVU5LX1RZUEVfSlNPTiA9IDB4NGU0ZjUzNGE7XG5jb25zdCBHTEJfQ0hVTktfVFlQRV9CSU4gPSAweDAwNGU0OTQyO1xuY29uc3QgR0xCX1YxX0NPTlRFTlRfRk9STUFUX0pTT04gPSAweDA7XG5jb25zdCBHTEJfQ0hVTktfVFlQRV9KU09OX1hWSVpfREVQUkVDQVRFRCA9IDA7XG5jb25zdCBHTEJfQ0hVTktfVFlQRV9CSVhfWFZJWl9ERVBSRUNBVEVEID0gMTtcbmZ1bmN0aW9uIGdldE1hZ2ljU3RyaW5nKGRhdGFWaWV3KSB7XG4gIGxldCBieXRlT2Zmc2V0ID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiAwO1xuICByZXR1cm4gYFxcXG4ke1N0cmluZy5mcm9tQ2hhckNvZGUoZGF0YVZpZXcuZ2V0VWludDgoYnl0ZU9mZnNldCArIDApKX1cXFxuJHtTdHJpbmcuZnJvbUNoYXJDb2RlKGRhdGFWaWV3LmdldFVpbnQ4KGJ5dGVPZmZzZXQgKyAxKSl9XFxcbiR7U3RyaW5nLmZyb21DaGFyQ29kZShkYXRhVmlldy5nZXRVaW50OChieXRlT2Zmc2V0ICsgMikpfVxcXG4ke1N0cmluZy5mcm9tQ2hhckNvZGUoZGF0YVZpZXcuZ2V0VWludDgoYnl0ZU9mZnNldCArIDMpKX1gO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGlzR0xCKGFycmF5QnVmZmVyKSB7XG4gIGxldCBieXRlT2Zmc2V0ID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiAwO1xuICBsZXQgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDoge307XG4gIGNvbnN0IGRhdGFWaWV3ID0gbmV3IERhdGFWaWV3KGFycmF5QnVmZmVyKTtcbiAgY29uc3Qge1xuICAgIG1hZ2ljID0gTUFHSUNfZ2xURlxuICB9ID0gb3B0aW9ucztcbiAgY29uc3QgbWFnaWMxID0gZGF0YVZpZXcuZ2V0VWludDMyKGJ5dGVPZmZzZXQsIGZhbHNlKTtcbiAgcmV0dXJuIG1hZ2ljMSA9PT0gbWFnaWMgfHwgbWFnaWMxID09PSBNQUdJQ19nbFRGO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlR0xCU3luYyhnbGIsIGFycmF5QnVmZmVyKSB7XG4gIGxldCBieXRlT2Zmc2V0ID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiAwO1xuICBsZXQgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAzICYmIGFyZ3VtZW50c1szXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzNdIDoge307XG4gIGNvbnN0IGRhdGFWaWV3ID0gbmV3IERhdGFWaWV3KGFycmF5QnVmZmVyKTtcbiAgY29uc3QgdHlwZSA9IGdldE1hZ2ljU3RyaW5nKGRhdGFWaWV3LCBieXRlT2Zmc2V0ICsgMCk7XG4gIGNvbnN0IHZlcnNpb24gPSBkYXRhVmlldy5nZXRVaW50MzIoYnl0ZU9mZnNldCArIDQsIExJVFRMRV9FTkRJQU4pO1xuICBjb25zdCBieXRlTGVuZ3RoID0gZGF0YVZpZXcuZ2V0VWludDMyKGJ5dGVPZmZzZXQgKyA4LCBMSVRUTEVfRU5ESUFOKTtcbiAgT2JqZWN0LmFzc2lnbihnbGIsIHtcbiAgICBoZWFkZXI6IHtcbiAgICAgIGJ5dGVPZmZzZXQsXG4gICAgICBieXRlTGVuZ3RoLFxuICAgICAgaGFzQmluQ2h1bms6IGZhbHNlXG4gICAgfSxcbiAgICB0eXBlLFxuICAgIHZlcnNpb24sXG4gICAganNvbjoge30sXG4gICAgYmluQ2h1bmtzOiBbXVxuICB9KTtcbiAgYnl0ZU9mZnNldCArPSBHTEJfRklMRV9IRUFERVJfU0laRTtcbiAgc3dpdGNoIChnbGIudmVyc2lvbikge1xuICAgIGNhc2UgMTpcbiAgICAgIHJldHVybiBwYXJzZUdMQlYxKGdsYiwgZGF0YVZpZXcsIGJ5dGVPZmZzZXQpO1xuICAgIGNhc2UgMjpcbiAgICAgIHJldHVybiBwYXJzZUdMQlYyKGdsYiwgZGF0YVZpZXcsIGJ5dGVPZmZzZXQsIG9wdGlvbnMgPSB7fSk7XG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBHTEIgdmVyc2lvbiAke2dsYi52ZXJzaW9ufS4gT25seSBzdXBwb3J0cyB2ZXJzaW9uIDEgYW5kIDIuYCk7XG4gIH1cbn1cbmZ1bmN0aW9uIHBhcnNlR0xCVjEoZ2xiLCBkYXRhVmlldywgYnl0ZU9mZnNldCkge1xuICBhc3NlcnQoZ2xiLmhlYWRlci5ieXRlTGVuZ3RoID4gR0xCX0ZJTEVfSEVBREVSX1NJWkUgKyBHTEJfQ0hVTktfSEVBREVSX1NJWkUpO1xuICBjb25zdCBjb250ZW50TGVuZ3RoID0gZGF0YVZpZXcuZ2V0VWludDMyKGJ5dGVPZmZzZXQgKyAwLCBMSVRUTEVfRU5ESUFOKTtcbiAgY29uc3QgY29udGVudEZvcm1hdCA9IGRhdGFWaWV3LmdldFVpbnQzMihieXRlT2Zmc2V0ICsgNCwgTElUVExFX0VORElBTik7XG4gIGJ5dGVPZmZzZXQgKz0gR0xCX0NIVU5LX0hFQURFUl9TSVpFO1xuICBhc3NlcnQoY29udGVudEZvcm1hdCA9PT0gR0xCX1YxX0NPTlRFTlRfRk9STUFUX0pTT04pO1xuICBwYXJzZUpTT05DaHVuayhnbGIsIGRhdGFWaWV3LCBieXRlT2Zmc2V0LCBjb250ZW50TGVuZ3RoKTtcbiAgYnl0ZU9mZnNldCArPSBjb250ZW50TGVuZ3RoO1xuICBieXRlT2Zmc2V0ICs9IHBhcnNlQklOQ2h1bmsoZ2xiLCBkYXRhVmlldywgYnl0ZU9mZnNldCwgZ2xiLmhlYWRlci5ieXRlTGVuZ3RoKTtcbiAgcmV0dXJuIGJ5dGVPZmZzZXQ7XG59XG5mdW5jdGlvbiBwYXJzZUdMQlYyKGdsYiwgZGF0YVZpZXcsIGJ5dGVPZmZzZXQsIG9wdGlvbnMpIHtcbiAgYXNzZXJ0KGdsYi5oZWFkZXIuYnl0ZUxlbmd0aCA+IEdMQl9GSUxFX0hFQURFUl9TSVpFICsgR0xCX0NIVU5LX0hFQURFUl9TSVpFKTtcbiAgcGFyc2VHTEJDaHVua3NTeW5jKGdsYiwgZGF0YVZpZXcsIGJ5dGVPZmZzZXQsIG9wdGlvbnMpO1xuICByZXR1cm4gYnl0ZU9mZnNldCArIGdsYi5oZWFkZXIuYnl0ZUxlbmd0aDtcbn1cbmZ1bmN0aW9uIHBhcnNlR0xCQ2h1bmtzU3luYyhnbGIsIGRhdGFWaWV3LCBieXRlT2Zmc2V0LCBvcHRpb25zKSB7XG4gIHdoaWxlIChieXRlT2Zmc2V0ICsgOCA8PSBnbGIuaGVhZGVyLmJ5dGVMZW5ndGgpIHtcbiAgICBjb25zdCBjaHVua0xlbmd0aCA9IGRhdGFWaWV3LmdldFVpbnQzMihieXRlT2Zmc2V0ICsgMCwgTElUVExFX0VORElBTik7XG4gICAgY29uc3QgY2h1bmtGb3JtYXQgPSBkYXRhVmlldy5nZXRVaW50MzIoYnl0ZU9mZnNldCArIDQsIExJVFRMRV9FTkRJQU4pO1xuICAgIGJ5dGVPZmZzZXQgKz0gR0xCX0NIVU5LX0hFQURFUl9TSVpFO1xuICAgIHN3aXRjaCAoY2h1bmtGb3JtYXQpIHtcbiAgICAgIGNhc2UgR0xCX0NIVU5LX1RZUEVfSlNPTjpcbiAgICAgICAgcGFyc2VKU09OQ2h1bmsoZ2xiLCBkYXRhVmlldywgYnl0ZU9mZnNldCwgY2h1bmtMZW5ndGgpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgR0xCX0NIVU5LX1RZUEVfQklOOlxuICAgICAgICBwYXJzZUJJTkNodW5rKGdsYiwgZGF0YVZpZXcsIGJ5dGVPZmZzZXQsIGNodW5rTGVuZ3RoKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIEdMQl9DSFVOS19UWVBFX0pTT05fWFZJWl9ERVBSRUNBVEVEOlxuICAgICAgICBpZiAoIW9wdGlvbnMuc3RyaWN0KSB7XG4gICAgICAgICAgcGFyc2VKU09OQ2h1bmsoZ2xiLCBkYXRhVmlldywgYnl0ZU9mZnNldCwgY2h1bmtMZW5ndGgpO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBHTEJfQ0hVTktfVFlQRV9CSVhfWFZJWl9ERVBSRUNBVEVEOlxuICAgICAgICBpZiAoIW9wdGlvbnMuc3RyaWN0KSB7XG4gICAgICAgICAgcGFyc2VCSU5DaHVuayhnbGIsIGRhdGFWaWV3LCBieXRlT2Zmc2V0LCBjaHVua0xlbmd0aCk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICBicmVhaztcbiAgICB9XG4gICAgYnl0ZU9mZnNldCArPSBwYWRUb05CeXRlcyhjaHVua0xlbmd0aCwgNCk7XG4gIH1cbiAgcmV0dXJuIGJ5dGVPZmZzZXQ7XG59XG5mdW5jdGlvbiBwYXJzZUpTT05DaHVuayhnbGIsIGRhdGFWaWV3LCBieXRlT2Zmc2V0LCBjaHVua0xlbmd0aCkge1xuICBjb25zdCBqc29uQ2h1bmsgPSBuZXcgVWludDhBcnJheShkYXRhVmlldy5idWZmZXIsIGJ5dGVPZmZzZXQsIGNodW5rTGVuZ3RoKTtcbiAgY29uc3QgdGV4dERlY29kZXIgPSBuZXcgVGV4dERlY29kZXIoJ3V0ZjgnKTtcbiAgY29uc3QganNvblRleHQgPSB0ZXh0RGVjb2Rlci5kZWNvZGUoanNvbkNodW5rKTtcbiAgZ2xiLmpzb24gPSBKU09OLnBhcnNlKGpzb25UZXh0KTtcbiAgcmV0dXJuIHBhZFRvTkJ5dGVzKGNodW5rTGVuZ3RoLCA0KTtcbn1cbmZ1bmN0aW9uIHBhcnNlQklOQ2h1bmsoZ2xiLCBkYXRhVmlldywgYnl0ZU9mZnNldCwgY2h1bmtMZW5ndGgpIHtcbiAgZ2xiLmhlYWRlci5oYXNCaW5DaHVuayA9IHRydWU7XG4gIGdsYi5iaW5DaHVua3MucHVzaCh7XG4gICAgYnl0ZU9mZnNldCxcbiAgICBieXRlTGVuZ3RoOiBjaHVua0xlbmd0aCxcbiAgICBhcnJheUJ1ZmZlcjogZGF0YVZpZXcuYnVmZmVyXG4gIH0pO1xuICByZXR1cm4gcGFkVG9OQnl0ZXMoY2h1bmtMZW5ndGgsIDQpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cGFyc2UtZ2xiLmpzLm1hcCIsImV4cG9ydCBjb25zdCBWRVJTSU9OID0gdHlwZW9mIFwiNC4xLjNcIiAhPT0gJ3VuZGVmaW5lZCcgPyBcIjQuMS4zXCIgOiAnbGF0ZXN0Jztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXZlcnNpb24uanMubWFwIiwiZXhwb3J0IGZ1bmN0aW9uIGNvbXBhcmVBcnJheUJ1ZmZlcnMoYXJyYXlCdWZmZXIxLCBhcnJheUJ1ZmZlcjIsIGJ5dGVMZW5ndGgpIHtcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggfHwgYXJyYXlCdWZmZXIxLmJ5dGVMZW5ndGg7XG4gIGlmIChhcnJheUJ1ZmZlcjEuYnl0ZUxlbmd0aCA8IGJ5dGVMZW5ndGggfHwgYXJyYXlCdWZmZXIyLmJ5dGVMZW5ndGggPCBieXRlTGVuZ3RoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGNvbnN0IGFycmF5MSA9IG5ldyBVaW50OEFycmF5KGFycmF5QnVmZmVyMSk7XG4gIGNvbnN0IGFycmF5MiA9IG5ldyBVaW50OEFycmF5KGFycmF5QnVmZmVyMik7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgYXJyYXkxLmxlbmd0aDsgKytpKSB7XG4gICAgaWYgKGFycmF5MVtpXSAhPT0gYXJyYXkyW2ldKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIHJldHVybiB0cnVlO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGNvbmNhdGVuYXRlQXJyYXlCdWZmZXJzKCkge1xuICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgc291cmNlcyA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICBzb3VyY2VzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICB9XG4gIHJldHVybiBjb25jYXRlbmF0ZUFycmF5QnVmZmVyc0Zyb21BcnJheShzb3VyY2VzKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBjb25jYXRlbmF0ZUFycmF5QnVmZmVyc0Zyb21BcnJheShzb3VyY2VzKSB7XG4gIGNvbnN0IHNvdXJjZUFycmF5cyA9IHNvdXJjZXMubWFwKHNvdXJjZTIgPT4gc291cmNlMiBpbnN0YW5jZW9mIEFycmF5QnVmZmVyID8gbmV3IFVpbnQ4QXJyYXkoc291cmNlMikgOiBzb3VyY2UyKTtcbiAgY29uc3QgYnl0ZUxlbmd0aCA9IHNvdXJjZUFycmF5cy5yZWR1Y2UoKGxlbmd0aCwgdHlwZWRBcnJheSkgPT4gbGVuZ3RoICsgdHlwZWRBcnJheS5ieXRlTGVuZ3RoLCAwKTtcbiAgY29uc3QgcmVzdWx0ID0gbmV3IFVpbnQ4QXJyYXkoYnl0ZUxlbmd0aCk7XG4gIGxldCBvZmZzZXQgPSAwO1xuICBmb3IgKGNvbnN0IHNvdXJjZUFycmF5IG9mIHNvdXJjZUFycmF5cykge1xuICAgIHJlc3VsdC5zZXQoc291cmNlQXJyYXksIG9mZnNldCk7XG4gICAgb2Zmc2V0ICs9IHNvdXJjZUFycmF5LmJ5dGVMZW5ndGg7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdC5idWZmZXI7XG59XG5leHBvcnQgZnVuY3Rpb24gY29uY2F0ZW5hdGVUeXBlZEFycmF5cygpIHtcbiAgZm9yICh2YXIgX2xlbjIgPSBhcmd1bWVudHMubGVuZ3RoLCB0eXBlZEFycmF5cyA9IG5ldyBBcnJheShfbGVuMiksIF9rZXkyID0gMDsgX2tleTIgPCBfbGVuMjsgX2tleTIrKykge1xuICAgIHR5cGVkQXJyYXlzW19rZXkyXSA9IGFyZ3VtZW50c1tfa2V5Ml07XG4gIH1cbiAgY29uc3QgYXJyYXlzID0gdHlwZWRBcnJheXM7XG4gIGNvbnN0IFR5cGVkQXJyYXlDb25zdHJ1Y3RvciA9IGFycmF5cyAmJiBhcnJheXMubGVuZ3RoID4gMSAmJiBhcnJheXNbMF0uY29uc3RydWN0b3IgfHwgbnVsbDtcbiAgaWYgKCFUeXBlZEFycmF5Q29uc3RydWN0b3IpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1wiY29uY2F0ZW5hdGVUeXBlZEFycmF5c1wiIC0gaW5jb3JyZWN0IHF1YW50aXR5IG9mIGFyZ3VtZW50cyBvciBhcmd1bWVudHMgaGF2ZSBpbmNvbXBhdGlibGUgZGF0YSB0eXBlcycpO1xuICB9XG4gIGNvbnN0IHN1bUxlbmd0aCA9IGFycmF5cy5yZWR1Y2UoKGFjYywgdmFsdWUpID0+IGFjYyArIHZhbHVlLmxlbmd0aCwgMCk7XG4gIGNvbnN0IHJlc3VsdCA9IG5ldyBUeXBlZEFycmF5Q29uc3RydWN0b3Ioc3VtTGVuZ3RoKTtcbiAgbGV0IG9mZnNldCA9IDA7XG4gIGZvciAoY29uc3QgYXJyYXkgb2YgYXJyYXlzKSB7XG4gICAgcmVzdWx0LnNldChhcnJheSwgb2Zmc2V0KTtcbiAgICBvZmZzZXQgKz0gYXJyYXkubGVuZ3RoO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5leHBvcnQgZnVuY3Rpb24gc2xpY2VBcnJheUJ1ZmZlcihhcnJheUJ1ZmZlciwgYnl0ZU9mZnNldCwgYnl0ZUxlbmd0aCkge1xuICBjb25zdCBzdWJBcnJheSA9IGJ5dGVMZW5ndGggIT09IHVuZGVmaW5lZCA/IG5ldyBVaW50OEFycmF5KGFycmF5QnVmZmVyKS5zdWJhcnJheShieXRlT2Zmc2V0LCBieXRlT2Zmc2V0ICsgYnl0ZUxlbmd0aCkgOiBuZXcgVWludDhBcnJheShhcnJheUJ1ZmZlcikuc3ViYXJyYXkoYnl0ZU9mZnNldCk7XG4gIGNvbnN0IGFycmF5Q29weSA9IG5ldyBVaW50OEFycmF5KHN1YkFycmF5KTtcbiAgcmV0dXJuIGFycmF5Q29weS5idWZmZXI7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hcnJheS1idWZmZXItdXRpbHMuanMubWFwIiwiaW1wb3J0ICogYXMgbm9kZSBmcm9tIFwiLi4vbm9kZS9idWZmZXIuanNcIjtcbmV4cG9ydCBmdW5jdGlvbiBpc0J1ZmZlcih2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgJiYgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiB2YWx1ZS5pc0J1ZmZlcjtcbn1cbmV4cG9ydCBmdW5jdGlvbiB0b0J1ZmZlcihkYXRhKSB7XG4gIHJldHVybiBub2RlLnRvQnVmZmVyID8gbm9kZS50b0J1ZmZlcihkYXRhKSA6IGRhdGE7XG59XG5leHBvcnQgZnVuY3Rpb24gdG9BcnJheUJ1ZmZlcihkYXRhKSB7XG4gIGlmIChpc0J1ZmZlcihkYXRhKSkge1xuICAgIHJldHVybiBub2RlLnRvQXJyYXlCdWZmZXIoZGF0YSk7XG4gIH1cbiAgaWYgKGRhdGEgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikge1xuICAgIHJldHVybiBkYXRhO1xuICB9XG4gIGlmIChBcnJheUJ1ZmZlci5pc1ZpZXcoZGF0YSkpIHtcbiAgICBpZiAoZGF0YS5ieXRlT2Zmc2V0ID09PSAwICYmIGRhdGEuYnl0ZUxlbmd0aCA9PT0gZGF0YS5idWZmZXIuYnl0ZUxlbmd0aCkge1xuICAgICAgcmV0dXJuIGRhdGEuYnVmZmVyO1xuICAgIH1cbiAgICByZXR1cm4gZGF0YS5idWZmZXIuc2xpY2UoZGF0YS5ieXRlT2Zmc2V0LCBkYXRhLmJ5dGVPZmZzZXQgKyBkYXRhLmJ5dGVMZW5ndGgpO1xuICB9XG4gIGlmICh0eXBlb2YgZGF0YSA9PT0gJ3N0cmluZycpIHtcbiAgICBjb25zdCB0ZXh0ID0gZGF0YTtcbiAgICBjb25zdCB1aW50OEFycmF5ID0gbmV3IFRleHRFbmNvZGVyKCkuZW5jb2RlKHRleHQpO1xuICAgIHJldHVybiB1aW50OEFycmF5LmJ1ZmZlcjtcbiAgfVxuICBpZiAoZGF0YSAmJiB0eXBlb2YgZGF0YSA9PT0gJ29iamVjdCcgJiYgZGF0YS5fdG9BcnJheUJ1ZmZlcikge1xuICAgIHJldHVybiBkYXRhLl90b0FycmF5QnVmZmVyKCk7XG4gIH1cbiAgdGhyb3cgbmV3IEVycm9yKCd0b0FycmF5QnVmZmVyJyk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tZW1vcnktY29udmVyc2lvbi11dGlscy5qcy5tYXAiLCJpbXBvcnQgeyBhc3NlcnQgfSBmcm9tIFwiLi4vZW52LXV0aWxzL2Fzc2VydC5qc1wiO1xuZXhwb3J0IGZ1bmN0aW9uIHBhZFRvTkJ5dGVzKGJ5dGVMZW5ndGgsIHBhZGRpbmcpIHtcbiAgYXNzZXJ0KGJ5dGVMZW5ndGggPj0gMCk7XG4gIGFzc2VydChwYWRkaW5nID4gMCk7XG4gIHJldHVybiBieXRlTGVuZ3RoICsgKHBhZGRpbmcgLSAxKSAmIH4ocGFkZGluZyAtIDEpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGNvcHlBcnJheUJ1ZmZlcih0YXJnZXRCdWZmZXIsIHNvdXJjZUJ1ZmZlciwgYnl0ZU9mZnNldCkge1xuICBsZXQgYnl0ZUxlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGggPiAzICYmIGFyZ3VtZW50c1szXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzNdIDogc291cmNlQnVmZmVyLmJ5dGVMZW5ndGg7XG4gIGNvbnN0IHRhcmdldEFycmF5ID0gbmV3IFVpbnQ4QXJyYXkodGFyZ2V0QnVmZmVyLCBieXRlT2Zmc2V0LCBieXRlTGVuZ3RoKTtcbiAgY29uc3Qgc291cmNlQXJyYXkgPSBuZXcgVWludDhBcnJheShzb3VyY2VCdWZmZXIpO1xuICB0YXJnZXRBcnJheS5zZXQoc291cmNlQXJyYXkpO1xuICByZXR1cm4gdGFyZ2V0QnVmZmVyO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGNvcHlUb0FycmF5KHNvdXJjZSwgdGFyZ2V0LCB0YXJnZXRPZmZzZXQpIHtcbiAgbGV0IHNvdXJjZUFycmF5O1xuICBpZiAoc291cmNlIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHtcbiAgICBzb3VyY2VBcnJheSA9IG5ldyBVaW50OEFycmF5KHNvdXJjZSk7XG4gIH0gZWxzZSB7XG4gICAgY29uc3Qgc3JjQnl0ZU9mZnNldCA9IHNvdXJjZS5ieXRlT2Zmc2V0O1xuICAgIGNvbnN0IHNyY0J5dGVMZW5ndGggPSBzb3VyY2UuYnl0ZUxlbmd0aDtcbiAgICBzb3VyY2VBcnJheSA9IG5ldyBVaW50OEFycmF5KHNvdXJjZS5idWZmZXIgfHwgc291cmNlLmFycmF5QnVmZmVyLCBzcmNCeXRlT2Zmc2V0LCBzcmNCeXRlTGVuZ3RoKTtcbiAgfVxuICB0YXJnZXQuc2V0KHNvdXJjZUFycmF5LCB0YXJnZXRPZmZzZXQpO1xuICByZXR1cm4gdGFyZ2V0T2Zmc2V0ICsgcGFkVG9OQnl0ZXMoc291cmNlQXJyYXkuYnl0ZUxlbmd0aCwgNCk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tZW1vcnktY29weS11dGlscy5qcy5tYXAiLCJleHBvcnQgZnVuY3Rpb24gYXNzZXJ0KGNvbmRpdGlvbiwgbWVzc2FnZSkge1xuICBpZiAoIWNvbmRpdGlvbikge1xuICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlIHx8ICdsb2FkZXIgYXNzZXJ0aW9uIGZhaWxlZC4nKTtcbiAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YXNzZXJ0LmpzLm1hcCIsImNvbnN0IGdsb2JhbHMgPSB7XG4gIHNlbGY6IHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJyAmJiBzZWxmLFxuICB3aW5kb3c6IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdyxcbiAgZ2xvYmFsOiB0eXBlb2YgZ2xvYmFsICE9PSAndW5kZWZpbmVkJyAmJiBnbG9iYWwsXG4gIGRvY3VtZW50OiB0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnICYmIGRvY3VtZW50XG59O1xuY29uc3Qgc2VsZl8gPSBnbG9iYWxzLnNlbGYgfHwgZ2xvYmFscy53aW5kb3cgfHwgZ2xvYmFscy5nbG9iYWwgfHwge307XG5jb25zdCB3aW5kb3dfID0gZ2xvYmFscy53aW5kb3cgfHwgZ2xvYmFscy5zZWxmIHx8IGdsb2JhbHMuZ2xvYmFsIHx8IHt9O1xuY29uc3QgZ2xvYmFsXyA9IGdsb2JhbHMuZ2xvYmFsIHx8IGdsb2JhbHMuc2VsZiB8fCBnbG9iYWxzLndpbmRvdyB8fCB7fTtcbmNvbnN0IGRvY3VtZW50XyA9IGdsb2JhbHMuZG9jdW1lbnQgfHwge307XG5leHBvcnQgeyBzZWxmXyBhcyBzZWxmLCB3aW5kb3dfIGFzIHdpbmRvdywgZ2xvYmFsXyBhcyBnbG9iYWwsIGRvY3VtZW50XyBhcyBkb2N1bWVudCB9O1xuZXhwb3J0IGNvbnN0IGlzQnJvd3NlciA9IEJvb2xlYW4odHlwZW9mIHByb2Nlc3MgIT09ICdvYmplY3QnIHx8IFN0cmluZyhwcm9jZXNzKSAhPT0gJ1tvYmplY3QgcHJvY2Vzc10nIHx8IHByb2Nlc3MuYnJvd3Nlcik7XG5leHBvcnQgY29uc3QgaXNXb3JrZXIgPSB0eXBlb2YgaW1wb3J0U2NyaXB0cyA9PT0gJ2Z1bmN0aW9uJztcbmNvbnN0IG1hdGNoZXMgPSB0eXBlb2YgcHJvY2VzcyAhPT0gJ3VuZGVmaW5lZCcgJiYgcHJvY2Vzcy52ZXJzaW9uICYmIC92KFswLTldKikvLmV4ZWMocHJvY2Vzcy52ZXJzaW9uKTtcbmV4cG9ydCBjb25zdCBub2RlVmVyc2lvbiA9IG1hdGNoZXMgJiYgcGFyc2VGbG9hdChtYXRjaGVzWzFdKSB8fCAwO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Z2xvYmFscy5qcy5tYXAiLCJpbXBvcnQgeyBjb25jYXRlbmF0ZUFycmF5QnVmZmVycyB9IGZyb20gXCIuLi9iaW5hcnktdXRpbHMvYXJyYXktYnVmZmVyLXV0aWxzLmpzXCI7XG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZm9yRWFjaChpdGVyYXRvciwgdmlzaXRvcikge1xuICB3aGlsZSAodHJ1ZSkge1xuICAgIGNvbnN0IHtcbiAgICAgIGRvbmUsXG4gICAgICB2YWx1ZVxuICAgIH0gPSBhd2FpdCBpdGVyYXRvci5uZXh0KCk7XG4gICAgaWYgKGRvbmUpIHtcbiAgICAgIGl0ZXJhdG9yLnJldHVybigpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBjYW5jZWwgPSB2aXNpdG9yKHZhbHVlKTtcbiAgICBpZiAoY2FuY2VsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICB9XG59XG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gY29uY2F0ZW5hdGVBcnJheUJ1ZmZlcnNBc3luYyhhc3luY0l0ZXJhdG9yKSB7XG4gIGNvbnN0IGFycmF5QnVmZmVycyA9IFtdO1xuICBmb3IgYXdhaXQgKGNvbnN0IGNodW5rIG9mIGFzeW5jSXRlcmF0b3IpIHtcbiAgICBhcnJheUJ1ZmZlcnMucHVzaChjaHVuayk7XG4gIH1cbiAgcmV0dXJuIGNvbmNhdGVuYXRlQXJyYXlCdWZmZXJzKC4uLmFycmF5QnVmZmVycyk7XG59XG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gY29uY2F0ZW5hdGVTdHJpbmdzQXN5bmMoYXN5bmNJdGVyYXRvcikge1xuICBjb25zdCBzdHJpbmdzID0gW107XG4gIGZvciBhd2FpdCAoY29uc3QgY2h1bmsgb2YgYXN5bmNJdGVyYXRvcikge1xuICAgIHN0cmluZ3MucHVzaChjaHVuayk7XG4gIH1cbiAgcmV0dXJuIHN0cmluZ3Muam9pbignJyk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hc3luYy1pdGVyYXRpb24uanMubWFwIiwiZXhwb3J0IGZ1bmN0aW9uIHRvQXJyYXlCdWZmZXIoYnVmZmVyKSB7XG4gIHJldHVybiBidWZmZXI7XG59XG5leHBvcnQgZnVuY3Rpb24gdG9CdWZmZXIoYmluYXJ5RGF0YSkge1xuICB0aHJvdyBuZXcgRXJyb3IoJ0J1ZmZlciBub3Qgc3VwcG9ydGVkIGluIGJyb3dzZXInKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJ1ZmZlci5icm93c2VyLmpzLm1hcCIsImV4cG9ydCBmdW5jdGlvbiBtZXJnZUxvYWRlck9wdGlvbnMoYmFzZU9wdGlvbnMsIG5ld09wdGlvbnMpIHtcbiAgcmV0dXJuIG1lcmdlT3B0aW9uc1JlY3Vyc2l2ZWx5KGJhc2VPcHRpb25zIHx8IHt9LCBuZXdPcHRpb25zKTtcbn1cbmZ1bmN0aW9uIG1lcmdlT3B0aW9uc1JlY3Vyc2l2ZWx5KGJhc2VPcHRpb25zLCBuZXdPcHRpb25zKSB7XG4gIGxldCBsZXZlbCA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogMDtcbiAgaWYgKGxldmVsID4gMykge1xuICAgIHJldHVybiBuZXdPcHRpb25zO1xuICB9XG4gIGNvbnN0IG9wdGlvbnMgPSB7XG4gICAgLi4uYmFzZU9wdGlvbnNcbiAgfTtcbiAgZm9yIChjb25zdCBba2V5LCBuZXdWYWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMobmV3T3B0aW9ucykpIHtcbiAgICBpZiAobmV3VmFsdWUgJiYgdHlwZW9mIG5ld1ZhbHVlID09PSAnb2JqZWN0JyAmJiAhQXJyYXkuaXNBcnJheShuZXdWYWx1ZSkpIHtcbiAgICAgIG9wdGlvbnNba2V5XSA9IG1lcmdlT3B0aW9uc1JlY3Vyc2l2ZWx5KG9wdGlvbnNba2V5XSB8fCB7fSwgbmV3T3B0aW9uc1trZXldLCBsZXZlbCArIDEpO1xuICAgIH0gZWxzZSB7XG4gICAgICBvcHRpb25zW2tleV0gPSBuZXdPcHRpb25zW2tleV07XG4gICAgfVxuICB9XG4gIHJldHVybiBvcHRpb25zO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bWVyZ2UtbG9hZGVyLW9wdGlvbnMuanMubWFwIiwibGV0IHBhdGhQcmVmaXggPSAnJztcbmNvbnN0IGZpbGVBbGlhc2VzID0ge307XG5leHBvcnQgZnVuY3Rpb24gc2V0UGF0aFByZWZpeChwcmVmaXgpIHtcbiAgcGF0aFByZWZpeCA9IHByZWZpeDtcbn1cbmV4cG9ydCBmdW5jdGlvbiBnZXRQYXRoUHJlZml4KCkge1xuICByZXR1cm4gcGF0aFByZWZpeDtcbn1cbmV4cG9ydCBmdW5jdGlvbiBhZGRBbGlhc2VzKGFsaWFzZXMpIHtcbiAgT2JqZWN0LmFzc2lnbihmaWxlQWxpYXNlcywgYWxpYXNlcyk7XG59XG5leHBvcnQgZnVuY3Rpb24gcmVzb2x2ZVBhdGgoZmlsZW5hbWUpIHtcbiAgZm9yIChjb25zdCBhbGlhcyBpbiBmaWxlQWxpYXNlcykge1xuICAgIGlmIChmaWxlbmFtZS5zdGFydHNXaXRoKGFsaWFzKSkge1xuICAgICAgY29uc3QgcmVwbGFjZW1lbnQgPSBmaWxlQWxpYXNlc1thbGlhc107XG4gICAgICBmaWxlbmFtZSA9IGZpbGVuYW1lLnJlcGxhY2UoYWxpYXMsIHJlcGxhY2VtZW50KTtcbiAgICB9XG4gIH1cbiAgaWYgKCFmaWxlbmFtZS5zdGFydHNXaXRoKCdodHRwOi8vJykgJiYgIWZpbGVuYW1lLnN0YXJ0c1dpdGgoJ2h0dHBzOi8vJykpIHtcbiAgICBmaWxlbmFtZSA9IGAke3BhdGhQcmVmaXh9JHtmaWxlbmFtZX1gO1xuICB9XG4gIHJldHVybiBmaWxlbmFtZTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWZpbGUtYWxpYXNlcy5qcy5tYXAiLCJleHBvcnQgZnVuY3Rpb24gZ2V0Q1dEKCkge1xuICB2YXIgX3dpbmRvdyRsb2NhdGlvbjtcbiAgaWYgKHR5cGVvZiBwcm9jZXNzICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgcHJvY2Vzcy5jd2QgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuIHByb2Nlc3MuY3dkKCk7XG4gIH1cbiAgY29uc3QgcGF0aG5hbWUgPSAoX3dpbmRvdyRsb2NhdGlvbiA9IHdpbmRvdy5sb2NhdGlvbikgPT09IG51bGwgfHwgX3dpbmRvdyRsb2NhdGlvbiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3dpbmRvdyRsb2NhdGlvbi5wYXRobmFtZTtcbiAgcmV0dXJuIChwYXRobmFtZSA9PT0gbnVsbCB8fCBwYXRobmFtZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogcGF0aG5hbWUuc2xpY2UoMCwgcGF0aG5hbWUubGFzdEluZGV4T2YoJy8nKSArIDEpKSB8fCAnJztcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWdldC1jd2QuanMubWFwIiwiaW1wb3J0IHsgZ2V0Q1dEIH0gZnJvbSBcIi4vZ2V0LWN3ZC5qc1wiO1xuZXhwb3J0IGZ1bmN0aW9uIGZpbGVuYW1lKHVybCkge1xuICBjb25zdCBzbGFzaEluZGV4ID0gdXJsID8gdXJsLmxhc3RJbmRleE9mKCcvJykgOiAtMTtcbiAgcmV0dXJuIHNsYXNoSW5kZXggPj0gMCA/IHVybC5zdWJzdHIoc2xhc2hJbmRleCArIDEpIDogJyc7XG59XG5leHBvcnQgZnVuY3Rpb24gZGlybmFtZSh1cmwpIHtcbiAgY29uc3Qgc2xhc2hJbmRleCA9IHVybCA/IHVybC5sYXN0SW5kZXhPZignLycpIDogLTE7XG4gIHJldHVybiBzbGFzaEluZGV4ID49IDAgPyB1cmwuc3Vic3RyKDAsIHNsYXNoSW5kZXgpIDogJyc7XG59XG5leHBvcnQgZnVuY3Rpb24gam9pbigpIHtcbiAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIHBhcnRzID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgIHBhcnRzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICB9XG4gIGNvbnN0IHNlcGFyYXRvciA9ICcvJztcbiAgcGFydHMgPSBwYXJ0cy5tYXAoKHBhcnQsIGluZGV4KSA9PiB7XG4gICAgaWYgKGluZGV4KSB7XG4gICAgICBwYXJ0ID0gcGFydC5yZXBsYWNlKG5ldyBSZWdFeHAoYF4ke3NlcGFyYXRvcn1gKSwgJycpO1xuICAgIH1cbiAgICBpZiAoaW5kZXggIT09IHBhcnRzLmxlbmd0aCAtIDEpIHtcbiAgICAgIHBhcnQgPSBwYXJ0LnJlcGxhY2UobmV3IFJlZ0V4cChgJHtzZXBhcmF0b3J9JGApLCAnJyk7XG4gICAgfVxuICAgIHJldHVybiBwYXJ0O1xuICB9KTtcbiAgcmV0dXJuIHBhcnRzLmpvaW4oc2VwYXJhdG9yKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiByZXNvbHZlKCkge1xuICBjb25zdCBwYXRocyA9IFtdO1xuICBmb3IgKGxldCBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgIHBhdGhzW19pXSA9IF9pIDwgMCB8fCBhcmd1bWVudHMubGVuZ3RoIDw9IF9pID8gdW5kZWZpbmVkIDogYXJndW1lbnRzW19pXTtcbiAgfVxuICBsZXQgcmVzb2x2ZWRQYXRoID0gJyc7XG4gIGxldCByZXNvbHZlZEFic29sdXRlID0gZmFsc2U7XG4gIGxldCBjd2Q7XG4gIGZvciAobGV0IGkgPSBwYXRocy5sZW5ndGggLSAxOyBpID49IC0xICYmICFyZXNvbHZlZEFic29sdXRlOyBpLS0pIHtcbiAgICBsZXQgcGF0aDtcbiAgICBpZiAoaSA+PSAwKSB7XG4gICAgICBwYXRoID0gcGF0aHNbaV07XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChjd2QgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBjd2QgPSBnZXRDV0QoKTtcbiAgICAgIH1cbiAgICAgIHBhdGggPSBjd2Q7XG4gICAgfVxuICAgIGlmIChwYXRoLmxlbmd0aCA9PT0gMCkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIHJlc29sdmVkUGF0aCA9IGAke3BhdGh9LyR7cmVzb2x2ZWRQYXRofWA7XG4gICAgcmVzb2x2ZWRBYnNvbHV0ZSA9IHBhdGguY2hhckNvZGVBdCgwKSA9PT0gU0xBU0g7XG4gIH1cbiAgcmVzb2x2ZWRQYXRoID0gbm9ybWFsaXplU3RyaW5nUG9zaXgocmVzb2x2ZWRQYXRoLCAhcmVzb2x2ZWRBYnNvbHV0ZSk7XG4gIGlmIChyZXNvbHZlZEFic29sdXRlKSB7XG4gICAgcmV0dXJuIGAvJHtyZXNvbHZlZFBhdGh9YDtcbiAgfSBlbHNlIGlmIChyZXNvbHZlZFBhdGgubGVuZ3RoID4gMCkge1xuICAgIHJldHVybiByZXNvbHZlZFBhdGg7XG4gIH1cbiAgcmV0dXJuICcuJztcbn1cbmNvbnN0IFNMQVNIID0gNDc7XG5jb25zdCBET1QgPSA0NjtcbmZ1bmN0aW9uIG5vcm1hbGl6ZVN0cmluZ1Bvc2l4KHBhdGgsIGFsbG93QWJvdmVSb290KSB7XG4gIGxldCByZXMgPSAnJztcbiAgbGV0IGxhc3RTbGFzaCA9IC0xO1xuICBsZXQgZG90cyA9IDA7XG4gIGxldCBjb2RlO1xuICBsZXQgaXNBYm92ZVJvb3QgPSBmYWxzZTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPD0gcGF0aC5sZW5ndGg7ICsraSkge1xuICAgIGlmIChpIDwgcGF0aC5sZW5ndGgpIHtcbiAgICAgIGNvZGUgPSBwYXRoLmNoYXJDb2RlQXQoaSk7XG4gICAgfSBlbHNlIGlmIChjb2RlID09PSBTTEFTSCkge1xuICAgICAgYnJlYWs7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvZGUgPSBTTEFTSDtcbiAgICB9XG4gICAgaWYgKGNvZGUgPT09IFNMQVNIKSB7XG4gICAgICBpZiAobGFzdFNsYXNoID09PSBpIC0gMSB8fCBkb3RzID09PSAxKSB7fSBlbHNlIGlmIChsYXN0U2xhc2ggIT09IGkgLSAxICYmIGRvdHMgPT09IDIpIHtcbiAgICAgICAgaWYgKHJlcy5sZW5ndGggPCAyIHx8ICFpc0Fib3ZlUm9vdCB8fCByZXMuY2hhckNvZGVBdChyZXMubGVuZ3RoIC0gMSkgIT09IERPVCB8fCByZXMuY2hhckNvZGVBdChyZXMubGVuZ3RoIC0gMikgIT09IERPVCkge1xuICAgICAgICAgIGlmIChyZXMubGVuZ3RoID4gMikge1xuICAgICAgICAgICAgY29uc3Qgc3RhcnQgPSByZXMubGVuZ3RoIC0gMTtcbiAgICAgICAgICAgIGxldCBqID0gc3RhcnQ7XG4gICAgICAgICAgICBmb3IgKDsgaiA+PSAwOyAtLWopIHtcbiAgICAgICAgICAgICAgaWYgKHJlcy5jaGFyQ29kZUF0KGopID09PSBTTEFTSCkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaiAhPT0gc3RhcnQpIHtcbiAgICAgICAgICAgICAgcmVzID0gaiA9PT0gLTEgPyAnJyA6IHJlcy5zbGljZSgwLCBqKTtcbiAgICAgICAgICAgICAgbGFzdFNsYXNoID0gaTtcbiAgICAgICAgICAgICAgZG90cyA9IDA7XG4gICAgICAgICAgICAgIGlzQWJvdmVSb290ID0gZmFsc2U7XG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSBpZiAocmVzLmxlbmd0aCA9PT0gMiB8fCByZXMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICByZXMgPSAnJztcbiAgICAgICAgICAgIGxhc3RTbGFzaCA9IGk7XG4gICAgICAgICAgICBkb3RzID0gMDtcbiAgICAgICAgICAgIGlzQWJvdmVSb290ID0gZmFsc2U7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFsbG93QWJvdmVSb290KSB7XG4gICAgICAgICAgaWYgKHJlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICByZXMgKz0gJy8uLic7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlcyA9ICcuLic7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlzQWJvdmVSb290ID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3Qgc2xpY2UgPSBwYXRoLnNsaWNlKGxhc3RTbGFzaCArIDEsIGkpO1xuICAgICAgICBpZiAocmVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICByZXMgKz0gYC8ke3NsaWNlfWA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVzID0gc2xpY2U7XG4gICAgICAgIH1cbiAgICAgICAgaXNBYm92ZVJvb3QgPSBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGxhc3RTbGFzaCA9IGk7XG4gICAgICBkb3RzID0gMDtcbiAgICB9IGVsc2UgaWYgKGNvZGUgPT09IERPVCAmJiBkb3RzICE9PSAtMSkge1xuICAgICAgKytkb3RzO1xuICAgIH0gZWxzZSB7XG4gICAgICBkb3RzID0gLTE7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXM7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wYXRoLmpzLm1hcCIsImltcG9ydCB7IGlzQnJvd3NlciB9IGZyb20gJ0Bsb2FkZXJzLmdsL3dvcmtlci11dGlscyc7XG5pbXBvcnQgeyBXb3JrZXJGYXJtLCBnZXRXb3JrZXJVUkwgfSBmcm9tICdAbG9hZGVycy5nbC93b3JrZXItdXRpbHMnO1xuZXhwb3J0IGZ1bmN0aW9uIGNhblBhcnNlV2l0aFdvcmtlcihsb2FkZXIsIG9wdGlvbnMpIHtcbiAgaWYgKCFXb3JrZXJGYXJtLmlzU3VwcG9ydGVkKCkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKCFpc0Jyb3dzZXIgJiYgIShvcHRpb25zICE9PSBudWxsICYmIG9wdGlvbnMgIT09IHZvaWQgMCAmJiBvcHRpb25zLl9ub2RlV29ya2VycykpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIGxvYWRlci53b3JrZXIgJiYgKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy53b3JrZXIpO1xufVxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHBhcnNlV2l0aFdvcmtlcihsb2FkZXIsIGRhdGEsIG9wdGlvbnMsIGNvbnRleHQsIHBhcnNlT25NYWluVGhyZWFkKSB7XG4gIGNvbnN0IG5hbWUgPSBsb2FkZXIuaWQ7XG4gIGNvbnN0IHVybCA9IGdldFdvcmtlclVSTChsb2FkZXIsIG9wdGlvbnMpO1xuICBjb25zdCB3b3JrZXJGYXJtID0gV29ya2VyRmFybS5nZXRXb3JrZXJGYXJtKG9wdGlvbnMpO1xuICBjb25zdCB3b3JrZXJQb29sID0gd29ya2VyRmFybS5nZXRXb3JrZXJQb29sKHtcbiAgICBuYW1lLFxuICAgIHVybFxuICB9KTtcbiAgb3B0aW9ucyA9IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkob3B0aW9ucykpO1xuICBjb250ZXh0ID0gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShjb250ZXh0IHx8IHt9KSk7XG4gIGNvbnN0IGpvYiA9IGF3YWl0IHdvcmtlclBvb2wuc3RhcnRKb2IoJ3Byb2Nlc3Mtb24td29ya2VyJywgb25NZXNzYWdlLmJpbmQobnVsbCwgcGFyc2VPbk1haW5UaHJlYWQpKTtcbiAgam9iLnBvc3RNZXNzYWdlKCdwcm9jZXNzJywge1xuICAgIGlucHV0OiBkYXRhLFxuICAgIG9wdGlvbnMsXG4gICAgY29udGV4dFxuICB9KTtcbiAgY29uc3QgcmVzdWx0ID0gYXdhaXQgam9iLnJlc3VsdDtcbiAgcmV0dXJuIGF3YWl0IHJlc3VsdC5yZXN1bHQ7XG59XG5hc3luYyBmdW5jdGlvbiBvbk1lc3NhZ2UocGFyc2VPbk1haW5UaHJlYWQsIGpvYiwgdHlwZSwgcGF5bG9hZCkge1xuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlICdkb25lJzpcbiAgICAgIGpvYi5kb25lKHBheWxvYWQpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnZXJyb3InOlxuICAgICAgam9iLmVycm9yKG5ldyBFcnJvcihwYXlsb2FkLmVycm9yKSk7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdwcm9jZXNzJzpcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgaWQsXG4gICAgICAgIGlucHV0LFxuICAgICAgICBvcHRpb25zXG4gICAgICB9ID0gcGF5bG9hZDtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHBhcnNlT25NYWluVGhyZWFkKGlucHV0LCBvcHRpb25zKTtcbiAgICAgICAgam9iLnBvc3RNZXNzYWdlKCdkb25lJywge1xuICAgICAgICAgIGlkLFxuICAgICAgICAgIHJlc3VsdFxuICAgICAgICB9KTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IubWVzc2FnZSA6ICd1bmtub3duIGVycm9yJztcbiAgICAgICAgam9iLnBvc3RNZXNzYWdlKCdlcnJvcicsIHtcbiAgICAgICAgICBpZCxcbiAgICAgICAgICBlcnJvcjogbWVzc2FnZVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICBjb25zb2xlLndhcm4oYHBhcnNlLXdpdGgtd29ya2VyIHVua25vd24gbWVzc2FnZSAke3R5cGV9YCk7XG4gIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXBhcnNlLXdpdGgtd29ya2VyLmpzLm1hcCIsImV4cG9ydCBmdW5jdGlvbiBhc3NlcnQoY29uZGl0aW9uLCBtZXNzYWdlKSB7XG4gIGlmICghY29uZGl0aW9uKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UgfHwgJ2xvYWRlcnMuZ2wgYXNzZXJ0aW9uIGZhaWxlZC4nKTtcbiAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YXNzZXJ0LmpzLm1hcCIsImNvbnN0IGdsb2JhbHMgPSB7XG4gIHNlbGY6IHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJyAmJiBzZWxmLFxuICB3aW5kb3c6IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdyxcbiAgZ2xvYmFsOiB0eXBlb2YgZ2xvYmFsICE9PSAndW5kZWZpbmVkJyAmJiBnbG9iYWwsXG4gIGRvY3VtZW50OiB0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnICYmIGRvY3VtZW50XG59O1xuY29uc3Qgc2VsZl8gPSBnbG9iYWxzLnNlbGYgfHwgZ2xvYmFscy53aW5kb3cgfHwgZ2xvYmFscy5nbG9iYWwgfHwge307XG5jb25zdCB3aW5kb3dfID0gZ2xvYmFscy53aW5kb3cgfHwgZ2xvYmFscy5zZWxmIHx8IGdsb2JhbHMuZ2xvYmFsIHx8IHt9O1xuY29uc3QgZ2xvYmFsXyA9IGdsb2JhbHMuZ2xvYmFsIHx8IGdsb2JhbHMuc2VsZiB8fCBnbG9iYWxzLndpbmRvdyB8fCB7fTtcbmNvbnN0IGRvY3VtZW50XyA9IGdsb2JhbHMuZG9jdW1lbnQgfHwge307XG5leHBvcnQgeyBzZWxmXyBhcyBzZWxmLCB3aW5kb3dfIGFzIHdpbmRvdywgZ2xvYmFsXyBhcyBnbG9iYWwsIGRvY3VtZW50XyBhcyBkb2N1bWVudCB9O1xuZXhwb3J0IGNvbnN0IGlzQnJvd3NlciA9IHR5cGVvZiBwcm9jZXNzICE9PSAnb2JqZWN0JyB8fCBTdHJpbmcocHJvY2VzcykgIT09ICdbb2JqZWN0IHByb2Nlc3NdJyB8fCBwcm9jZXNzLmJyb3dzZXI7XG5leHBvcnQgY29uc3QgaXNXb3JrZXIgPSB0eXBlb2YgaW1wb3J0U2NyaXB0cyA9PT0gJ2Z1bmN0aW9uJztcbmV4cG9ydCBjb25zdCBpc01vYmlsZSA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiB3aW5kb3cub3JpZW50YXRpb24gIT09ICd1bmRlZmluZWQnO1xuY29uc3QgbWF0Y2hlcyA9IHR5cGVvZiBwcm9jZXNzICE9PSAndW5kZWZpbmVkJyAmJiBwcm9jZXNzLnZlcnNpb24gJiYgL3YoWzAtOV0qKS8uZXhlYyhwcm9jZXNzLnZlcnNpb24pO1xuZXhwb3J0IGNvbnN0IG5vZGVWZXJzaW9uID0gbWF0Y2hlcyAmJiBwYXJzZUZsb2F0KG1hdGNoZXNbMV0pIHx8IDA7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1nbG9iYWxzLmpzLm1hcCIsImV4cG9ydCBjb25zdCBOUE1fVEFHID0gJ2xhdGVzdCc7XG5mdW5jdGlvbiBnZXRWZXJzaW9uKCkge1xuICB2YXIgX2dsb2JhbFRoaXMkX2xvYWRlcnNnO1xuICBpZiAoISgoX2dsb2JhbFRoaXMkX2xvYWRlcnNnID0gZ2xvYmFsVGhpcy5fbG9hZGVyc2dsXykgIT09IG51bGwgJiYgX2dsb2JhbFRoaXMkX2xvYWRlcnNnICE9PSB2b2lkIDAgJiYgX2dsb2JhbFRoaXMkX2xvYWRlcnNnLnZlcnNpb24pKSB7XG4gICAgZ2xvYmFsVGhpcy5fbG9hZGVyc2dsXyA9IGdsb2JhbFRoaXMuX2xvYWRlcnNnbF8gfHwge307XG4gICAgaWYgKHR5cGVvZiBcIjQuMS4zXCIgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBjb25zb2xlLndhcm4oJ2xvYWRlcnMuZ2w6IFRoZSBfX1ZFUlNJT05fXyB2YXJpYWJsZSBpcyBub3QgaW5qZWN0ZWQgdXNpbmcgYmFiZWwgcGx1Z2luLiBMYXRlc3QgdW5zdGFibGUgd29ya2VycyB3b3VsZCBiZSBmZXRjaGVkIGZyb20gdGhlIENETi4nKTtcbiAgICAgIGdsb2JhbFRoaXMuX2xvYWRlcnNnbF8udmVyc2lvbiA9IE5QTV9UQUc7XG4gICAgfSBlbHNlIHtcbiAgICAgIGdsb2JhbFRoaXMuX2xvYWRlcnNnbF8udmVyc2lvbiA9IFwiNC4xLjNcIjtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGdsb2JhbFRoaXMuX2xvYWRlcnNnbF8udmVyc2lvbjtcbn1cbmV4cG9ydCBjb25zdCBWRVJTSU9OID0gZ2V0VmVyc2lvbigpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dmVyc2lvbi5qcy5tYXAiLCJleHBvcnQgY2xhc3MgTm9kZVdvcmtlciB7XG4gIHRlcm1pbmF0ZSgpIHt9XG59XG5leHBvcnQgY29uc3QgcGFyZW50UG9ydCA9IG51bGw7XG4vLyMgc291cmNlTWFwcGluZ1VSTD13b3JrZXJfdGhyZWFkcy1icm93c2VyLmpzLm1hcCIsImltcG9ydCB7IGFzc2VydCB9IGZyb20gXCIuLi9lbnYtdXRpbHMvYXNzZXJ0LmpzXCI7XG5pbXBvcnQgeyBpc0Jyb3dzZXIgfSBmcm9tIFwiLi4vZW52LXV0aWxzL2dsb2JhbHMuanNcIjtcbmltcG9ydCB7IFZFUlNJT04sIE5QTV9UQUcgfSBmcm9tIFwiLi4vZW52LXV0aWxzL3ZlcnNpb24uanNcIjtcbmV4cG9ydCBmdW5jdGlvbiBnZXRXb3JrZXJOYW1lKHdvcmtlcikge1xuICBjb25zdCB3YXJuaW5nID0gd29ya2VyLnZlcnNpb24gIT09IFZFUlNJT04gPyBgICh3b3JrZXItdXRpbHNAJHtWRVJTSU9OfSlgIDogJyc7XG4gIHJldHVybiBgJHt3b3JrZXIubmFtZX1AJHt3b3JrZXIudmVyc2lvbn0ke3dhcm5pbmd9YDtcbn1cbmV4cG9ydCBmdW5jdGlvbiBnZXRXb3JrZXJVUkwod29ya2VyKSB7XG4gIGxldCBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgY29uc3Qgd29ya2VyT3B0aW9ucyA9IG9wdGlvbnNbd29ya2VyLmlkXSB8fCB7fTtcbiAgY29uc3Qgd29ya2VyRmlsZSA9IGlzQnJvd3NlciA/IGAke3dvcmtlci5pZH0td29ya2VyLmpzYCA6IGAke3dvcmtlci5pZH0td29ya2VyLW5vZGUuanNgO1xuICBsZXQgdXJsID0gd29ya2VyT3B0aW9ucy53b3JrZXJVcmw7XG4gIGlmICghdXJsICYmIHdvcmtlci5pZCA9PT0gJ2NvbXByZXNzaW9uJykge1xuICAgIHVybCA9IG9wdGlvbnMud29ya2VyVXJsO1xuICB9XG4gIGlmIChvcHRpb25zLl93b3JrZXJUeXBlID09PSAndGVzdCcpIHtcbiAgICBpZiAoaXNCcm93c2VyKSB7XG4gICAgICB1cmwgPSBgbW9kdWxlcy8ke3dvcmtlci5tb2R1bGV9L2Rpc3QvJHt3b3JrZXJGaWxlfWA7XG4gICAgfSBlbHNlIHtcbiAgICAgIHVybCA9IGBtb2R1bGVzLyR7d29ya2VyLm1vZHVsZX0vc3JjL3dvcmtlcnMvJHt3b3JrZXIuaWR9LXdvcmtlci1ub2RlLnRzYDtcbiAgICB9XG4gIH1cbiAgaWYgKCF1cmwpIHtcbiAgICBsZXQgdmVyc2lvbiA9IHdvcmtlci52ZXJzaW9uO1xuICAgIGlmICh2ZXJzaW9uID09PSAnbGF0ZXN0Jykge1xuICAgICAgdmVyc2lvbiA9IE5QTV9UQUc7XG4gICAgfVxuICAgIGNvbnN0IHZlcnNpb25UYWcgPSB2ZXJzaW9uID8gYEAke3ZlcnNpb259YCA6ICcnO1xuICAgIHVybCA9IGBodHRwczovL3VucGtnLmNvbS9AbG9hZGVycy5nbC8ke3dvcmtlci5tb2R1bGV9JHt2ZXJzaW9uVGFnfS9kaXN0LyR7d29ya2VyRmlsZX1gO1xuICB9XG4gIGFzc2VydCh1cmwpO1xuICByZXR1cm4gdXJsO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Z2V0LXdvcmtlci11cmwuanMubWFwIiwiaW1wb3J0IHsgYXNzZXJ0IH0gZnJvbSBcIi4uL2Vudi11dGlscy9hc3NlcnQuanNcIjtcbmltcG9ydCB7IFZFUlNJT04gfSBmcm9tIFwiLi4vZW52LXV0aWxzL3ZlcnNpb24uanNcIjtcbmV4cG9ydCBmdW5jdGlvbiB2YWxpZGF0ZVdvcmtlclZlcnNpb24od29ya2VyKSB7XG4gIGxldCBjb3JlVmVyc2lvbiA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogVkVSU0lPTjtcbiAgYXNzZXJ0KHdvcmtlciwgJ25vIHdvcmtlciBwcm92aWRlZCcpO1xuICBjb25zdCB3b3JrZXJWZXJzaW9uID0gd29ya2VyLnZlcnNpb247XG4gIGlmICghY29yZVZlcnNpb24gfHwgIXdvcmtlclZlcnNpb24pIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5mdW5jdGlvbiBwYXJzZVZlcnNpb24odmVyc2lvbikge1xuICBjb25zdCBwYXJ0cyA9IHZlcnNpb24uc3BsaXQoJy4nKS5tYXAoTnVtYmVyKTtcbiAgcmV0dXJuIHtcbiAgICBtYWpvcjogcGFydHNbMF0sXG4gICAgbWlub3I6IHBhcnRzWzFdXG4gIH07XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD12YWxpZGF0ZS13b3JrZXItdmVyc2lvbi5qcy5tYXAiLCJpbXBvcnQgV29ya2VyUG9vbCBmcm9tIFwiLi93b3JrZXItcG9vbC5qc1wiO1xuaW1wb3J0IFdvcmtlclRocmVhZCBmcm9tIFwiLi93b3JrZXItdGhyZWFkLmpzXCI7XG5jb25zdCBERUZBVUxUX1BST1BTID0ge1xuICBtYXhDb25jdXJyZW5jeTogMyxcbiAgbWF4TW9iaWxlQ29uY3VycmVuY3k6IDEsXG4gIHJldXNlV29ya2VyczogdHJ1ZSxcbiAgb25EZWJ1ZzogKCkgPT4ge31cbn07XG5leHBvcnQgZGVmYXVsdCBjbGFzcyBXb3JrZXJGYXJtIHtcbiAgc3RhdGljIGlzU3VwcG9ydGVkKCkge1xuICAgIHJldHVybiBXb3JrZXJUaHJlYWQuaXNTdXBwb3J0ZWQoKTtcbiAgfVxuICBzdGF0aWMgZ2V0V29ya2VyRmFybSgpIHtcbiAgICBsZXQgcHJvcHMgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuICAgIFdvcmtlckZhcm0uX3dvcmtlckZhcm0gPSBXb3JrZXJGYXJtLl93b3JrZXJGYXJtIHx8IG5ldyBXb3JrZXJGYXJtKHt9KTtcbiAgICBXb3JrZXJGYXJtLl93b3JrZXJGYXJtLnNldFByb3BzKHByb3BzKTtcbiAgICByZXR1cm4gV29ya2VyRmFybS5fd29ya2VyRmFybTtcbiAgfVxuICBjb25zdHJ1Y3Rvcihwcm9wcykge1xuICAgIHRoaXMucHJvcHMgPSB2b2lkIDA7XG4gICAgdGhpcy53b3JrZXJQb29scyA9IG5ldyBNYXAoKTtcbiAgICB0aGlzLnByb3BzID0ge1xuICAgICAgLi4uREVGQVVMVF9QUk9QU1xuICAgIH07XG4gICAgdGhpcy5zZXRQcm9wcyhwcm9wcyk7XG4gICAgdGhpcy53b3JrZXJQb29scyA9IG5ldyBNYXAoKTtcbiAgfVxuICBkZXN0cm95KCkge1xuICAgIGZvciAoY29uc3Qgd29ya2VyUG9vbCBvZiB0aGlzLndvcmtlclBvb2xzLnZhbHVlcygpKSB7XG4gICAgICB3b3JrZXJQb29sLmRlc3Ryb3koKTtcbiAgICB9XG4gICAgdGhpcy53b3JrZXJQb29scyA9IG5ldyBNYXAoKTtcbiAgfVxuICBzZXRQcm9wcyhwcm9wcykge1xuICAgIHRoaXMucHJvcHMgPSB7XG4gICAgICAuLi50aGlzLnByb3BzLFxuICAgICAgLi4ucHJvcHNcbiAgICB9O1xuICAgIGZvciAoY29uc3Qgd29ya2VyUG9vbCBvZiB0aGlzLndvcmtlclBvb2xzLnZhbHVlcygpKSB7XG4gICAgICB3b3JrZXJQb29sLnNldFByb3BzKHRoaXMuX2dldFdvcmtlclBvb2xQcm9wcygpKTtcbiAgICB9XG4gIH1cbiAgZ2V0V29ya2VyUG9vbChvcHRpb25zKSB7XG4gICAgY29uc3Qge1xuICAgICAgbmFtZSxcbiAgICAgIHNvdXJjZSxcbiAgICAgIHVybFxuICAgIH0gPSBvcHRpb25zO1xuICAgIGxldCB3b3JrZXJQb29sID0gdGhpcy53b3JrZXJQb29scy5nZXQobmFtZSk7XG4gICAgaWYgKCF3b3JrZXJQb29sKSB7XG4gICAgICB3b3JrZXJQb29sID0gbmV3IFdvcmtlclBvb2woe1xuICAgICAgICBuYW1lLFxuICAgICAgICBzb3VyY2UsXG4gICAgICAgIHVybFxuICAgICAgfSk7XG4gICAgICB3b3JrZXJQb29sLnNldFByb3BzKHRoaXMuX2dldFdvcmtlclBvb2xQcm9wcygpKTtcbiAgICAgIHRoaXMud29ya2VyUG9vbHMuc2V0KG5hbWUsIHdvcmtlclBvb2wpO1xuICAgIH1cbiAgICByZXR1cm4gd29ya2VyUG9vbDtcbiAgfVxuICBfZ2V0V29ya2VyUG9vbFByb3BzKCkge1xuICAgIHJldHVybiB7XG4gICAgICBtYXhDb25jdXJyZW5jeTogdGhpcy5wcm9wcy5tYXhDb25jdXJyZW5jeSxcbiAgICAgIG1heE1vYmlsZUNvbmN1cnJlbmN5OiB0aGlzLnByb3BzLm1heE1vYmlsZUNvbmN1cnJlbmN5LFxuICAgICAgcmV1c2VXb3JrZXJzOiB0aGlzLnByb3BzLnJldXNlV29ya2VycyxcbiAgICAgIG9uRGVidWc6IHRoaXMucHJvcHMub25EZWJ1Z1xuICAgIH07XG4gIH1cbn1cbldvcmtlckZhcm0uX3dvcmtlckZhcm0gPSB2b2lkIDA7XG4vLyMgc291cmNlTWFwcGluZ1VSTD13b3JrZXItZmFybS5qcy5tYXAiLCJpbXBvcnQgeyBhc3NlcnQgfSBmcm9tIFwiLi4vZW52LXV0aWxzL2Fzc2VydC5qc1wiO1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgV29ya2VySm9iIHtcbiAgY29uc3RydWN0b3Ioam9iTmFtZSwgd29ya2VyVGhyZWFkKSB7XG4gICAgdGhpcy5uYW1lID0gdm9pZCAwO1xuICAgIHRoaXMud29ya2VyVGhyZWFkID0gdm9pZCAwO1xuICAgIHRoaXMuaXNSdW5uaW5nID0gdHJ1ZTtcbiAgICB0aGlzLnJlc3VsdCA9IHZvaWQgMDtcbiAgICB0aGlzLl9yZXNvbHZlID0gKCkgPT4ge307XG4gICAgdGhpcy5fcmVqZWN0ID0gKCkgPT4ge307XG4gICAgdGhpcy5uYW1lID0gam9iTmFtZTtcbiAgICB0aGlzLndvcmtlclRocmVhZCA9IHdvcmtlclRocmVhZDtcbiAgICB0aGlzLnJlc3VsdCA9IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIHRoaXMuX3Jlc29sdmUgPSByZXNvbHZlO1xuICAgICAgdGhpcy5fcmVqZWN0ID0gcmVqZWN0O1xuICAgIH0pO1xuICB9XG4gIHBvc3RNZXNzYWdlKHR5cGUsIHBheWxvYWQpIHtcbiAgICB0aGlzLndvcmtlclRocmVhZC5wb3N0TWVzc2FnZSh7XG4gICAgICBzb3VyY2U6ICdsb2FkZXJzLmdsJyxcbiAgICAgIHR5cGUsXG4gICAgICBwYXlsb2FkXG4gICAgfSk7XG4gIH1cbiAgZG9uZSh2YWx1ZSkge1xuICAgIGFzc2VydCh0aGlzLmlzUnVubmluZyk7XG4gICAgdGhpcy5pc1J1bm5pbmcgPSBmYWxzZTtcbiAgICB0aGlzLl9yZXNvbHZlKHZhbHVlKTtcbiAgfVxuICBlcnJvcihlcnJvcikge1xuICAgIGFzc2VydCh0aGlzLmlzUnVubmluZyk7XG4gICAgdGhpcy5pc1J1bm5pbmcgPSBmYWxzZTtcbiAgICB0aGlzLl9yZWplY3QoZXJyb3IpO1xuICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD13b3JrZXItam9iLmpzLm1hcCIsImltcG9ydCB7IGlzTW9iaWxlLCBpc0Jyb3dzZXIgfSBmcm9tIFwiLi4vZW52LXV0aWxzL2dsb2JhbHMuanNcIjtcbmltcG9ydCBXb3JrZXJUaHJlYWQgZnJvbSBcIi4vd29ya2VyLXRocmVhZC5qc1wiO1xuaW1wb3J0IFdvcmtlckpvYiBmcm9tIFwiLi93b3JrZXItam9iLmpzXCI7XG5leHBvcnQgZGVmYXVsdCBjbGFzcyBXb3JrZXJQb29sIHtcbiAgc3RhdGljIGlzU3VwcG9ydGVkKCkge1xuICAgIHJldHVybiBXb3JrZXJUaHJlYWQuaXNTdXBwb3J0ZWQoKTtcbiAgfVxuICBjb25zdHJ1Y3Rvcihwcm9wcykge1xuICAgIHRoaXMubmFtZSA9ICd1bm5hbWVkJztcbiAgICB0aGlzLnNvdXJjZSA9IHZvaWQgMDtcbiAgICB0aGlzLnVybCA9IHZvaWQgMDtcbiAgICB0aGlzLm1heENvbmN1cnJlbmN5ID0gMTtcbiAgICB0aGlzLm1heE1vYmlsZUNvbmN1cnJlbmN5ID0gMTtcbiAgICB0aGlzLm9uRGVidWcgPSAoKSA9PiB7fTtcbiAgICB0aGlzLnJldXNlV29ya2VycyA9IHRydWU7XG4gICAgdGhpcy5wcm9wcyA9IHt9O1xuICAgIHRoaXMuam9iUXVldWUgPSBbXTtcbiAgICB0aGlzLmlkbGVRdWV1ZSA9IFtdO1xuICAgIHRoaXMuY291bnQgPSAwO1xuICAgIHRoaXMuaXNEZXN0cm95ZWQgPSBmYWxzZTtcbiAgICB0aGlzLnNvdXJjZSA9IHByb3BzLnNvdXJjZTtcbiAgICB0aGlzLnVybCA9IHByb3BzLnVybDtcbiAgICB0aGlzLnNldFByb3BzKHByb3BzKTtcbiAgfVxuICBkZXN0cm95KCkge1xuICAgIHRoaXMuaWRsZVF1ZXVlLmZvckVhY2god29ya2VyID0+IHdvcmtlci5kZXN0cm95KCkpO1xuICAgIHRoaXMuaXNEZXN0cm95ZWQgPSB0cnVlO1xuICB9XG4gIHNldFByb3BzKHByb3BzKSB7XG4gICAgdGhpcy5wcm9wcyA9IHtcbiAgICAgIC4uLnRoaXMucHJvcHMsXG4gICAgICAuLi5wcm9wc1xuICAgIH07XG4gICAgaWYgKHByb3BzLm5hbWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcy5uYW1lID0gcHJvcHMubmFtZTtcbiAgICB9XG4gICAgaWYgKHByb3BzLm1heENvbmN1cnJlbmN5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHRoaXMubWF4Q29uY3VycmVuY3kgPSBwcm9wcy5tYXhDb25jdXJyZW5jeTtcbiAgICB9XG4gICAgaWYgKHByb3BzLm1heE1vYmlsZUNvbmN1cnJlbmN5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHRoaXMubWF4TW9iaWxlQ29uY3VycmVuY3kgPSBwcm9wcy5tYXhNb2JpbGVDb25jdXJyZW5jeTtcbiAgICB9XG4gICAgaWYgKHByb3BzLnJldXNlV29ya2VycyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aGlzLnJldXNlV29ya2VycyA9IHByb3BzLnJldXNlV29ya2VycztcbiAgICB9XG4gICAgaWYgKHByb3BzLm9uRGVidWcgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcy5vbkRlYnVnID0gcHJvcHMub25EZWJ1ZztcbiAgICB9XG4gIH1cbiAgYXN5bmMgc3RhcnRKb2IobmFtZSkge1xuICAgIGxldCBvbk1lc3NhZ2UgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IChqb2IsIHR5cGUsIGRhdGEpID0+IGpvYi5kb25lKGRhdGEpO1xuICAgIGxldCBvbkVycm9yID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiAoam9iLCBlcnJvcikgPT4gam9iLmVycm9yKGVycm9yKTtcbiAgICBjb25zdCBzdGFydFByb21pc2UgPSBuZXcgUHJvbWlzZShvblN0YXJ0ID0+IHtcbiAgICAgIHRoaXMuam9iUXVldWUucHVzaCh7XG4gICAgICAgIG5hbWUsXG4gICAgICAgIG9uTWVzc2FnZSxcbiAgICAgICAgb25FcnJvcixcbiAgICAgICAgb25TdGFydFxuICAgICAgfSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9KTtcbiAgICB0aGlzLl9zdGFydFF1ZXVlZEpvYigpO1xuICAgIHJldHVybiBhd2FpdCBzdGFydFByb21pc2U7XG4gIH1cbiAgYXN5bmMgX3N0YXJ0UXVldWVkSm9iKCkge1xuICAgIGlmICghdGhpcy5qb2JRdWV1ZS5sZW5ndGgpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qgd29ya2VyVGhyZWFkID0gdGhpcy5fZ2V0QXZhaWxhYmxlV29ya2VyKCk7XG4gICAgaWYgKCF3b3JrZXJUaHJlYWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgcXVldWVkSm9iID0gdGhpcy5qb2JRdWV1ZS5zaGlmdCgpO1xuICAgIGlmIChxdWV1ZWRKb2IpIHtcbiAgICAgIHRoaXMub25EZWJ1Zyh7XG4gICAgICAgIG1lc3NhZ2U6ICdTdGFydGluZyBqb2InLFxuICAgICAgICBuYW1lOiBxdWV1ZWRKb2IubmFtZSxcbiAgICAgICAgd29ya2VyVGhyZWFkLFxuICAgICAgICBiYWNrbG9nOiB0aGlzLmpvYlF1ZXVlLmxlbmd0aFxuICAgICAgfSk7XG4gICAgICBjb25zdCBqb2IgPSBuZXcgV29ya2VySm9iKHF1ZXVlZEpvYi5uYW1lLCB3b3JrZXJUaHJlYWQpO1xuICAgICAgd29ya2VyVGhyZWFkLm9uTWVzc2FnZSA9IGRhdGEgPT4gcXVldWVkSm9iLm9uTWVzc2FnZShqb2IsIGRhdGEudHlwZSwgZGF0YS5wYXlsb2FkKTtcbiAgICAgIHdvcmtlclRocmVhZC5vbkVycm9yID0gZXJyb3IgPT4gcXVldWVkSm9iLm9uRXJyb3Ioam9iLCBlcnJvcik7XG4gICAgICBxdWV1ZWRKb2Iub25TdGFydChqb2IpO1xuICAgICAgdHJ5IHtcbiAgICAgICAgYXdhaXQgam9iLnJlc3VsdDtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoYFdvcmtlciBleGNlcHRpb246ICR7ZXJyb3J9YCk7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICB0aGlzLnJldHVybldvcmtlclRvUXVldWUod29ya2VyVGhyZWFkKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuV29ya2VyVG9RdWV1ZSh3b3JrZXIpIHtcbiAgICBjb25zdCBzaG91bGREZXN0cm95V29ya2VyID0gIWlzQnJvd3NlciB8fCB0aGlzLmlzRGVzdHJveWVkIHx8ICF0aGlzLnJldXNlV29ya2VycyB8fCB0aGlzLmNvdW50ID4gdGhpcy5fZ2V0TWF4Q29uY3VycmVuY3koKTtcbiAgICBpZiAoc2hvdWxkRGVzdHJveVdvcmtlcikge1xuICAgICAgd29ya2VyLmRlc3Ryb3koKTtcbiAgICAgIHRoaXMuY291bnQtLTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5pZGxlUXVldWUucHVzaCh3b3JrZXIpO1xuICAgIH1cbiAgICBpZiAoIXRoaXMuaXNEZXN0cm95ZWQpIHtcbiAgICAgIHRoaXMuX3N0YXJ0UXVldWVkSm9iKCk7XG4gICAgfVxuICB9XG4gIF9nZXRBdmFpbGFibGVXb3JrZXIoKSB7XG4gICAgaWYgKHRoaXMuaWRsZVF1ZXVlLmxlbmd0aCA+IDApIHtcbiAgICAgIHJldHVybiB0aGlzLmlkbGVRdWV1ZS5zaGlmdCgpIHx8IG51bGw7XG4gICAgfVxuICAgIGlmICh0aGlzLmNvdW50IDwgdGhpcy5fZ2V0TWF4Q29uY3VycmVuY3koKSkge1xuICAgICAgdGhpcy5jb3VudCsrO1xuICAgICAgY29uc3QgbmFtZSA9IGAke3RoaXMubmFtZS50b0xvd2VyQ2FzZSgpfSAoIyR7dGhpcy5jb3VudH0gb2YgJHt0aGlzLm1heENvbmN1cnJlbmN5fSlgO1xuICAgICAgcmV0dXJuIG5ldyBXb3JrZXJUaHJlYWQoe1xuICAgICAgICBuYW1lLFxuICAgICAgICBzb3VyY2U6IHRoaXMuc291cmNlLFxuICAgICAgICB1cmw6IHRoaXMudXJsXG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgX2dldE1heENvbmN1cnJlbmN5KCkge1xuICAgIHJldHVybiBpc01vYmlsZSA/IHRoaXMubWF4TW9iaWxlQ29uY3VycmVuY3kgOiB0aGlzLm1heENvbmN1cnJlbmN5O1xuICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD13b3JrZXItcG9vbC5qcy5tYXAiLCJpbXBvcnQgeyBOb2RlV29ya2VyIH0gZnJvbSBcIi4uL25vZGUvd29ya2VyX3RocmVhZHMuanNcIjtcbmltcG9ydCB7IGlzQnJvd3NlciB9IGZyb20gXCIuLi9lbnYtdXRpbHMvZ2xvYmFscy5qc1wiO1xuaW1wb3J0IHsgYXNzZXJ0IH0gZnJvbSBcIi4uL2Vudi11dGlscy9hc3NlcnQuanNcIjtcbmltcG9ydCB7IGdldExvYWRhYmxlV29ya2VyVVJMIH0gZnJvbSBcIi4uL3dvcmtlci11dGlscy9nZXQtbG9hZGFibGUtd29ya2VyLXVybC5qc1wiO1xuaW1wb3J0IHsgZ2V0VHJhbnNmZXJMaXN0IH0gZnJvbSBcIi4uL3dvcmtlci11dGlscy9nZXQtdHJhbnNmZXItbGlzdC5qc1wiO1xuY29uc3QgTk9PUCA9ICgpID0+IHt9O1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgV29ya2VyVGhyZWFkIHtcbiAgc3RhdGljIGlzU3VwcG9ydGVkKCkge1xuICAgIHJldHVybiB0eXBlb2YgV29ya2VyICE9PSAndW5kZWZpbmVkJyAmJiBpc0Jyb3dzZXIgfHwgdHlwZW9mIE5vZGVXb3JrZXIgIT09ICd1bmRlZmluZWQnICYmICFpc0Jyb3dzZXI7XG4gIH1cbiAgY29uc3RydWN0b3IocHJvcHMpIHtcbiAgICB0aGlzLm5hbWUgPSB2b2lkIDA7XG4gICAgdGhpcy5zb3VyY2UgPSB2b2lkIDA7XG4gICAgdGhpcy51cmwgPSB2b2lkIDA7XG4gICAgdGhpcy50ZXJtaW5hdGVkID0gZmFsc2U7XG4gICAgdGhpcy53b3JrZXIgPSB2b2lkIDA7XG4gICAgdGhpcy5vbk1lc3NhZ2UgPSB2b2lkIDA7XG4gICAgdGhpcy5vbkVycm9yID0gdm9pZCAwO1xuICAgIHRoaXMuX2xvYWRhYmxlVVJMID0gJyc7XG4gICAgY29uc3Qge1xuICAgICAgbmFtZSxcbiAgICAgIHNvdXJjZSxcbiAgICAgIHVybFxuICAgIH0gPSBwcm9wcztcbiAgICBhc3NlcnQoc291cmNlIHx8IHVybCk7XG4gICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICB0aGlzLnNvdXJjZSA9IHNvdXJjZTtcbiAgICB0aGlzLnVybCA9IHVybDtcbiAgICB0aGlzLm9uTWVzc2FnZSA9IE5PT1A7XG4gICAgdGhpcy5vbkVycm9yID0gZXJyb3IgPT4gY29uc29sZS5sb2coZXJyb3IpO1xuICAgIHRoaXMud29ya2VyID0gaXNCcm93c2VyID8gdGhpcy5fY3JlYXRlQnJvd3NlcldvcmtlcigpIDogdGhpcy5fY3JlYXRlTm9kZVdvcmtlcigpO1xuICB9XG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy5vbk1lc3NhZ2UgPSBOT09QO1xuICAgIHRoaXMub25FcnJvciA9IE5PT1A7XG4gICAgdGhpcy53b3JrZXIudGVybWluYXRlKCk7XG4gICAgdGhpcy50ZXJtaW5hdGVkID0gdHJ1ZTtcbiAgfVxuICBnZXQgaXNSdW5uaW5nKCkge1xuICAgIHJldHVybiBCb29sZWFuKHRoaXMub25NZXNzYWdlKTtcbiAgfVxuICBwb3N0TWVzc2FnZShkYXRhLCB0cmFuc2Zlckxpc3QpIHtcbiAgICB0cmFuc2Zlckxpc3QgPSB0cmFuc2Zlckxpc3QgfHwgZ2V0VHJhbnNmZXJMaXN0KGRhdGEpO1xuICAgIHRoaXMud29ya2VyLnBvc3RNZXNzYWdlKGRhdGEsIHRyYW5zZmVyTGlzdCk7XG4gIH1cbiAgX2dldEVycm9yRnJvbUVycm9yRXZlbnQoZXZlbnQpIHtcbiAgICBsZXQgbWVzc2FnZSA9ICdGYWlsZWQgdG8gbG9hZCAnO1xuICAgIG1lc3NhZ2UgKz0gYHdvcmtlciAke3RoaXMubmFtZX0gZnJvbSAke3RoaXMudXJsfS4gYDtcbiAgICBpZiAoZXZlbnQubWVzc2FnZSkge1xuICAgICAgbWVzc2FnZSArPSBgJHtldmVudC5tZXNzYWdlfSBpbiBgO1xuICAgIH1cbiAgICBpZiAoZXZlbnQubGluZW5vKSB7XG4gICAgICBtZXNzYWdlICs9IGA6JHtldmVudC5saW5lbm99OiR7ZXZlbnQuY29sbm99YDtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgfVxuICBfY3JlYXRlQnJvd3NlcldvcmtlcigpIHtcbiAgICB0aGlzLl9sb2FkYWJsZVVSTCA9IGdldExvYWRhYmxlV29ya2VyVVJMKHtcbiAgICAgIHNvdXJjZTogdGhpcy5zb3VyY2UsXG4gICAgICB1cmw6IHRoaXMudXJsXG4gICAgfSk7XG4gICAgY29uc3Qgd29ya2VyID0gbmV3IFdvcmtlcih0aGlzLl9sb2FkYWJsZVVSTCwge1xuICAgICAgbmFtZTogdGhpcy5uYW1lXG4gICAgfSk7XG4gICAgd29ya2VyLm9ubWVzc2FnZSA9IGV2ZW50ID0+IHtcbiAgICAgIGlmICghZXZlbnQuZGF0YSkge1xuICAgICAgICB0aGlzLm9uRXJyb3IobmV3IEVycm9yKCdObyBkYXRhIHJlY2VpdmVkJykpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5vbk1lc3NhZ2UoZXZlbnQuZGF0YSk7XG4gICAgICB9XG4gICAgfTtcbiAgICB3b3JrZXIub25lcnJvciA9IGVycm9yID0+IHtcbiAgICAgIHRoaXMub25FcnJvcih0aGlzLl9nZXRFcnJvckZyb21FcnJvckV2ZW50KGVycm9yKSk7XG4gICAgICB0aGlzLnRlcm1pbmF0ZWQgPSB0cnVlO1xuICAgIH07XG4gICAgd29ya2VyLm9ubWVzc2FnZWVycm9yID0gZXZlbnQgPT4gY29uc29sZS5lcnJvcihldmVudCk7XG4gICAgcmV0dXJuIHdvcmtlcjtcbiAgfVxuICBfY3JlYXRlTm9kZVdvcmtlcigpIHtcbiAgICBsZXQgd29ya2VyO1xuICAgIGlmICh0aGlzLnVybCkge1xuICAgICAgY29uc3QgYWJzb2x1dGUgPSB0aGlzLnVybC5pbmNsdWRlcygnOi8nKSB8fCB0aGlzLnVybC5zdGFydHNXaXRoKCcvJyk7XG4gICAgICBjb25zdCB1cmwgPSBhYnNvbHV0ZSA/IHRoaXMudXJsIDogYC4vJHt0aGlzLnVybH1gO1xuICAgICAgd29ya2VyID0gbmV3IE5vZGVXb3JrZXIodXJsLCB7XG4gICAgICAgIGV2YWw6IGZhbHNlXG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuc291cmNlKSB7XG4gICAgICB3b3JrZXIgPSBuZXcgTm9kZVdvcmtlcih0aGlzLnNvdXJjZSwge1xuICAgICAgICBldmFsOiB0cnVlXG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdubyB3b3JrZXInKTtcbiAgICB9XG4gICAgd29ya2VyLm9uKCdtZXNzYWdlJywgZGF0YSA9PiB7XG4gICAgICB0aGlzLm9uTWVzc2FnZShkYXRhKTtcbiAgICB9KTtcbiAgICB3b3JrZXIub24oJ2Vycm9yJywgZXJyb3IgPT4ge1xuICAgICAgdGhpcy5vbkVycm9yKGVycm9yKTtcbiAgICB9KTtcbiAgICB3b3JrZXIub24oJ2V4aXQnLCBjb2RlID0+IHt9KTtcbiAgICByZXR1cm4gd29ya2VyO1xuICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD13b3JrZXItdGhyZWFkLmpzLm1hcCIsImltcG9ydCB7IGFzc2VydCB9IGZyb20gXCIuLi9lbnYtdXRpbHMvYXNzZXJ0LmpzXCI7XG5jb25zdCB3b3JrZXJVUkxDYWNoZSA9IG5ldyBNYXAoKTtcbmV4cG9ydCBmdW5jdGlvbiBnZXRMb2FkYWJsZVdvcmtlclVSTChwcm9wcykge1xuICBhc3NlcnQocHJvcHMuc291cmNlICYmICFwcm9wcy51cmwgfHwgIXByb3BzLnNvdXJjZSAmJiBwcm9wcy51cmwpO1xuICBsZXQgd29ya2VyVVJMID0gd29ya2VyVVJMQ2FjaGUuZ2V0KHByb3BzLnNvdXJjZSB8fCBwcm9wcy51cmwpO1xuICBpZiAoIXdvcmtlclVSTCkge1xuICAgIGlmIChwcm9wcy51cmwpIHtcbiAgICAgIHdvcmtlclVSTCA9IGdldExvYWRhYmxlV29ya2VyVVJMRnJvbVVSTChwcm9wcy51cmwpO1xuICAgICAgd29ya2VyVVJMQ2FjaGUuc2V0KHByb3BzLnVybCwgd29ya2VyVVJMKTtcbiAgICB9XG4gICAgaWYgKHByb3BzLnNvdXJjZSkge1xuICAgICAgd29ya2VyVVJMID0gZ2V0TG9hZGFibGVXb3JrZXJVUkxGcm9tU291cmNlKHByb3BzLnNvdXJjZSk7XG4gICAgICB3b3JrZXJVUkxDYWNoZS5zZXQocHJvcHMuc291cmNlLCB3b3JrZXJVUkwpO1xuICAgIH1cbiAgfVxuICBhc3NlcnQod29ya2VyVVJMKTtcbiAgcmV0dXJuIHdvcmtlclVSTDtcbn1cbmZ1bmN0aW9uIGdldExvYWRhYmxlV29ya2VyVVJMRnJvbVVSTCh1cmwpIHtcbiAgaWYgKCF1cmwuc3RhcnRzV2l0aCgnaHR0cCcpKSB7XG4gICAgcmV0dXJuIHVybDtcbiAgfVxuICBjb25zdCB3b3JrZXJTb3VyY2UgPSBidWlsZFNjcmlwdFNvdXJjZSh1cmwpO1xuICByZXR1cm4gZ2V0TG9hZGFibGVXb3JrZXJVUkxGcm9tU291cmNlKHdvcmtlclNvdXJjZSk7XG59XG5mdW5jdGlvbiBnZXRMb2FkYWJsZVdvcmtlclVSTEZyb21Tb3VyY2Uod29ya2VyU291cmNlKSB7XG4gIGNvbnN0IGJsb2IgPSBuZXcgQmxvYihbd29ya2VyU291cmNlXSwge1xuICAgIHR5cGU6ICdhcHBsaWNhdGlvbi9qYXZhc2NyaXB0J1xuICB9KTtcbiAgcmV0dXJuIFVSTC5jcmVhdGVPYmplY3RVUkwoYmxvYik7XG59XG5mdW5jdGlvbiBidWlsZFNjcmlwdFNvdXJjZSh3b3JrZXJVcmwpIHtcbiAgcmV0dXJuIGBcXFxudHJ5IHtcbiAgaW1wb3J0U2NyaXB0cygnJHt3b3JrZXJVcmx9Jyk7XG59IGNhdGNoIChlcnJvcikge1xuICBjb25zb2xlLmVycm9yKGVycm9yKTtcbiAgdGhyb3cgZXJyb3I7XG59YDtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWdldC1sb2FkYWJsZS13b3JrZXItdXJsLmpzLm1hcCIsImV4cG9ydCBmdW5jdGlvbiBnZXRUcmFuc2Zlckxpc3Qob2JqZWN0KSB7XG4gIGxldCByZWN1cnNpdmUgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHRydWU7XG4gIGxldCB0cmFuc2ZlcnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiA/IGFyZ3VtZW50c1syXSA6IHVuZGVmaW5lZDtcbiAgY29uc3QgdHJhbnNmZXJzU2V0ID0gdHJhbnNmZXJzIHx8IG5ldyBTZXQoKTtcbiAgaWYgKCFvYmplY3QpIHt9IGVsc2UgaWYgKGlzVHJhbnNmZXJhYmxlKG9iamVjdCkpIHtcbiAgICB0cmFuc2ZlcnNTZXQuYWRkKG9iamVjdCk7XG4gIH0gZWxzZSBpZiAoaXNUcmFuc2ZlcmFibGUob2JqZWN0LmJ1ZmZlcikpIHtcbiAgICB0cmFuc2ZlcnNTZXQuYWRkKG9iamVjdC5idWZmZXIpO1xuICB9IGVsc2UgaWYgKEFycmF5QnVmZmVyLmlzVmlldyhvYmplY3QpKSB7fSBlbHNlIGlmIChyZWN1cnNpdmUgJiYgdHlwZW9mIG9iamVjdCA9PT0gJ29iamVjdCcpIHtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBvYmplY3QpIHtcbiAgICAgIGdldFRyYW5zZmVyTGlzdChvYmplY3Rba2V5XSwgcmVjdXJzaXZlLCB0cmFuc2ZlcnNTZXQpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdHJhbnNmZXJzID09PSB1bmRlZmluZWQgPyBBcnJheS5mcm9tKHRyYW5zZmVyc1NldCkgOiBbXTtcbn1cbmZ1bmN0aW9uIGlzVHJhbnNmZXJhYmxlKG9iamVjdCkge1xuICBpZiAoIW9iamVjdCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAob2JqZWN0IGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBpZiAodHlwZW9mIE1lc3NhZ2VQb3J0ICE9PSAndW5kZWZpbmVkJyAmJiBvYmplY3QgaW5zdGFuY2VvZiBNZXNzYWdlUG9ydCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGlmICh0eXBlb2YgSW1hZ2VCaXRtYXAgIT09ICd1bmRlZmluZWQnICYmIG9iamVjdCBpbnN0YW5jZW9mIEltYWdlQml0bWFwKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgaWYgKHR5cGVvZiBPZmZzY3JlZW5DYW52YXMgIT09ICd1bmRlZmluZWQnICYmIG9iamVjdCBpbnN0YW5jZW9mIE9mZnNjcmVlbkNhbnZhcykge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBnZXRUcmFuc2Zlckxpc3RGb3JXcml0ZXIob2JqZWN0KSB7XG4gIGlmIChvYmplY3QgPT09IG51bGwpIHtcbiAgICByZXR1cm4ge307XG4gIH1cbiAgY29uc3QgY2xvbmUgPSBPYmplY3QuYXNzaWduKHt9LCBvYmplY3QpO1xuICBPYmplY3Qua2V5cyhjbG9uZSkuZm9yRWFjaChrZXkgPT4ge1xuICAgIGlmICh0eXBlb2Ygb2JqZWN0W2tleV0gPT09ICdvYmplY3QnICYmICFBcnJheUJ1ZmZlci5pc1ZpZXcob2JqZWN0W2tleV0pICYmICEob2JqZWN0W2tleV0gaW5zdGFuY2VvZiBBcnJheSkpIHtcbiAgICAgIGNsb25lW2tleV0gPSBnZXRUcmFuc2Zlckxpc3RGb3JXcml0ZXIob2JqZWN0W2tleV0pO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIGNsb25lW2tleV0gPT09ICdmdW5jdGlvbicgfHwgY2xvbmVba2V5XSBpbnN0YW5jZW9mIFJlZ0V4cCkge1xuICAgICAgY2xvbmVba2V5XSA9IHt9O1xuICAgIH0gZWxzZSB7XG4gICAgICBjbG9uZVtrZXldID0gb2JqZWN0W2tleV07XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIGNsb25lO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Z2V0LXRyYW5zZmVyLWxpc3QuanMubWFwIiwiLy8gRXh0cmFjdCBpbmplY3RlZCB2ZXJzaW9uIGZyb20gcGFja2FnZS5qc29uIChpbmplY3RlZCBieSBiYWJlbCBwbHVnaW4pXG4vLyBAdHMtZXhwZWN0LWVycm9yXG5leHBvcnQgY29uc3QgVkVSU0lPTiA9IHR5cGVvZiBcIjQuMC43XCIgIT09ICd1bmRlZmluZWQnID8gXCI0LjAuN1wiIDogJ3VudHJhbnNwaWxlZCBzb3VyY2UnO1xuLy8gRU5WSVJPTk1FTlRcbmV4cG9ydCB7IHNlbGYsIHdpbmRvdywgZ2xvYmFsLCBkb2N1bWVudCwgcHJvY2VzcywgY29uc29sZSB9IGZyb20gXCIuL2xpYi9nbG9iYWxzLmpzXCI7XG5leHBvcnQgeyBpc0Jyb3dzZXIgfSBmcm9tIFwiLi9saWIvaXMtYnJvd3Nlci5qc1wiO1xuZXhwb3J0IHsgZ2V0QnJvd3NlciwgaXNNb2JpbGUgfSBmcm9tIFwiLi9saWIvZ2V0LWJyb3dzZXIuanNcIjtcbmV4cG9ydCB7IGlzRWxlY3Ryb24gfSBmcm9tIFwiLi9saWIvaXMtZWxlY3Ryb24uanNcIjtcbi8vIEVOVklST05NRU5UJ1MgQVNTRVJUIElTIDUtMTVLQiwgU08gV0UgUFJPVklERSBPVVIgT1dOXG5leHBvcnQgeyBhc3NlcnQgfSBmcm9tIFwiLi91dGlscy9hc3NlcnQuanNcIjtcbi8vIFRPRE8gLSB3aXNoIHdlIGNvdWxkIGp1c3QgZXhwb3J0IGEgY29uc3RhbnRcbi8vIGV4cG9ydCBjb25zdCBpc0Jyb3dzZXIgPSBjaGVja0lmQnJvd3NlcigpO1xuIiwiLy8gQ29weXJpZ2h0IChjKSAyMDE3IFViZXIgVGVjaG5vbG9naWVzLCBJbmMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuLy8gb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuLy8gaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuLy8gdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuLy8gY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4vLyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4vLyBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4vLyBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbi8vIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuLy8gQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuLy8gTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbi8vIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cbi8vIFRIRSBTT0ZUV0FSRS5cbi8vIFRoaXMgZnVuY3Rpb24gaXMgbmVlZGVkIGluIGluaXRpYWxpemF0aW9uIHN0YWdlcyxcbi8vIG1ha2Ugc3VyZSBpdCBjYW4gYmUgaW1wb3J0ZWQgaW4gaXNvbGF0aW9uXG5pbXBvcnQgeyBpc0Jyb3dzZXIgfSBmcm9tIFwiLi9pcy1icm93c2VyLmpzXCI7XG5pbXBvcnQgeyBpc0VsZWN0cm9uIH0gZnJvbSBcIi4vaXMtZWxlY3Ryb24uanNcIjtcbmltcG9ydCB7IG5hdmlnYXRvciB9IGZyb20gXCIuL2dsb2JhbHMuanNcIjtcbmV4cG9ydCBmdW5jdGlvbiBpc01vYmlsZSgpIHtcbiAgICByZXR1cm4gdHlwZW9mIGdsb2JhbFRoaXMub3JpZW50YXRpb24gIT09ICd1bmRlZmluZWQnO1xufVxuLy8gU2ltcGxlIGJyb3dzZXIgZGV0ZWN0aW9uXG4vLyBgbW9ja1VzZXJBZ2VudGAgcGFyYW1ldGVyIGFsbG93cyB1c2VyIGFnZW50IHRvIGJlIG92ZXJyaWRkZW4gZm9yIHRlc3Rpbmdcbi8qIGVzbGludC1kaXNhYmxlIGNvbXBsZXhpdHkgKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRCcm93c2VyKG1vY2tVc2VyQWdlbnQpIHtcbiAgICBpZiAoIW1vY2tVc2VyQWdlbnQgJiYgIWlzQnJvd3NlcigpKSB7XG4gICAgICAgIHJldHVybiAnTm9kZSc7XG4gICAgfVxuICAgIGlmIChpc0VsZWN0cm9uKG1vY2tVc2VyQWdlbnQpKSB7XG4gICAgICAgIHJldHVybiAnRWxlY3Ryb24nO1xuICAgIH1cbiAgICBjb25zdCB1c2VyQWdlbnQgPSBtb2NrVXNlckFnZW50IHx8IG5hdmlnYXRvci51c2VyQWdlbnQgfHwgJyc7XG4gICAgLy8gTk9URTogT3JkZXIgb2YgdGVzdHMgbWF0dGVyLCBhcyBtYW55IGFnZW50cyBsaXN0IENocm9tZSBldGMuXG4gICAgaWYgKHVzZXJBZ2VudC5pbmRleE9mKCdFZGdlJykgPiAtMSkge1xuICAgICAgICByZXR1cm4gJ0VkZ2UnO1xuICAgIH1cbiAgICBpZiAoZ2xvYmFsVGhpcy5jaHJvbWUpIHtcbiAgICAgICAgcmV0dXJuICdDaHJvbWUnO1xuICAgIH1cbiAgICBpZiAoZ2xvYmFsVGhpcy5zYWZhcmkpIHtcbiAgICAgICAgcmV0dXJuICdTYWZhcmknO1xuICAgIH1cbiAgICBpZiAoZ2xvYmFsVGhpcy5tb3pJbm5lclNjcmVlblgpIHtcbiAgICAgICAgcmV0dXJuICdGaXJlZm94JztcbiAgICB9XG4gICAgcmV0dXJuICdVbmtub3duJztcbn1cbiIsIi8vIERvIG5vdCBuYW1lIHRoZXNlIHZhcmlhYmxlcyB0aGUgc2FtZSBhcyB0aGUgZ2xvYmFsIG9iamVjdHMgLSB3aWxsIGJyZWFrIGJ1bmRsaW5nXG5jb25zdCBnbG9iYWxfID0gZ2xvYmFsVGhpcztcbmNvbnN0IHdpbmRvd18gPSBnbG9iYWxUaGlzO1xuY29uc3QgZG9jdW1lbnRfID0gZ2xvYmFsVGhpcy5kb2N1bWVudCB8fCB7fTtcbmNvbnN0IHByb2Nlc3NfID0gZ2xvYmFsVGhpcy5wcm9jZXNzIHx8IHt9O1xuY29uc3QgY29uc29sZV8gPSBnbG9iYWxUaGlzLmNvbnNvbGU7XG5jb25zdCBuYXZpZ2F0b3JfID0gZ2xvYmFsVGhpcy5uYXZpZ2F0b3IgfHwge307XG5leHBvcnQgeyBnbG9iYWxfIGFzIGdsb2JhbCwgZ2xvYmFsXyBhcyBzZWxmLCB3aW5kb3dfIGFzIHdpbmRvdywgZG9jdW1lbnRfIGFzIGRvY3VtZW50LCBwcm9jZXNzXyBhcyBwcm9jZXNzLCBjb25zb2xlXyBhcyBjb25zb2xlLCBuYXZpZ2F0b3JfIGFzIG5hdmlnYXRvciB9O1xuIiwiLy8gVGhpcyBmdW5jdGlvbiBpcyBuZWVkZWQgaW4gaW5pdGlhbGl6YXRpb24gc3RhZ2VzLFxuLy8gbWFrZSBzdXJlIGl0IGNhbiBiZSBpbXBvcnRlZCBpbiBpc29sYXRpb25cbmltcG9ydCB7IGlzRWxlY3Ryb24gfSBmcm9tIFwiLi9pcy1lbGVjdHJvbi5qc1wiO1xuLyoqIENoZWNrIGlmIGluIGJyb3dzZXIgYnkgZHVjay10eXBpbmcgTm9kZSBjb250ZXh0ICovXG5leHBvcnQgZnVuY3Rpb24gaXNCcm93c2VyKCkge1xuICAgIGNvbnN0IGlzTm9kZSA9IFxuICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICB0eXBlb2YgcHJvY2VzcyA9PT0gJ29iamVjdCcgJiYgU3RyaW5nKHByb2Nlc3MpID09PSAnW29iamVjdCBwcm9jZXNzXScgJiYgIXByb2Nlc3M/LmJyb3dzZXI7XG4gICAgcmV0dXJuICFpc05vZGUgfHwgaXNFbGVjdHJvbigpO1xufVxuIiwiLy8gYmFzZWQgb24gaHR0cHM6Ly9naXRodWIuY29tL2NoZXRvbi9pcy1lbGVjdHJvblxuLy8gaHR0cHM6Ly9naXRodWIuY29tL2VsZWN0cm9uL2VsZWN0cm9uL2lzc3Vlcy8yMjg4XG4vKiBlc2xpbnQtZGlzYWJsZSBjb21wbGV4aXR5ICovXG5leHBvcnQgZnVuY3Rpb24gaXNFbGVjdHJvbihtb2NrVXNlckFnZW50KSB7XG4gICAgLy8gUmVuZGVyZXIgcHJvY2Vzc1xuICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LnByb2Nlc3M/LnR5cGUgPT09ICdyZW5kZXJlcicpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIC8vIE1haW4gcHJvY2Vzc1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxuICAgIGlmICh0eXBlb2YgcHJvY2VzcyAhPT0gJ3VuZGVmaW5lZCcgJiYgQm9vbGVhbihwcm9jZXNzLnZlcnNpb25zPy5bJ2VsZWN0cm9uJ10pKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICAvLyBEZXRlY3QgdGhlIHVzZXIgYWdlbnQgd2hlbiB0aGUgYG5vZGVJbnRlZ3JhdGlvbmAgb3B0aW9uIGlzIHNldCB0byB0cnVlXG4gICAgY29uc3QgcmVhbFVzZXJBZ2VudCA9IHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnICYmIG5hdmlnYXRvci51c2VyQWdlbnQ7XG4gICAgY29uc3QgdXNlckFnZW50ID0gbW9ja1VzZXJBZ2VudCB8fCByZWFsVXNlckFnZW50O1xuICAgIHJldHVybiBCb29sZWFuKHVzZXJBZ2VudCAmJiB1c2VyQWdlbnQuaW5kZXhPZignRWxlY3Ryb24nKSA+PSAwKTtcbn1cbiIsImV4cG9ydCBmdW5jdGlvbiBhc3NlcnQoY29uZGl0aW9uLCBtZXNzYWdlKSB7XG4gICAgaWYgKCFjb25kaXRpb24pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UgfHwgJ0Fzc2VydGlvbiBmYWlsZWQnKTtcbiAgICB9XG59XG4iLCIvLyBwcm9iZS5nbCwgTUlUIGxpY2Vuc2Vcbi8qIGVzbGludC1kaXNhYmxlIG5vLWNvbnNvbGUgKi9cbmltcG9ydCB7IFZFUlNJT04sIGlzQnJvd3NlciB9IGZyb20gJ0Bwcm9iZS5nbC9lbnYnO1xuaW1wb3J0IHsgTG9jYWxTdG9yYWdlIH0gZnJvbSBcIi4vdXRpbHMvbG9jYWwtc3RvcmFnZS5qc1wiO1xuaW1wb3J0IHsgZm9ybWF0VGltZSwgbGVmdFBhZCB9IGZyb20gXCIuL3V0aWxzL2Zvcm1hdHRlcnMuanNcIjtcbmltcG9ydCB7IGFkZENvbG9yIH0gZnJvbSBcIi4vdXRpbHMvY29sb3IuanNcIjtcbmltcG9ydCB7IGF1dG9iaW5kIH0gZnJvbSBcIi4vdXRpbHMvYXV0b2JpbmQuanNcIjtcbmltcG9ydCBhc3NlcnQgZnJvbSBcIi4vdXRpbHMvYXNzZXJ0LmpzXCI7XG5pbXBvcnQgeyBnZXRIaVJlc1RpbWVzdGFtcCB9IGZyb20gXCIuL3V0aWxzL2hpLXJlcy10aW1lc3RhbXAuanNcIjtcbi8vIEluc3RydW1lbnRhdGlvbiBpbiBvdGhlciBwYWNrYWdlcyBtYXkgb3ZlcnJpZGUgY29uc29sZSBtZXRob2RzLCBzbyBwcmVzZXJ2ZSB0aGVtIGhlcmVcbmNvbnN0IG9yaWdpbmFsQ29uc29sZSA9IHtcbiAgICBkZWJ1ZzogaXNCcm93c2VyKCkgPyBjb25zb2xlLmRlYnVnIHx8IGNvbnNvbGUubG9nIDogY29uc29sZS5sb2csXG4gICAgbG9nOiBjb25zb2xlLmxvZyxcbiAgICBpbmZvOiBjb25zb2xlLmluZm8sXG4gICAgd2FybjogY29uc29sZS53YXJuLFxuICAgIGVycm9yOiBjb25zb2xlLmVycm9yXG59O1xuY29uc3QgREVGQVVMVF9MT0dfQ09ORklHVVJBVElPTiA9IHtcbiAgICBlbmFibGVkOiB0cnVlLFxuICAgIGxldmVsOiAwXG59O1xuZnVuY3Rpb24gbm9vcCgpIHsgfSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1lbXB0eS1mdW5jdGlvblxuY29uc3QgY2FjaGUgPSB7fTtcbmNvbnN0IE9OQ0UgPSB7IG9uY2U6IHRydWUgfTtcbi8qKiBBIGNvbnNvbGUgd3JhcHBlciAqL1xuZXhwb3J0IGNsYXNzIExvZyB7XG4gICAgY29uc3RydWN0b3IoeyBpZCB9ID0geyBpZDogJycgfSkge1xuICAgICAgICB0aGlzLlZFUlNJT04gPSBWRVJTSU9OO1xuICAgICAgICB0aGlzLl9zdGFydFRzID0gZ2V0SGlSZXNUaW1lc3RhbXAoKTtcbiAgICAgICAgdGhpcy5fZGVsdGFUcyA9IGdldEhpUmVzVGltZXN0YW1wKCk7XG4gICAgICAgIHRoaXMudXNlckRhdGEgPSB7fTtcbiAgICAgICAgLy8gVE9ETyAtIGZpeCBzdXBwb3J0IGZyb20gdGhyb3R0bGluZyBncm91cHNcbiAgICAgICAgdGhpcy5MT0dfVEhST1RUTEVfVElNRU9VVCA9IDA7IC8vIFRpbWUgYmVmb3JlIHRocm90dGxlZCBtZXNzYWdlcyBhcmUgbG9nZ2VkIGFnYWluXG4gICAgICAgIHRoaXMuaWQgPSBpZDtcbiAgICAgICAgdGhpcy51c2VyRGF0YSA9IHt9O1xuICAgICAgICB0aGlzLl9zdG9yYWdlID0gbmV3IExvY2FsU3RvcmFnZShgX19wcm9iZS0ke3RoaXMuaWR9X19gLCBERUZBVUxUX0xPR19DT05GSUdVUkFUSU9OKTtcbiAgICAgICAgdGhpcy50aW1lU3RhbXAoYCR7dGhpcy5pZH0gc3RhcnRlZGApO1xuICAgICAgICBhdXRvYmluZCh0aGlzKTtcbiAgICAgICAgT2JqZWN0LnNlYWwodGhpcyk7XG4gICAgfVxuICAgIHNldCBsZXZlbChuZXdMZXZlbCkge1xuICAgICAgICB0aGlzLnNldExldmVsKG5ld0xldmVsKTtcbiAgICB9XG4gICAgZ2V0IGxldmVsKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRMZXZlbCgpO1xuICAgIH1cbiAgICBpc0VuYWJsZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zdG9yYWdlLmNvbmZpZy5lbmFibGVkO1xuICAgIH1cbiAgICBnZXRMZXZlbCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3N0b3JhZ2UuY29uZmlnLmxldmVsO1xuICAgIH1cbiAgICAvKiogQHJldHVybiBtaWxsaXNlY29uZHMsIHdpdGggZnJhY3Rpb25zICovXG4gICAgZ2V0VG90YWwoKSB7XG4gICAgICAgIHJldHVybiBOdW1iZXIoKGdldEhpUmVzVGltZXN0YW1wKCkgLSB0aGlzLl9zdGFydFRzKS50b1ByZWNpc2lvbigxMCkpO1xuICAgIH1cbiAgICAvKiogQHJldHVybiBtaWxsaXNlY29uZHMsIHdpdGggZnJhY3Rpb25zICovXG4gICAgZ2V0RGVsdGEoKSB7XG4gICAgICAgIHJldHVybiBOdW1iZXIoKGdldEhpUmVzVGltZXN0YW1wKCkgLSB0aGlzLl9kZWx0YVRzKS50b1ByZWNpc2lvbigxMCkpO1xuICAgIH1cbiAgICAvKiogQGRlcHJlY2F0ZWQgdXNlIGxvZ0xldmVsICovXG4gICAgc2V0IHByaW9yaXR5KG5ld1ByaW9yaXR5KSB7XG4gICAgICAgIHRoaXMubGV2ZWwgPSBuZXdQcmlvcml0eTtcbiAgICB9XG4gICAgLyoqIEBkZXByZWNhdGVkIHVzZSBsb2dMZXZlbCAqL1xuICAgIGdldCBwcmlvcml0eSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubGV2ZWw7XG4gICAgfVxuICAgIC8qKiBAZGVwcmVjYXRlZCB1c2UgbG9nTGV2ZWwgKi9cbiAgICBnZXRQcmlvcml0eSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubGV2ZWw7XG4gICAgfVxuICAgIC8vIENvbmZpZ3VyZVxuICAgIGVuYWJsZShlbmFibGVkID0gdHJ1ZSkge1xuICAgICAgICB0aGlzLl9zdG9yYWdlLnNldENvbmZpZ3VyYXRpb24oeyBlbmFibGVkIH0pO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgc2V0TGV2ZWwobGV2ZWwpIHtcbiAgICAgICAgdGhpcy5fc3RvcmFnZS5zZXRDb25maWd1cmF0aW9uKHsgbGV2ZWwgfSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKiogcmV0dXJuIHRoZSBjdXJyZW50IHN0YXR1cyBvZiB0aGUgc2V0dGluZyAqL1xuICAgIGdldChzZXR0aW5nKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zdG9yYWdlLmNvbmZpZ1tzZXR0aW5nXTtcbiAgICB9XG4gICAgLy8gdXBkYXRlIHRoZSBzdGF0dXMgb2YgdGhlIHNldHRpbmdcbiAgICBzZXQoc2V0dGluZywgdmFsdWUpIHtcbiAgICAgICAgdGhpcy5fc3RvcmFnZS5zZXRDb25maWd1cmF0aW9uKHsgW3NldHRpbmddOiB2YWx1ZSB9KTtcbiAgICB9XG4gICAgLyoqIExvZ3MgdGhlIGN1cnJlbnQgc2V0dGluZ3MgYXMgYSB0YWJsZSAqL1xuICAgIHNldHRpbmdzKCkge1xuICAgICAgICBpZiAoY29uc29sZS50YWJsZSkge1xuICAgICAgICAgICAgY29uc29sZS50YWJsZSh0aGlzLl9zdG9yYWdlLmNvbmZpZyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyh0aGlzLl9zdG9yYWdlLmNvbmZpZyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gVW5jb25kaXRpb25hbCBsb2dnaW5nXG4gICAgYXNzZXJ0KGNvbmRpdGlvbiwgbWVzc2FnZSkge1xuICAgICAgICBpZiAoIWNvbmRpdGlvbikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UgfHwgJ0Fzc2VydGlvbiBmYWlsZWQnKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB3YXJuKG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2dldExvZ0Z1bmN0aW9uKDAsIG1lc3NhZ2UsIG9yaWdpbmFsQ29uc29sZS53YXJuLCBhcmd1bWVudHMsIE9OQ0UpO1xuICAgIH1cbiAgICBlcnJvcihtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9nZXRMb2dGdW5jdGlvbigwLCBtZXNzYWdlLCBvcmlnaW5hbENvbnNvbGUuZXJyb3IsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIC8qKiBQcmludCBhIGRlcHJlY2F0aW9uIHdhcm5pbmcgKi9cbiAgICBkZXByZWNhdGVkKG9sZFVzYWdlLCBuZXdVc2FnZSkge1xuICAgICAgICByZXR1cm4gdGhpcy53YXJuKGBcXGAke29sZFVzYWdlfVxcYCBpcyBkZXByZWNhdGVkIGFuZCB3aWxsIGJlIHJlbW92ZWQgXFxcbmluIGEgbGF0ZXIgdmVyc2lvbi4gVXNlIFxcYCR7bmV3VXNhZ2V9XFxgIGluc3RlYWRgKTtcbiAgICB9XG4gICAgLyoqIFByaW50IGEgcmVtb3ZhbCB3YXJuaW5nICovXG4gICAgcmVtb3ZlZChvbGRVc2FnZSwgbmV3VXNhZ2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZXJyb3IoYFxcYCR7b2xkVXNhZ2V9XFxgIGhhcyBiZWVuIHJlbW92ZWQuIFVzZSBcXGAke25ld1VzYWdlfVxcYCBpbnN0ZWFkYCk7XG4gICAgfVxuICAgIHByb2JlKGxvZ0xldmVsLCBtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9nZXRMb2dGdW5jdGlvbihsb2dMZXZlbCwgbWVzc2FnZSwgb3JpZ2luYWxDb25zb2xlLmxvZywgYXJndW1lbnRzLCB7XG4gICAgICAgICAgICB0aW1lOiB0cnVlLFxuICAgICAgICAgICAgb25jZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgbG9nKGxvZ0xldmVsLCBtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9nZXRMb2dGdW5jdGlvbihsb2dMZXZlbCwgbWVzc2FnZSwgb3JpZ2luYWxDb25zb2xlLmRlYnVnLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBpbmZvKGxvZ0xldmVsLCBtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9nZXRMb2dGdW5jdGlvbihsb2dMZXZlbCwgbWVzc2FnZSwgY29uc29sZS5pbmZvLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBvbmNlKGxvZ0xldmVsLCBtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9nZXRMb2dGdW5jdGlvbihsb2dMZXZlbCwgbWVzc2FnZSwgb3JpZ2luYWxDb25zb2xlLmRlYnVnIHx8IG9yaWdpbmFsQ29uc29sZS5pbmZvLCBhcmd1bWVudHMsIE9OQ0UpO1xuICAgIH1cbiAgICAvKiogTG9ncyBhbiBvYmplY3QgYXMgYSB0YWJsZSAqL1xuICAgIHRhYmxlKGxvZ0xldmVsLCB0YWJsZSwgY29sdW1ucykge1xuICAgICAgICBpZiAodGFibGUpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9nZXRMb2dGdW5jdGlvbihsb2dMZXZlbCwgdGFibGUsIGNvbnNvbGUudGFibGUgfHwgbm9vcCwgKGNvbHVtbnMgJiYgW2NvbHVtbnNdKSwge1xuICAgICAgICAgICAgICAgIHRhZzogZ2V0VGFibGVIZWFkZXIodGFibGUpXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbm9vcDtcbiAgICB9XG4gICAgdGltZShsb2dMZXZlbCwgbWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZ2V0TG9nRnVuY3Rpb24obG9nTGV2ZWwsIG1lc3NhZ2UsIGNvbnNvbGUudGltZSA/IGNvbnNvbGUudGltZSA6IGNvbnNvbGUuaW5mbyk7XG4gICAgfVxuICAgIHRpbWVFbmQobG9nTGV2ZWwsIG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2dldExvZ0Z1bmN0aW9uKGxvZ0xldmVsLCBtZXNzYWdlLCBjb25zb2xlLnRpbWVFbmQgPyBjb25zb2xlLnRpbWVFbmQgOiBjb25zb2xlLmluZm8pO1xuICAgIH1cbiAgICB0aW1lU3RhbXAobG9nTGV2ZWwsIG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2dldExvZ0Z1bmN0aW9uKGxvZ0xldmVsLCBtZXNzYWdlLCBjb25zb2xlLnRpbWVTdGFtcCB8fCBub29wKTtcbiAgICB9XG4gICAgZ3JvdXAobG9nTGV2ZWwsIG1lc3NhZ2UsIG9wdHMgPSB7IGNvbGxhcHNlZDogZmFsc2UgfSkge1xuICAgICAgICBjb25zdCBvcHRpb25zID0gbm9ybWFsaXplQXJndW1lbnRzKHsgbG9nTGV2ZWwsIG1lc3NhZ2UsIG9wdHMgfSk7XG4gICAgICAgIGNvbnN0IHsgY29sbGFwc2VkIH0gPSBvcHRzO1xuICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgIG9wdGlvbnMubWV0aG9kID0gKGNvbGxhcHNlZCA/IGNvbnNvbGUuZ3JvdXBDb2xsYXBzZWQgOiBjb25zb2xlLmdyb3VwKSB8fCBjb25zb2xlLmluZm87XG4gICAgICAgIHJldHVybiB0aGlzLl9nZXRMb2dGdW5jdGlvbihvcHRpb25zKTtcbiAgICB9XG4gICAgZ3JvdXBDb2xsYXBzZWQobG9nTGV2ZWwsIG1lc3NhZ2UsIG9wdHMgPSB7fSkge1xuICAgICAgICByZXR1cm4gdGhpcy5ncm91cChsb2dMZXZlbCwgbWVzc2FnZSwgT2JqZWN0LmFzc2lnbih7fSwgb3B0cywgeyBjb2xsYXBzZWQ6IHRydWUgfSkpO1xuICAgIH1cbiAgICBncm91cEVuZChsb2dMZXZlbCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZ2V0TG9nRnVuY3Rpb24obG9nTGV2ZWwsICcnLCBjb25zb2xlLmdyb3VwRW5kIHx8IG5vb3ApO1xuICAgIH1cbiAgICAvLyBFWFBFUklNRU5UQUxcbiAgICB3aXRoR3JvdXAobG9nTGV2ZWwsIG1lc3NhZ2UsIGZ1bmMpIHtcbiAgICAgICAgdGhpcy5ncm91cChsb2dMZXZlbCwgbWVzc2FnZSkoKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGZ1bmMoKTtcbiAgICAgICAgfVxuICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgIHRoaXMuZ3JvdXBFbmQobG9nTGV2ZWwpKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdHJhY2UoKSB7XG4gICAgICAgIGlmIChjb25zb2xlLnRyYWNlKSB7XG4gICAgICAgICAgICBjb25zb2xlLnRyYWNlKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gUFJJVkFURSBNRVRIT0RTXG4gICAgLyoqIERlZHVjZXMgbG9nIGxldmVsIGZyb20gYSB2YXJpZXR5IG9mIGFyZ3VtZW50cyAqL1xuICAgIF9zaG91bGRMb2cobG9nTGV2ZWwpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaXNFbmFibGVkKCkgJiYgdGhpcy5nZXRMZXZlbCgpID49IG5vcm1hbGl6ZUxvZ0xldmVsKGxvZ0xldmVsKTtcbiAgICB9XG4gICAgX2dldExvZ0Z1bmN0aW9uKGxvZ0xldmVsLCBtZXNzYWdlLCBtZXRob2QsIGFyZ3MsIG9wdHMpIHtcbiAgICAgICAgaWYgKHRoaXMuX3Nob3VsZExvZyhsb2dMZXZlbCkpIHtcbiAgICAgICAgICAgIC8vIG5vcm1hbGl6ZWQgb3B0cyArIHRpbWluZ3NcbiAgICAgICAgICAgIG9wdHMgPSBub3JtYWxpemVBcmd1bWVudHMoeyBsb2dMZXZlbCwgbWVzc2FnZSwgYXJncywgb3B0cyB9KTtcbiAgICAgICAgICAgIG1ldGhvZCA9IG1ldGhvZCB8fCBvcHRzLm1ldGhvZDtcbiAgICAgICAgICAgIGFzc2VydChtZXRob2QpO1xuICAgICAgICAgICAgb3B0cy50b3RhbCA9IHRoaXMuZ2V0VG90YWwoKTtcbiAgICAgICAgICAgIG9wdHMuZGVsdGEgPSB0aGlzLmdldERlbHRhKCk7XG4gICAgICAgICAgICAvLyByZXNldCBkZWx0YSB0aW1lclxuICAgICAgICAgICAgdGhpcy5fZGVsdGFUcyA9IGdldEhpUmVzVGltZXN0YW1wKCk7XG4gICAgICAgICAgICBjb25zdCB0YWcgPSBvcHRzLnRhZyB8fCBvcHRzLm1lc3NhZ2U7XG4gICAgICAgICAgICBpZiAob3B0cy5vbmNlICYmIHRhZykge1xuICAgICAgICAgICAgICAgIGlmICghY2FjaGVbdGFnXSkge1xuICAgICAgICAgICAgICAgICAgICBjYWNoZVt0YWddID0gZ2V0SGlSZXNUaW1lc3RhbXAoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBub29wO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFRPRE8gLSBNYWtlIHRocm90dGxpbmcgd29yayB3aXRoIGdyb3Vwc1xuICAgICAgICAgICAgLy8gaWYgKG9wdHMubm90aHJvdHRsZSB8fCAhdGhyb3R0bGUodGFnLCB0aGlzLkxPR19USFJPVFRMRV9USU1FT1VUKSkge1xuICAgICAgICAgICAgLy8gICByZXR1cm4gbm9vcDtcbiAgICAgICAgICAgIC8vIH1cbiAgICAgICAgICAgIG1lc3NhZ2UgPSBkZWNvcmF0ZU1lc3NhZ2UodGhpcy5pZCwgb3B0cy5tZXNzYWdlLCBvcHRzKTtcbiAgICAgICAgICAgIC8vIEJpbmQgY29uc29sZSBmdW5jdGlvbiBzbyB0aGF0IGl0IGNhbiBiZSBjYWxsZWQgYWZ0ZXIgYmVpbmcgcmV0dXJuZWRcbiAgICAgICAgICAgIHJldHVybiBtZXRob2QuYmluZChjb25zb2xlLCBtZXNzYWdlLCAuLi5vcHRzLmFyZ3MpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBub29wO1xuICAgIH1cbn1cbkxvZy5WRVJTSU9OID0gVkVSU0lPTjtcbi8qKlxuICogR2V0IGxvZ0xldmVsIGZyb20gZmlyc3QgYXJndW1lbnQ6XG4gKiAtIGxvZyhsb2dMZXZlbCwgbWVzc2FnZSwgYXJncykgPT4gbG9nTGV2ZWxcbiAqIC0gbG9nKG1lc3NhZ2UsIGFyZ3MpID0+IDBcbiAqIC0gbG9nKHtsb2dMZXZlbCwgLi4ufSwgbWVzc2FnZSwgYXJncykgPT4gbG9nTGV2ZWxcbiAqIC0gbG9nKHtsb2dMZXZlbCwgbWVzc2FnZSwgYXJnc30pID0+IGxvZ0xldmVsXG4gKi9cbmZ1bmN0aW9uIG5vcm1hbGl6ZUxvZ0xldmVsKGxvZ0xldmVsKSB7XG4gICAgaWYgKCFsb2dMZXZlbCkge1xuICAgICAgICByZXR1cm4gMDtcbiAgICB9XG4gICAgbGV0IHJlc29sdmVkTGV2ZWw7XG4gICAgc3dpdGNoICh0eXBlb2YgbG9nTGV2ZWwpIHtcbiAgICAgICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgICAgICAgIHJlc29sdmVkTGV2ZWwgPSBsb2dMZXZlbDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdvYmplY3QnOlxuICAgICAgICAgICAgLy8gQmFja3dhcmQgY29tcGF0aWJpbGl0eVxuICAgICAgICAgICAgLy8gVE9ETyAtIGRlcHJlY2F0ZSBgcHJpb3JpdHlgXG4gICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgICAgICByZXNvbHZlZExldmVsID0gbG9nTGV2ZWwubG9nTGV2ZWwgfHwgbG9nTGV2ZWwucHJpb3JpdHkgfHwgMDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIC8vICdsb2cgbGV2ZWwgbXVzdCBiZSBhIG51bWJlcidcbiAgICBhc3NlcnQoTnVtYmVyLmlzRmluaXRlKHJlc29sdmVkTGV2ZWwpICYmIHJlc29sdmVkTGV2ZWwgPj0gMCk7XG4gICAgcmV0dXJuIHJlc29sdmVkTGV2ZWw7XG59XG4vKipcbiAqIFwiTm9ybWFsaXplc1wiIHRoZSB2YXJpb3VzIGFyZ3VtZW50IHBhdHRlcm5zIGludG8gYW4gb2JqZWN0IHdpdGgga25vd24gdHlwZXNcbiAqIC0gbG9nKGxvZ0xldmVsLCBtZXNzYWdlLCBhcmdzKSA9PiB7bG9nTGV2ZWwsIG1lc3NhZ2UsIGFyZ3N9XG4gKiAtIGxvZyhtZXNzYWdlLCBhcmdzKSA9PiB7bG9nTGV2ZWw6IDAsIG1lc3NhZ2UsIGFyZ3N9XG4gKiAtIGxvZyh7bG9nTGV2ZWwsIC4uLn0sIG1lc3NhZ2UsIGFyZ3MpID0+IHtsb2dMZXZlbCwgbWVzc2FnZSwgYXJnc31cbiAqIC0gbG9nKHtsb2dMZXZlbCwgbWVzc2FnZSwgYXJnc30pID0+IHtsb2dMZXZlbCwgbWVzc2FnZSwgYXJnc31cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG5vcm1hbGl6ZUFyZ3VtZW50cyhvcHRzKSB7XG4gICAgY29uc3QgeyBsb2dMZXZlbCwgbWVzc2FnZSB9ID0gb3B0cztcbiAgICBvcHRzLmxvZ0xldmVsID0gbm9ybWFsaXplTG9nTGV2ZWwobG9nTGV2ZWwpO1xuICAgIC8vIFdlIHVzZSBgYXJndW1lbnRzYCBpbnN0ZWFkIG9mIHJlc3QgcGFyYW1ldGVycyAoLi4uYXJncykgYmVjYXVzZSBJRVxuICAgIC8vIGRvZXMgbm90IHN1cHBvcnQgdGhlIHN5bnRheC4gUmVzdCBwYXJhbWV0ZXJzIGlzIHRyYW5zcGlsZWQgdG8gY29kZSB3aXRoXG4gICAgLy8gcGVyZiBpbXBhY3QuIERvaW5nIGl0IGhlcmUgaW5zdGVhZCBhdm9pZHMgY29uc3RydWN0aW5nIGFyZ3Mgd2hlbiBsb2dnaW5nIGlzXG4gICAgLy8gZGlzYWJsZWQuXG4gICAgLy8gVE9ETyAtIHJlbW92ZSB3aGVuL2lmIElFIHN1cHBvcnQgaXMgZHJvcHBlZFxuICAgIGNvbnN0IGFyZ3MgPSBvcHRzLmFyZ3MgPyBBcnJheS5mcm9tKG9wdHMuYXJncykgOiBbXTtcbiAgICAvLyBhcmdzIHNob3VsZCBvbmx5IGNvbnRhaW4gYXJndW1lbnRzIHRoYXQgYXBwZWFyIGFmdGVyIGBtZXNzYWdlYFxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1lbXB0eVxuICAgIHdoaWxlIChhcmdzLmxlbmd0aCAmJiBhcmdzLnNoaWZ0KCkgIT09IG1lc3NhZ2UpIHsgfVxuICAgIHN3aXRjaCAodHlwZW9mIGxvZ0xldmVsKSB7XG4gICAgICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICAgIGNhc2UgJ2Z1bmN0aW9uJzpcbiAgICAgICAgICAgIGlmIChtZXNzYWdlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBhcmdzLnVuc2hpZnQobWVzc2FnZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvcHRzLm1lc3NhZ2UgPSBsb2dMZXZlbDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdvYmplY3QnOlxuICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihvcHRzLCBsb2dMZXZlbCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICB9XG4gICAgLy8gUmVzb2x2ZSBmdW5jdGlvbnMgaW50byBzdHJpbmdzIGJ5IGNhbGxpbmcgdGhlbVxuICAgIGlmICh0eXBlb2Ygb3B0cy5tZXNzYWdlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIG9wdHMubWVzc2FnZSA9IG9wdHMubWVzc2FnZSgpO1xuICAgIH1cbiAgICBjb25zdCBtZXNzYWdlVHlwZSA9IHR5cGVvZiBvcHRzLm1lc3NhZ2U7XG4gICAgLy8gJ2xvZyBtZXNzYWdlIG11c3QgYmUgYSBzdHJpbmcnIG9yIG9iamVjdFxuICAgIGFzc2VydChtZXNzYWdlVHlwZSA9PT0gJ3N0cmluZycgfHwgbWVzc2FnZVR5cGUgPT09ICdvYmplY3QnKTtcbiAgICAvLyBvcmlnaW5hbCBvcHRzICsgbm9ybWFsaXplZCBvcHRzICsgb3B0cyBhcmcgKyBmaXhlZCB1cCBtZXNzYWdlXG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24ob3B0cywgeyBhcmdzIH0sIG9wdHMub3B0cyk7XG59XG5mdW5jdGlvbiBkZWNvcmF0ZU1lc3NhZ2UoaWQsIG1lc3NhZ2UsIG9wdHMpIHtcbiAgICBpZiAodHlwZW9mIG1lc3NhZ2UgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGNvbnN0IHRpbWUgPSBvcHRzLnRpbWUgPyBsZWZ0UGFkKGZvcm1hdFRpbWUob3B0cy50b3RhbCkpIDogJyc7XG4gICAgICAgIG1lc3NhZ2UgPSBvcHRzLnRpbWUgPyBgJHtpZH06ICR7dGltZX0gICR7bWVzc2FnZX1gIDogYCR7aWR9OiAke21lc3NhZ2V9YDtcbiAgICAgICAgbWVzc2FnZSA9IGFkZENvbG9yKG1lc3NhZ2UsIG9wdHMuY29sb3IsIG9wdHMuYmFja2dyb3VuZCk7XG4gICAgfVxuICAgIHJldHVybiBtZXNzYWdlO1xufVxuZnVuY3Rpb24gZ2V0VGFibGVIZWFkZXIodGFibGUpIHtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiB0YWJsZSkge1xuICAgICAgICBmb3IgKGNvbnN0IHRpdGxlIGluIHRhYmxlW2tleV0pIHtcbiAgICAgICAgICAgIHJldHVybiB0aXRsZSB8fCAndW50aXRsZWQnO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiAnZW1wdHknO1xufVxuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gYXNzZXJ0KGNvbmRpdGlvbiwgbWVzc2FnZSkge1xuICAgIGlmICghY29uZGl0aW9uKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlIHx8ICdBc3NlcnRpb24gZmFpbGVkJyk7XG4gICAgfVxufVxuIiwiLy8gQ29weXJpZ2h0IChjKSAyMDE1IC0gMjAxNyBVYmVyIFRlY2hub2xvZ2llcywgSW5jLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbi8vIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbi8vIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbi8vIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbi8vIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuLy8gZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuLy8gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuLy8gSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4vLyBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbi8vIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbi8vIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4vLyBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG4vLyBUSEUgU09GVFdBUkUuXG4vKipcbiAqIEJpbmRzIHRoZSBcInRoaXNcIiBhcmd1bWVudCBvZiBhbGwgZnVuY3Rpb25zIG9uIGEgY2xhc3MgaW5zdGFuY2UgdG8gdGhlIGluc3RhbmNlXG4gKiBAcGFyYW0gb2JqIC0gY2xhc3MgaW5zdGFuY2UgKHR5cGljYWxseSBhIHJlYWN0IGNvbXBvbmVudClcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGF1dG9iaW5kKG9iaiwgcHJlZGVmaW5lZCA9IFsnY29uc3RydWN0b3InXSkge1xuICAgIGNvbnN0IHByb3RvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKG9iaik7XG4gICAgY29uc3QgcHJvcE5hbWVzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMocHJvdG8pO1xuICAgIGNvbnN0IG9iamVjdCA9IG9iajtcbiAgICBmb3IgKGNvbnN0IGtleSBvZiBwcm9wTmFtZXMpIHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBvYmplY3Rba2V5XTtcbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgaWYgKCFwcmVkZWZpbmVkLmZpbmQobmFtZSA9PiBrZXkgPT09IG5hbWUpKSB7XG4gICAgICAgICAgICAgICAgb2JqZWN0W2tleV0gPSB2YWx1ZS5iaW5kKG9iaik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG4iLCJpbXBvcnQgeyBpc0Jyb3dzZXIgfSBmcm9tICdAcHJvYmUuZ2wvZW52JztcbmV4cG9ydCB2YXIgQ09MT1I7XG4oZnVuY3Rpb24gKENPTE9SKSB7XG4gICAgQ09MT1JbQ09MT1JbXCJCTEFDS1wiXSA9IDMwXSA9IFwiQkxBQ0tcIjtcbiAgICBDT0xPUltDT0xPUltcIlJFRFwiXSA9IDMxXSA9IFwiUkVEXCI7XG4gICAgQ09MT1JbQ09MT1JbXCJHUkVFTlwiXSA9IDMyXSA9IFwiR1JFRU5cIjtcbiAgICBDT0xPUltDT0xPUltcIllFTExPV1wiXSA9IDMzXSA9IFwiWUVMTE9XXCI7XG4gICAgQ09MT1JbQ09MT1JbXCJCTFVFXCJdID0gMzRdID0gXCJCTFVFXCI7XG4gICAgQ09MT1JbQ09MT1JbXCJNQUdFTlRBXCJdID0gMzVdID0gXCJNQUdFTlRBXCI7XG4gICAgQ09MT1JbQ09MT1JbXCJDWUFOXCJdID0gMzZdID0gXCJDWUFOXCI7XG4gICAgQ09MT1JbQ09MT1JbXCJXSElURVwiXSA9IDM3XSA9IFwiV0hJVEVcIjtcbiAgICBDT0xPUltDT0xPUltcIkJSSUdIVF9CTEFDS1wiXSA9IDkwXSA9IFwiQlJJR0hUX0JMQUNLXCI7XG4gICAgQ09MT1JbQ09MT1JbXCJCUklHSFRfUkVEXCJdID0gOTFdID0gXCJCUklHSFRfUkVEXCI7XG4gICAgQ09MT1JbQ09MT1JbXCJCUklHSFRfR1JFRU5cIl0gPSA5Ml0gPSBcIkJSSUdIVF9HUkVFTlwiO1xuICAgIENPTE9SW0NPTE9SW1wiQlJJR0hUX1lFTExPV1wiXSA9IDkzXSA9IFwiQlJJR0hUX1lFTExPV1wiO1xuICAgIENPTE9SW0NPTE9SW1wiQlJJR0hUX0JMVUVcIl0gPSA5NF0gPSBcIkJSSUdIVF9CTFVFXCI7XG4gICAgQ09MT1JbQ09MT1JbXCJCUklHSFRfTUFHRU5UQVwiXSA9IDk1XSA9IFwiQlJJR0hUX01BR0VOVEFcIjtcbiAgICBDT0xPUltDT0xPUltcIkJSSUdIVF9DWUFOXCJdID0gOTZdID0gXCJCUklHSFRfQ1lBTlwiO1xuICAgIENPTE9SW0NPTE9SW1wiQlJJR0hUX1dISVRFXCJdID0gOTddID0gXCJCUklHSFRfV0hJVEVcIjtcbn0pKENPTE9SIHx8IChDT0xPUiA9IHt9KSk7XG5jb25zdCBCQUNLR1JPVU5EX0lOQ1JFTUVOVCA9IDEwO1xuZnVuY3Rpb24gZ2V0Q29sb3IoY29sb3IpIHtcbiAgICBpZiAodHlwZW9mIGNvbG9yICE9PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4gY29sb3I7XG4gICAgfVxuICAgIGNvbG9yID0gY29sb3IudG9VcHBlckNhc2UoKTtcbiAgICByZXR1cm4gQ09MT1JbY29sb3JdIHx8IENPTE9SLldISVRFO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGFkZENvbG9yKHN0cmluZywgY29sb3IsIGJhY2tncm91bmQpIHtcbiAgICBpZiAoIWlzQnJvd3NlciAmJiB0eXBlb2Ygc3RyaW5nID09PSAnc3RyaW5nJykge1xuICAgICAgICBpZiAoY29sb3IpIHtcbiAgICAgICAgICAgIGNvbnN0IGNvbG9yQ29kZSA9IGdldENvbG9yKGNvbG9yKTtcbiAgICAgICAgICAgIHN0cmluZyA9IGBcXHUwMDFiWyR7Y29sb3JDb2RlfW0ke3N0cmluZ31cXHUwMDFiWzM5bWA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGJhY2tncm91bmQpIHtcbiAgICAgICAgICAgIC8vIGJhY2tncm91bmQgY29sb3JzIHZhbHVlcyBhcmUgKzEwXG4gICAgICAgICAgICBjb25zdCBjb2xvckNvZGUgPSBnZXRDb2xvcihiYWNrZ3JvdW5kKTtcbiAgICAgICAgICAgIHN0cmluZyA9IGBcXHUwMDFiWyR7Y29sb3JDb2RlICsgQkFDS0dST1VORF9JTkNSRU1FTlR9bSR7c3RyaW5nfVxcdTAwMWJbNDltYDtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gc3RyaW5nO1xufVxuIiwiLy8gcHJvYmUuZ2wsIE1JVCBsaWNlbnNlXG4vKipcbiAqIEZvcm1hdCB0aW1lXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmb3JtYXRUaW1lKG1zKSB7XG4gICAgbGV0IGZvcm1hdHRlZDtcbiAgICBpZiAobXMgPCAxMCkge1xuICAgICAgICBmb3JtYXR0ZWQgPSBgJHttcy50b0ZpeGVkKDIpfW1zYDtcbiAgICB9XG4gICAgZWxzZSBpZiAobXMgPCAxMDApIHtcbiAgICAgICAgZm9ybWF0dGVkID0gYCR7bXMudG9GaXhlZCgxKX1tc2A7XG4gICAgfVxuICAgIGVsc2UgaWYgKG1zIDwgMTAwMCkge1xuICAgICAgICBmb3JtYXR0ZWQgPSBgJHttcy50b0ZpeGVkKDApfW1zYDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGZvcm1hdHRlZCA9IGAkeyhtcyAvIDEwMDApLnRvRml4ZWQoMil9c2A7XG4gICAgfVxuICAgIHJldHVybiBmb3JtYXR0ZWQ7XG59XG5leHBvcnQgZnVuY3Rpb24gbGVmdFBhZChzdHJpbmcsIGxlbmd0aCA9IDgpIHtcbiAgICBjb25zdCBwYWRMZW5ndGggPSBNYXRoLm1heChsZW5ndGggLSBzdHJpbmcubGVuZ3RoLCAwKTtcbiAgICByZXR1cm4gYCR7JyAnLnJlcGVhdChwYWRMZW5ndGgpfSR7c3RyaW5nfWA7XG59XG5leHBvcnQgZnVuY3Rpb24gcmlnaHRQYWQoc3RyaW5nLCBsZW5ndGggPSA4KSB7XG4gICAgY29uc3QgcGFkTGVuZ3RoID0gTWF0aC5tYXgobGVuZ3RoIC0gc3RyaW5nLmxlbmd0aCwgMCk7XG4gICAgcmV0dXJuIGAke3N0cmluZ30keycgJy5yZXBlYXQocGFkTGVuZ3RoKX1gO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGZvcm1hdFZhbHVlKHYsIG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IEVQU0lMT04gPSAxZS0xNjtcbiAgICBjb25zdCB7IGlzSW50ZWdlciA9IGZhbHNlIH0gPSBvcHRpb25zO1xuICAgIGlmIChBcnJheS5pc0FycmF5KHYpIHx8IEFycmF5QnVmZmVyLmlzVmlldyh2KSkge1xuICAgICAgICByZXR1cm4gZm9ybWF0QXJyYXlWYWx1ZSh2LCBvcHRpb25zKTtcbiAgICB9XG4gICAgaWYgKCFOdW1iZXIuaXNGaW5pdGUodikpIHtcbiAgICAgICAgcmV0dXJuIFN0cmluZyh2KTtcbiAgICB9XG4gICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgIGlmIChNYXRoLmFicyh2KSA8IEVQU0lMT04pIHtcbiAgICAgICAgcmV0dXJuIGlzSW50ZWdlciA/ICcwJyA6ICcwLic7XG4gICAgfVxuICAgIGlmIChpc0ludGVnZXIpIHtcbiAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICByZXR1cm4gdi50b0ZpeGVkKDApO1xuICAgIH1cbiAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgaWYgKE1hdGguYWJzKHYpID4gMTAwICYmIE1hdGguYWJzKHYpIDwgMTAwMDApIHtcbiAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICByZXR1cm4gdi50b0ZpeGVkKDApO1xuICAgIH1cbiAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgY29uc3Qgc3RyaW5nID0gdi50b1ByZWNpc2lvbigyKTtcbiAgICBjb25zdCBkZWNpbWFsID0gc3RyaW5nLmluZGV4T2YoJy4wJyk7XG4gICAgcmV0dXJuIGRlY2ltYWwgPT09IHN0cmluZy5sZW5ndGggLSAyID8gc3RyaW5nLnNsaWNlKDAsIC0xKSA6IHN0cmluZztcbn1cbi8qKiBIZWxwZXIgdG8gZm9ybWF0VmFsdWUgKi9cbmZ1bmN0aW9uIGZvcm1hdEFycmF5VmFsdWUodiwgb3B0aW9ucykge1xuICAgIGNvbnN0IHsgbWF4RWx0cyA9IDE2LCBzaXplID0gMSB9ID0gb3B0aW9ucztcbiAgICBsZXQgc3RyaW5nID0gJ1snO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdi5sZW5ndGggJiYgaSA8IG1heEVsdHM7ICsraSkge1xuICAgICAgICBpZiAoaSA+IDApIHtcbiAgICAgICAgICAgIHN0cmluZyArPSBgLCR7aSAlIHNpemUgPT09IDAgPyAnICcgOiAnJ31gO1xuICAgICAgICB9XG4gICAgICAgIHN0cmluZyArPSBmb3JtYXRWYWx1ZSh2W2ldLCBvcHRpb25zKTtcbiAgICB9XG4gICAgY29uc3QgdGVybWluYXRvciA9IHYubGVuZ3RoID4gbWF4RWx0cyA/ICcuLi4nIDogJ10nO1xuICAgIHJldHVybiBgJHtzdHJpbmd9JHt0ZXJtaW5hdG9yfWA7XG59XG4iLCIvLyBwcm9iZS5nbCwgTUlUIGxpY2Vuc2VcbmltcG9ydCB7IHdpbmRvdywgcHJvY2VzcywgaXNCcm93c2VyIH0gZnJvbSAnQHByb2JlLmdsL2Vudic7XG4vKiogR2V0IGJlc3QgdGltZXIgYXZhaWxhYmxlLiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldEhpUmVzVGltZXN0YW1wKCkge1xuICAgIGxldCB0aW1lc3RhbXA7XG4gICAgaWYgKGlzQnJvd3NlcigpICYmIHdpbmRvdy5wZXJmb3JtYW5jZSkge1xuICAgICAgICB0aW1lc3RhbXAgPSB3aW5kb3c/LnBlcmZvcm1hbmNlPy5ub3c/LigpO1xuICAgIH1cbiAgICBlbHNlIGlmICgnaHJ0aW1lJyBpbiBwcm9jZXNzKSB7XG4gICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgY29uc3QgdGltZVBhcnRzID0gcHJvY2Vzcz8uaHJ0aW1lPy4oKTtcbiAgICAgICAgdGltZXN0YW1wID0gdGltZVBhcnRzWzBdICogMTAwMCArIHRpbWVQYXJ0c1sxXSAvIDFlNjtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHRpbWVzdGFtcCA9IERhdGUubm93KCk7XG4gICAgfVxuICAgIHJldHVybiB0aW1lc3RhbXA7XG59XG4iLCIvLyBwcm9iZS5nbCwgTUlUIGxpY2Vuc2VcbmZ1bmN0aW9uIGdldFN0b3JhZ2UodHlwZSkge1xuICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHN0b3JhZ2UgPSB3aW5kb3dbdHlwZV07XG4gICAgICAgIGNvbnN0IHggPSAnX19zdG9yYWdlX3Rlc3RfXyc7XG4gICAgICAgIHN0b3JhZ2Uuc2V0SXRlbSh4LCB4KTtcbiAgICAgICAgc3RvcmFnZS5yZW1vdmVJdGVtKHgpO1xuICAgICAgICByZXR1cm4gc3RvcmFnZTtcbiAgICB9XG4gICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxufVxuLy8gU3RvcmUga2V5cyBpbiBsb2NhbCBzdG9yYWdlIHZpYSBzaW1wbGUgaW50ZXJmYWNlXG5leHBvcnQgY2xhc3MgTG9jYWxTdG9yYWdlIHtcbiAgICBjb25zdHJ1Y3RvcihpZCwgZGVmYXVsdENvbmZpZywgdHlwZSA9ICdzZXNzaW9uU3RvcmFnZScpIHtcbiAgICAgICAgdGhpcy5zdG9yYWdlID0gZ2V0U3RvcmFnZSh0eXBlKTtcbiAgICAgICAgdGhpcy5pZCA9IGlkO1xuICAgICAgICB0aGlzLmNvbmZpZyA9IGRlZmF1bHRDb25maWc7XG4gICAgICAgIHRoaXMuX2xvYWRDb25maWd1cmF0aW9uKCk7XG4gICAgfVxuICAgIGdldENvbmZpZ3VyYXRpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbmZpZztcbiAgICB9XG4gICAgc2V0Q29uZmlndXJhdGlvbihjb25maWd1cmF0aW9uKSB7XG4gICAgICAgIE9iamVjdC5hc3NpZ24odGhpcy5jb25maWcsIGNvbmZpZ3VyYXRpb24pO1xuICAgICAgICBpZiAodGhpcy5zdG9yYWdlKSB7XG4gICAgICAgICAgICBjb25zdCBzZXJpYWxpemVkID0gSlNPTi5zdHJpbmdpZnkodGhpcy5jb25maWcpO1xuICAgICAgICAgICAgdGhpcy5zdG9yYWdlLnNldEl0ZW0odGhpcy5pZCwgc2VyaWFsaXplZCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gR2V0IGNvbmZpZyBmcm9tIHBlcnNpc3RlbnQgc3RvcmUsIGlmIGF2YWlsYWJsZVxuICAgIF9sb2FkQ29uZmlndXJhdGlvbigpIHtcbiAgICAgICAgbGV0IGNvbmZpZ3VyYXRpb24gPSB7fTtcbiAgICAgICAgaWYgKHRoaXMuc3RvcmFnZSkge1xuICAgICAgICAgICAgY29uc3Qgc2VyaWFsaXplZENvbmZpZ3VyYXRpb24gPSB0aGlzLnN0b3JhZ2UuZ2V0SXRlbSh0aGlzLmlkKTtcbiAgICAgICAgICAgIGNvbmZpZ3VyYXRpb24gPSBzZXJpYWxpemVkQ29uZmlndXJhdGlvbiA/IEpTT04ucGFyc2Uoc2VyaWFsaXplZENvbmZpZ3VyYXRpb24pIDoge307XG4gICAgICAgIH1cbiAgICAgICAgT2JqZWN0LmFzc2lnbih0aGlzLmNvbmZpZywgY29uZmlndXJhdGlvbik7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbn1cbiIsIi8qIHdncHUtbWF0cml4QDMuMC4xLCBsaWNlbnNlIE1JVCAqL1xuZnVuY3Rpb24gd3JhcENvbnN0cnVjdG9yKE9yaWdpbmFsQ29uc3RydWN0b3IsIG1vZGlmaWVyKSB7XG4gICAgcmV0dXJuIGNsYXNzIGV4dGVuZHMgT3JpZ2luYWxDb25zdHJ1Y3RvciB7XG4gICAgICAgIGNvbnN0cnVjdG9yKC4uLmFyZ3MpIHtcbiAgICAgICAgICAgIHN1cGVyKC4uLmFyZ3MpO1xuICAgICAgICAgICAgbW9kaWZpZXIodGhpcyk7XG4gICAgICAgIH1cbiAgICB9OyAvLyBUeXBlIGFzc2VydGlvbiBpcyBuZWNlc3NhcnkgaGVyZVxufVxuY29uc3QgWmVyb0FycmF5ID0gd3JhcENvbnN0cnVjdG9yKChBcnJheSksIGEgPT4gYS5maWxsKDApKTtcblxuLypcbiAqIENvcHlyaWdodCAyMDIyIEdyZWdnIFRhdmFyZXNcbiAqXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuICogY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLFxuICogdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvblxuICogdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsXG4gKiBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGVcbiAqIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4gKlxuICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbiAqIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuICpcbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbiAqIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gIElOIE5PIEVWRU5UIFNIQUxMXG4gKiBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuICogTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkdcbiAqIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVJcbiAqIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cbiAqL1xubGV0IEVQU0lMT04gPSAwLjAwMDAwMTtcbi8qKlxuICogU2V0IHRoZSB2YWx1ZSBmb3IgRVBTSUxPTiBmb3IgdmFyaW91cyBjaGVja3NcbiAqIEBwYXJhbSB2IC0gVmFsdWUgdG8gdXNlIGZvciBFUFNJTE9OLlxuICogQHJldHVybnMgcHJldmlvdXMgdmFsdWUgb2YgRVBTSUxPTjtcbiAqL1xuZnVuY3Rpb24gc2V0RXBzaWxvbih2KSB7XG4gICAgY29uc3Qgb2xkID0gRVBTSUxPTjtcbiAgICBFUFNJTE9OID0gdjtcbiAgICByZXR1cm4gb2xkO1xufVxuLyoqXG4gKiBDb252ZXJ0IGRlZ3JlZXMgdG8gcmFkaWFuc1xuICogQHBhcmFtIGRlZ3JlZXMgLSBBbmdsZSBpbiBkZWdyZWVzXG4gKiBAcmV0dXJucyBhbmdsZSBjb252ZXJ0ZWQgdG8gcmFkaWFuc1xuICovXG5mdW5jdGlvbiBkZWdUb1JhZChkZWdyZWVzKSB7XG4gICAgcmV0dXJuIGRlZ3JlZXMgKiBNYXRoLlBJIC8gMTgwO1xufVxuLyoqXG4gKiBDb252ZXJ0IHJhZGlhbnMgdG8gZGVncmVlc1xuICogQHBhcmFtIHJhZGlhbnMgLSBBbmdsZSBpbiByYWRpYW5zXG4gKiBAcmV0dXJucyBhbmdsZSBjb252ZXJ0ZWQgdG8gZGVncmVlc1xuICovXG5mdW5jdGlvbiByYWRUb0RlZyhyYWRpYW5zKSB7XG4gICAgcmV0dXJuIHJhZGlhbnMgKiAxODAgLyBNYXRoLlBJO1xufVxuLyoqXG4gKiBMZXJwcyBiZXR3ZWVuIGEgYW5kIGIgdmlhIHRcbiAqIEBwYXJhbSBhIC0gc3RhcnRpbmcgdmFsdWVcbiAqIEBwYXJhbSBiIC0gZW5kaW5nIHZhbHVlXG4gKiBAcGFyYW0gdCAtIHZhbHVlIHdoZXJlIDAgPSBhIGFuZCAxID0gYlxuICogQHJldHVybnMgYSArIChiIC0gYSkgKiB0XG4gKi9cbmZ1bmN0aW9uIGxlcnAoYSwgYiwgdCkge1xuICAgIHJldHVybiBhICsgKGIgLSBhKSAqIHQ7XG59XG4vKipcbiAqIENvbXB1dGUgdGhlIG9wcG9zaXRlIG9mIGxlcnAuIEdpdmVuIGEgYW5kIGIgYW5kIGEgdmFsdWUgYmV0d2VlblxuICogYSBhbmQgYiByZXR1cm5zIGEgdmFsdWUgYmV0d2VlbiAwIGFuZCAxLiAwIGlmIGEsIDEgaWYgYi5cbiAqIE5vdGU6IG5vIGNsYW1waW5nIGlzIGRvbmUuXG4gKiBAcGFyYW0gYSAtIHN0YXJ0IHZhbHVlXG4gKiBAcGFyYW0gYiAtIGVuZCB2YWx1ZVxuICogQHBhcmFtIHYgLSB2YWx1ZSBiZXR3ZWVuIGEgYW5kIGJcbiAqIEByZXR1cm5zICh2IC0gYSkgLyAoYiAtIGEpXG4gKi9cbmZ1bmN0aW9uIGludmVyc2VMZXJwKGEsIGIsIHYpIHtcbiAgICBjb25zdCBkID0gYiAtIGE7XG4gICAgcmV0dXJuIChNYXRoLmFicyhiIC0gYSkgPCBFUFNJTE9OKVxuICAgICAgICA/IGFcbiAgICAgICAgOiAodiAtIGEpIC8gZDtcbn1cbi8qKlxuICogQ29tcHV0ZSB0aGUgZXVjbGlkZWFuIG1vZHVsb1xuICpcbiAqIGBgYFxuICogLy8gdGFibGUgZm9yIG4gLyAzXG4gKiAtNSwgLTQsIC0zLCAtMiwgLTEsICAwLCAgMSwgIDIsICAzLCAgNCwgIDUgICA8LSBuXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIC0yICAtMSAgLTAgIC0yICAtMSAgIDAsICAxLCAgMiwgIDAsICAxLCAgMiAgIDwtIG4gJSAzXG4gKiAgMSAgIDIgICAwICAgMSAgIDIgICAwLCAgMSwgIDIsICAwLCAgMSwgIDIgICA8LSBldWNsaWRlYW5Nb2R1bGUobiwgMylcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBuIC0gZGl2aWRlbmRcbiAqIEBwYXJhbSBtIC0gZGl2aXNvclxuICogQHJldHVybnMgdGhlIGV1Y2xpZGVhbiBtb2R1bG8gb2YgbiAvIG1cbiAqL1xuZnVuY3Rpb24gZXVjbGlkZWFuTW9kdWxvKG4sIG0pIHtcbiAgICByZXR1cm4gKChuICUgbSkgKyBtKSAlIG07XG59XG5cbnZhciB1dGlscyA9IHtcbiAgICBfX3Byb3RvX186IG51bGwsXG4gICAgZ2V0IEVQU0lMT04gKCkgeyByZXR1cm4gRVBTSUxPTjsgfSxcbiAgICBkZWdUb1JhZDogZGVnVG9SYWQsXG4gICAgZXVjbGlkZWFuTW9kdWxvOiBldWNsaWRlYW5Nb2R1bG8sXG4gICAgaW52ZXJzZUxlcnA6IGludmVyc2VMZXJwLFxuICAgIGxlcnA6IGxlcnAsXG4gICAgcmFkVG9EZWc6IHJhZFRvRGVnLFxuICAgIHNldEVwc2lsb246IHNldEVwc2lsb25cbn07XG5cbi8qXG4gKiBDb3B5cmlnaHQgMjAyMiBHcmVnZyBUYXZhcmVzXG4gKlxuICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbiAqIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSxcbiAqIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb25cbiAqIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLFxuICogYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlXG4gKiBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuICpcbiAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4gKiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbiAqXG4gKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4gKiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbiAqIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuICBJTiBOTyBFVkVOVCBTSEFMTFxuICogVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbiAqIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HXG4gKiBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSXG4gKiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG4gKi9cbi8qKlxuICogR2VuZXJhdGVzIGFtIHR5cGVkIEFQSSBmb3IgVmVjM1xuICovXG5mdW5jdGlvbiBnZXRBUElJbXBsJDUoQ3Rvcikge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBWZWMyOyBtYXkgYmUgY2FsbGVkIHdpdGggeCwgeSwgeiB0byBzZXQgaW5pdGlhbCB2YWx1ZXMuXG4gICAgICpcbiAgICAgKiBOb3RlOiBTaW5jZSBwYXNzaW5nIGluIGEgcmF3IEphdmFTY3JpcHQgYXJyYXlcbiAgICAgKiBpcyB2YWxpZCBpbiBhbGwgY2lyY3Vtc3RhbmNlcywgaWYgeW91IHdhbnQgdG9cbiAgICAgKiBmb3JjZSBhIEphdmFTY3JpcHQgYXJyYXkgaW50byBhIFZlYzIncyBzcGVjaWZpZWQgdHlwZVxuICAgICAqIGl0IHdvdWxkIGJlIGZhc3RlciB0byB1c2VcbiAgICAgKlxuICAgICAqIGBgYFxuICAgICAqIGNvbnN0IHYgPSB2ZWMyLmNsb25lKHNvbWVKU0FycmF5KTtcbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIEBwYXJhbSB4IC0gSW5pdGlhbCB4IHZhbHVlLlxuICAgICAqIEBwYXJhbSB5IC0gSW5pdGlhbCB5IHZhbHVlLlxuICAgICAqIEByZXR1cm5zIHRoZSBjcmVhdGVkIHZlY3RvclxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZSh4ID0gMCwgeSA9IDApIHtcbiAgICAgICAgY29uc3QgbmV3RHN0ID0gbmV3IEN0b3IoMik7XG4gICAgICAgIGlmICh4ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIG5ld0RzdFswXSA9IHg7XG4gICAgICAgICAgICBpZiAoeSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgbmV3RHN0WzFdID0geTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3RHN0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgVmVjMjsgbWF5IGJlIGNhbGxlZCB3aXRoIHgsIHksIHogdG8gc2V0IGluaXRpYWwgdmFsdWVzLiAoc2FtZSBhcyBjcmVhdGUpXG4gICAgICogQHBhcmFtIHggLSBJbml0aWFsIHggdmFsdWUuXG4gICAgICogQHBhcmFtIHkgLSBJbml0aWFsIHkgdmFsdWUuXG4gICAgICogQHJldHVybnMgdGhlIGNyZWF0ZWQgdmVjdG9yXG4gICAgICovXG4gICAgY29uc3QgZnJvbVZhbHVlcyA9IGNyZWF0ZTtcbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSB2YWx1ZXMgb2YgYSBWZWMyXG4gICAgICogQWxzbyBzZWUge0BsaW5rIHZlYzIuY3JlYXRlfSBhbmQge0BsaW5rIHZlYzIuY29weX1cbiAgICAgKlxuICAgICAqIEBwYXJhbSB4IGZpcnN0IHZhbHVlXG4gICAgICogQHBhcmFtIHkgc2Vjb25kIHZhbHVlXG4gICAgICogQHBhcmFtIGRzdCAtIHZlY3RvciB0byBob2xkIHJlc3VsdC4gSWYgbm90IHBhc3NlZCBpbiBhIG5ldyBvbmUgaXMgY3JlYXRlZC5cbiAgICAgKiBAcmV0dXJucyBBIHZlY3RvciB3aXRoIGl0cyBlbGVtZW50cyBzZXQuXG4gICAgICovXG4gICAgZnVuY3Rpb24gc2V0KHgsIHksIGRzdCkge1xuICAgICAgICBjb25zdCBuZXdEc3QgPSAoZHN0ID8/IG5ldyBDdG9yKDIpKTtcbiAgICAgICAgbmV3RHN0WzBdID0geDtcbiAgICAgICAgbmV3RHN0WzFdID0geTtcbiAgICAgICAgcmV0dXJuIG5ld0RzdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQXBwbGllcyBNYXRoLmNlaWwgdG8gZWFjaCBlbGVtZW50IG9mIHZlY3RvclxuICAgICAqIEBwYXJhbSB2IC0gT3BlcmFuZCB2ZWN0b3IuXG4gICAgICogQHBhcmFtIGRzdCAtIHZlY3RvciB0byBob2xkIHJlc3VsdC4gSWYgbm90IHBhc3NlZCBpbiBhIG5ldyBvbmUgaXMgY3JlYXRlZC5cbiAgICAgKiBAcmV0dXJucyBBIHZlY3RvciB0aGF0IGlzIHRoZSBjZWlsIG9mIGVhY2ggZWxlbWVudCBvZiB2LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNlaWwodiwgZHN0KSB7XG4gICAgICAgIGNvbnN0IG5ld0RzdCA9IChkc3QgPz8gbmV3IEN0b3IoMikpO1xuICAgICAgICBuZXdEc3RbMF0gPSBNYXRoLmNlaWwodlswXSk7XG4gICAgICAgIG5ld0RzdFsxXSA9IE1hdGguY2VpbCh2WzFdKTtcbiAgICAgICAgcmV0dXJuIG5ld0RzdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQXBwbGllcyBNYXRoLmZsb29yIHRvIGVhY2ggZWxlbWVudCBvZiB2ZWN0b3JcbiAgICAgKiBAcGFyYW0gdiAtIE9wZXJhbmQgdmVjdG9yLlxuICAgICAqIEBwYXJhbSBkc3QgLSB2ZWN0b3IgdG8gaG9sZCByZXN1bHQuIElmIG5vdCBwYXNzZWQgaW4gYSBuZXcgb25lIGlzIGNyZWF0ZWQuXG4gICAgICogQHJldHVybnMgQSB2ZWN0b3IgdGhhdCBpcyB0aGUgZmxvb3Igb2YgZWFjaCBlbGVtZW50IG9mIHYuXG4gICAgICovXG4gICAgZnVuY3Rpb24gZmxvb3IodiwgZHN0KSB7XG4gICAgICAgIGNvbnN0IG5ld0RzdCA9IChkc3QgPz8gbmV3IEN0b3IoMikpO1xuICAgICAgICBuZXdEc3RbMF0gPSBNYXRoLmZsb29yKHZbMF0pO1xuICAgICAgICBuZXdEc3RbMV0gPSBNYXRoLmZsb29yKHZbMV0pO1xuICAgICAgICByZXR1cm4gbmV3RHN0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBcHBsaWVzIE1hdGgucm91bmQgdG8gZWFjaCBlbGVtZW50IG9mIHZlY3RvclxuICAgICAqIEBwYXJhbSB2IC0gT3BlcmFuZCB2ZWN0b3IuXG4gICAgICogQHBhcmFtIGRzdCAtIHZlY3RvciB0byBob2xkIHJlc3VsdC4gSWYgbm90IHBhc3NlZCBpbiBhIG5ldyBvbmUgaXMgY3JlYXRlZC5cbiAgICAgKiBAcmV0dXJucyBBIHZlY3RvciB0aGF0IGlzIHRoZSByb3VuZCBvZiBlYWNoIGVsZW1lbnQgb2Ygdi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiByb3VuZCh2LCBkc3QpIHtcbiAgICAgICAgY29uc3QgbmV3RHN0ID0gKGRzdCA/PyBuZXcgQ3RvcigyKSk7XG4gICAgICAgIG5ld0RzdFswXSA9IE1hdGgucm91bmQodlswXSk7XG4gICAgICAgIG5ld0RzdFsxXSA9IE1hdGgucm91bmQodlsxXSk7XG4gICAgICAgIHJldHVybiBuZXdEc3Q7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENsYW1wIGVhY2ggZWxlbWVudCBvZiB2ZWN0b3IgYmV0d2VlbiBtaW4gYW5kIG1heFxuICAgICAqIEBwYXJhbSB2IC0gT3BlcmFuZCB2ZWN0b3IuXG4gICAgICogQHBhcmFtIG1heCAtIE1pbiB2YWx1ZSwgZGVmYXVsdCAwXG4gICAgICogQHBhcmFtIG1pbiAtIE1heCB2YWx1ZSwgZGVmYXVsdCAxXG4gICAgICogQHBhcmFtIGRzdCAtIHZlY3RvciB0byBob2xkIHJlc3VsdC4gSWYgbm90IHBhc3NlZCBpbiBhIG5ldyBvbmUgaXMgY3JlYXRlZC5cbiAgICAgKiBAcmV0dXJucyBBIHZlY3RvciB0aGF0IHRoZSBjbGFtcGVkIHZhbHVlIG9mIGVhY2ggZWxlbWVudCBvZiB2LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNsYW1wKHYsIG1pbiA9IDAsIG1heCA9IDEsIGRzdCkge1xuICAgICAgICBjb25zdCBuZXdEc3QgPSAoZHN0ID8/IG5ldyBDdG9yKDIpKTtcbiAgICAgICAgbmV3RHN0WzBdID0gTWF0aC5taW4obWF4LCBNYXRoLm1heChtaW4sIHZbMF0pKTtcbiAgICAgICAgbmV3RHN0WzFdID0gTWF0aC5taW4obWF4LCBNYXRoLm1heChtaW4sIHZbMV0pKTtcbiAgICAgICAgcmV0dXJuIG5ld0RzdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWRkcyB0d28gdmVjdG9yczsgYXNzdW1lcyBhIGFuZCBiIGhhdmUgdGhlIHNhbWUgZGltZW5zaW9uLlxuICAgICAqIEBwYXJhbSBhIC0gT3BlcmFuZCB2ZWN0b3IuXG4gICAgICogQHBhcmFtIGIgLSBPcGVyYW5kIHZlY3Rvci5cbiAgICAgKiBAcGFyYW0gZHN0IC0gdmVjdG9yIHRvIGhvbGQgcmVzdWx0LiBJZiBub3QgcGFzc2VkIGluIGEgbmV3IG9uZSBpcyBjcmVhdGVkLlxuICAgICAqIEByZXR1cm5zIEEgdmVjdG9yIHRoYXQgaXMgdGhlIHN1bSBvZiBhIGFuZCBiLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGFkZChhLCBiLCBkc3QpIHtcbiAgICAgICAgY29uc3QgbmV3RHN0ID0gKGRzdCA/PyBuZXcgQ3RvcigyKSk7XG4gICAgICAgIG5ld0RzdFswXSA9IGFbMF0gKyBiWzBdO1xuICAgICAgICBuZXdEc3RbMV0gPSBhWzFdICsgYlsxXTtcbiAgICAgICAgcmV0dXJuIG5ld0RzdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWRkcyB0d28gdmVjdG9ycywgc2NhbGluZyB0aGUgMm5kOyBhc3N1bWVzIGEgYW5kIGIgaGF2ZSB0aGUgc2FtZSBkaW1lbnNpb24uXG4gICAgICogQHBhcmFtIGEgLSBPcGVyYW5kIHZlY3Rvci5cbiAgICAgKiBAcGFyYW0gYiAtIE9wZXJhbmQgdmVjdG9yLlxuICAgICAqIEBwYXJhbSBzY2FsZSAtIEFtb3VudCB0byBzY2FsZSBiXG4gICAgICogQHBhcmFtIGRzdCAtIHZlY3RvciB0byBob2xkIHJlc3VsdC4gSWYgbm90IHBhc3NlZCBpbiBhIG5ldyBvbmUgaXMgY3JlYXRlZC5cbiAgICAgKiBAcmV0dXJucyBBIHZlY3RvciB0aGF0IGlzIHRoZSBzdW0gb2YgYSArIGIgKiBzY2FsZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBhZGRTY2FsZWQoYSwgYiwgc2NhbGUsIGRzdCkge1xuICAgICAgICBjb25zdCBuZXdEc3QgPSAoZHN0ID8/IG5ldyBDdG9yKDIpKTtcbiAgICAgICAgbmV3RHN0WzBdID0gYVswXSArIGJbMF0gKiBzY2FsZTtcbiAgICAgICAgbmV3RHN0WzFdID0gYVsxXSArIGJbMV0gKiBzY2FsZTtcbiAgICAgICAgcmV0dXJuIG5ld0RzdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgYW5nbGUgaW4gcmFkaWFucyBiZXR3ZWVuIHR3byB2ZWN0b3JzLlxuICAgICAqIEBwYXJhbSBhIC0gT3BlcmFuZCB2ZWN0b3IuXG4gICAgICogQHBhcmFtIGIgLSBPcGVyYW5kIHZlY3Rvci5cbiAgICAgKiBAcmV0dXJucyBUaGUgYW5nbGUgaW4gcmFkaWFucyBiZXR3ZWVuIHRoZSAyIHZlY3RvcnMuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYW5nbGUoYSwgYikge1xuICAgICAgICBjb25zdCBheCA9IGFbMF07XG4gICAgICAgIGNvbnN0IGF5ID0gYVsxXTtcbiAgICAgICAgY29uc3QgYnggPSBiWzBdO1xuICAgICAgICBjb25zdCBieSA9IGJbMV07XG4gICAgICAgIGNvbnN0IG1hZzEgPSBNYXRoLnNxcnQoYXggKiBheCArIGF5ICogYXkpO1xuICAgICAgICBjb25zdCBtYWcyID0gTWF0aC5zcXJ0KGJ4ICogYnggKyBieSAqIGJ5KTtcbiAgICAgICAgY29uc3QgbWFnID0gbWFnMSAqIG1hZzI7XG4gICAgICAgIGNvbnN0IGNvc2luZSA9IG1hZyAmJiBkb3QoYSwgYikgLyBtYWc7XG4gICAgICAgIHJldHVybiBNYXRoLmFjb3MoY29zaW5lKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU3VidHJhY3RzIHR3byB2ZWN0b3JzLlxuICAgICAqIEBwYXJhbSBhIC0gT3BlcmFuZCB2ZWN0b3IuXG4gICAgICogQHBhcmFtIGIgLSBPcGVyYW5kIHZlY3Rvci5cbiAgICAgKiBAcGFyYW0gZHN0IC0gdmVjdG9yIHRvIGhvbGQgcmVzdWx0LiBJZiBub3QgcGFzc2VkIGluIGEgbmV3IG9uZSBpcyBjcmVhdGVkLlxuICAgICAqIEByZXR1cm5zIEEgdmVjdG9yIHRoYXQgaXMgdGhlIGRpZmZlcmVuY2Ugb2YgYSBhbmQgYi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzdWJ0cmFjdChhLCBiLCBkc3QpIHtcbiAgICAgICAgY29uc3QgbmV3RHN0ID0gKGRzdCA/PyBuZXcgQ3RvcigyKSk7XG4gICAgICAgIG5ld0RzdFswXSA9IGFbMF0gLSBiWzBdO1xuICAgICAgICBuZXdEc3RbMV0gPSBhWzFdIC0gYlsxXTtcbiAgICAgICAgcmV0dXJuIG5ld0RzdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU3VidHJhY3RzIHR3byB2ZWN0b3JzLlxuICAgICAqIEBwYXJhbSBhIC0gT3BlcmFuZCB2ZWN0b3IuXG4gICAgICogQHBhcmFtIGIgLSBPcGVyYW5kIHZlY3Rvci5cbiAgICAgKiBAcGFyYW0gZHN0IC0gdmVjdG9yIHRvIGhvbGQgcmVzdWx0LiBJZiBub3QgcGFzc2VkIGluIGEgbmV3IG9uZSBpcyBjcmVhdGVkLlxuICAgICAqIEByZXR1cm5zIEEgdmVjdG9yIHRoYXQgaXMgdGhlIGRpZmZlcmVuY2Ugb2YgYSBhbmQgYi5cbiAgICAgKi9cbiAgICBjb25zdCBzdWIgPSBzdWJ0cmFjdDtcbiAgICAvKipcbiAgICAgKiBDaGVjayBpZiAyIHZlY3RvcnMgYXJlIGFwcHJveGltYXRlbHkgZXF1YWxcbiAgICAgKiBAcGFyYW0gYSAtIE9wZXJhbmQgdmVjdG9yLlxuICAgICAqIEBwYXJhbSBiIC0gT3BlcmFuZCB2ZWN0b3IuXG4gICAgICogQHJldHVybnMgdHJ1ZSBpZiB2ZWN0b3JzIGFyZSBhcHByb3hpbWF0ZWx5IGVxdWFsXG4gICAgICovXG4gICAgZnVuY3Rpb24gZXF1YWxzQXBwcm94aW1hdGVseShhLCBiKSB7XG4gICAgICAgIHJldHVybiBNYXRoLmFicyhhWzBdIC0gYlswXSkgPCBFUFNJTE9OICYmXG4gICAgICAgICAgICBNYXRoLmFicyhhWzFdIC0gYlsxXSkgPCBFUFNJTE9OO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDaGVjayBpZiAyIHZlY3RvcnMgYXJlIGV4YWN0bHkgZXF1YWxcbiAgICAgKiBAcGFyYW0gYSAtIE9wZXJhbmQgdmVjdG9yLlxuICAgICAqIEBwYXJhbSBiIC0gT3BlcmFuZCB2ZWN0b3IuXG4gICAgICogQHJldHVybnMgdHJ1ZSBpZiB2ZWN0b3JzIGFyZSBleGFjdGx5IGVxdWFsXG4gICAgICovXG4gICAgZnVuY3Rpb24gZXF1YWxzKGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIGFbMF0gPT09IGJbMF0gJiYgYVsxXSA9PT0gYlsxXTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUGVyZm9ybXMgbGluZWFyIGludGVycG9sYXRpb24gb24gdHdvIHZlY3RvcnMuXG4gICAgICogR2l2ZW4gdmVjdG9ycyBhIGFuZCBiIGFuZCBpbnRlcnBvbGF0aW9uIGNvZWZmaWNpZW50IHQsIHJldHVybnNcbiAgICAgKiBhICsgdCAqIChiIC0gYSkuXG4gICAgICogQHBhcmFtIGEgLSBPcGVyYW5kIHZlY3Rvci5cbiAgICAgKiBAcGFyYW0gYiAtIE9wZXJhbmQgdmVjdG9yLlxuICAgICAqIEBwYXJhbSB0IC0gSW50ZXJwb2xhdGlvbiBjb2VmZmljaWVudC5cbiAgICAgKiBAcGFyYW0gZHN0IC0gdmVjdG9yIHRvIGhvbGQgcmVzdWx0LiBJZiBub3QgcGFzc2VkIGluIGEgbmV3IG9uZSBpcyBjcmVhdGVkLlxuICAgICAqIEByZXR1cm5zIFRoZSBsaW5lYXIgaW50ZXJwb2xhdGVkIHJlc3VsdC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBsZXJwKGEsIGIsIHQsIGRzdCkge1xuICAgICAgICBjb25zdCBuZXdEc3QgPSAoZHN0ID8/IG5ldyBDdG9yKDIpKTtcbiAgICAgICAgbmV3RHN0WzBdID0gYVswXSArIHQgKiAoYlswXSAtIGFbMF0pO1xuICAgICAgICBuZXdEc3RbMV0gPSBhWzFdICsgdCAqIChiWzFdIC0gYVsxXSk7XG4gICAgICAgIHJldHVybiBuZXdEc3Q7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFBlcmZvcm1zIGxpbmVhciBpbnRlcnBvbGF0aW9uIG9uIHR3byB2ZWN0b3JzLlxuICAgICAqIEdpdmVuIHZlY3RvcnMgYSBhbmQgYiBhbmQgaW50ZXJwb2xhdGlvbiBjb2VmZmljaWVudCB2ZWN0b3IgdCwgcmV0dXJuc1xuICAgICAqIGEgKyB0ICogKGIgLSBhKS5cbiAgICAgKiBAcGFyYW0gYSAtIE9wZXJhbmQgdmVjdG9yLlxuICAgICAqIEBwYXJhbSBiIC0gT3BlcmFuZCB2ZWN0b3IuXG4gICAgICogQHBhcmFtIHQgLSBJbnRlcnBvbGF0aW9uIGNvZWZmaWNpZW50cyB2ZWN0b3IuXG4gICAgICogQHBhcmFtIGRzdCAtIHZlY3RvciB0byBob2xkIHJlc3VsdC4gSWYgbm90IHBhc3NlZCBpbiBhIG5ldyBvbmUgaXMgY3JlYXRlZC5cbiAgICAgKiBAcmV0dXJucyB0aGUgbGluZWFyIGludGVycG9sYXRlZCByZXN1bHQuXG4gICAgICovXG4gICAgZnVuY3Rpb24gbGVycFYoYSwgYiwgdCwgZHN0KSB7XG4gICAgICAgIGNvbnN0IG5ld0RzdCA9IChkc3QgPz8gbmV3IEN0b3IoMikpO1xuICAgICAgICBuZXdEc3RbMF0gPSBhWzBdICsgdFswXSAqIChiWzBdIC0gYVswXSk7XG4gICAgICAgIG5ld0RzdFsxXSA9IGFbMV0gKyB0WzFdICogKGJbMV0gLSBhWzFdKTtcbiAgICAgICAgcmV0dXJuIG5ld0RzdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJuIG1heCB2YWx1ZXMgb2YgdHdvIHZlY3RvcnMuXG4gICAgICogR2l2ZW4gdmVjdG9ycyBhIGFuZCBiIHJldHVybnNcbiAgICAgKiBbbWF4KGFbMF0sIGJbMF0pLCBtYXgoYVsxXSwgYlsxXSksIG1heChhWzJdLCBiWzJdKV0uXG4gICAgICogQHBhcmFtIGEgLSBPcGVyYW5kIHZlY3Rvci5cbiAgICAgKiBAcGFyYW0gYiAtIE9wZXJhbmQgdmVjdG9yLlxuICAgICAqIEBwYXJhbSBkc3QgLSB2ZWN0b3IgdG8gaG9sZCByZXN1bHQuIElmIG5vdCBwYXNzZWQgaW4gYSBuZXcgb25lIGlzIGNyZWF0ZWQuXG4gICAgICogQHJldHVybnMgVGhlIG1heCBjb21wb25lbnRzIHZlY3Rvci5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBtYXgoYSwgYiwgZHN0KSB7XG4gICAgICAgIGNvbnN0IG5ld0RzdCA9IChkc3QgPz8gbmV3IEN0b3IoMikpO1xuICAgICAgICBuZXdEc3RbMF0gPSBNYXRoLm1heChhWzBdLCBiWzBdKTtcbiAgICAgICAgbmV3RHN0WzFdID0gTWF0aC5tYXgoYVsxXSwgYlsxXSk7XG4gICAgICAgIHJldHVybiBuZXdEc3Q7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybiBtaW4gdmFsdWVzIG9mIHR3byB2ZWN0b3JzLlxuICAgICAqIEdpdmVuIHZlY3RvcnMgYSBhbmQgYiByZXR1cm5zXG4gICAgICogW21pbihhWzBdLCBiWzBdKSwgbWluKGFbMV0sIGJbMV0pLCBtaW4oYVsyXSwgYlsyXSldLlxuICAgICAqIEBwYXJhbSBhIC0gT3BlcmFuZCB2ZWN0b3IuXG4gICAgICogQHBhcmFtIGIgLSBPcGVyYW5kIHZlY3Rvci5cbiAgICAgKiBAcGFyYW0gZHN0IC0gdmVjdG9yIHRvIGhvbGQgcmVzdWx0LiBJZiBub3QgcGFzc2VkIGluIGEgbmV3IG9uZSBpcyBjcmVhdGVkLlxuICAgICAqIEByZXR1cm5zIFRoZSBtaW4gY29tcG9uZW50cyB2ZWN0b3IuXG4gICAgICovXG4gICAgZnVuY3Rpb24gbWluKGEsIGIsIGRzdCkge1xuICAgICAgICBjb25zdCBuZXdEc3QgPSAoZHN0ID8/IG5ldyBDdG9yKDIpKTtcbiAgICAgICAgbmV3RHN0WzBdID0gTWF0aC5taW4oYVswXSwgYlswXSk7XG4gICAgICAgIG5ld0RzdFsxXSA9IE1hdGgubWluKGFbMV0sIGJbMV0pO1xuICAgICAgICByZXR1cm4gbmV3RHN0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBNdWx0aXBsaWVzIGEgdmVjdG9yIGJ5IGEgc2NhbGFyLlxuICAgICAqIEBwYXJhbSB2IC0gVGhlIHZlY3Rvci5cbiAgICAgKiBAcGFyYW0gayAtIFRoZSBzY2FsYXIuXG4gICAgICogQHBhcmFtIGRzdCAtIHZlY3RvciB0byBob2xkIHJlc3VsdC4gSWYgbm90IHBhc3NlZCBpbiBhIG5ldyBvbmUgaXMgY3JlYXRlZC5cbiAgICAgKiBAcmV0dXJucyBUaGUgc2NhbGVkIHZlY3Rvci5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBtdWxTY2FsYXIodiwgaywgZHN0KSB7XG4gICAgICAgIGNvbnN0IG5ld0RzdCA9IChkc3QgPz8gbmV3IEN0b3IoMikpO1xuICAgICAgICBuZXdEc3RbMF0gPSB2WzBdICogaztcbiAgICAgICAgbmV3RHN0WzFdID0gdlsxXSAqIGs7XG4gICAgICAgIHJldHVybiBuZXdEc3Q7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE11bHRpcGxpZXMgYSB2ZWN0b3IgYnkgYSBzY2FsYXIuIChzYW1lIGFzIG11bFNjYWxhcilcbiAgICAgKiBAcGFyYW0gdiAtIFRoZSB2ZWN0b3IuXG4gICAgICogQHBhcmFtIGsgLSBUaGUgc2NhbGFyLlxuICAgICAqIEBwYXJhbSBkc3QgLSB2ZWN0b3IgdG8gaG9sZCByZXN1bHQuIElmIG5vdCBwYXNzZWQgaW4gYSBuZXcgb25lIGlzIGNyZWF0ZWQuXG4gICAgICogQHJldHVybnMgVGhlIHNjYWxlZCB2ZWN0b3IuXG4gICAgICovXG4gICAgY29uc3Qgc2NhbGUgPSBtdWxTY2FsYXI7XG4gICAgLyoqXG4gICAgICogRGl2aWRlcyBhIHZlY3RvciBieSBhIHNjYWxhci5cbiAgICAgKiBAcGFyYW0gdiAtIFRoZSB2ZWN0b3IuXG4gICAgICogQHBhcmFtIGsgLSBUaGUgc2NhbGFyLlxuICAgICAqIEBwYXJhbSBkc3QgLSB2ZWN0b3IgdG8gaG9sZCByZXN1bHQuIElmIG5vdCBwYXNzZWQgaW4gYSBuZXcgb25lIGlzIGNyZWF0ZWQuXG4gICAgICogQHJldHVybnMgVGhlIHNjYWxlZCB2ZWN0b3IuXG4gICAgICovXG4gICAgZnVuY3Rpb24gZGl2U2NhbGFyKHYsIGssIGRzdCkge1xuICAgICAgICBjb25zdCBuZXdEc3QgPSAoZHN0ID8/IG5ldyBDdG9yKDIpKTtcbiAgICAgICAgbmV3RHN0WzBdID0gdlswXSAvIGs7XG4gICAgICAgIG5ld0RzdFsxXSA9IHZbMV0gLyBrO1xuICAgICAgICByZXR1cm4gbmV3RHN0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJbnZlcnNlIGEgdmVjdG9yLlxuICAgICAqIEBwYXJhbSB2IC0gVGhlIHZlY3Rvci5cbiAgICAgKiBAcGFyYW0gZHN0IC0gdmVjdG9yIHRvIGhvbGQgcmVzdWx0LiBJZiBub3QgcGFzc2VkIGluIGEgbmV3IG9uZSBpcyBjcmVhdGVkLlxuICAgICAqIEByZXR1cm5zIFRoZSBpbnZlcnRlZCB2ZWN0b3IuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaW52ZXJzZSh2LCBkc3QpIHtcbiAgICAgICAgY29uc3QgbmV3RHN0ID0gKGRzdCA/PyBuZXcgQ3RvcigyKSk7XG4gICAgICAgIG5ld0RzdFswXSA9IDEgLyB2WzBdO1xuICAgICAgICBuZXdEc3RbMV0gPSAxIC8gdlsxXTtcbiAgICAgICAgcmV0dXJuIG5ld0RzdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSW52ZXJ0IGEgdmVjdG9yLiAoc2FtZSBhcyBpbnZlcnNlKVxuICAgICAqIEBwYXJhbSB2IC0gVGhlIHZlY3Rvci5cbiAgICAgKiBAcGFyYW0gZHN0IC0gdmVjdG9yIHRvIGhvbGQgcmVzdWx0LiBJZiBub3QgcGFzc2VkIGluIGEgbmV3IG9uZSBpcyBjcmVhdGVkLlxuICAgICAqIEByZXR1cm5zIFRoZSBpbnZlcnRlZCB2ZWN0b3IuXG4gICAgICovXG4gICAgY29uc3QgaW52ZXJ0ID0gaW52ZXJzZTtcbiAgICAvKipcbiAgICAgKiBDb21wdXRlcyB0aGUgY3Jvc3MgcHJvZHVjdCBvZiB0d28gdmVjdG9yczsgYXNzdW1lcyBib3RoIHZlY3RvcnMgaGF2ZVxuICAgICAqIHRocmVlIGVudHJpZXMuXG4gICAgICogQHBhcmFtIGEgLSBPcGVyYW5kIHZlY3Rvci5cbiAgICAgKiBAcGFyYW0gYiAtIE9wZXJhbmQgdmVjdG9yLlxuICAgICAqIEBwYXJhbSBkc3QgLSB2ZWN0b3IgdG8gaG9sZCByZXN1bHQuIElmIG5vdCBwYXNzZWQgaW4gYSBuZXcgb25lIGlzIGNyZWF0ZWQuXG4gICAgICogQHJldHVybnMgVGhlIHZlY3RvciBvZiBhIGNyb3NzIGIuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3Jvc3MoYSwgYiwgZHN0KSB7XG4gICAgICAgIGNvbnN0IG5ld0RzdCA9IChkc3QgPz8gbmV3IEN0b3IoMykpO1xuICAgICAgICBjb25zdCB6ID0gYVswXSAqIGJbMV0gLSBhWzFdICogYlswXTtcbiAgICAgICAgbmV3RHN0WzBdID0gMDtcbiAgICAgICAgbmV3RHN0WzFdID0gMDtcbiAgICAgICAgbmV3RHN0WzJdID0gejtcbiAgICAgICAgcmV0dXJuIG5ld0RzdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29tcHV0ZXMgdGhlIGRvdCBwcm9kdWN0IG9mIHR3byB2ZWN0b3JzOyBhc3N1bWVzIGJvdGggdmVjdG9ycyBoYXZlXG4gICAgICogdGhyZWUgZW50cmllcy5cbiAgICAgKiBAcGFyYW0gYSAtIE9wZXJhbmQgdmVjdG9yLlxuICAgICAqIEBwYXJhbSBiIC0gT3BlcmFuZCB2ZWN0b3IuXG4gICAgICogQHJldHVybnMgZG90IHByb2R1Y3RcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBkb3QoYSwgYikge1xuICAgICAgICByZXR1cm4gYVswXSAqIGJbMF0gKyBhWzFdICogYlsxXTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29tcHV0ZXMgdGhlIGxlbmd0aCBvZiB2ZWN0b3JcbiAgICAgKiBAcGFyYW0gdiAtIHZlY3Rvci5cbiAgICAgKiBAcmV0dXJucyBsZW5ndGggb2YgdmVjdG9yLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGxlbmd0aCh2KSB7XG4gICAgICAgIGNvbnN0IHYwID0gdlswXTtcbiAgICAgICAgY29uc3QgdjEgPSB2WzFdO1xuICAgICAgICByZXR1cm4gTWF0aC5zcXJ0KHYwICogdjAgKyB2MSAqIHYxKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29tcHV0ZXMgdGhlIGxlbmd0aCBvZiB2ZWN0b3IgKHNhbWUgYXMgbGVuZ3RoKVxuICAgICAqIEBwYXJhbSB2IC0gdmVjdG9yLlxuICAgICAqIEByZXR1cm5zIGxlbmd0aCBvZiB2ZWN0b3IuXG4gICAgICovXG4gICAgY29uc3QgbGVuID0gbGVuZ3RoO1xuICAgIC8qKlxuICAgICAqIENvbXB1dGVzIHRoZSBzcXVhcmUgb2YgdGhlIGxlbmd0aCBvZiB2ZWN0b3JcbiAgICAgKiBAcGFyYW0gdiAtIHZlY3Rvci5cbiAgICAgKiBAcmV0dXJucyBzcXVhcmUgb2YgdGhlIGxlbmd0aCBvZiB2ZWN0b3IuXG4gICAgICovXG4gICAgZnVuY3Rpb24gbGVuZ3RoU3Eodikge1xuICAgICAgICBjb25zdCB2MCA9IHZbMF07XG4gICAgICAgIGNvbnN0IHYxID0gdlsxXTtcbiAgICAgICAgcmV0dXJuIHYwICogdjAgKyB2MSAqIHYxO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb21wdXRlcyB0aGUgc3F1YXJlIG9mIHRoZSBsZW5ndGggb2YgdmVjdG9yIChzYW1lIGFzIGxlbmd0aFNxKVxuICAgICAqIEBwYXJhbSB2IC0gdmVjdG9yLlxuICAgICAqIEByZXR1cm5zIHNxdWFyZSBvZiB0aGUgbGVuZ3RoIG9mIHZlY3Rvci5cbiAgICAgKi9cbiAgICBjb25zdCBsZW5TcSA9IGxlbmd0aFNxO1xuICAgIC8qKlxuICAgICAqIENvbXB1dGVzIHRoZSBkaXN0YW5jZSBiZXR3ZWVuIDIgcG9pbnRzXG4gICAgICogQHBhcmFtIGEgLSB2ZWN0b3IuXG4gICAgICogQHBhcmFtIGIgLSB2ZWN0b3IuXG4gICAgICogQHJldHVybnMgZGlzdGFuY2UgYmV0d2VlbiBhIGFuZCBiXG4gICAgICovXG4gICAgZnVuY3Rpb24gZGlzdGFuY2UoYSwgYikge1xuICAgICAgICBjb25zdCBkeCA9IGFbMF0gLSBiWzBdO1xuICAgICAgICBjb25zdCBkeSA9IGFbMV0gLSBiWzFdO1xuICAgICAgICByZXR1cm4gTWF0aC5zcXJ0KGR4ICogZHggKyBkeSAqIGR5KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29tcHV0ZXMgdGhlIGRpc3RhbmNlIGJldHdlZW4gMiBwb2ludHMgKHNhbWUgYXMgZGlzdGFuY2UpXG4gICAgICogQHBhcmFtIGEgLSB2ZWN0b3IuXG4gICAgICogQHBhcmFtIGIgLSB2ZWN0b3IuXG4gICAgICogQHJldHVybnMgZGlzdGFuY2UgYmV0d2VlbiBhIGFuZCBiXG4gICAgICovXG4gICAgY29uc3QgZGlzdCA9IGRpc3RhbmNlO1xuICAgIC8qKlxuICAgICAqIENvbXB1dGVzIHRoZSBzcXVhcmUgb2YgdGhlIGRpc3RhbmNlIGJldHdlZW4gMiBwb2ludHNcbiAgICAgKiBAcGFyYW0gYSAtIHZlY3Rvci5cbiAgICAgKiBAcGFyYW0gYiAtIHZlY3Rvci5cbiAgICAgKiBAcmV0dXJucyBzcXVhcmUgb2YgdGhlIGRpc3RhbmNlIGJldHdlZW4gYSBhbmQgYlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGRpc3RhbmNlU3EoYSwgYikge1xuICAgICAgICBjb25zdCBkeCA9IGFbMF0gLSBiWzBdO1xuICAgICAgICBjb25zdCBkeSA9IGFbMV0gLSBiWzFdO1xuICAgICAgICByZXR1cm4gZHggKiBkeCArIGR5ICogZHk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbXB1dGVzIHRoZSBzcXVhcmUgb2YgdGhlIGRpc3RhbmNlIGJldHdlZW4gMiBwb2ludHMgKHNhbWUgYXMgZGlzdGFuY2VTcSlcbiAgICAgKiBAcGFyYW0gYSAtIHZlY3Rvci5cbiAgICAgKiBAcGFyYW0gYiAtIHZlY3Rvci5cbiAgICAgKiBAcmV0dXJucyBzcXVhcmUgb2YgdGhlIGRpc3RhbmNlIGJldHdlZW4gYSBhbmQgYlxuICAgICAqL1xuICAgIGNvbnN0IGRpc3RTcSA9IGRpc3RhbmNlU3E7XG4gICAgLyoqXG4gICAgICogRGl2aWRlcyBhIHZlY3RvciBieSBpdHMgRXVjbGlkZWFuIGxlbmd0aCBhbmQgcmV0dXJucyB0aGUgcXVvdGllbnQuXG4gICAgICogQHBhcmFtIHYgLSBUaGUgdmVjdG9yLlxuICAgICAqIEBwYXJhbSBkc3QgLSB2ZWN0b3IgdG8gaG9sZCByZXN1bHQuIElmIG5vdCBwYXNzZWQgaW4gYSBuZXcgb25lIGlzIGNyZWF0ZWQuXG4gICAgICogQHJldHVybnMgVGhlIG5vcm1hbGl6ZWQgdmVjdG9yLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG5vcm1hbGl6ZSh2LCBkc3QpIHtcbiAgICAgICAgY29uc3QgbmV3RHN0ID0gKGRzdCA/PyBuZXcgQ3RvcigyKSk7XG4gICAgICAgIGNvbnN0IHYwID0gdlswXTtcbiAgICAgICAgY29uc3QgdjEgPSB2WzFdO1xuICAgICAgICBjb25zdCBsZW4gPSBNYXRoLnNxcnQodjAgKiB2MCArIHYxICogdjEpO1xuICAgICAgICBpZiAobGVuID4gMC4wMDAwMSkge1xuICAgICAgICAgICAgbmV3RHN0WzBdID0gdjAgLyBsZW47XG4gICAgICAgICAgICBuZXdEc3RbMV0gPSB2MSAvIGxlbjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG5ld0RzdFswXSA9IDA7XG4gICAgICAgICAgICBuZXdEc3RbMV0gPSAwO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXdEc3Q7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE5lZ2F0ZXMgYSB2ZWN0b3IuXG4gICAgICogQHBhcmFtIHYgLSBUaGUgdmVjdG9yLlxuICAgICAqIEBwYXJhbSBkc3QgLSB2ZWN0b3IgdG8gaG9sZCByZXN1bHQuIElmIG5vdCBwYXNzZWQgaW4gYSBuZXcgb25lIGlzIGNyZWF0ZWQuXG4gICAgICogQHJldHVybnMgLXYuXG4gICAgICovXG4gICAgZnVuY3Rpb24gbmVnYXRlKHYsIGRzdCkge1xuICAgICAgICBjb25zdCBuZXdEc3QgPSAoZHN0ID8/IG5ldyBDdG9yKDIpKTtcbiAgICAgICAgbmV3RHN0WzBdID0gLXZbMF07XG4gICAgICAgIG5ld0RzdFsxXSA9IC12WzFdO1xuICAgICAgICByZXR1cm4gbmV3RHN0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb3BpZXMgYSB2ZWN0b3IuIChzYW1lIGFzIHtAbGluayB2ZWMyLmNsb25lfSlcbiAgICAgKiBBbHNvIHNlZSB7QGxpbmsgdmVjMi5jcmVhdGV9IGFuZCB7QGxpbmsgdmVjMi5zZXR9XG4gICAgICogQHBhcmFtIHYgLSBUaGUgdmVjdG9yLlxuICAgICAqIEBwYXJhbSBkc3QgLSB2ZWN0b3IgdG8gaG9sZCByZXN1bHQuIElmIG5vdCBwYXNzZWQgaW4gYSBuZXcgb25lIGlzIGNyZWF0ZWQuXG4gICAgICogQHJldHVybnMgQSBjb3B5IG9mIHYuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY29weSh2LCBkc3QpIHtcbiAgICAgICAgY29uc3QgbmV3RHN0ID0gKGRzdCA/PyBuZXcgQ3RvcigyKSk7XG4gICAgICAgIG5ld0RzdFswXSA9IHZbMF07XG4gICAgICAgIG5ld0RzdFsxXSA9IHZbMV07XG4gICAgICAgIHJldHVybiBuZXdEc3Q7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENsb25lcyBhIHZlY3Rvci4gKHNhbWUgYXMge0BsaW5rIHZlYzIuY29weX0pXG4gICAgICogQWxzbyBzZWUge0BsaW5rIHZlYzIuY3JlYXRlfSBhbmQge0BsaW5rIHZlYzIuc2V0fVxuICAgICAqIEBwYXJhbSB2IC0gVGhlIHZlY3Rvci5cbiAgICAgKiBAcGFyYW0gZHN0IC0gdmVjdG9yIHRvIGhvbGQgcmVzdWx0LiBJZiBub3QgcGFzc2VkIGluIGEgbmV3IG9uZSBpcyBjcmVhdGVkLlxuICAgICAqIEByZXR1cm5zIEEgY29weSBvZiB2LlxuICAgICAqL1xuICAgIGNvbnN0IGNsb25lID0gY29weTtcbiAgICAvKipcbiAgICAgKiBNdWx0aXBsaWVzIGEgdmVjdG9yIGJ5IGFub3RoZXIgdmVjdG9yIChjb21wb25lbnQtd2lzZSk7IGFzc3VtZXMgYSBhbmRcbiAgICAgKiBiIGhhdmUgdGhlIHNhbWUgbGVuZ3RoLlxuICAgICAqIEBwYXJhbSBhIC0gT3BlcmFuZCB2ZWN0b3IuXG4gICAgICogQHBhcmFtIGIgLSBPcGVyYW5kIHZlY3Rvci5cbiAgICAgKiBAcGFyYW0gZHN0IC0gdmVjdG9yIHRvIGhvbGQgcmVzdWx0LiBJZiBub3QgcGFzc2VkIGluIGEgbmV3IG9uZSBpcyBjcmVhdGVkLlxuICAgICAqIEByZXR1cm5zIFRoZSB2ZWN0b3Igb2YgcHJvZHVjdHMgb2YgZW50cmllcyBvZiBhIGFuZCBiLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG11bHRpcGx5KGEsIGIsIGRzdCkge1xuICAgICAgICBjb25zdCBuZXdEc3QgPSAoZHN0ID8/IG5ldyBDdG9yKDIpKTtcbiAgICAgICAgbmV3RHN0WzBdID0gYVswXSAqIGJbMF07XG4gICAgICAgIG5ld0RzdFsxXSA9IGFbMV0gKiBiWzFdO1xuICAgICAgICByZXR1cm4gbmV3RHN0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBNdWx0aXBsaWVzIGEgdmVjdG9yIGJ5IGFub3RoZXIgdmVjdG9yIChjb21wb25lbnQtd2lzZSk7IGFzc3VtZXMgYSBhbmRcbiAgICAgKiBiIGhhdmUgdGhlIHNhbWUgbGVuZ3RoLiAoc2FtZSBhcyBtdWwpXG4gICAgICogQHBhcmFtIGEgLSBPcGVyYW5kIHZlY3Rvci5cbiAgICAgKiBAcGFyYW0gYiAtIE9wZXJhbmQgdmVjdG9yLlxuICAgICAqIEBwYXJhbSBkc3QgLSB2ZWN0b3IgdG8gaG9sZCByZXN1bHQuIElmIG5vdCBwYXNzZWQgaW4gYSBuZXcgb25lIGlzIGNyZWF0ZWQuXG4gICAgICogQHJldHVybnMgVGhlIHZlY3RvciBvZiBwcm9kdWN0cyBvZiBlbnRyaWVzIG9mIGEgYW5kIGIuXG4gICAgICovXG4gICAgY29uc3QgbXVsID0gbXVsdGlwbHk7XG4gICAgLyoqXG4gICAgICogRGl2aWRlcyBhIHZlY3RvciBieSBhbm90aGVyIHZlY3RvciAoY29tcG9uZW50LXdpc2UpOyBhc3N1bWVzIGEgYW5kXG4gICAgICogYiBoYXZlIHRoZSBzYW1lIGxlbmd0aC5cbiAgICAgKiBAcGFyYW0gYSAtIE9wZXJhbmQgdmVjdG9yLlxuICAgICAqIEBwYXJhbSBiIC0gT3BlcmFuZCB2ZWN0b3IuXG4gICAgICogQHBhcmFtIGRzdCAtIHZlY3RvciB0byBob2xkIHJlc3VsdC4gSWYgbm90IHBhc3NlZCBpbiBhIG5ldyBvbmUgaXMgY3JlYXRlZC5cbiAgICAgKiBAcmV0dXJucyBUaGUgdmVjdG9yIG9mIHF1b3RpZW50cyBvZiBlbnRyaWVzIG9mIGEgYW5kIGIuXG4gICAgICovXG4gICAgZnVuY3Rpb24gZGl2aWRlKGEsIGIsIGRzdCkge1xuICAgICAgICBjb25zdCBuZXdEc3QgPSAoZHN0ID8/IG5ldyBDdG9yKDIpKTtcbiAgICAgICAgbmV3RHN0WzBdID0gYVswXSAvIGJbMF07XG4gICAgICAgIG5ld0RzdFsxXSA9IGFbMV0gLyBiWzFdO1xuICAgICAgICByZXR1cm4gbmV3RHN0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEaXZpZGVzIGEgdmVjdG9yIGJ5IGFub3RoZXIgdmVjdG9yIChjb21wb25lbnQtd2lzZSk7IGFzc3VtZXMgYSBhbmRcbiAgICAgKiBiIGhhdmUgdGhlIHNhbWUgbGVuZ3RoLiAoc2FtZSBhcyBkaXZpZGUpXG4gICAgICogQHBhcmFtIGEgLSBPcGVyYW5kIHZlY3Rvci5cbiAgICAgKiBAcGFyYW0gYiAtIE9wZXJhbmQgdmVjdG9yLlxuICAgICAqIEBwYXJhbSBkc3QgLSB2ZWN0b3IgdG8gaG9sZCByZXN1bHQuIElmIG5vdCBwYXNzZWQgaW4gYSBuZXcgb25lIGlzIGNyZWF0ZWQuXG4gICAgICogQHJldHVybnMgVGhlIHZlY3RvciBvZiBxdW90aWVudHMgb2YgZW50cmllcyBvZiBhIGFuZCBiLlxuICAgICAqL1xuICAgIGNvbnN0IGRpdiA9IGRpdmlkZTtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgcmFuZG9tIHVuaXQgdmVjdG9yICogc2NhbGVcbiAgICAgKiBAcGFyYW0gc2NhbGUgLSBEZWZhdWx0IDFcbiAgICAgKiBAcGFyYW0gZHN0IC0gdmVjdG9yIHRvIGhvbGQgcmVzdWx0LiBJZiBub3QgcGFzc2VkIGluIGEgbmV3IG9uZSBpcyBjcmVhdGVkLlxuICAgICAqIEByZXR1cm5zIFRoZSByYW5kb20gdmVjdG9yLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHJhbmRvbShzY2FsZSA9IDEsIGRzdCkge1xuICAgICAgICBjb25zdCBuZXdEc3QgPSAoZHN0ID8/IG5ldyBDdG9yKDIpKTtcbiAgICAgICAgY29uc3QgYW5nbGUgPSBNYXRoLnJhbmRvbSgpICogMiAqIE1hdGguUEk7XG4gICAgICAgIG5ld0RzdFswXSA9IE1hdGguY29zKGFuZ2xlKSAqIHNjYWxlO1xuICAgICAgICBuZXdEc3RbMV0gPSBNYXRoLnNpbihhbmdsZSkgKiBzY2FsZTtcbiAgICAgICAgcmV0dXJuIG5ld0RzdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogWmVybydzIGEgdmVjdG9yXG4gICAgICogQHBhcmFtIGRzdCAtIHZlY3RvciB0byBob2xkIHJlc3VsdC4gSWYgbm90IHBhc3NlZCBpbiBhIG5ldyBvbmUgaXMgY3JlYXRlZC5cbiAgICAgKiBAcmV0dXJucyBUaGUgemVyb2VkIHZlY3Rvci5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB6ZXJvKGRzdCkge1xuICAgICAgICBjb25zdCBuZXdEc3QgPSAoZHN0ID8/IG5ldyBDdG9yKDIpKTtcbiAgICAgICAgbmV3RHN0WzBdID0gMDtcbiAgICAgICAgbmV3RHN0WzFdID0gMDtcbiAgICAgICAgcmV0dXJuIG5ld0RzdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogdHJhbnNmb3JtIFZlYzIgYnkgNHg0IG1hdHJpeFxuICAgICAqIEBwYXJhbSB2IC0gdGhlIHZlY3RvclxuICAgICAqIEBwYXJhbSBtIC0gVGhlIG1hdHJpeC5cbiAgICAgKiBAcGFyYW0gZHN0IC0gb3B0aW9uYWwgVmVjMiB0byBzdG9yZSByZXN1bHQuIElmIG5vdCBwYXNzZWQgYSBuZXcgb25lIGlzIGNyZWF0ZWQuXG4gICAgICogQHJldHVybnMgdGhlIHRyYW5zZm9ybWVkIHZlY3RvclxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRyYW5zZm9ybU1hdDQodiwgbSwgZHN0KSB7XG4gICAgICAgIGNvbnN0IG5ld0RzdCA9IChkc3QgPz8gbmV3IEN0b3IoMikpO1xuICAgICAgICBjb25zdCB4ID0gdlswXTtcbiAgICAgICAgY29uc3QgeSA9IHZbMV07XG4gICAgICAgIG5ld0RzdFswXSA9IHggKiBtWzBdICsgeSAqIG1bNF0gKyBtWzEyXTtcbiAgICAgICAgbmV3RHN0WzFdID0geCAqIG1bMV0gKyB5ICogbVs1XSArIG1bMTNdO1xuICAgICAgICByZXR1cm4gbmV3RHN0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUcmFuc2Zvcm1zIHZlYzQgYnkgM3gzIG1hdHJpeFxuICAgICAqXG4gICAgICogQHBhcmFtIHYgLSB0aGUgdmVjdG9yXG4gICAgICogQHBhcmFtIG0gLSBUaGUgbWF0cml4LlxuICAgICAqIEBwYXJhbSBkc3QgLSBvcHRpb25hbCBWZWMyIHRvIHN0b3JlIHJlc3VsdC4gSWYgbm90IHBhc3NlZCBhIG5ldyBvbmUgaXMgY3JlYXRlZC5cbiAgICAgKiBAcmV0dXJucyB0aGUgdHJhbnNmb3JtZWQgdmVjdG9yXG4gICAgICovXG4gICAgZnVuY3Rpb24gdHJhbnNmb3JtTWF0Myh2LCBtLCBkc3QpIHtcbiAgICAgICAgY29uc3QgbmV3RHN0ID0gKGRzdCA/PyBuZXcgQ3RvcigyKSk7XG4gICAgICAgIGNvbnN0IHggPSB2WzBdO1xuICAgICAgICBjb25zdCB5ID0gdlsxXTtcbiAgICAgICAgbmV3RHN0WzBdID0gbVswXSAqIHggKyBtWzRdICogeSArIG1bOF07XG4gICAgICAgIG5ld0RzdFsxXSA9IG1bMV0gKiB4ICsgbVs1XSAqIHkgKyBtWzldO1xuICAgICAgICByZXR1cm4gbmV3RHN0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSb3RhdGUgYSAyRCB2ZWN0b3JcbiAgICAgKlxuICAgICAqIEBwYXJhbSBhIFRoZSB2ZWMyIHBvaW50IHRvIHJvdGF0ZVxuICAgICAqIEBwYXJhbSBiIFRoZSBvcmlnaW4gb2YgdGhlIHJvdGF0aW9uXG4gICAgICogQHBhcmFtIHJhZCBUaGUgYW5nbGUgb2Ygcm90YXRpb24gaW4gcmFkaWFuc1xuICAgICAqIEByZXR1cm5zIHRoZSByb3RhdGVkIHZlY3RvclxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHJvdGF0ZShhLCBiLCByYWQsIGRzdCkge1xuICAgICAgICBjb25zdCBuZXdEc3QgPSAoZHN0ID8/IG5ldyBDdG9yKDIpKTtcbiAgICAgICAgLy8gVHJhbnNsYXRlIHBvaW50IHRvIHRoZSBvcmlnaW5cbiAgICAgICAgY29uc3QgcDAgPSBhWzBdIC0gYlswXTtcbiAgICAgICAgY29uc3QgcDEgPSBhWzFdIC0gYlsxXTtcbiAgICAgICAgY29uc3Qgc2luQyA9IE1hdGguc2luKHJhZCk7XG4gICAgICAgIGNvbnN0IGNvc0MgPSBNYXRoLmNvcyhyYWQpO1xuICAgICAgICAvL3BlcmZvcm0gcm90YXRpb24gYW5kIHRyYW5zbGF0ZSB0byBjb3JyZWN0IHBvc2l0aW9uXG4gICAgICAgIG5ld0RzdFswXSA9IHAwICogY29zQyAtIHAxICogc2luQyArIGJbMF07XG4gICAgICAgIG5ld0RzdFsxXSA9IHAwICogc2luQyArIHAxICogY29zQyArIGJbMV07XG4gICAgICAgIHJldHVybiBuZXdEc3Q7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRyZWF0IGEgMkQgdmVjdG9yIGFzIGEgZGlyZWN0aW9uIGFuZCBzZXQgaXQncyBsZW5ndGhcbiAgICAgKlxuICAgICAqIEBwYXJhbSBhIFRoZSB2ZWMyIHRvIGxlbmd0aGVuXG4gICAgICogQHBhcmFtIGxlbiBUaGUgbGVuZ3RoIG9mIHRoZSByZXN1bHRpbmcgdmVjdG9yXG4gICAgICogQHJldHVybnMgVGhlIGxlbmd0aGVuZWQgdmVjdG9yXG4gICAgICovXG4gICAgZnVuY3Rpb24gc2V0TGVuZ3RoKGEsIGxlbiwgZHN0KSB7XG4gICAgICAgIGNvbnN0IG5ld0RzdCA9IChkc3QgPz8gbmV3IEN0b3IoMikpO1xuICAgICAgICBub3JtYWxpemUoYSwgbmV3RHN0KTtcbiAgICAgICAgcmV0dXJuIG11bFNjYWxhcihuZXdEc3QsIGxlbiwgbmV3RHN0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRW5zdXJlIGEgdmVjdG9yIGlzIG5vdCBsb25nZXIgdGhhbiBhIG1heCBsZW5ndGhcbiAgICAgKlxuICAgICAqIEBwYXJhbSBhIFRoZSB2ZWMyIHRvIGxpbWl0XG4gICAgICogQHBhcmFtIG1heExlbiBUaGUgbG9uZ2VzdCBsZW5ndGggb2YgdGhlIHJlc3VsdGluZyB2ZWN0b3JcbiAgICAgKiBAcmV0dXJucyBUaGUgdmVjdG9yLCBzaG9ydGVuZWQgdG8gbWF4TGVuIGlmIGl0J3MgdG9vIGxvbmdcbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0cnVuY2F0ZShhLCBtYXhMZW4sIGRzdCkge1xuICAgICAgICBjb25zdCBuZXdEc3QgPSAoZHN0ID8/IG5ldyBDdG9yKDIpKTtcbiAgICAgICAgaWYgKGxlbmd0aChhKSA+IG1heExlbikge1xuICAgICAgICAgICAgcmV0dXJuIHNldExlbmd0aChhLCBtYXhMZW4sIG5ld0RzdCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvcHkoYSwgbmV3RHN0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJuIHRoZSB2ZWN0b3IgZXhhY3RseSBiZXR3ZWVuIDIgZW5kcG9pbnQgdmVjdG9yc1xuICAgICAqXG4gICAgICogQHBhcmFtIGEgRW5kcG9pbnQgMVxuICAgICAqIEBwYXJhbSBiIEVuZHBvaW50IDJcbiAgICAgKiBAcmV0dXJucyBUaGUgdmVjdG9yIGV4YWN0bHkgcmVzaWRpbmcgYmV0d2VlbiBlbmRwb2ludHMgMSBhbmQgMlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG1pZHBvaW50KGEsIGIsIGRzdCkge1xuICAgICAgICBjb25zdCBuZXdEc3QgPSAoZHN0ID8/IG5ldyBDdG9yKDIpKTtcbiAgICAgICAgcmV0dXJuIGxlcnAoYSwgYiwgMC41LCBuZXdEc3QpO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBjcmVhdGUsXG4gICAgICAgIGZyb21WYWx1ZXMsXG4gICAgICAgIHNldCxcbiAgICAgICAgY2VpbCxcbiAgICAgICAgZmxvb3IsXG4gICAgICAgIHJvdW5kLFxuICAgICAgICBjbGFtcCxcbiAgICAgICAgYWRkLFxuICAgICAgICBhZGRTY2FsZWQsXG4gICAgICAgIGFuZ2xlLFxuICAgICAgICBzdWJ0cmFjdCxcbiAgICAgICAgc3ViLFxuICAgICAgICBlcXVhbHNBcHByb3hpbWF0ZWx5LFxuICAgICAgICBlcXVhbHMsXG4gICAgICAgIGxlcnAsXG4gICAgICAgIGxlcnBWLFxuICAgICAgICBtYXgsXG4gICAgICAgIG1pbixcbiAgICAgICAgbXVsU2NhbGFyLFxuICAgICAgICBzY2FsZSxcbiAgICAgICAgZGl2U2NhbGFyLFxuICAgICAgICBpbnZlcnNlLFxuICAgICAgICBpbnZlcnQsXG4gICAgICAgIGNyb3NzLFxuICAgICAgICBkb3QsXG4gICAgICAgIGxlbmd0aCxcbiAgICAgICAgbGVuLFxuICAgICAgICBsZW5ndGhTcSxcbiAgICAgICAgbGVuU3EsXG4gICAgICAgIGRpc3RhbmNlLFxuICAgICAgICBkaXN0LFxuICAgICAgICBkaXN0YW5jZVNxLFxuICAgICAgICBkaXN0U3EsXG4gICAgICAgIG5vcm1hbGl6ZSxcbiAgICAgICAgbmVnYXRlLFxuICAgICAgICBjb3B5LFxuICAgICAgICBjbG9uZSxcbiAgICAgICAgbXVsdGlwbHksXG4gICAgICAgIG11bCxcbiAgICAgICAgZGl2aWRlLFxuICAgICAgICBkaXYsXG4gICAgICAgIHJhbmRvbSxcbiAgICAgICAgemVybyxcbiAgICAgICAgdHJhbnNmb3JtTWF0NCxcbiAgICAgICAgdHJhbnNmb3JtTWF0MyxcbiAgICAgICAgcm90YXRlLFxuICAgICAgICBzZXRMZW5ndGgsXG4gICAgICAgIHRydW5jYXRlLFxuICAgICAgICBtaWRwb2ludCxcbiAgICB9O1xufVxuY29uc3QgY2FjaGUkNSA9IG5ldyBNYXAoKTtcbmZ1bmN0aW9uIGdldEFQSSQ1KEN0b3IpIHtcbiAgICBsZXQgYXBpID0gY2FjaGUkNS5nZXQoQ3Rvcik7XG4gICAgaWYgKCFhcGkpIHtcbiAgICAgICAgYXBpID0gZ2V0QVBJSW1wbCQ1KEN0b3IpO1xuICAgICAgICBjYWNoZSQ1LnNldChDdG9yLCBhcGkpO1xuICAgIH1cbiAgICByZXR1cm4gYXBpO1xufVxuXG4vKlxuICogQ29weXJpZ2h0IDIwMjIgR3JlZ2cgVGF2YXJlc1xuICpcbiAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4gKiBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksXG4gKiB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uXG4gKiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSxcbiAqIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZVxuICogU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbiAqXG4gKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuICogYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gKlxuICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuICogSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4gKiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiAgSU4gTk8gRVZFTlQgU0hBTExcbiAqIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4gKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lOR1xuICogRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUlxuICogREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuICovXG4vKipcbiAqIEdlbmVyYXRlcyBhIHR5cGVkIEFQSSBmb3IgTWF0M1xuICogKi9cbmZ1bmN0aW9uIGdldEFQSUltcGwkNChDdG9yKSB7XG4gICAgY29uc3QgdmVjMiA9IGdldEFQSSQ1KEN0b3IpO1xuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIE1hdDMgZnJvbSB2YWx1ZXNcbiAgICAgKlxuICAgICAqIE5vdGU6IFNpbmNlIHBhc3NpbmcgaW4gYSByYXcgSmF2YVNjcmlwdCBhcnJheVxuICAgICAqIGlzIHZhbGlkIGluIGFsbCBjaXJjdW1zdGFuY2VzLCBpZiB5b3Ugd2FudCB0b1xuICAgICAqIGZvcmNlIGEgSmF2YVNjcmlwdCBhcnJheSBpbnRvIGEgTWF0MydzIHNwZWNpZmllZCB0eXBlXG4gICAgICogaXQgd291bGQgYmUgZmFzdGVyIHRvIHVzZVxuICAgICAqXG4gICAgICogYGBgXG4gICAgICogY29uc3QgbSA9IG1hdDMuY2xvbmUoc29tZUpTQXJyYXkpO1xuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogQHBhcmFtIHYwIC0gdmFsdWUgZm9yIGVsZW1lbnQgMFxuICAgICAqIEBwYXJhbSB2MSAtIHZhbHVlIGZvciBlbGVtZW50IDFcbiAgICAgKiBAcGFyYW0gdjIgLSB2YWx1ZSBmb3IgZWxlbWVudCAyXG4gICAgICogQHBhcmFtIHYzIC0gdmFsdWUgZm9yIGVsZW1lbnQgM1xuICAgICAqIEBwYXJhbSB2NCAtIHZhbHVlIGZvciBlbGVtZW50IDRcbiAgICAgKiBAcGFyYW0gdjUgLSB2YWx1ZSBmb3IgZWxlbWVudCA1XG4gICAgICogQHBhcmFtIHY2IC0gdmFsdWUgZm9yIGVsZW1lbnQgNlxuICAgICAqIEBwYXJhbSB2NyAtIHZhbHVlIGZvciBlbGVtZW50IDdcbiAgICAgKiBAcGFyYW0gdjggLSB2YWx1ZSBmb3IgZWxlbWVudCA4XG4gICAgICogQHJldHVybnMgbWF0cml4IGNyZWF0ZWQgZnJvbSB2YWx1ZXMuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlKHYwLCB2MSwgdjIsIHYzLCB2NCwgdjUsIHY2LCB2NywgdjgpIHtcbiAgICAgICAgY29uc3QgbmV3RHN0ID0gbmV3IEN0b3IoMTIpO1xuICAgICAgICAvLyB0byBtYWtlIHRoZSBhcnJheSBob21vZ2Vub3VzXG4gICAgICAgIG5ld0RzdFszXSA9IDA7XG4gICAgICAgIG5ld0RzdFs3XSA9IDA7XG4gICAgICAgIG5ld0RzdFsxMV0gPSAwO1xuICAgICAgICBpZiAodjAgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgbmV3RHN0WzBdID0gdjA7XG4gICAgICAgICAgICBpZiAodjEgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIG5ld0RzdFsxXSA9IHYxO1xuICAgICAgICAgICAgICAgIGlmICh2MiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIG5ld0RzdFsyXSA9IHYyO1xuICAgICAgICAgICAgICAgICAgICBpZiAodjMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV3RHN0WzRdID0gdjM7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodjQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld0RzdFs1XSA9IHY0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2NSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld0RzdFs2XSA9IHY1O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodjYgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3RHN0WzhdID0gdjY7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodjcgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld0RzdFs5XSA9IHY3O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2OCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld0RzdFsxMF0gPSB2ODtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ld0RzdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgdmFsdWVzIG9mIGEgTWF0M1xuICAgICAqIEFsc28gc2VlIHtAbGluayBtYXQzLmNyZWF0ZX0gYW5kIHtAbGluayBtYXQzLmNvcHl9XG4gICAgICpcbiAgICAgKiBAcGFyYW0gdjAgLSB2YWx1ZSBmb3IgZWxlbWVudCAwXG4gICAgICogQHBhcmFtIHYxIC0gdmFsdWUgZm9yIGVsZW1lbnQgMVxuICAgICAqIEBwYXJhbSB2MiAtIHZhbHVlIGZvciBlbGVtZW50IDJcbiAgICAgKiBAcGFyYW0gdjMgLSB2YWx1ZSBmb3IgZWxlbWVudCAzXG4gICAgICogQHBhcmFtIHY0IC0gdmFsdWUgZm9yIGVsZW1lbnQgNFxuICAgICAqIEBwYXJhbSB2NSAtIHZhbHVlIGZvciBlbGVtZW50IDVcbiAgICAgKiBAcGFyYW0gdjYgLSB2YWx1ZSBmb3IgZWxlbWVudCA2XG4gICAgICogQHBhcmFtIHY3IC0gdmFsdWUgZm9yIGVsZW1lbnQgN1xuICAgICAqIEBwYXJhbSB2OCAtIHZhbHVlIGZvciBlbGVtZW50IDhcbiAgICAgKiBAcGFyYW0gZHN0IC0gbWF0cml4IHRvIGhvbGQgcmVzdWx0LiBJZiBub3QgcGFzc2VkIGEgbmV3IG9uZSBpcyBjcmVhdGVkLlxuICAgICAqIEByZXR1cm5zIE1hdDMgc2V0IGZyb20gdmFsdWVzLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNldCh2MCwgdjEsIHYyLCB2MywgdjQsIHY1LCB2NiwgdjcsIHY4LCBkc3QpIHtcbiAgICAgICAgY29uc3QgbmV3RHN0ID0gKGRzdCA/PyBuZXcgQ3RvcigxMikpO1xuICAgICAgICBuZXdEc3RbMF0gPSB2MDtcbiAgICAgICAgbmV3RHN0WzFdID0gdjE7XG4gICAgICAgIG5ld0RzdFsyXSA9IHYyO1xuICAgICAgICBuZXdEc3RbM10gPSAwO1xuICAgICAgICBuZXdEc3RbNF0gPSB2MztcbiAgICAgICAgbmV3RHN0WzVdID0gdjQ7XG4gICAgICAgIG5ld0RzdFs2XSA9IHY1O1xuICAgICAgICBuZXdEc3RbN10gPSAwO1xuICAgICAgICBuZXdEc3RbOF0gPSB2NjtcbiAgICAgICAgbmV3RHN0WzldID0gdjc7XG4gICAgICAgIG5ld0RzdFsxMF0gPSB2ODtcbiAgICAgICAgbmV3RHN0WzExXSA9IDA7XG4gICAgICAgIHJldHVybiBuZXdEc3Q7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBNYXQzIGZyb20gdGhlIHVwcGVyIGxlZnQgM3gzIHBhcnQgb2YgYSBNYXQ0XG4gICAgICogQHBhcmFtIG00IC0gc291cmNlIG1hdHJpeFxuICAgICAqIEBwYXJhbSBkc3QgLSBtYXRyaXggdG8gaG9sZCByZXN1bHQuIElmIG5vdCBwYXNzZWQgYSBuZXcgb25lIGlzIGNyZWF0ZWQuXG4gICAgICogQHJldHVybnMgTWF0MyBtYWRlIGZyb20gbTRcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmcm9tTWF0NChtNCwgZHN0KSB7XG4gICAgICAgIGNvbnN0IG5ld0RzdCA9IChkc3QgPz8gbmV3IEN0b3IoMTIpKTtcbiAgICAgICAgbmV3RHN0WzBdID0gbTRbMF07XG4gICAgICAgIG5ld0RzdFsxXSA9IG00WzFdO1xuICAgICAgICBuZXdEc3RbMl0gPSBtNFsyXTtcbiAgICAgICAgbmV3RHN0WzNdID0gMDtcbiAgICAgICAgbmV3RHN0WzRdID0gbTRbNF07XG4gICAgICAgIG5ld0RzdFs1XSA9IG00WzVdO1xuICAgICAgICBuZXdEc3RbNl0gPSBtNFs2XTtcbiAgICAgICAgbmV3RHN0WzddID0gMDtcbiAgICAgICAgbmV3RHN0WzhdID0gbTRbOF07XG4gICAgICAgIG5ld0RzdFs5XSA9IG00WzldO1xuICAgICAgICBuZXdEc3RbMTBdID0gbTRbMTBdO1xuICAgICAgICBuZXdEc3RbMTFdID0gMDtcbiAgICAgICAgcmV0dXJuIG5ld0RzdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIE1hdDMgcm90YXRpb24gbWF0cml4IGZyb20gYSBxdWF0ZXJuaW9uXG4gICAgICogQHBhcmFtIHEgLSBxdWF0ZXJuaW9uIHRvIGNyZWF0ZSBtYXRyaXggZnJvbVxuICAgICAqIEBwYXJhbSBkc3QgLSBtYXRyaXggdG8gaG9sZCByZXN1bHQuIElmIG5vdCBwYXNzZWQgYSBuZXcgb25lIGlzIGNyZWF0ZWQuXG4gICAgICogQHJldHVybnMgTWF0MyBtYWRlIGZyb20gcVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZyb21RdWF0KHEsIGRzdCkge1xuICAgICAgICBjb25zdCBuZXdEc3QgPSAoZHN0ID8/IG5ldyBDdG9yKDEyKSk7XG4gICAgICAgIGNvbnN0IHggPSBxWzBdO1xuICAgICAgICBjb25zdCB5ID0gcVsxXTtcbiAgICAgICAgY29uc3QgeiA9IHFbMl07XG4gICAgICAgIGNvbnN0IHcgPSBxWzNdO1xuICAgICAgICBjb25zdCB4MiA9IHggKyB4O1xuICAgICAgICBjb25zdCB5MiA9IHkgKyB5O1xuICAgICAgICBjb25zdCB6MiA9IHogKyB6O1xuICAgICAgICBjb25zdCB4eCA9IHggKiB4MjtcbiAgICAgICAgY29uc3QgeXggPSB5ICogeDI7XG4gICAgICAgIGNvbnN0IHl5ID0geSAqIHkyO1xuICAgICAgICBjb25zdCB6eCA9IHogKiB4MjtcbiAgICAgICAgY29uc3QgenkgPSB6ICogeTI7XG4gICAgICAgIGNvbnN0IHp6ID0geiAqIHoyO1xuICAgICAgICBjb25zdCB3eCA9IHcgKiB4MjtcbiAgICAgICAgY29uc3Qgd3kgPSB3ICogeTI7XG4gICAgICAgIGNvbnN0IHd6ID0gdyAqIHoyO1xuICAgICAgICBuZXdEc3RbMF0gPSAxIC0geXkgLSB6ejtcbiAgICAgICAgbmV3RHN0WzFdID0geXggKyB3ejtcbiAgICAgICAgbmV3RHN0WzJdID0genggLSB3eTtcbiAgICAgICAgbmV3RHN0WzNdID0gMDtcbiAgICAgICAgbmV3RHN0WzRdID0geXggLSB3ejtcbiAgICAgICAgbmV3RHN0WzVdID0gMSAtIHh4IC0geno7XG4gICAgICAgIG5ld0RzdFs2XSA9IHp5ICsgd3g7XG4gICAgICAgIG5ld0RzdFs3XSA9IDA7XG4gICAgICAgIG5ld0RzdFs4XSA9IHp4ICsgd3k7XG4gICAgICAgIG5ld0RzdFs5XSA9IHp5IC0gd3g7XG4gICAgICAgIG5ld0RzdFsxMF0gPSAxIC0geHggLSB5eTtcbiAgICAgICAgbmV3RHN0WzExXSA9IDA7XG4gICAgICAgIHJldHVybiBuZXdEc3Q7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE5lZ2F0ZXMgYSBtYXRyaXguXG4gICAgICogQHBhcmFtIG0gLSBUaGUgbWF0cml4LlxuICAgICAqIEBwYXJhbSBkc3QgLSBtYXRyaXggdG8gaG9sZCByZXN1bHQuIElmIG5vdCBwYXNzZWQgYSBuZXcgb25lIGlzIGNyZWF0ZWQuXG4gICAgICogQHJldHVybnMgLW0uXG4gICAgICovXG4gICAgZnVuY3Rpb24gbmVnYXRlKG0sIGRzdCkge1xuICAgICAgICBjb25zdCBuZXdEc3QgPSAoZHN0ID8/IG5ldyBDdG9yKDEyKSk7XG4gICAgICAgIG5ld0RzdFswXSA9IC1tWzBdO1xuICAgICAgICBuZXdEc3RbMV0gPSAtbVsxXTtcbiAgICAgICAgbmV3RHN0WzJdID0gLW1bMl07XG4gICAgICAgIG5ld0RzdFs0XSA9IC1tWzRdO1xuICAgICAgICBuZXdEc3RbNV0gPSAtbVs1XTtcbiAgICAgICAgbmV3RHN0WzZdID0gLW1bNl07XG4gICAgICAgIG5ld0RzdFs4XSA9IC1tWzhdO1xuICAgICAgICBuZXdEc3RbOV0gPSAtbVs5XTtcbiAgICAgICAgbmV3RHN0WzEwXSA9IC1tWzEwXTtcbiAgICAgICAgcmV0dXJuIG5ld0RzdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29waWVzIGEgbWF0cml4LiAoc2FtZSBhcyB7QGxpbmsgbWF0My5jbG9uZX0pXG4gICAgICogQWxzbyBzZWUge0BsaW5rIG1hdDMuY3JlYXRlfSBhbmQge0BsaW5rIG1hdDMuc2V0fVxuICAgICAqIEBwYXJhbSBtIC0gVGhlIG1hdHJpeC5cbiAgICAgKiBAcGFyYW0gZHN0IC0gVGhlIG1hdHJpeC4gSWYgbm90IHBhc3NlZCBhIG5ldyBvbmUgaXMgY3JlYXRlZC5cbiAgICAgKiBAcmV0dXJucyBBIGNvcHkgb2YgbS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjb3B5KG0sIGRzdCkge1xuICAgICAgICBjb25zdCBuZXdEc3QgPSAoZHN0ID8/IG5ldyBDdG9yKDEyKSk7XG4gICAgICAgIG5ld0RzdFswXSA9IG1bMF07XG4gICAgICAgIG5ld0RzdFsxXSA9IG1bMV07XG4gICAgICAgIG5ld0RzdFsyXSA9IG1bMl07XG4gICAgICAgIG5ld0RzdFs0XSA9IG1bNF07XG4gICAgICAgIG5ld0RzdFs1XSA9IG1bNV07XG4gICAgICAgIG5ld0RzdFs2XSA9IG1bNl07XG4gICAgICAgIG5ld0RzdFs4XSA9IG1bOF07XG4gICAgICAgIG5ld0RzdFs5XSA9IG1bOV07XG4gICAgICAgIG5ld0RzdFsxMF0gPSBtWzEwXTtcbiAgICAgICAgcmV0dXJuIG5ld0RzdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29waWVzIGEgbWF0cml4IChzYW1lIGFzIHtAbGluayBtYXQzLmNvcHl9KVxuICAgICAqIEFsc28gc2VlIHtAbGluayBtYXQzLmNyZWF0ZX0gYW5kIHtAbGluayBtYXQzLnNldH1cbiAgICAgKiBAcGFyYW0gbSAtIFRoZSBtYXRyaXguXG4gICAgICogQHBhcmFtIGRzdCAtIFRoZSBtYXRyaXguIElmIG5vdCBwYXNzZWQgYSBuZXcgb25lIGlzIGNyZWF0ZWQuXG4gICAgICogQHJldHVybnMgQSBjb3B5IG9mIG0uXG4gICAgICovXG4gICAgY29uc3QgY2xvbmUgPSBjb3B5O1xuICAgIC8qKlxuICAgICAqIENoZWNrIGlmIDIgbWF0cmljZXMgYXJlIGFwcHJveGltYXRlbHkgZXF1YWxcbiAgICAgKiBAcGFyYW0gYSBPcGVyYW5kIG1hdHJpeC5cbiAgICAgKiBAcGFyYW0gYiBPcGVyYW5kIG1hdHJpeC5cbiAgICAgKiBAcmV0dXJucyB0cnVlIGlmIG1hdHJpY2VzIGFyZSBhcHByb3hpbWF0ZWx5IGVxdWFsXG4gICAgICovXG4gICAgZnVuY3Rpb24gZXF1YWxzQXBwcm94aW1hdGVseShhLCBiKSB7XG4gICAgICAgIHJldHVybiBNYXRoLmFicyhhWzBdIC0gYlswXSkgPCBFUFNJTE9OICYmXG4gICAgICAgICAgICBNYXRoLmFicyhhWzFdIC0gYlsxXSkgPCBFUFNJTE9OICYmXG4gICAgICAgICAgICBNYXRoLmFicyhhWzJdIC0gYlsyXSkgPCBFUFNJTE9OICYmXG4gICAgICAgICAgICBNYXRoLmFicyhhWzRdIC0gYls0XSkgPCBFUFNJTE9OICYmXG4gICAgICAgICAgICBNYXRoLmFicyhhWzVdIC0gYls1XSkgPCBFUFNJTE9OICYmXG4gICAgICAgICAgICBNYXRoLmFicyhhWzZdIC0gYls2XSkgPCBFUFNJTE9OICYmXG4gICAgICAgICAgICBNYXRoLmFicyhhWzhdIC0gYls4XSkgPCBFUFNJTE9OICYmXG4gICAgICAgICAgICBNYXRoLmFicyhhWzldIC0gYls5XSkgPCBFUFNJTE9OICYmXG4gICAgICAgICAgICBNYXRoLmFicyhhWzEwXSAtIGJbMTBdKSA8IEVQU0lMT047XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENoZWNrIGlmIDIgbWF0cmljZXMgYXJlIGV4YWN0bHkgZXF1YWxcbiAgICAgKiBAcGFyYW0gYSBPcGVyYW5kIG1hdHJpeC5cbiAgICAgKiBAcGFyYW0gYiBPcGVyYW5kIG1hdHJpeC5cbiAgICAgKiBAcmV0dXJucyB0cnVlIGlmIG1hdHJpY2VzIGFyZSBleGFjdGx5IGVxdWFsXG4gICAgICovXG4gICAgZnVuY3Rpb24gZXF1YWxzKGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIGFbMF0gPT09IGJbMF0gJiZcbiAgICAgICAgICAgIGFbMV0gPT09IGJbMV0gJiZcbiAgICAgICAgICAgIGFbMl0gPT09IGJbMl0gJiZcbiAgICAgICAgICAgIGFbNF0gPT09IGJbNF0gJiZcbiAgICAgICAgICAgIGFbNV0gPT09IGJbNV0gJiZcbiAgICAgICAgICAgIGFbNl0gPT09IGJbNl0gJiZcbiAgICAgICAgICAgIGFbOF0gPT09IGJbOF0gJiZcbiAgICAgICAgICAgIGFbOV0gPT09IGJbOV0gJiZcbiAgICAgICAgICAgIGFbMTBdID09PSBiWzEwXTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIDMtYnktMyBpZGVudGl0eSBtYXRyaXguXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZHN0IC0gbWF0cml4IHRvIGhvbGQgcmVzdWx0LiBJZiBub3QgcGFzc2VkIGEgbmV3IG9uZSBpcyBjcmVhdGVkLlxuICAgICAqIEByZXR1cm5zIEEgMy1ieS0zIGlkZW50aXR5IG1hdHJpeC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpZGVudGl0eShkc3QpIHtcbiAgICAgICAgY29uc3QgbmV3RHN0ID0gKGRzdCA/PyBuZXcgQ3RvcigxMikpO1xuICAgICAgICBuZXdEc3RbMF0gPSAxO1xuICAgICAgICBuZXdEc3RbMV0gPSAwO1xuICAgICAgICBuZXdEc3RbMl0gPSAwO1xuICAgICAgICBuZXdEc3RbNF0gPSAwO1xuICAgICAgICBuZXdEc3RbNV0gPSAxO1xuICAgICAgICBuZXdEc3RbNl0gPSAwO1xuICAgICAgICBuZXdEc3RbOF0gPSAwO1xuICAgICAgICBuZXdEc3RbOV0gPSAwO1xuICAgICAgICBuZXdEc3RbMTBdID0gMTtcbiAgICAgICAgcmV0dXJuIG5ld0RzdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGFrZXMgdGhlIHRyYW5zcG9zZSBvZiBhIG1hdHJpeC5cbiAgICAgKiBAcGFyYW0gbSAtIFRoZSBtYXRyaXguXG4gICAgICogQHBhcmFtIGRzdCAtIG1hdHJpeCB0byBob2xkIHJlc3VsdC4gSWYgbm90IHBhc3NlZCBhIG5ldyBvbmUgaXMgY3JlYXRlZC5cbiAgICAgKiBAcmV0dXJucyBUaGUgdHJhbnNwb3NlIG9mIG0uXG4gICAgICovXG4gICAgZnVuY3Rpb24gdHJhbnNwb3NlKG0sIGRzdCkge1xuICAgICAgICBjb25zdCBuZXdEc3QgPSAoZHN0ID8/IG5ldyBDdG9yKDEyKSk7XG4gICAgICAgIGlmIChuZXdEc3QgPT09IG0pIHtcbiAgICAgICAgICAgIGxldCB0O1xuICAgICAgICAgICAgLy8gMCAxIDJcbiAgICAgICAgICAgIC8vIDQgNSA2XG4gICAgICAgICAgICAvLyA4IDkgMTBcbiAgICAgICAgICAgIHQgPSBtWzFdO1xuICAgICAgICAgICAgbVsxXSA9IG1bNF07XG4gICAgICAgICAgICBtWzRdID0gdDtcbiAgICAgICAgICAgIHQgPSBtWzJdO1xuICAgICAgICAgICAgbVsyXSA9IG1bOF07XG4gICAgICAgICAgICBtWzhdID0gdDtcbiAgICAgICAgICAgIHQgPSBtWzZdO1xuICAgICAgICAgICAgbVs2XSA9IG1bOV07XG4gICAgICAgICAgICBtWzldID0gdDtcbiAgICAgICAgICAgIHJldHVybiBuZXdEc3Q7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbTAwID0gbVswICogNCArIDBdO1xuICAgICAgICBjb25zdCBtMDEgPSBtWzAgKiA0ICsgMV07XG4gICAgICAgIGNvbnN0IG0wMiA9IG1bMCAqIDQgKyAyXTtcbiAgICAgICAgY29uc3QgbTEwID0gbVsxICogNCArIDBdO1xuICAgICAgICBjb25zdCBtMTEgPSBtWzEgKiA0ICsgMV07XG4gICAgICAgIGNvbnN0IG0xMiA9IG1bMSAqIDQgKyAyXTtcbiAgICAgICAgY29uc3QgbTIwID0gbVsyICogNCArIDBdO1xuICAgICAgICBjb25zdCBtMjEgPSBtWzIgKiA0ICsgMV07XG4gICAgICAgIGNvbnN0IG0yMiA9IG1bMiAqIDQgKyAyXTtcbiAgICAgICAgbmV3RHN0WzBdID0gbTAwO1xuICAgICAgICBuZXdEc3RbMV0gPSBtMTA7XG4gICAgICAgIG5ld0RzdFsyXSA9IG0yMDtcbiAgICAgICAgbmV3RHN0WzRdID0gbTAxO1xuICAgICAgICBuZXdEc3RbNV0gPSBtMTE7XG4gICAgICAgIG5ld0RzdFs2XSA9IG0yMTtcbiAgICAgICAgbmV3RHN0WzhdID0gbTAyO1xuICAgICAgICBuZXdEc3RbOV0gPSBtMTI7XG4gICAgICAgIG5ld0RzdFsxMF0gPSBtMjI7XG4gICAgICAgIHJldHVybiBuZXdEc3Q7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbXB1dGVzIHRoZSBpbnZlcnNlIG9mIGEgMy1ieS0zIG1hdHJpeC5cbiAgICAgKiBAcGFyYW0gbSAtIFRoZSBtYXRyaXguXG4gICAgICogQHBhcmFtIGRzdCAtIG1hdHJpeCB0byBob2xkIHJlc3VsdC4gSWYgbm90IHBhc3NlZCBhIG5ldyBvbmUgaXMgY3JlYXRlZC5cbiAgICAgKiBAcmV0dXJucyBUaGUgaW52ZXJzZSBvZiBtLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGludmVyc2UobSwgZHN0KSB7XG4gICAgICAgIGNvbnN0IG5ld0RzdCA9IChkc3QgPz8gbmV3IEN0b3IoMTIpKTtcbiAgICAgICAgY29uc3QgbTAwID0gbVswICogNCArIDBdO1xuICAgICAgICBjb25zdCBtMDEgPSBtWzAgKiA0ICsgMV07XG4gICAgICAgIGNvbnN0IG0wMiA9IG1bMCAqIDQgKyAyXTtcbiAgICAgICAgY29uc3QgbTEwID0gbVsxICogNCArIDBdO1xuICAgICAgICBjb25zdCBtMTEgPSBtWzEgKiA0ICsgMV07XG4gICAgICAgIGNvbnN0IG0xMiA9IG1bMSAqIDQgKyAyXTtcbiAgICAgICAgY29uc3QgbTIwID0gbVsyICogNCArIDBdO1xuICAgICAgICBjb25zdCBtMjEgPSBtWzIgKiA0ICsgMV07XG4gICAgICAgIGNvbnN0IG0yMiA9IG1bMiAqIDQgKyAyXTtcbiAgICAgICAgY29uc3QgYjAxID0gbTIyICogbTExIC0gbTEyICogbTIxO1xuICAgICAgICBjb25zdCBiMTEgPSAtbTIyICogbTEwICsgbTEyICogbTIwO1xuICAgICAgICBjb25zdCBiMjEgPSBtMjEgKiBtMTAgLSBtMTEgKiBtMjA7XG4gICAgICAgIGNvbnN0IGludkRldCA9IDEgLyAobTAwICogYjAxICsgbTAxICogYjExICsgbTAyICogYjIxKTtcbiAgICAgICAgbmV3RHN0WzBdID0gYjAxICogaW52RGV0O1xuICAgICAgICBuZXdEc3RbMV0gPSAoLW0yMiAqIG0wMSArIG0wMiAqIG0yMSkgKiBpbnZEZXQ7XG4gICAgICAgIG5ld0RzdFsyXSA9IChtMTIgKiBtMDEgLSBtMDIgKiBtMTEpICogaW52RGV0O1xuICAgICAgICBuZXdEc3RbNF0gPSBiMTEgKiBpbnZEZXQ7XG4gICAgICAgIG5ld0RzdFs1XSA9IChtMjIgKiBtMDAgLSBtMDIgKiBtMjApICogaW52RGV0O1xuICAgICAgICBuZXdEc3RbNl0gPSAoLW0xMiAqIG0wMCArIG0wMiAqIG0xMCkgKiBpbnZEZXQ7XG4gICAgICAgIG5ld0RzdFs4XSA9IGIyMSAqIGludkRldDtcbiAgICAgICAgbmV3RHN0WzldID0gKC1tMjEgKiBtMDAgKyBtMDEgKiBtMjApICogaW52RGV0O1xuICAgICAgICBuZXdEc3RbMTBdID0gKG0xMSAqIG0wMCAtIG0wMSAqIG0xMCkgKiBpbnZEZXQ7XG4gICAgICAgIHJldHVybiBuZXdEc3Q7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbXB1dGUgdGhlIGRldGVybWluYW50IG9mIGEgbWF0cml4XG4gICAgICogQHBhcmFtIG0gLSB0aGUgbWF0cml4XG4gICAgICogQHJldHVybnMgdGhlIGRldGVybWluYW50XG4gICAgICovXG4gICAgZnVuY3Rpb24gZGV0ZXJtaW5hbnQobSkge1xuICAgICAgICBjb25zdCBtMDAgPSBtWzAgKiA0ICsgMF07XG4gICAgICAgIGNvbnN0IG0wMSA9IG1bMCAqIDQgKyAxXTtcbiAgICAgICAgY29uc3QgbTAyID0gbVswICogNCArIDJdO1xuICAgICAgICBjb25zdCBtMTAgPSBtWzEgKiA0ICsgMF07XG4gICAgICAgIGNvbnN0IG0xMSA9IG1bMSAqIDQgKyAxXTtcbiAgICAgICAgY29uc3QgbTEyID0gbVsxICogNCArIDJdO1xuICAgICAgICBjb25zdCBtMjAgPSBtWzIgKiA0ICsgMF07XG4gICAgICAgIGNvbnN0IG0yMSA9IG1bMiAqIDQgKyAxXTtcbiAgICAgICAgY29uc3QgbTIyID0gbVsyICogNCArIDJdO1xuICAgICAgICByZXR1cm4gbTAwICogKG0xMSAqIG0yMiAtIG0yMSAqIG0xMikgLVxuICAgICAgICAgICAgbTEwICogKG0wMSAqIG0yMiAtIG0yMSAqIG0wMikgK1xuICAgICAgICAgICAgbTIwICogKG0wMSAqIG0xMiAtIG0xMSAqIG0wMik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbXB1dGVzIHRoZSBpbnZlcnNlIG9mIGEgMy1ieS0zIG1hdHJpeC4gKHNhbWUgYXMgaW52ZXJzZSlcbiAgICAgKiBAcGFyYW0gbSAtIFRoZSBtYXRyaXguXG4gICAgICogQHBhcmFtIGRzdCAtIG1hdHJpeCB0byBob2xkIHJlc3VsdC4gSWYgbm90IHBhc3NlZCBhIG5ldyBvbmUgaXMgY3JlYXRlZC5cbiAgICAgKiBAcmV0dXJucyBUaGUgaW52ZXJzZSBvZiBtLlxuICAgICAqL1xuICAgIGNvbnN0IGludmVydCA9IGludmVyc2U7XG4gICAgLyoqXG4gICAgICogTXVsdGlwbGllcyB0d28gMy1ieS0zIG1hdHJpY2VzIHdpdGggYSBvbiB0aGUgbGVmdCBhbmQgYiBvbiB0aGUgcmlnaHRcbiAgICAgKiBAcGFyYW0gYSAtIFRoZSBtYXRyaXggb24gdGhlIGxlZnQuXG4gICAgICogQHBhcmFtIGIgLSBUaGUgbWF0cml4IG9uIHRoZSByaWdodC5cbiAgICAgKiBAcGFyYW0gZHN0IC0gbWF0cml4IHRvIGhvbGQgcmVzdWx0LiBJZiBub3QgcGFzc2VkIGEgbmV3IG9uZSBpcyBjcmVhdGVkLlxuICAgICAqIEByZXR1cm5zIFRoZSBtYXRyaXggcHJvZHVjdCBvZiBhIGFuZCBiLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG11bHRpcGx5KGEsIGIsIGRzdCkge1xuICAgICAgICBjb25zdCBuZXdEc3QgPSAoZHN0ID8/IG5ldyBDdG9yKDEyKSk7XG4gICAgICAgIGNvbnN0IGEwMCA9IGFbMF07XG4gICAgICAgIGNvbnN0IGEwMSA9IGFbMV07XG4gICAgICAgIGNvbnN0IGEwMiA9IGFbMl07XG4gICAgICAgIGNvbnN0IGExMCA9IGFbNCArIDBdO1xuICAgICAgICBjb25zdCBhMTEgPSBhWzQgKyAxXTtcbiAgICAgICAgY29uc3QgYTEyID0gYVs0ICsgMl07XG4gICAgICAgIGNvbnN0IGEyMCA9IGFbOCArIDBdO1xuICAgICAgICBjb25zdCBhMjEgPSBhWzggKyAxXTtcbiAgICAgICAgY29uc3QgYTIyID0gYVs4ICsgMl07XG4gICAgICAgIGNvbnN0IGIwMCA9IGJbMF07XG4gICAgICAgIGNvbnN0IGIwMSA9IGJbMV07XG4gICAgICAgIGNvbnN0IGIwMiA9IGJbMl07XG4gICAgICAgIGNvbnN0IGIxMCA9IGJbNCArIDBdO1xuICAgICAgICBjb25zdCBiMTEgPSBiWzQgKyAxXTtcbiAgICAgICAgY29uc3QgYjEyID0gYls0ICsgMl07XG4gICAgICAgIGNvbnN0IGIyMCA9IGJbOCArIDBdO1xuICAgICAgICBjb25zdCBiMjEgPSBiWzggKyAxXTtcbiAgICAgICAgY29uc3QgYjIyID0gYls4ICsgMl07XG4gICAgICAgIG5ld0RzdFswXSA9IGEwMCAqIGIwMCArIGExMCAqIGIwMSArIGEyMCAqIGIwMjtcbiAgICAgICAgbmV3RHN0WzFdID0gYTAxICogYjAwICsgYTExICogYjAxICsgYTIxICogYjAyO1xuICAgICAgICBuZXdEc3RbMl0gPSBhMDIgKiBiMDAgKyBhMTIgKiBiMDEgKyBhMjIgKiBiMDI7XG4gICAgICAgIG5ld0RzdFs0XSA9IGEwMCAqIGIxMCArIGExMCAqIGIxMSArIGEyMCAqIGIxMjtcbiAgICAgICAgbmV3RHN0WzVdID0gYTAxICogYjEwICsgYTExICogYjExICsgYTIxICogYjEyO1xuICAgICAgICBuZXdEc3RbNl0gPSBhMDIgKiBiMTAgKyBhMTIgKiBiMTEgKyBhMjIgKiBiMTI7XG4gICAgICAgIG5ld0RzdFs4XSA9IGEwMCAqIGIyMCArIGExMCAqIGIyMSArIGEyMCAqIGIyMjtcbiAgICAgICAgbmV3RHN0WzldID0gYTAxICogYjIwICsgYTExICogYjIxICsgYTIxICogYjIyO1xuICAgICAgICBuZXdEc3RbMTBdID0gYTAyICogYjIwICsgYTEyICogYjIxICsgYTIyICogYjIyO1xuICAgICAgICByZXR1cm4gbmV3RHN0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBNdWx0aXBsaWVzIHR3byAzLWJ5LTMgbWF0cmljZXMgd2l0aCBhIG9uIHRoZSBsZWZ0IGFuZCBiIG9uIHRoZSByaWdodCAoc2FtZSBhcyBtdWx0aXBseSlcbiAgICAgKiBAcGFyYW0gYSAtIFRoZSBtYXRyaXggb24gdGhlIGxlZnQuXG4gICAgICogQHBhcmFtIGIgLSBUaGUgbWF0cml4IG9uIHRoZSByaWdodC5cbiAgICAgKiBAcGFyYW0gZHN0IC0gbWF0cml4IHRvIGhvbGQgcmVzdWx0LiBJZiBub3QgcGFzc2VkIGEgbmV3IG9uZSBpcyBjcmVhdGVkLlxuICAgICAqIEByZXR1cm5zIFRoZSBtYXRyaXggcHJvZHVjdCBvZiBhIGFuZCBiLlxuICAgICAqL1xuICAgIGNvbnN0IG11bCA9IG11bHRpcGx5O1xuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIHRyYW5zbGF0aW9uIGNvbXBvbmVudCBvZiBhIDMtYnktMyBtYXRyaXggdG8gdGhlIGdpdmVuXG4gICAgICogdmVjdG9yLlxuICAgICAqIEBwYXJhbSBhIC0gVGhlIG1hdHJpeC5cbiAgICAgKiBAcGFyYW0gdiAtIFRoZSB2ZWN0b3IuXG4gICAgICogQHBhcmFtIGRzdCAtIG1hdHJpeCB0byBob2xkIHJlc3VsdC4gSWYgbm90IHBhc3NlZCBhIG5ldyBvbmUgaXMgY3JlYXRlZC5cbiAgICAgKiBAcmV0dXJucyBUaGUgbWF0cml4IHdpdGggdHJhbnNsYXRpb24gc2V0LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNldFRyYW5zbGF0aW9uKGEsIHYsIGRzdCkge1xuICAgICAgICBjb25zdCBuZXdEc3QgPSAoZHN0ID8/IGlkZW50aXR5KCkpO1xuICAgICAgICBpZiAoYSAhPT0gbmV3RHN0KSB7XG4gICAgICAgICAgICBuZXdEc3RbMF0gPSBhWzBdO1xuICAgICAgICAgICAgbmV3RHN0WzFdID0gYVsxXTtcbiAgICAgICAgICAgIG5ld0RzdFsyXSA9IGFbMl07XG4gICAgICAgICAgICBuZXdEc3RbNF0gPSBhWzRdO1xuICAgICAgICAgICAgbmV3RHN0WzVdID0gYVs1XTtcbiAgICAgICAgICAgIG5ld0RzdFs2XSA9IGFbNl07XG4gICAgICAgIH1cbiAgICAgICAgbmV3RHN0WzhdID0gdlswXTtcbiAgICAgICAgbmV3RHN0WzldID0gdlsxXTtcbiAgICAgICAgbmV3RHN0WzEwXSA9IDE7XG4gICAgICAgIHJldHVybiBuZXdEc3Q7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHRyYW5zbGF0aW9uIGNvbXBvbmVudCBvZiBhIDMtYnktMyBtYXRyaXggYXMgYSB2ZWN0b3Igd2l0aCAzXG4gICAgICogZW50cmllcy5cbiAgICAgKiBAcGFyYW0gbSAtIFRoZSBtYXRyaXguXG4gICAgICogQHBhcmFtIGRzdCAtIHZlY3RvciB0byBob2xkIHJlc3VsdC4gSWYgbm90IHBhc3NlZCBhIG5ldyBvbmUgaXMgY3JlYXRlZC5cbiAgICAgKiBAcmV0dXJucyBUaGUgdHJhbnNsYXRpb24gY29tcG9uZW50IG9mIG0uXG4gICAgICovXG4gICAgZnVuY3Rpb24gZ2V0VHJhbnNsYXRpb24obSwgZHN0KSB7XG4gICAgICAgIGNvbnN0IG5ld0RzdCA9IChkc3QgPz8gdmVjMi5jcmVhdGUoKSk7XG4gICAgICAgIG5ld0RzdFswXSA9IG1bOF07XG4gICAgICAgIG5ld0RzdFsxXSA9IG1bOV07XG4gICAgICAgIHJldHVybiBuZXdEc3Q7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYW4gYXhpcyBvZiBhIDN4MyBtYXRyaXggYXMgYSB2ZWN0b3Igd2l0aCAyIGVudHJpZXNcbiAgICAgKiBAcGFyYW0gbSAtIFRoZSBtYXRyaXguXG4gICAgICogQHBhcmFtIGF4aXMgLSBUaGUgYXhpcyAwID0geCwgMSA9IHksXG4gICAgICogQHJldHVybnMgVGhlIGF4aXMgY29tcG9uZW50IG9mIG0uXG4gICAgICovXG4gICAgZnVuY3Rpb24gZ2V0QXhpcyhtLCBheGlzLCBkc3QpIHtcbiAgICAgICAgY29uc3QgbmV3RHN0ID0gKGRzdCA/PyB2ZWMyLmNyZWF0ZSgpKTtcbiAgICAgICAgY29uc3Qgb2ZmID0gYXhpcyAqIDQ7XG4gICAgICAgIG5ld0RzdFswXSA9IG1bb2ZmICsgMF07XG4gICAgICAgIG5ld0RzdFsxXSA9IG1bb2ZmICsgMV07XG4gICAgICAgIHJldHVybiBuZXdEc3Q7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldHMgYW4gYXhpcyBvZiBhIDN4MyBtYXRyaXggYXMgYSB2ZWN0b3Igd2l0aCAyIGVudHJpZXNcbiAgICAgKiBAcGFyYW0gbSAtIFRoZSBtYXRyaXguXG4gICAgICogQHBhcmFtIHYgLSB0aGUgYXhpcyB2ZWN0b3JcbiAgICAgKiBAcGFyYW0gYXhpcyAtIFRoZSBheGlzICAwID0geCwgMSA9IHk7XG4gICAgICogQHBhcmFtIGRzdCAtIFRoZSBtYXRyaXggdG8gc2V0LiBJZiBub3QgcGFzc2VkIGEgbmV3IG9uZSBpcyBjcmVhdGVkLlxuICAgICAqIEByZXR1cm5zIFRoZSBtYXRyaXggd2l0aCBheGlzIHNldC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzZXRBeGlzKG0sIHYsIGF4aXMsIGRzdCkge1xuICAgICAgICBjb25zdCBuZXdEc3QgPSAoZHN0ID09PSBtID8gbSA6IGNvcHkobSwgZHN0KSk7XG4gICAgICAgIGNvbnN0IG9mZiA9IGF4aXMgKiA0O1xuICAgICAgICBuZXdEc3Rbb2ZmICsgMF0gPSB2WzBdO1xuICAgICAgICBuZXdEc3Rbb2ZmICsgMV0gPSB2WzFdO1xuICAgICAgICByZXR1cm4gbmV3RHN0O1xuICAgIH1cbiAgICAvLy8qKlxuICAgIC8vICogUmV0dXJucyB0aGUgc2NhbGluZyBjb21wb25lbnQgb2YgdGhlIG1hdHJpeFxuICAgIC8vICogQHBhcmFtIG0gLSBUaGUgTWF0cml4XG4gICAgLy8gKiBAcGFyYW0gZHN0IC0gVGhlIHZlY3RvciB0byBzZXQuIElmIG5vdCBwYXNzZWQgYSBuZXcgb25lIGlzIGNyZWF0ZWQuXG4gICAgLy8gKi9cbiAgICBmdW5jdGlvbiBnZXRTY2FsaW5nKG0sIGRzdCkge1xuICAgICAgICBjb25zdCBuZXdEc3QgPSAoZHN0ID8/IHZlYzIuY3JlYXRlKCkpO1xuICAgICAgICBjb25zdCB4eCA9IG1bMF07XG4gICAgICAgIGNvbnN0IHh5ID0gbVsxXTtcbiAgICAgICAgY29uc3QgeXggPSBtWzRdO1xuICAgICAgICBjb25zdCB5eSA9IG1bNV07XG4gICAgICAgIG5ld0RzdFswXSA9IE1hdGguc3FydCh4eCAqIHh4ICsgeHkgKiB4eSk7XG4gICAgICAgIG5ld0RzdFsxXSA9IE1hdGguc3FydCh5eCAqIHl4ICsgeXkgKiB5eSk7XG4gICAgICAgIHJldHVybiBuZXdEc3Q7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSAzLWJ5LTMgbWF0cml4IHdoaWNoIHRyYW5zbGF0ZXMgYnkgdGhlIGdpdmVuIHZlY3RvciB2LlxuICAgICAqIEBwYXJhbSB2IC0gVGhlIHZlY3RvciBieSB3aGljaCB0byB0cmFuc2xhdGUuXG4gICAgICogQHBhcmFtIGRzdCAtIG1hdHJpeCB0byBob2xkIHJlc3VsdC4gSWYgbm90IHBhc3NlZCBhIG5ldyBvbmUgaXMgY3JlYXRlZC5cbiAgICAgKiBAcmV0dXJucyBUaGUgdHJhbnNsYXRpb24gbWF0cml4LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRyYW5zbGF0aW9uKHYsIGRzdCkge1xuICAgICAgICBjb25zdCBuZXdEc3QgPSAoZHN0ID8/IG5ldyBDdG9yKDEyKSk7XG4gICAgICAgIG5ld0RzdFswXSA9IDE7XG4gICAgICAgIG5ld0RzdFsxXSA9IDA7XG4gICAgICAgIG5ld0RzdFsyXSA9IDA7XG4gICAgICAgIG5ld0RzdFs0XSA9IDA7XG4gICAgICAgIG5ld0RzdFs1XSA9IDE7XG4gICAgICAgIG5ld0RzdFs2XSA9IDA7XG4gICAgICAgIG5ld0RzdFs4XSA9IHZbMF07XG4gICAgICAgIG5ld0RzdFs5XSA9IHZbMV07XG4gICAgICAgIG5ld0RzdFsxMF0gPSAxO1xuICAgICAgICByZXR1cm4gbmV3RHN0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUcmFuc2xhdGVzIHRoZSBnaXZlbiAzLWJ5LTMgbWF0cml4IGJ5IHRoZSBnaXZlbiB2ZWN0b3Igdi5cbiAgICAgKiBAcGFyYW0gbSAtIFRoZSBtYXRyaXguXG4gICAgICogQHBhcmFtIHYgLSBUaGUgdmVjdG9yIGJ5IHdoaWNoIHRvIHRyYW5zbGF0ZS5cbiAgICAgKiBAcGFyYW0gZHN0IC0gbWF0cml4IHRvIGhvbGQgcmVzdWx0LiBJZiBub3QgcGFzc2VkIGEgbmV3IG9uZSBpcyBjcmVhdGVkLlxuICAgICAqIEByZXR1cm5zIFRoZSB0cmFuc2xhdGVkIG1hdHJpeC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0cmFuc2xhdGUobSwgdiwgZHN0KSB7XG4gICAgICAgIGNvbnN0IG5ld0RzdCA9IChkc3QgPz8gbmV3IEN0b3IoMTIpKTtcbiAgICAgICAgY29uc3QgdjAgPSB2WzBdO1xuICAgICAgICBjb25zdCB2MSA9IHZbMV07XG4gICAgICAgIGNvbnN0IG0wMCA9IG1bMF07XG4gICAgICAgIGNvbnN0IG0wMSA9IG1bMV07XG4gICAgICAgIGNvbnN0IG0wMiA9IG1bMl07XG4gICAgICAgIGNvbnN0IG0xMCA9IG1bMSAqIDQgKyAwXTtcbiAgICAgICAgY29uc3QgbTExID0gbVsxICogNCArIDFdO1xuICAgICAgICBjb25zdCBtMTIgPSBtWzEgKiA0ICsgMl07XG4gICAgICAgIGNvbnN0IG0yMCA9IG1bMiAqIDQgKyAwXTtcbiAgICAgICAgY29uc3QgbTIxID0gbVsyICogNCArIDFdO1xuICAgICAgICBjb25zdCBtMjIgPSBtWzIgKiA0ICsgMl07XG4gICAgICAgIGlmIChtICE9PSBuZXdEc3QpIHtcbiAgICAgICAgICAgIG5ld0RzdFswXSA9IG0wMDtcbiAgICAgICAgICAgIG5ld0RzdFsxXSA9IG0wMTtcbiAgICAgICAgICAgIG5ld0RzdFsyXSA9IG0wMjtcbiAgICAgICAgICAgIG5ld0RzdFs0XSA9IG0xMDtcbiAgICAgICAgICAgIG5ld0RzdFs1XSA9IG0xMTtcbiAgICAgICAgICAgIG5ld0RzdFs2XSA9IG0xMjtcbiAgICAgICAgfVxuICAgICAgICBuZXdEc3RbOF0gPSBtMDAgKiB2MCArIG0xMCAqIHYxICsgbTIwO1xuICAgICAgICBuZXdEc3RbOV0gPSBtMDEgKiB2MCArIG0xMSAqIHYxICsgbTIxO1xuICAgICAgICBuZXdEc3RbMTBdID0gbTAyICogdjAgKyBtMTIgKiB2MSArIG0yMjtcbiAgICAgICAgcmV0dXJuIG5ld0RzdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIDMtYnktMyBtYXRyaXggd2hpY2ggcm90YXRlcyAgYnkgdGhlIGdpdmVuIGFuZ2xlLlxuICAgICAqIEBwYXJhbSBhbmdsZUluUmFkaWFucyAtIFRoZSBhbmdsZSBieSB3aGljaCB0byByb3RhdGUgKGluIHJhZGlhbnMpLlxuICAgICAqIEBwYXJhbSBkc3QgLSBtYXRyaXggdG8gaG9sZCByZXN1bHQuIElmIG5vdCBwYXNzZWQgYSBuZXcgb25lIGlzIGNyZWF0ZWQuXG4gICAgICogQHJldHVybnMgVGhlIHJvdGF0aW9uIG1hdHJpeC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiByb3RhdGlvbihhbmdsZUluUmFkaWFucywgZHN0KSB7XG4gICAgICAgIGNvbnN0IG5ld0RzdCA9IChkc3QgPz8gbmV3IEN0b3IoMTIpKTtcbiAgICAgICAgY29uc3QgYyA9IE1hdGguY29zKGFuZ2xlSW5SYWRpYW5zKTtcbiAgICAgICAgY29uc3QgcyA9IE1hdGguc2luKGFuZ2xlSW5SYWRpYW5zKTtcbiAgICAgICAgbmV3RHN0WzBdID0gYztcbiAgICAgICAgbmV3RHN0WzFdID0gcztcbiAgICAgICAgbmV3RHN0WzJdID0gMDtcbiAgICAgICAgbmV3RHN0WzRdID0gLXM7XG4gICAgICAgIG5ld0RzdFs1XSA9IGM7XG4gICAgICAgIG5ld0RzdFs2XSA9IDA7XG4gICAgICAgIG5ld0RzdFs4XSA9IDA7XG4gICAgICAgIG5ld0RzdFs5XSA9IDA7XG4gICAgICAgIG5ld0RzdFsxMF0gPSAxO1xuICAgICAgICByZXR1cm4gbmV3RHN0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSb3RhdGVzIHRoZSBnaXZlbiAzLWJ5LTMgbWF0cml4ICBieSB0aGUgZ2l2ZW4gYW5nbGUuXG4gICAgICogQHBhcmFtIG0gLSBUaGUgbWF0cml4LlxuICAgICAqIEBwYXJhbSBhbmdsZUluUmFkaWFucyAtIFRoZSBhbmdsZSBieSB3aGljaCB0byByb3RhdGUgKGluIHJhZGlhbnMpLlxuICAgICAqIEBwYXJhbSBkc3QgLSBtYXRyaXggdG8gaG9sZCByZXN1bHQuIElmIG5vdCBwYXNzZWQgYSBuZXcgb25lIGlzIGNyZWF0ZWQuXG4gICAgICogQHJldHVybnMgVGhlIHJvdGF0ZWQgbWF0cml4LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHJvdGF0ZShtLCBhbmdsZUluUmFkaWFucywgZHN0KSB7XG4gICAgICAgIGNvbnN0IG5ld0RzdCA9IChkc3QgPz8gbmV3IEN0b3IoMTIpKTtcbiAgICAgICAgY29uc3QgbTAwID0gbVswICogNCArIDBdO1xuICAgICAgICBjb25zdCBtMDEgPSBtWzAgKiA0ICsgMV07XG4gICAgICAgIGNvbnN0IG0wMiA9IG1bMCAqIDQgKyAyXTtcbiAgICAgICAgY29uc3QgbTEwID0gbVsxICogNCArIDBdO1xuICAgICAgICBjb25zdCBtMTEgPSBtWzEgKiA0ICsgMV07XG4gICAgICAgIGNvbnN0IG0xMiA9IG1bMSAqIDQgKyAyXTtcbiAgICAgICAgY29uc3QgYyA9IE1hdGguY29zKGFuZ2xlSW5SYWRpYW5zKTtcbiAgICAgICAgY29uc3QgcyA9IE1hdGguc2luKGFuZ2xlSW5SYWRpYW5zKTtcbiAgICAgICAgbmV3RHN0WzBdID0gYyAqIG0wMCArIHMgKiBtMTA7XG4gICAgICAgIG5ld0RzdFsxXSA9IGMgKiBtMDEgKyBzICogbTExO1xuICAgICAgICBuZXdEc3RbMl0gPSBjICogbTAyICsgcyAqIG0xMjtcbiAgICAgICAgbmV3RHN0WzRdID0gYyAqIG0xMCAtIHMgKiBtMDA7XG4gICAgICAgIG5ld0RzdFs1XSA9IGMgKiBtMTEgLSBzICogbTAxO1xuICAgICAgICBuZXdEc3RbNl0gPSBjICogbTEyIC0gcyAqIG0wMjtcbiAgICAgICAgaWYgKG0gIT09IG5ld0RzdCkge1xuICAgICAgICAgICAgbmV3RHN0WzhdID0gbVs4XTtcbiAgICAgICAgICAgIG5ld0RzdFs5XSA9IG1bOV07XG4gICAgICAgICAgICBuZXdEc3RbMTBdID0gbVsxMF07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ld0RzdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIDMtYnktMyBtYXRyaXggd2hpY2ggc2NhbGVzIGluIGVhY2ggZGltZW5zaW9uIGJ5IGFuIGFtb3VudCBnaXZlbiBieVxuICAgICAqIHRoZSBjb3JyZXNwb25kaW5nIGVudHJ5IGluIHRoZSBnaXZlbiB2ZWN0b3I7IGFzc3VtZXMgdGhlIHZlY3RvciBoYXMgdGhyZWVcbiAgICAgKiBlbnRyaWVzLlxuICAgICAqIEBwYXJhbSB2IC0gQSB2ZWN0b3Igb2ZcbiAgICAgKiAgICAgMiBlbnRyaWVzIHNwZWNpZnlpbmcgdGhlIGZhY3RvciBieSB3aGljaCB0byBzY2FsZSBpbiBlYWNoIGRpbWVuc2lvbi5cbiAgICAgKiBAcGFyYW0gZHN0IC0gbWF0cml4IHRvIGhvbGQgcmVzdWx0LiBJZiBub3QgcGFzc2VkIGEgbmV3IG9uZSBpcyBjcmVhdGVkLlxuICAgICAqIEByZXR1cm5zIFRoZSBzY2FsaW5nIG1hdHJpeC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzY2FsaW5nKHYsIGRzdCkge1xuICAgICAgICBjb25zdCBuZXdEc3QgPSAoZHN0ID8/IG5ldyBDdG9yKDEyKSk7XG4gICAgICAgIG5ld0RzdFswXSA9IHZbMF07XG4gICAgICAgIG5ld0RzdFsxXSA9IDA7XG4gICAgICAgIG5ld0RzdFsyXSA9IDA7XG4gICAgICAgIG5ld0RzdFs0XSA9IDA7XG4gICAgICAgIG5ld0RzdFs1XSA9IHZbMV07XG4gICAgICAgIG5ld0RzdFs2XSA9IDA7XG4gICAgICAgIG5ld0RzdFs4XSA9IDA7XG4gICAgICAgIG5ld0RzdFs5XSA9IDA7XG4gICAgICAgIG5ld0RzdFsxMF0gPSAxO1xuICAgICAgICByZXR1cm4gbmV3RHN0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTY2FsZXMgdGhlIGdpdmVuIDMtYnktMyBtYXRyaXggaW4gZWFjaCBkaW1lbnNpb24gYnkgYW4gYW1vdW50XG4gICAgICogZ2l2ZW4gYnkgdGhlIGNvcnJlc3BvbmRpbmcgZW50cnkgaW4gdGhlIGdpdmVuIHZlY3RvcjsgYXNzdW1lcyB0aGUgdmVjdG9yIGhhc1xuICAgICAqIHRocmVlIGVudHJpZXMuXG4gICAgICogQHBhcmFtIG0gLSBUaGUgbWF0cml4IHRvIGJlIG1vZGlmaWVkLlxuICAgICAqIEBwYXJhbSB2IC0gQSB2ZWN0b3Igb2YgMiBlbnRyaWVzIHNwZWNpZnlpbmcgdGhlXG4gICAgICogICAgIGZhY3RvciBieSB3aGljaCB0byBzY2FsZSBpbiBlYWNoIGRpbWVuc2lvbi5cbiAgICAgKiBAcGFyYW0gZHN0IC0gbWF0cml4IHRvIGhvbGQgcmVzdWx0LiBJZiBub3QgcGFzc2VkIGEgbmV3IG9uZSBpcyBjcmVhdGVkLlxuICAgICAqIEByZXR1cm5zIFRoZSBzY2FsZWQgbWF0cml4LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNjYWxlKG0sIHYsIGRzdCkge1xuICAgICAgICBjb25zdCBuZXdEc3QgPSAoZHN0ID8/IG5ldyBDdG9yKDEyKSk7XG4gICAgICAgIGNvbnN0IHYwID0gdlswXTtcbiAgICAgICAgY29uc3QgdjEgPSB2WzFdO1xuICAgICAgICBuZXdEc3RbMF0gPSB2MCAqIG1bMCAqIDQgKyAwXTtcbiAgICAgICAgbmV3RHN0WzFdID0gdjAgKiBtWzAgKiA0ICsgMV07XG4gICAgICAgIG5ld0RzdFsyXSA9IHYwICogbVswICogNCArIDJdO1xuICAgICAgICBuZXdEc3RbNF0gPSB2MSAqIG1bMSAqIDQgKyAwXTtcbiAgICAgICAgbmV3RHN0WzVdID0gdjEgKiBtWzEgKiA0ICsgMV07XG4gICAgICAgIG5ld0RzdFs2XSA9IHYxICogbVsxICogNCArIDJdO1xuICAgICAgICBpZiAobSAhPT0gbmV3RHN0KSB7XG4gICAgICAgICAgICBuZXdEc3RbOF0gPSBtWzhdO1xuICAgICAgICAgICAgbmV3RHN0WzldID0gbVs5XTtcbiAgICAgICAgICAgIG5ld0RzdFsxMF0gPSBtWzEwXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3RHN0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgMy1ieS0zIG1hdHJpeCB3aGljaCBzY2FsZXMgdW5pZm9ybWx5IGluIGVhY2ggZGltZW5zaW9uXG4gICAgICogQHBhcmFtIHMgLSBBbW91bnQgdG8gc2NhbGVcbiAgICAgKiBAcGFyYW0gZHN0IC0gbWF0cml4IHRvIGhvbGQgcmVzdWx0LiBJZiBub3QgcGFzc2VkIGEgbmV3IG9uZSBpcyBjcmVhdGVkLlxuICAgICAqIEByZXR1cm5zIFRoZSBzY2FsaW5nIG1hdHJpeC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB1bmlmb3JtU2NhbGluZyhzLCBkc3QpIHtcbiAgICAgICAgY29uc3QgbmV3RHN0ID0gKGRzdCA/PyBuZXcgQ3RvcigxMikpO1xuICAgICAgICBuZXdEc3RbMF0gPSBzO1xuICAgICAgICBuZXdEc3RbMV0gPSAwO1xuICAgICAgICBuZXdEc3RbMl0gPSAwO1xuICAgICAgICBuZXdEc3RbNF0gPSAwO1xuICAgICAgICBuZXdEc3RbNV0gPSBzO1xuICAgICAgICBuZXdEc3RbNl0gPSAwO1xuICAgICAgICBuZXdEc3RbOF0gPSAwO1xuICAgICAgICBuZXdEc3RbOV0gPSAwO1xuICAgICAgICBuZXdEc3RbMTBdID0gMTtcbiAgICAgICAgcmV0dXJuIG5ld0RzdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2NhbGVzIHRoZSBnaXZlbiAzLWJ5LTMgbWF0cml4IGluIGVhY2ggZGltZW5zaW9uIGJ5IGFuIGFtb3VudFxuICAgICAqIGdpdmVuLlxuICAgICAqIEBwYXJhbSBtIC0gVGhlIG1hdHJpeCB0byBiZSBtb2RpZmllZC5cbiAgICAgKiBAcGFyYW0gcyAtIEFtb3VudCB0byBzY2FsZS5cbiAgICAgKiBAcGFyYW0gZHN0IC0gbWF0cml4IHRvIGhvbGQgcmVzdWx0LiBJZiBub3QgcGFzc2VkIGEgbmV3IG9uZSBpcyBjcmVhdGVkLlxuICAgICAqIEByZXR1cm5zIFRoZSBzY2FsZWQgbWF0cml4LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHVuaWZvcm1TY2FsZShtLCBzLCBkc3QpIHtcbiAgICAgICAgY29uc3QgbmV3RHN0ID0gKGRzdCA/PyBuZXcgQ3RvcigxMikpO1xuICAgICAgICBuZXdEc3RbMF0gPSBzICogbVswICogNCArIDBdO1xuICAgICAgICBuZXdEc3RbMV0gPSBzICogbVswICogNCArIDFdO1xuICAgICAgICBuZXdEc3RbMl0gPSBzICogbVswICogNCArIDJdO1xuICAgICAgICBuZXdEc3RbNF0gPSBzICogbVsxICogNCArIDBdO1xuICAgICAgICBuZXdEc3RbNV0gPSBzICogbVsxICogNCArIDFdO1xuICAgICAgICBuZXdEc3RbNl0gPSBzICogbVsxICogNCArIDJdO1xuICAgICAgICBpZiAobSAhPT0gbmV3RHN0KSB7XG4gICAgICAgICAgICBuZXdEc3RbOF0gPSBtWzhdO1xuICAgICAgICAgICAgbmV3RHN0WzldID0gbVs5XTtcbiAgICAgICAgICAgIG5ld0RzdFsxMF0gPSBtWzEwXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3RHN0O1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBjbG9uZSxcbiAgICAgICAgY3JlYXRlLFxuICAgICAgICBzZXQsXG4gICAgICAgIGZyb21NYXQ0LFxuICAgICAgICBmcm9tUXVhdCxcbiAgICAgICAgbmVnYXRlLFxuICAgICAgICBjb3B5LFxuICAgICAgICBlcXVhbHNBcHByb3hpbWF0ZWx5LFxuICAgICAgICBlcXVhbHMsXG4gICAgICAgIGlkZW50aXR5LFxuICAgICAgICB0cmFuc3Bvc2UsXG4gICAgICAgIGludmVyc2UsXG4gICAgICAgIGludmVydCxcbiAgICAgICAgZGV0ZXJtaW5hbnQsXG4gICAgICAgIG11bCxcbiAgICAgICAgbXVsdGlwbHksXG4gICAgICAgIHNldFRyYW5zbGF0aW9uLFxuICAgICAgICBnZXRUcmFuc2xhdGlvbixcbiAgICAgICAgZ2V0QXhpcyxcbiAgICAgICAgc2V0QXhpcyxcbiAgICAgICAgZ2V0U2NhbGluZyxcbiAgICAgICAgdHJhbnNsYXRpb24sXG4gICAgICAgIHRyYW5zbGF0ZSxcbiAgICAgICAgcm90YXRpb24sXG4gICAgICAgIHJvdGF0ZSxcbiAgICAgICAgc2NhbGluZyxcbiAgICAgICAgc2NhbGUsXG4gICAgICAgIHVuaWZvcm1TY2FsaW5nLFxuICAgICAgICB1bmlmb3JtU2NhbGUsXG4gICAgfTtcbn1cbmNvbnN0IGNhY2hlJDQgPSBuZXcgTWFwKCk7XG5mdW5jdGlvbiBnZXRBUEkkNChDdG9yKSB7XG4gICAgbGV0IGFwaSA9IGNhY2hlJDQuZ2V0KEN0b3IpO1xuICAgIGlmICghYXBpKSB7XG4gICAgICAgIGFwaSA9IGdldEFQSUltcGwkNChDdG9yKTtcbiAgICAgICAgY2FjaGUkNC5zZXQoQ3RvciwgYXBpKTtcbiAgICB9XG4gICAgcmV0dXJuIGFwaTtcbn1cblxuLypcbiAqIENvcHlyaWdodCAyMDIyIEdyZWdnIFRhdmFyZXNcbiAqXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuICogY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLFxuICogdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvblxuICogdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsXG4gKiBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGVcbiAqIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4gKlxuICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbiAqIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuICpcbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbiAqIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gIElOIE5PIEVWRU5UIFNIQUxMXG4gKiBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuICogTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkdcbiAqIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVJcbiAqIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cbiAqL1xuLyoqXG4gKiBHZW5lcmF0ZXMgYW0gdHlwZWQgQVBJIGZvciBWZWMzXG4gKiAqL1xuZnVuY3Rpb24gZ2V0QVBJSW1wbCQzKEN0b3IpIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgdmVjMzsgbWF5IGJlIGNhbGxlZCB3aXRoIHgsIHksIHogdG8gc2V0IGluaXRpYWwgdmFsdWVzLlxuICAgICAqIEBwYXJhbSB4IC0gSW5pdGlhbCB4IHZhbHVlLlxuICAgICAqIEBwYXJhbSB5IC0gSW5pdGlhbCB5IHZhbHVlLlxuICAgICAqIEBwYXJhbSB6IC0gSW5pdGlhbCB6IHZhbHVlLlxuICAgICAqIEByZXR1cm5zIHRoZSBjcmVhdGVkIHZlY3RvclxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZSh4LCB5LCB6KSB7XG4gICAgICAgIGNvbnN0IG5ld0RzdCA9IG5ldyBDdG9yKDMpO1xuICAgICAgICBpZiAoeCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBuZXdEc3RbMF0gPSB4O1xuICAgICAgICAgICAgaWYgKHkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIG5ld0RzdFsxXSA9IHk7XG4gICAgICAgICAgICAgICAgaWYgKHogIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICBuZXdEc3RbMl0gPSB6O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3RHN0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgdmVjMzsgbWF5IGJlIGNhbGxlZCB3aXRoIHgsIHksIHogdG8gc2V0IGluaXRpYWwgdmFsdWVzLiAoc2FtZSBhcyBjcmVhdGUpXG4gICAgICogQHBhcmFtIHggLSBJbml0aWFsIHggdmFsdWUuXG4gICAgICogQHBhcmFtIHkgLSBJbml0aWFsIHkgdmFsdWUuXG4gICAgICogQHBhcmFtIHogLSBJbml0aWFsIHogdmFsdWUuXG4gICAgICogQHJldHVybnMgdGhlIGNyZWF0ZWQgdmVjdG9yXG4gICAgICovXG4gICAgY29uc3QgZnJvbVZhbHVlcyA9IGNyZWF0ZTtcbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSB2YWx1ZXMgb2YgYSBWZWMzXG4gICAgICogQWxzbyBzZWUge0BsaW5rIHZlYzMuY3JlYXRlfSBhbmQge0BsaW5rIHZlYzMuY29weX1cbiAgICAgKlxuICAgICAqIEBwYXJhbSB4IGZpcnN0IHZhbHVlXG4gICAgICogQHBhcmFtIHkgc2Vjb25kIHZhbHVlXG4gICAgICogQHBhcmFtIHogdGhpcmQgdmFsdWVcbiAgICAgKiBAcGFyYW0gZHN0IC0gdmVjdG9yIHRvIGhvbGQgcmVzdWx0LiBJZiBub3QgcGFzc2VkIGluIGEgbmV3IG9uZSBpcyBjcmVhdGVkLlxuICAgICAqIEByZXR1cm5zIEEgdmVjdG9yIHdpdGggaXRzIGVsZW1lbnRzIHNldC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzZXQoeCwgeSwgeiwgZHN0KSB7XG4gICAgICAgIGNvbnN0IG5ld0RzdCA9IChkc3QgPz8gbmV3IEN0b3IoMykpO1xuICAgICAgICBuZXdEc3RbMF0gPSB4O1xuICAgICAgICBuZXdEc3RbMV0gPSB5O1xuICAgICAgICBuZXdEc3RbMl0gPSB6O1xuICAgICAgICByZXR1cm4gbmV3RHN0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBcHBsaWVzIE1hdGguY2VpbCB0byBlYWNoIGVsZW1lbnQgb2YgdmVjdG9yXG4gICAgICogQHBhcmFtIHYgLSBPcGVyYW5kIHZlY3Rvci5cbiAgICAgKiBAcGFyYW0gZHN0IC0gdmVjdG9yIHRvIGhvbGQgcmVzdWx0LiBJZiBub3QgcGFzc2VkIGluIGEgbmV3IG9uZSBpcyBjcmVhdGVkLlxuICAgICAqIEByZXR1cm5zIEEgdmVjdG9yIHRoYXQgaXMgdGhlIGNlaWwgb2YgZWFjaCBlbGVtZW50IG9mIHYuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY2VpbCh2LCBkc3QpIHtcbiAgICAgICAgY29uc3QgbmV3RHN0ID0gKGRzdCA/PyBuZXcgQ3RvcigzKSk7XG4gICAgICAgIG5ld0RzdFswXSA9IE1hdGguY2VpbCh2WzBdKTtcbiAgICAgICAgbmV3RHN0WzFdID0gTWF0aC5jZWlsKHZbMV0pO1xuICAgICAgICBuZXdEc3RbMl0gPSBNYXRoLmNlaWwodlsyXSk7XG4gICAgICAgIHJldHVybiBuZXdEc3Q7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFwcGxpZXMgTWF0aC5mbG9vciB0byBlYWNoIGVsZW1lbnQgb2YgdmVjdG9yXG4gICAgICogQHBhcmFtIHYgLSBPcGVyYW5kIHZlY3Rvci5cbiAgICAgKiBAcGFyYW0gZHN0IC0gdmVjdG9yIHRvIGhvbGQgcmVzdWx0LiBJZiBub3QgcGFzc2VkIGluIGEgbmV3IG9uZSBpcyBjcmVhdGVkLlxuICAgICAqIEByZXR1cm5zIEEgdmVjdG9yIHRoYXQgaXMgdGhlIGZsb29yIG9mIGVhY2ggZWxlbWVudCBvZiB2LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZsb29yKHYsIGRzdCkge1xuICAgICAgICBjb25zdCBuZXdEc3QgPSAoZHN0ID8/IG5ldyBDdG9yKDMpKTtcbiAgICAgICAgbmV3RHN0WzBdID0gTWF0aC5mbG9vcih2WzBdKTtcbiAgICAgICAgbmV3RHN0WzFdID0gTWF0aC5mbG9vcih2WzFdKTtcbiAgICAgICAgbmV3RHN0WzJdID0gTWF0aC5mbG9vcih2WzJdKTtcbiAgICAgICAgcmV0dXJuIG5ld0RzdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQXBwbGllcyBNYXRoLnJvdW5kIHRvIGVhY2ggZWxlbWVudCBvZiB2ZWN0b3JcbiAgICAgKiBAcGFyYW0gdiAtIE9wZXJhbmQgdmVjdG9yLlxuICAgICAqIEBwYXJhbSBkc3QgLSB2ZWN0b3IgdG8gaG9sZCByZXN1bHQuIElmIG5vdCBwYXNzZWQgaW4gYSBuZXcgb25lIGlzIGNyZWF0ZWQuXG4gICAgICogQHJldHVybnMgQSB2ZWN0b3IgdGhhdCBpcyB0aGUgcm91bmQgb2YgZWFjaCBlbGVtZW50IG9mIHYuXG4gICAgICovXG4gICAgZnVuY3Rpb24gcm91bmQodiwgZHN0KSB7XG4gICAgICAgIGNvbnN0IG5ld0RzdCA9IChkc3QgPz8gbmV3IEN0b3IoMykpO1xuICAgICAgICBuZXdEc3RbMF0gPSBNYXRoLnJvdW5kKHZbMF0pO1xuICAgICAgICBuZXdEc3RbMV0gPSBNYXRoLnJvdW5kKHZbMV0pO1xuICAgICAgICBuZXdEc3RbMl0gPSBNYXRoLnJvdW5kKHZbMl0pO1xuICAgICAgICByZXR1cm4gbmV3RHN0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDbGFtcCBlYWNoIGVsZW1lbnQgb2YgdmVjdG9yIGJldHdlZW4gbWluIGFuZCBtYXhcbiAgICAgKiBAcGFyYW0gdiAtIE9wZXJhbmQgdmVjdG9yLlxuICAgICAqIEBwYXJhbSBtYXggLSBNaW4gdmFsdWUsIGRlZmF1bHQgMFxuICAgICAqIEBwYXJhbSBtaW4gLSBNYXggdmFsdWUsIGRlZmF1bHQgMVxuICAgICAqIEBwYXJhbSBkc3QgLSB2ZWN0b3IgdG8gaG9sZCByZXN1bHQuIElmIG5vdCBwYXNzZWQgaW4gYSBuZXcgb25lIGlzIGNyZWF0ZWQuXG4gICAgICogQHJldHVybnMgQSB2ZWN0b3IgdGhhdCB0aGUgY2xhbXBlZCB2YWx1ZSBvZiBlYWNoIGVsZW1lbnQgb2Ygdi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjbGFtcCh2LCBtaW4gPSAwLCBtYXggPSAxLCBkc3QpIHtcbiAgICAgICAgY29uc3QgbmV3RHN0ID0gKGRzdCA/PyBuZXcgQ3RvcigzKSk7XG4gICAgICAgIG5ld0RzdFswXSA9IE1hdGgubWluKG1heCwgTWF0aC5tYXgobWluLCB2WzBdKSk7XG4gICAgICAgIG5ld0RzdFsxXSA9IE1hdGgubWluKG1heCwgTWF0aC5tYXgobWluLCB2WzFdKSk7XG4gICAgICAgIG5ld0RzdFsyXSA9IE1hdGgubWluKG1heCwgTWF0aC5tYXgobWluLCB2WzJdKSk7XG4gICAgICAgIHJldHVybiBuZXdEc3Q7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkZHMgdHdvIHZlY3RvcnM7IGFzc3VtZXMgYSBhbmQgYiBoYXZlIHRoZSBzYW1lIGRpbWVuc2lvbi5cbiAgICAgKiBAcGFyYW0gYSAtIE9wZXJhbmQgdmVjdG9yLlxuICAgICAqIEBwYXJhbSBiIC0gT3BlcmFuZCB2ZWN0b3IuXG4gICAgICogQHBhcmFtIGRzdCAtIHZlY3RvciB0byBob2xkIHJlc3VsdC4gSWYgbm90IHBhc3NlZCBpbiBhIG5ldyBvbmUgaXMgY3JlYXRlZC5cbiAgICAgKiBAcmV0dXJucyBBIHZlY3RvciB0aGF0IGlzIHRoZSBzdW0gb2YgYSBhbmQgYi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBhZGQoYSwgYiwgZHN0KSB7XG4gICAgICAgIGNvbnN0IG5ld0RzdCA9IChkc3QgPz8gbmV3IEN0b3IoMykpO1xuICAgICAgICBuZXdEc3RbMF0gPSBhWzBdICsgYlswXTtcbiAgICAgICAgbmV3RHN0WzFdID0gYVsxXSArIGJbMV07XG4gICAgICAgIG5ld0RzdFsyXSA9IGFbMl0gKyBiWzJdO1xuICAgICAgICByZXR1cm4gbmV3RHN0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGRzIHR3byB2ZWN0b3JzLCBzY2FsaW5nIHRoZSAybmQ7IGFzc3VtZXMgYSBhbmQgYiBoYXZlIHRoZSBzYW1lIGRpbWVuc2lvbi5cbiAgICAgKiBAcGFyYW0gYSAtIE9wZXJhbmQgdmVjdG9yLlxuICAgICAqIEBwYXJhbSBiIC0gT3BlcmFuZCB2ZWN0b3IuXG4gICAgICogQHBhcmFtIHNjYWxlIC0gQW1vdW50IHRvIHNjYWxlIGJcbiAgICAgKiBAcGFyYW0gZHN0IC0gdmVjdG9yIHRvIGhvbGQgcmVzdWx0LiBJZiBub3QgcGFzc2VkIGluIGEgbmV3IG9uZSBpcyBjcmVhdGVkLlxuICAgICAqIEByZXR1cm5zIEEgdmVjdG9yIHRoYXQgaXMgdGhlIHN1bSBvZiBhICsgYiAqIHNjYWxlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGFkZFNjYWxlZChhLCBiLCBzY2FsZSwgZHN0KSB7XG4gICAgICAgIGNvbnN0IG5ld0RzdCA9IChkc3QgPz8gbmV3IEN0b3IoMykpO1xuICAgICAgICBuZXdEc3RbMF0gPSBhWzBdICsgYlswXSAqIHNjYWxlO1xuICAgICAgICBuZXdEc3RbMV0gPSBhWzFdICsgYlsxXSAqIHNjYWxlO1xuICAgICAgICBuZXdEc3RbMl0gPSBhWzJdICsgYlsyXSAqIHNjYWxlO1xuICAgICAgICByZXR1cm4gbmV3RHN0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBhbmdsZSBpbiByYWRpYW5zIGJldHdlZW4gdHdvIHZlY3RvcnMuXG4gICAgICogQHBhcmFtIGEgLSBPcGVyYW5kIHZlY3Rvci5cbiAgICAgKiBAcGFyYW0gYiAtIE9wZXJhbmQgdmVjdG9yLlxuICAgICAqIEByZXR1cm5zIFRoZSBhbmdsZSBpbiByYWRpYW5zIGJldHdlZW4gdGhlIDIgdmVjdG9ycy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBhbmdsZShhLCBiKSB7XG4gICAgICAgIGNvbnN0IGF4ID0gYVswXTtcbiAgICAgICAgY29uc3QgYXkgPSBhWzFdO1xuICAgICAgICBjb25zdCBheiA9IGFbMl07XG4gICAgICAgIGNvbnN0IGJ4ID0gYlswXTtcbiAgICAgICAgY29uc3QgYnkgPSBiWzFdO1xuICAgICAgICBjb25zdCBieiA9IGJbMl07XG4gICAgICAgIGNvbnN0IG1hZzEgPSBNYXRoLnNxcnQoYXggKiBheCArIGF5ICogYXkgKyBheiAqIGF6KTtcbiAgICAgICAgY29uc3QgbWFnMiA9IE1hdGguc3FydChieCAqIGJ4ICsgYnkgKiBieSArIGJ6ICogYnopO1xuICAgICAgICBjb25zdCBtYWcgPSBtYWcxICogbWFnMjtcbiAgICAgICAgY29uc3QgY29zaW5lID0gbWFnICYmIGRvdChhLCBiKSAvIG1hZztcbiAgICAgICAgcmV0dXJuIE1hdGguYWNvcyhjb3NpbmUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTdWJ0cmFjdHMgdHdvIHZlY3RvcnMuXG4gICAgICogQHBhcmFtIGEgLSBPcGVyYW5kIHZlY3Rvci5cbiAgICAgKiBAcGFyYW0gYiAtIE9wZXJhbmQgdmVjdG9yLlxuICAgICAqIEBwYXJhbSBkc3QgLSB2ZWN0b3IgdG8gaG9sZCByZXN1bHQuIElmIG5vdCBwYXNzZWQgaW4gYSBuZXcgb25lIGlzIGNyZWF0ZWQuXG4gICAgICogQHJldHVybnMgQSB2ZWN0b3IgdGhhdCBpcyB0aGUgZGlmZmVyZW5jZSBvZiBhIGFuZCBiLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHN1YnRyYWN0KGEsIGIsIGRzdCkge1xuICAgICAgICBjb25zdCBuZXdEc3QgPSAoZHN0ID8/IG5ldyBDdG9yKDMpKTtcbiAgICAgICAgbmV3RHN0WzBdID0gYVswXSAtIGJbMF07XG4gICAgICAgIG5ld0RzdFsxXSA9IGFbMV0gLSBiWzFdO1xuICAgICAgICBuZXdEc3RbMl0gPSBhWzJdIC0gYlsyXTtcbiAgICAgICAgcmV0dXJuIG5ld0RzdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU3VidHJhY3RzIHR3byB2ZWN0b3JzLlxuICAgICAqIEBwYXJhbSBhIC0gT3BlcmFuZCB2ZWN0b3IuXG4gICAgICogQHBhcmFtIGIgLSBPcGVyYW5kIHZlY3Rvci5cbiAgICAgKiBAcGFyYW0gZHN0IC0gdmVjdG9yIHRvIGhvbGQgcmVzdWx0LiBJZiBub3QgcGFzc2VkIGluIGEgbmV3IG9uZSBpcyBjcmVhdGVkLlxuICAgICAqIEByZXR1cm5zIEEgdmVjdG9yIHRoYXQgaXMgdGhlIGRpZmZlcmVuY2Ugb2YgYSBhbmQgYi5cbiAgICAgKi9cbiAgICBjb25zdCBzdWIgPSBzdWJ0cmFjdDtcbiAgICAvKipcbiAgICAgKiBDaGVjayBpZiAyIHZlY3RvcnMgYXJlIGFwcHJveGltYXRlbHkgZXF1YWxcbiAgICAgKiBAcGFyYW0gYSAtIE9wZXJhbmQgdmVjdG9yLlxuICAgICAqIEBwYXJhbSBiIC0gT3BlcmFuZCB2ZWN0b3IuXG4gICAgICogQHJldHVybnMgdHJ1ZSBpZiB2ZWN0b3JzIGFyZSBhcHByb3hpbWF0ZWx5IGVxdWFsXG4gICAgICovXG4gICAgZnVuY3Rpb24gZXF1YWxzQXBwcm94aW1hdGVseShhLCBiKSB7XG4gICAgICAgIHJldHVybiBNYXRoLmFicyhhWzBdIC0gYlswXSkgPCBFUFNJTE9OICYmXG4gICAgICAgICAgICBNYXRoLmFicyhhWzFdIC0gYlsxXSkgPCBFUFNJTE9OICYmXG4gICAgICAgICAgICBNYXRoLmFicyhhWzJdIC0gYlsyXSkgPCBFUFNJTE9OO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDaGVjayBpZiAyIHZlY3RvcnMgYXJlIGV4YWN0bHkgZXF1YWxcbiAgICAgKiBAcGFyYW0gYSAtIE9wZXJhbmQgdmVjdG9yLlxuICAgICAqIEBwYXJhbSBiIC0gT3BlcmFuZCB2ZWN0b3IuXG4gICAgICogQHJldHVybnMgdHJ1ZSBpZiB2ZWN0b3JzIGFyZSBleGFjdGx5IGVxdWFsXG4gICAgICovXG4gICAgZnVuY3Rpb24gZXF1YWxzKGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIGFbMF0gPT09IGJbMF0gJiYgYVsxXSA9PT0gYlsxXSAmJiBhWzJdID09PSBiWzJdO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQZXJmb3JtcyBsaW5lYXIgaW50ZXJwb2xhdGlvbiBvbiB0d28gdmVjdG9ycy5cbiAgICAgKiBHaXZlbiB2ZWN0b3JzIGEgYW5kIGIgYW5kIGludGVycG9sYXRpb24gY29lZmZpY2llbnQgdCwgcmV0dXJuc1xuICAgICAqIGEgKyB0ICogKGIgLSBhKS5cbiAgICAgKiBAcGFyYW0gYSAtIE9wZXJhbmQgdmVjdG9yLlxuICAgICAqIEBwYXJhbSBiIC0gT3BlcmFuZCB2ZWN0b3IuXG4gICAgICogQHBhcmFtIHQgLSBJbnRlcnBvbGF0aW9uIGNvZWZmaWNpZW50LlxuICAgICAqIEBwYXJhbSBkc3QgLSB2ZWN0b3IgdG8gaG9sZCByZXN1bHQuIElmIG5vdCBwYXNzZWQgaW4gYSBuZXcgb25lIGlzIGNyZWF0ZWQuXG4gICAgICogQHJldHVybnMgVGhlIGxpbmVhciBpbnRlcnBvbGF0ZWQgcmVzdWx0LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGxlcnAoYSwgYiwgdCwgZHN0KSB7XG4gICAgICAgIGNvbnN0IG5ld0RzdCA9IChkc3QgPz8gbmV3IEN0b3IoMykpO1xuICAgICAgICBuZXdEc3RbMF0gPSBhWzBdICsgdCAqIChiWzBdIC0gYVswXSk7XG4gICAgICAgIG5ld0RzdFsxXSA9IGFbMV0gKyB0ICogKGJbMV0gLSBhWzFdKTtcbiAgICAgICAgbmV3RHN0WzJdID0gYVsyXSArIHQgKiAoYlsyXSAtIGFbMl0pO1xuICAgICAgICByZXR1cm4gbmV3RHN0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQZXJmb3JtcyBsaW5lYXIgaW50ZXJwb2xhdGlvbiBvbiB0d28gdmVjdG9ycy5cbiAgICAgKiBHaXZlbiB2ZWN0b3JzIGEgYW5kIGIgYW5kIGludGVycG9sYXRpb24gY29lZmZpY2llbnQgdmVjdG9yIHQsIHJldHVybnNcbiAgICAgKiBhICsgdCAqIChiIC0gYSkuXG4gICAgICogQHBhcmFtIGEgLSBPcGVyYW5kIHZlY3Rvci5cbiAgICAgKiBAcGFyYW0gYiAtIE9wZXJhbmQgdmVjdG9yLlxuICAgICAqIEBwYXJhbSB0IC0gSW50ZXJwb2xhdGlvbiBjb2VmZmljaWVudHMgdmVjdG9yLlxuICAgICAqIEBwYXJhbSBkc3QgLSB2ZWN0b3IgdG8gaG9sZCByZXN1bHQuIElmIG5vdCBwYXNzZWQgaW4gYSBuZXcgb25lIGlzIGNyZWF0ZWQuXG4gICAgICogQHJldHVybnMgdGhlIGxpbmVhciBpbnRlcnBvbGF0ZWQgcmVzdWx0LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGxlcnBWKGEsIGIsIHQsIGRzdCkge1xuICAgICAgICBjb25zdCBuZXdEc3QgPSAoZHN0ID8/IG5ldyBDdG9yKDMpKTtcbiAgICAgICAgbmV3RHN0WzBdID0gYVswXSArIHRbMF0gKiAoYlswXSAtIGFbMF0pO1xuICAgICAgICBuZXdEc3RbMV0gPSBhWzFdICsgdFsxXSAqIChiWzFdIC0gYVsxXSk7XG4gICAgICAgIG5ld0RzdFsyXSA9IGFbMl0gKyB0WzJdICogKGJbMl0gLSBhWzJdKTtcbiAgICAgICAgcmV0dXJuIG5ld0RzdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJuIG1heCB2YWx1ZXMgb2YgdHdvIHZlY3RvcnMuXG4gICAgICogR2l2ZW4gdmVjdG9ycyBhIGFuZCBiIHJldHVybnNcbiAgICAgKiBbbWF4KGFbMF0sIGJbMF0pLCBtYXgoYVsxXSwgYlsxXSksIG1heChhWzJdLCBiWzJdKV0uXG4gICAgICogQHBhcmFtIGEgLSBPcGVyYW5kIHZlY3Rvci5cbiAgICAgKiBAcGFyYW0gYiAtIE9wZXJhbmQgdmVjdG9yLlxuICAgICAqIEBwYXJhbSBkc3QgLSB2ZWN0b3IgdG8gaG9sZCByZXN1bHQuIElmIG5vdCBwYXNzZWQgaW4gYSBuZXcgb25lIGlzIGNyZWF0ZWQuXG4gICAgICogQHJldHVybnMgVGhlIG1heCBjb21wb25lbnRzIHZlY3Rvci5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBtYXgoYSwgYiwgZHN0KSB7XG4gICAgICAgIGNvbnN0IG5ld0RzdCA9IChkc3QgPz8gbmV3IEN0b3IoMykpO1xuICAgICAgICBuZXdEc3RbMF0gPSBNYXRoLm1heChhWzBdLCBiWzBdKTtcbiAgICAgICAgbmV3RHN0WzFdID0gTWF0aC5tYXgoYVsxXSwgYlsxXSk7XG4gICAgICAgIG5ld0RzdFsyXSA9IE1hdGgubWF4KGFbMl0sIGJbMl0pO1xuICAgICAgICByZXR1cm4gbmV3RHN0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gbWluIHZhbHVlcyBvZiB0d28gdmVjdG9ycy5cbiAgICAgKiBHaXZlbiB2ZWN0b3JzIGEgYW5kIGIgcmV0dXJuc1xuICAgICAqIFttaW4oYVswXSwgYlswXSksIG1pbihhWzFdLCBiWzFdKSwgbWluKGFbMl0sIGJbMl0pXS5cbiAgICAgKiBAcGFyYW0gYSAtIE9wZXJhbmQgdmVjdG9yLlxuICAgICAqIEBwYXJhbSBiIC0gT3BlcmFuZCB2ZWN0b3IuXG4gICAgICogQHBhcmFtIGRzdCAtIHZlY3RvciB0byBob2xkIHJlc3VsdC4gSWYgbm90IHBhc3NlZCBpbiBhIG5ldyBvbmUgaXMgY3JlYXRlZC5cbiAgICAgKiBAcmV0dXJucyBUaGUgbWluIGNvbXBvbmVudHMgdmVjdG9yLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG1pbihhLCBiLCBkc3QpIHtcbiAgICAgICAgY29uc3QgbmV3RHN0ID0gKGRzdCA/PyBuZXcgQ3RvcigzKSk7XG4gICAgICAgIG5ld0RzdFswXSA9IE1hdGgubWluKGFbMF0sIGJbMF0pO1xuICAgICAgICBuZXdEc3RbMV0gPSBNYXRoLm1pbihhWzFdLCBiWzFdKTtcbiAgICAgICAgbmV3RHN0WzJdID0gTWF0aC5taW4oYVsyXSwgYlsyXSk7XG4gICAgICAgIHJldHVybiBuZXdEc3Q7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE11bHRpcGxpZXMgYSB2ZWN0b3IgYnkgYSBzY2FsYXIuXG4gICAgICogQHBhcmFtIHYgLSBUaGUgdmVjdG9yLlxuICAgICAqIEBwYXJhbSBrIC0gVGhlIHNjYWxhci5cbiAgICAgKiBAcGFyYW0gZHN0IC0gdmVjdG9yIHRvIGhvbGQgcmVzdWx0LiBJZiBub3QgcGFzc2VkIGluIGEgbmV3IG9uZSBpcyBjcmVhdGVkLlxuICAgICAqIEByZXR1cm5zIFRoZSBzY2FsZWQgdmVjdG9yLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG11bFNjYWxhcih2LCBrLCBkc3QpIHtcbiAgICAgICAgY29uc3QgbmV3RHN0ID0gKGRzdCA/PyBuZXcgQ3RvcigzKSk7XG4gICAgICAgIG5ld0RzdFswXSA9IHZbMF0gKiBrO1xuICAgICAgICBuZXdEc3RbMV0gPSB2WzFdICogaztcbiAgICAgICAgbmV3RHN0WzJdID0gdlsyXSAqIGs7XG4gICAgICAgIHJldHVybiBuZXdEc3Q7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE11bHRpcGxpZXMgYSB2ZWN0b3IgYnkgYSBzY2FsYXIuIChzYW1lIGFzIG11bFNjYWxhcilcbiAgICAgKiBAcGFyYW0gdiAtIFRoZSB2ZWN0b3IuXG4gICAgICogQHBhcmFtIGsgLSBUaGUgc2NhbGFyLlxuICAgICAqIEBwYXJhbSBkc3QgLSB2ZWN0b3IgdG8gaG9sZCByZXN1bHQuIElmIG5vdCBwYXNzZWQgaW4gYSBuZXcgb25lIGlzIGNyZWF0ZWQuXG4gICAgICogQHJldHVybnMgVGhlIHNjYWxlZCB2ZWN0b3IuXG4gICAgICovXG4gICAgY29uc3Qgc2NhbGUgPSBtdWxTY2FsYXI7XG4gICAgLyoqXG4gICAgICogRGl2aWRlcyBhIHZlY3RvciBieSBhIHNjYWxhci5cbiAgICAgKiBAcGFyYW0gdiAtIFRoZSB2ZWN0b3IuXG4gICAgICogQHBhcmFtIGsgLSBUaGUgc2NhbGFyLlxuICAgICAqIEBwYXJhbSBkc3QgLSB2ZWN0b3IgdG8gaG9sZCByZXN1bHQuIElmIG5vdCBwYXNzZWQgaW4gYSBuZXcgb25lIGlzIGNyZWF0ZWQuXG4gICAgICogQHJldHVybnMgVGhlIHNjYWxlZCB2ZWN0b3IuXG4gICAgICovXG4gICAgZnVuY3Rpb24gZGl2U2NhbGFyKHYsIGssIGRzdCkge1xuICAgICAgICBjb25zdCBuZXdEc3QgPSAoZHN0ID8/IG5ldyBDdG9yKDMpKTtcbiAgICAgICAgbmV3RHN0WzBdID0gdlswXSAvIGs7XG4gICAgICAgIG5ld0RzdFsxXSA9IHZbMV0gLyBrO1xuICAgICAgICBuZXdEc3RbMl0gPSB2WzJdIC8gaztcbiAgICAgICAgcmV0dXJuIG5ld0RzdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSW52ZXJzZSBhIHZlY3Rvci5cbiAgICAgKiBAcGFyYW0gdiAtIFRoZSB2ZWN0b3IuXG4gICAgICogQHBhcmFtIGRzdCAtIHZlY3RvciB0byBob2xkIHJlc3VsdC4gSWYgbm90IHBhc3NlZCBpbiBhIG5ldyBvbmUgaXMgY3JlYXRlZC5cbiAgICAgKiBAcmV0dXJucyBUaGUgaW52ZXJ0ZWQgdmVjdG9yLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGludmVyc2UodiwgZHN0KSB7XG4gICAgICAgIGNvbnN0IG5ld0RzdCA9IChkc3QgPz8gbmV3IEN0b3IoMykpO1xuICAgICAgICBuZXdEc3RbMF0gPSAxIC8gdlswXTtcbiAgICAgICAgbmV3RHN0WzFdID0gMSAvIHZbMV07XG4gICAgICAgIG5ld0RzdFsyXSA9IDEgLyB2WzJdO1xuICAgICAgICByZXR1cm4gbmV3RHN0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJbnZlcnQgYSB2ZWN0b3IuIChzYW1lIGFzIGludmVyc2UpXG4gICAgICogQHBhcmFtIHYgLSBUaGUgdmVjdG9yLlxuICAgICAqIEBwYXJhbSBkc3QgLSB2ZWN0b3IgdG8gaG9sZCByZXN1bHQuIElmIG5vdCBwYXNzZWQgaW4gYSBuZXcgb25lIGlzIGNyZWF0ZWQuXG4gICAgICogQHJldHVybnMgVGhlIGludmVydGVkIHZlY3Rvci5cbiAgICAgKi9cbiAgICBjb25zdCBpbnZlcnQgPSBpbnZlcnNlO1xuICAgIC8qKlxuICAgICAqIENvbXB1dGVzIHRoZSBjcm9zcyBwcm9kdWN0IG9mIHR3byB2ZWN0b3JzOyBhc3N1bWVzIGJvdGggdmVjdG9ycyBoYXZlXG4gICAgICogdGhyZWUgZW50cmllcy5cbiAgICAgKiBAcGFyYW0gYSAtIE9wZXJhbmQgdmVjdG9yLlxuICAgICAqIEBwYXJhbSBiIC0gT3BlcmFuZCB2ZWN0b3IuXG4gICAgICogQHBhcmFtIGRzdCAtIHZlY3RvciB0byBob2xkIHJlc3VsdC4gSWYgbm90IHBhc3NlZCBpbiBhIG5ldyBvbmUgaXMgY3JlYXRlZC5cbiAgICAgKiBAcmV0dXJucyBUaGUgdmVjdG9yIG9mIGEgY3Jvc3MgYi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcm9zcyhhLCBiLCBkc3QpIHtcbiAgICAgICAgY29uc3QgbmV3RHN0ID0gKGRzdCA/PyBuZXcgQ3RvcigzKSk7XG4gICAgICAgIGNvbnN0IHQxID0gYVsyXSAqIGJbMF0gLSBhWzBdICogYlsyXTtcbiAgICAgICAgY29uc3QgdDIgPSBhWzBdICogYlsxXSAtIGFbMV0gKiBiWzBdO1xuICAgICAgICBuZXdEc3RbMF0gPSBhWzFdICogYlsyXSAtIGFbMl0gKiBiWzFdO1xuICAgICAgICBuZXdEc3RbMV0gPSB0MTtcbiAgICAgICAgbmV3RHN0WzJdID0gdDI7XG4gICAgICAgIHJldHVybiBuZXdEc3Q7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbXB1dGVzIHRoZSBkb3QgcHJvZHVjdCBvZiB0d28gdmVjdG9yczsgYXNzdW1lcyBib3RoIHZlY3RvcnMgaGF2ZVxuICAgICAqIHRocmVlIGVudHJpZXMuXG4gICAgICogQHBhcmFtIGEgLSBPcGVyYW5kIHZlY3Rvci5cbiAgICAgKiBAcGFyYW0gYiAtIE9wZXJhbmQgdmVjdG9yLlxuICAgICAqIEByZXR1cm5zIGRvdCBwcm9kdWN0XG4gICAgICovXG4gICAgZnVuY3Rpb24gZG90KGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIChhWzBdICogYlswXSkgKyAoYVsxXSAqIGJbMV0pICsgKGFbMl0gKiBiWzJdKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29tcHV0ZXMgdGhlIGxlbmd0aCBvZiB2ZWN0b3JcbiAgICAgKiBAcGFyYW0gdiAtIHZlY3Rvci5cbiAgICAgKiBAcmV0dXJucyBsZW5ndGggb2YgdmVjdG9yLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGxlbmd0aCh2KSB7XG4gICAgICAgIGNvbnN0IHYwID0gdlswXTtcbiAgICAgICAgY29uc3QgdjEgPSB2WzFdO1xuICAgICAgICBjb25zdCB2MiA9IHZbMl07XG4gICAgICAgIHJldHVybiBNYXRoLnNxcnQodjAgKiB2MCArIHYxICogdjEgKyB2MiAqIHYyKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29tcHV0ZXMgdGhlIGxlbmd0aCBvZiB2ZWN0b3IgKHNhbWUgYXMgbGVuZ3RoKVxuICAgICAqIEBwYXJhbSB2IC0gdmVjdG9yLlxuICAgICAqIEByZXR1cm5zIGxlbmd0aCBvZiB2ZWN0b3IuXG4gICAgICovXG4gICAgY29uc3QgbGVuID0gbGVuZ3RoO1xuICAgIC8qKlxuICAgICAqIENvbXB1dGVzIHRoZSBzcXVhcmUgb2YgdGhlIGxlbmd0aCBvZiB2ZWN0b3JcbiAgICAgKiBAcGFyYW0gdiAtIHZlY3Rvci5cbiAgICAgKiBAcmV0dXJucyBzcXVhcmUgb2YgdGhlIGxlbmd0aCBvZiB2ZWN0b3IuXG4gICAgICovXG4gICAgZnVuY3Rpb24gbGVuZ3RoU3Eodikge1xuICAgICAgICBjb25zdCB2MCA9IHZbMF07XG4gICAgICAgIGNvbnN0IHYxID0gdlsxXTtcbiAgICAgICAgY29uc3QgdjIgPSB2WzJdO1xuICAgICAgICByZXR1cm4gdjAgKiB2MCArIHYxICogdjEgKyB2MiAqIHYyO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb21wdXRlcyB0aGUgc3F1YXJlIG9mIHRoZSBsZW5ndGggb2YgdmVjdG9yIChzYW1lIGFzIGxlbmd0aFNxKVxuICAgICAqIEBwYXJhbSB2IC0gdmVjdG9yLlxuICAgICAqIEByZXR1cm5zIHNxdWFyZSBvZiB0aGUgbGVuZ3RoIG9mIHZlY3Rvci5cbiAgICAgKi9cbiAgICBjb25zdCBsZW5TcSA9IGxlbmd0aFNxO1xuICAgIC8qKlxuICAgICAqIENvbXB1dGVzIHRoZSBkaXN0YW5jZSBiZXR3ZWVuIDIgcG9pbnRzXG4gICAgICogQHBhcmFtIGEgLSB2ZWN0b3IuXG4gICAgICogQHBhcmFtIGIgLSB2ZWN0b3IuXG4gICAgICogQHJldHVybnMgZGlzdGFuY2UgYmV0d2VlbiBhIGFuZCBiXG4gICAgICovXG4gICAgZnVuY3Rpb24gZGlzdGFuY2UoYSwgYikge1xuICAgICAgICBjb25zdCBkeCA9IGFbMF0gLSBiWzBdO1xuICAgICAgICBjb25zdCBkeSA9IGFbMV0gLSBiWzFdO1xuICAgICAgICBjb25zdCBkeiA9IGFbMl0gLSBiWzJdO1xuICAgICAgICByZXR1cm4gTWF0aC5zcXJ0KGR4ICogZHggKyBkeSAqIGR5ICsgZHogKiBkeik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbXB1dGVzIHRoZSBkaXN0YW5jZSBiZXR3ZWVuIDIgcG9pbnRzIChzYW1lIGFzIGRpc3RhbmNlKVxuICAgICAqIEBwYXJhbSBhIC0gdmVjdG9yLlxuICAgICAqIEBwYXJhbSBiIC0gdmVjdG9yLlxuICAgICAqIEByZXR1cm5zIGRpc3RhbmNlIGJldHdlZW4gYSBhbmQgYlxuICAgICAqL1xuICAgIGNvbnN0IGRpc3QgPSBkaXN0YW5jZTtcbiAgICAvKipcbiAgICAgKiBDb21wdXRlcyB0aGUgc3F1YXJlIG9mIHRoZSBkaXN0YW5jZSBiZXR3ZWVuIDIgcG9pbnRzXG4gICAgICogQHBhcmFtIGEgLSB2ZWN0b3IuXG4gICAgICogQHBhcmFtIGIgLSB2ZWN0b3IuXG4gICAgICogQHJldHVybnMgc3F1YXJlIG9mIHRoZSBkaXN0YW5jZSBiZXR3ZWVuIGEgYW5kIGJcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBkaXN0YW5jZVNxKGEsIGIpIHtcbiAgICAgICAgY29uc3QgZHggPSBhWzBdIC0gYlswXTtcbiAgICAgICAgY29uc3QgZHkgPSBhWzFdIC0gYlsxXTtcbiAgICAgICAgY29uc3QgZHogPSBhWzJdIC0gYlsyXTtcbiAgICAgICAgcmV0dXJuIGR4ICogZHggKyBkeSAqIGR5ICsgZHogKiBkejtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29tcHV0ZXMgdGhlIHNxdWFyZSBvZiB0aGUgZGlzdGFuY2UgYmV0d2VlbiAyIHBvaW50cyAoc2FtZSBhcyBkaXN0YW5jZVNxKVxuICAgICAqIEBwYXJhbSBhIC0gdmVjdG9yLlxuICAgICAqIEBwYXJhbSBiIC0gdmVjdG9yLlxuICAgICAqIEByZXR1cm5zIHNxdWFyZSBvZiB0aGUgZGlzdGFuY2UgYmV0d2VlbiBhIGFuZCBiXG4gICAgICovXG4gICAgY29uc3QgZGlzdFNxID0gZGlzdGFuY2VTcTtcbiAgICAvKipcbiAgICAgKiBEaXZpZGVzIGEgdmVjdG9yIGJ5IGl0cyBFdWNsaWRlYW4gbGVuZ3RoIGFuZCByZXR1cm5zIHRoZSBxdW90aWVudC5cbiAgICAgKiBAcGFyYW0gdiAtIFRoZSB2ZWN0b3IuXG4gICAgICogQHBhcmFtIGRzdCAtIHZlY3RvciB0byBob2xkIHJlc3VsdC4gSWYgbm90IHBhc3NlZCBpbiBhIG5ldyBvbmUgaXMgY3JlYXRlZC5cbiAgICAgKiBAcmV0dXJucyBUaGUgbm9ybWFsaXplZCB2ZWN0b3IuXG4gICAgICovXG4gICAgZnVuY3Rpb24gbm9ybWFsaXplKHYsIGRzdCkge1xuICAgICAgICBjb25zdCBuZXdEc3QgPSAoZHN0ID8/IG5ldyBDdG9yKDMpKTtcbiAgICAgICAgY29uc3QgdjAgPSB2WzBdO1xuICAgICAgICBjb25zdCB2MSA9IHZbMV07XG4gICAgICAgIGNvbnN0IHYyID0gdlsyXTtcbiAgICAgICAgY29uc3QgbGVuID0gTWF0aC5zcXJ0KHYwICogdjAgKyB2MSAqIHYxICsgdjIgKiB2Mik7XG4gICAgICAgIGlmIChsZW4gPiAwLjAwMDAxKSB7XG4gICAgICAgICAgICBuZXdEc3RbMF0gPSB2MCAvIGxlbjtcbiAgICAgICAgICAgIG5ld0RzdFsxXSA9IHYxIC8gbGVuO1xuICAgICAgICAgICAgbmV3RHN0WzJdID0gdjIgLyBsZW47XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBuZXdEc3RbMF0gPSAwO1xuICAgICAgICAgICAgbmV3RHN0WzFdID0gMDtcbiAgICAgICAgICAgIG5ld0RzdFsyXSA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ld0RzdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTmVnYXRlcyBhIHZlY3Rvci5cbiAgICAgKiBAcGFyYW0gdiAtIFRoZSB2ZWN0b3IuXG4gICAgICogQHBhcmFtIGRzdCAtIHZlY3RvciB0byBob2xkIHJlc3VsdC4gSWYgbm90IHBhc3NlZCBpbiBhIG5ldyBvbmUgaXMgY3JlYXRlZC5cbiAgICAgKiBAcmV0dXJucyAtdi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBuZWdhdGUodiwgZHN0KSB7XG4gICAgICAgIGNvbnN0IG5ld0RzdCA9IChkc3QgPz8gbmV3IEN0b3IoMykpO1xuICAgICAgICBuZXdEc3RbMF0gPSAtdlswXTtcbiAgICAgICAgbmV3RHN0WzFdID0gLXZbMV07XG4gICAgICAgIG5ld0RzdFsyXSA9IC12WzJdO1xuICAgICAgICByZXR1cm4gbmV3RHN0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb3BpZXMgYSB2ZWN0b3IuIChzYW1lIGFzIHtAbGluayB2ZWMzLmNsb25lfSlcbiAgICAgKiBBbHNvIHNlZSB7QGxpbmsgdmVjMy5jcmVhdGV9IGFuZCB7QGxpbmsgdmVjMy5zZXR9XG4gICAgICogQHBhcmFtIHYgLSBUaGUgdmVjdG9yLlxuICAgICAqIEBwYXJhbSBkc3QgLSB2ZWN0b3IgdG8gaG9sZCByZXN1bHQuIElmIG5vdCBwYXNzZWQgaW4gYSBuZXcgb25lIGlzIGNyZWF0ZWQuXG4gICAgICogQHJldHVybnMgQSBjb3B5IG9mIHYuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY29weSh2LCBkc3QpIHtcbiAgICAgICAgY29uc3QgbmV3RHN0ID0gKGRzdCA/PyBuZXcgQ3RvcigzKSk7XG4gICAgICAgIG5ld0RzdFswXSA9IHZbMF07XG4gICAgICAgIG5ld0RzdFsxXSA9IHZbMV07XG4gICAgICAgIG5ld0RzdFsyXSA9IHZbMl07XG4gICAgICAgIHJldHVybiBuZXdEc3Q7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENsb25lcyBhIHZlY3Rvci4gKHNhbWUgYXMge0BsaW5rIHZlYzMuY29weX0pXG4gICAgICogQWxzbyBzZWUge0BsaW5rIHZlYzMuY3JlYXRlfSBhbmQge0BsaW5rIHZlYzMuc2V0fVxuICAgICAqIEBwYXJhbSB2IC0gVGhlIHZlY3Rvci5cbiAgICAgKiBAcGFyYW0gZHN0IC0gdmVjdG9yIHRvIGhvbGQgcmVzdWx0LiBJZiBub3QgcGFzc2VkIGluIGEgbmV3IG9uZSBpcyBjcmVhdGVkLlxuICAgICAqIEByZXR1cm5zIEEgY29weSBvZiB2LlxuICAgICAqL1xuICAgIGNvbnN0IGNsb25lID0gY29weTtcbiAgICAvKipcbiAgICAgKiBNdWx0aXBsaWVzIGEgdmVjdG9yIGJ5IGFub3RoZXIgdmVjdG9yIChjb21wb25lbnQtd2lzZSk7IGFzc3VtZXMgYSBhbmRcbiAgICAgKiBiIGhhdmUgdGhlIHNhbWUgbGVuZ3RoLlxuICAgICAqIEBwYXJhbSBhIC0gT3BlcmFuZCB2ZWN0b3IuXG4gICAgICogQHBhcmFtIGIgLSBPcGVyYW5kIHZlY3Rvci5cbiAgICAgKiBAcGFyYW0gZHN0IC0gdmVjdG9yIHRvIGhvbGQgcmVzdWx0LiBJZiBub3QgcGFzc2VkIGluIGEgbmV3IG9uZSBpcyBjcmVhdGVkLlxuICAgICAqIEByZXR1cm5zIFRoZSB2ZWN0b3Igb2YgcHJvZHVjdHMgb2YgZW50cmllcyBvZiBhIGFuZCBiLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG11bHRpcGx5KGEsIGIsIGRzdCkge1xuICAgICAgICBjb25zdCBuZXdEc3QgPSAoZHN0ID8/IG5ldyBDdG9yKDMpKTtcbiAgICAgICAgbmV3RHN0WzBdID0gYVswXSAqIGJbMF07XG4gICAgICAgIG5ld0RzdFsxXSA9IGFbMV0gKiBiWzFdO1xuICAgICAgICBuZXdEc3RbMl0gPSBhWzJdICogYlsyXTtcbiAgICAgICAgcmV0dXJuIG5ld0RzdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTXVsdGlwbGllcyBhIHZlY3RvciBieSBhbm90aGVyIHZlY3RvciAoY29tcG9uZW50LXdpc2UpOyBhc3N1bWVzIGEgYW5kXG4gICAgICogYiBoYXZlIHRoZSBzYW1lIGxlbmd0aC4gKHNhbWUgYXMgbXVsKVxuICAgICAqIEBwYXJhbSBhIC0gT3BlcmFuZCB2ZWN0b3IuXG4gICAgICogQHBhcmFtIGIgLSBPcGVyYW5kIHZlY3Rvci5cbiAgICAgKiBAcGFyYW0gZHN0IC0gdmVjdG9yIHRvIGhvbGQgcmVzdWx0LiBJZiBub3QgcGFzc2VkIGluIGEgbmV3IG9uZSBpcyBjcmVhdGVkLlxuICAgICAqIEByZXR1cm5zIFRoZSB2ZWN0b3Igb2YgcHJvZHVjdHMgb2YgZW50cmllcyBvZiBhIGFuZCBiLlxuICAgICAqL1xuICAgIGNvbnN0IG11bCA9IG11bHRpcGx5O1xuICAgIC8qKlxuICAgICAqIERpdmlkZXMgYSB2ZWN0b3IgYnkgYW5vdGhlciB2ZWN0b3IgKGNvbXBvbmVudC13aXNlKTsgYXNzdW1lcyBhIGFuZFxuICAgICAqIGIgaGF2ZSB0aGUgc2FtZSBsZW5ndGguXG4gICAgICogQHBhcmFtIGEgLSBPcGVyYW5kIHZlY3Rvci5cbiAgICAgKiBAcGFyYW0gYiAtIE9wZXJhbmQgdmVjdG9yLlxuICAgICAqIEBwYXJhbSBkc3QgLSB2ZWN0b3IgdG8gaG9sZCByZXN1bHQuIElmIG5vdCBwYXNzZWQgaW4gYSBuZXcgb25lIGlzIGNyZWF0ZWQuXG4gICAgICogQHJldHVybnMgVGhlIHZlY3RvciBvZiBxdW90aWVudHMgb2YgZW50cmllcyBvZiBhIGFuZCBiLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGRpdmlkZShhLCBiLCBkc3QpIHtcbiAgICAgICAgY29uc3QgbmV3RHN0ID0gKGRzdCA/PyBuZXcgQ3RvcigzKSk7XG4gICAgICAgIG5ld0RzdFswXSA9IGFbMF0gLyBiWzBdO1xuICAgICAgICBuZXdEc3RbMV0gPSBhWzFdIC8gYlsxXTtcbiAgICAgICAgbmV3RHN0WzJdID0gYVsyXSAvIGJbMl07XG4gICAgICAgIHJldHVybiBuZXdEc3Q7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERpdmlkZXMgYSB2ZWN0b3IgYnkgYW5vdGhlciB2ZWN0b3IgKGNvbXBvbmVudC13aXNlKTsgYXNzdW1lcyBhIGFuZFxuICAgICAqIGIgaGF2ZSB0aGUgc2FtZSBsZW5ndGguIChzYW1lIGFzIGRpdmlkZSlcbiAgICAgKiBAcGFyYW0gYSAtIE9wZXJhbmQgdmVjdG9yLlxuICAgICAqIEBwYXJhbSBiIC0gT3BlcmFuZCB2ZWN0b3IuXG4gICAgICogQHBhcmFtIGRzdCAtIHZlY3RvciB0byBob2xkIHJlc3VsdC4gSWYgbm90IHBhc3NlZCBpbiBhIG5ldyBvbmUgaXMgY3JlYXRlZC5cbiAgICAgKiBAcmV0dXJucyBUaGUgdmVjdG9yIG9mIHF1b3RpZW50cyBvZiBlbnRyaWVzIG9mIGEgYW5kIGIuXG4gICAgICovXG4gICAgY29uc3QgZGl2ID0gZGl2aWRlO1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSByYW5kb20gdmVjdG9yXG4gICAgICogQHBhcmFtIHNjYWxlIC0gRGVmYXVsdCAxXG4gICAgICogQHBhcmFtIGRzdCAtIHZlY3RvciB0byBob2xkIHJlc3VsdC4gSWYgbm90IHBhc3NlZCBpbiBhIG5ldyBvbmUgaXMgY3JlYXRlZC5cbiAgICAgKiBAcmV0dXJucyBUaGUgcmFuZG9tIHZlY3Rvci5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiByYW5kb20oc2NhbGUgPSAxLCBkc3QpIHtcbiAgICAgICAgY29uc3QgbmV3RHN0ID0gKGRzdCA/PyBuZXcgQ3RvcigzKSk7XG4gICAgICAgIGNvbnN0IGFuZ2xlID0gTWF0aC5yYW5kb20oKSAqIDIgKiBNYXRoLlBJO1xuICAgICAgICBjb25zdCB6ID0gTWF0aC5yYW5kb20oKSAqIDIgLSAxO1xuICAgICAgICBjb25zdCB6U2NhbGUgPSBNYXRoLnNxcnQoMSAtIHogKiB6KSAqIHNjYWxlO1xuICAgICAgICBuZXdEc3RbMF0gPSBNYXRoLmNvcyhhbmdsZSkgKiB6U2NhbGU7XG4gICAgICAgIG5ld0RzdFsxXSA9IE1hdGguc2luKGFuZ2xlKSAqIHpTY2FsZTtcbiAgICAgICAgbmV3RHN0WzJdID0geiAqIHNjYWxlO1xuICAgICAgICByZXR1cm4gbmV3RHN0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBaZXJvJ3MgYSB2ZWN0b3JcbiAgICAgKiBAcGFyYW0gZHN0IC0gdmVjdG9yIHRvIGhvbGQgcmVzdWx0LiBJZiBub3QgcGFzc2VkIGluIGEgbmV3IG9uZSBpcyBjcmVhdGVkLlxuICAgICAqIEByZXR1cm5zIFRoZSB6ZXJvZWQgdmVjdG9yLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHplcm8oZHN0KSB7XG4gICAgICAgIGNvbnN0IG5ld0RzdCA9IChkc3QgPz8gbmV3IEN0b3IoMykpO1xuICAgICAgICBuZXdEc3RbMF0gPSAwO1xuICAgICAgICBuZXdEc3RbMV0gPSAwO1xuICAgICAgICBuZXdEc3RbMl0gPSAwO1xuICAgICAgICByZXR1cm4gbmV3RHN0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiB0cmFuc2Zvcm0gdmVjMyBieSA0eDQgbWF0cml4XG4gICAgICogQHBhcmFtIHYgLSB0aGUgdmVjdG9yXG4gICAgICogQHBhcmFtIG0gLSBUaGUgbWF0cml4LlxuICAgICAqIEBwYXJhbSBkc3QgLSBvcHRpb25hbCB2ZWMzIHRvIHN0b3JlIHJlc3VsdC4gSWYgbm90IHBhc3NlZCBhIG5ldyBvbmUgaXMgY3JlYXRlZC5cbiAgICAgKiBAcmV0dXJucyB0aGUgdHJhbnNmb3JtZWQgdmVjdG9yXG4gICAgICovXG4gICAgZnVuY3Rpb24gdHJhbnNmb3JtTWF0NCh2LCBtLCBkc3QpIHtcbiAgICAgICAgY29uc3QgbmV3RHN0ID0gKGRzdCA/PyBuZXcgQ3RvcigzKSk7XG4gICAgICAgIGNvbnN0IHggPSB2WzBdO1xuICAgICAgICBjb25zdCB5ID0gdlsxXTtcbiAgICAgICAgY29uc3QgeiA9IHZbMl07XG4gICAgICAgIGNvbnN0IHcgPSAobVszXSAqIHggKyBtWzddICogeSArIG1bMTFdICogeiArIG1bMTVdKSB8fCAxO1xuICAgICAgICBuZXdEc3RbMF0gPSAobVswXSAqIHggKyBtWzRdICogeSArIG1bOF0gKiB6ICsgbVsxMl0pIC8gdztcbiAgICAgICAgbmV3RHN0WzFdID0gKG1bMV0gKiB4ICsgbVs1XSAqIHkgKyBtWzldICogeiArIG1bMTNdKSAvIHc7XG4gICAgICAgIG5ld0RzdFsyXSA9IChtWzJdICogeCArIG1bNl0gKiB5ICsgbVsxMF0gKiB6ICsgbVsxNF0pIC8gdztcbiAgICAgICAgcmV0dXJuIG5ld0RzdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVHJhbnNmb3JtIHZlYzMgYnkgdXBwZXIgM3gzIG1hdHJpeCBpbnNpZGUgNHg0IG1hdHJpeC5cbiAgICAgKiBAcGFyYW0gdiAtIFRoZSBkaXJlY3Rpb24uXG4gICAgICogQHBhcmFtIG0gLSBUaGUgbWF0cml4LlxuICAgICAqIEBwYXJhbSBkc3QgLSBvcHRpb25hbCB2ZWMzIHRvIHN0b3JlIHJlc3VsdC4gSWYgbm90IHBhc3NlZCBhIG5ldyBvbmUgaXMgY3JlYXRlZC5cbiAgICAgKiBAcmV0dXJucyBUaGUgdHJhbnNmb3JtZWQgdmVjdG9yLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRyYW5zZm9ybU1hdDRVcHBlcjN4Myh2LCBtLCBkc3QpIHtcbiAgICAgICAgY29uc3QgbmV3RHN0ID0gKGRzdCA/PyBuZXcgQ3RvcigzKSk7XG4gICAgICAgIGNvbnN0IHYwID0gdlswXTtcbiAgICAgICAgY29uc3QgdjEgPSB2WzFdO1xuICAgICAgICBjb25zdCB2MiA9IHZbMl07XG4gICAgICAgIG5ld0RzdFswXSA9IHYwICogbVswICogNCArIDBdICsgdjEgKiBtWzEgKiA0ICsgMF0gKyB2MiAqIG1bMiAqIDQgKyAwXTtcbiAgICAgICAgbmV3RHN0WzFdID0gdjAgKiBtWzAgKiA0ICsgMV0gKyB2MSAqIG1bMSAqIDQgKyAxXSArIHYyICogbVsyICogNCArIDFdO1xuICAgICAgICBuZXdEc3RbMl0gPSB2MCAqIG1bMCAqIDQgKyAyXSArIHYxICogbVsxICogNCArIDJdICsgdjIgKiBtWzIgKiA0ICsgMl07XG4gICAgICAgIHJldHVybiBuZXdEc3Q7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRyYW5zZm9ybXMgdmVjMyBieSAzeDMgbWF0cml4XG4gICAgICpcbiAgICAgKiBAcGFyYW0gdiAtIHRoZSB2ZWN0b3JcbiAgICAgKiBAcGFyYW0gbSAtIFRoZSBtYXRyaXguXG4gICAgICogQHBhcmFtIGRzdCAtIG9wdGlvbmFsIHZlYzMgdG8gc3RvcmUgcmVzdWx0LiBJZiBub3QgcGFzc2VkIGEgbmV3IG9uZSBpcyBjcmVhdGVkLlxuICAgICAqIEByZXR1cm5zIHRoZSB0cmFuc2Zvcm1lZCB2ZWN0b3JcbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0cmFuc2Zvcm1NYXQzKHYsIG0sIGRzdCkge1xuICAgICAgICBjb25zdCBuZXdEc3QgPSAoZHN0ID8/IG5ldyBDdG9yKDMpKTtcbiAgICAgICAgY29uc3QgeCA9IHZbMF07XG4gICAgICAgIGNvbnN0IHkgPSB2WzFdO1xuICAgICAgICBjb25zdCB6ID0gdlsyXTtcbiAgICAgICAgbmV3RHN0WzBdID0geCAqIG1bMF0gKyB5ICogbVs0XSArIHogKiBtWzhdO1xuICAgICAgICBuZXdEc3RbMV0gPSB4ICogbVsxXSArIHkgKiBtWzVdICsgeiAqIG1bOV07XG4gICAgICAgIG5ld0RzdFsyXSA9IHggKiBtWzJdICsgeSAqIG1bNl0gKyB6ICogbVsxMF07XG4gICAgICAgIHJldHVybiBuZXdEc3Q7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRyYW5zZm9ybXMgdmVjMyBieSBRdWF0ZXJuaW9uXG4gICAgICogQHBhcmFtIHYgLSB0aGUgdmVjdG9yIHRvIHRyYW5zZm9ybVxuICAgICAqIEBwYXJhbSBxIC0gdGhlIHF1YXRlcm5pb24gdG8gdHJhbnNmb3JtIGJ5XG4gICAgICogQHBhcmFtIGRzdCAtIG9wdGlvbmFsIHZlYzMgdG8gc3RvcmUgcmVzdWx0LiBJZiBub3QgcGFzc2VkIGEgbmV3IG9uZSBpcyBjcmVhdGVkLlxuICAgICAqIEByZXR1cm5zIHRoZSB0cmFuc2Zvcm1lZFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRyYW5zZm9ybVF1YXQodiwgcSwgZHN0KSB7XG4gICAgICAgIGNvbnN0IG5ld0RzdCA9IChkc3QgPz8gbmV3IEN0b3IoMykpO1xuICAgICAgICBjb25zdCBxeCA9IHFbMF07XG4gICAgICAgIGNvbnN0IHF5ID0gcVsxXTtcbiAgICAgICAgY29uc3QgcXogPSBxWzJdO1xuICAgICAgICBjb25zdCB3MiA9IHFbM10gKiAyO1xuICAgICAgICBjb25zdCB4ID0gdlswXTtcbiAgICAgICAgY29uc3QgeSA9IHZbMV07XG4gICAgICAgIGNvbnN0IHogPSB2WzJdO1xuICAgICAgICBjb25zdCB1dlggPSBxeSAqIHogLSBxeiAqIHk7XG4gICAgICAgIGNvbnN0IHV2WSA9IHF6ICogeCAtIHF4ICogejtcbiAgICAgICAgY29uc3QgdXZaID0gcXggKiB5IC0gcXkgKiB4O1xuICAgICAgICBuZXdEc3RbMF0gPSB4ICsgdXZYICogdzIgKyAocXkgKiB1dlogLSBxeiAqIHV2WSkgKiAyO1xuICAgICAgICBuZXdEc3RbMV0gPSB5ICsgdXZZICogdzIgKyAocXogKiB1dlggLSBxeCAqIHV2WikgKiAyO1xuICAgICAgICBuZXdEc3RbMl0gPSB6ICsgdXZaICogdzIgKyAocXggKiB1dlkgLSBxeSAqIHV2WCkgKiAyO1xuICAgICAgICByZXR1cm4gbmV3RHN0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSB0cmFuc2xhdGlvbiBjb21wb25lbnQgb2YgYSA0LWJ5LTQgbWF0cml4IGFzIGEgdmVjdG9yIHdpdGggM1xuICAgICAqIGVudHJpZXMuXG4gICAgICogQHBhcmFtIG0gLSBUaGUgbWF0cml4LlxuICAgICAqIEBwYXJhbSBkc3QgLSB2ZWN0b3IgdG8gaG9sZCByZXN1bHQuIElmIG5vdCBwYXNzZWQgYSBuZXcgb25lIGlzIGNyZWF0ZWQuXG4gICAgICogQHJldHVybnMgVGhlIHRyYW5zbGF0aW9uIGNvbXBvbmVudCBvZiBtLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGdldFRyYW5zbGF0aW9uKG0sIGRzdCkge1xuICAgICAgICBjb25zdCBuZXdEc3QgPSAoZHN0ID8/IG5ldyBDdG9yKDMpKTtcbiAgICAgICAgbmV3RHN0WzBdID0gbVsxMl07XG4gICAgICAgIG5ld0RzdFsxXSA9IG1bMTNdO1xuICAgICAgICBuZXdEc3RbMl0gPSBtWzE0XTtcbiAgICAgICAgcmV0dXJuIG5ld0RzdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhbiBheGlzIG9mIGEgNHg0IG1hdHJpeCBhcyBhIHZlY3RvciB3aXRoIDMgZW50cmllc1xuICAgICAqIEBwYXJhbSBtIC0gVGhlIG1hdHJpeC5cbiAgICAgKiBAcGFyYW0gYXhpcyAtIFRoZSBheGlzIDAgPSB4LCAxID0geSwgMiA9IHo7XG4gICAgICogQHJldHVybnMgVGhlIGF4aXMgY29tcG9uZW50IG9mIG0uXG4gICAgICovXG4gICAgZnVuY3Rpb24gZ2V0QXhpcyhtLCBheGlzLCBkc3QpIHtcbiAgICAgICAgY29uc3QgbmV3RHN0ID0gKGRzdCA/PyBuZXcgQ3RvcigzKSk7XG4gICAgICAgIGNvbnN0IG9mZiA9IGF4aXMgKiA0O1xuICAgICAgICBuZXdEc3RbMF0gPSBtW29mZiArIDBdO1xuICAgICAgICBuZXdEc3RbMV0gPSBtW29mZiArIDFdO1xuICAgICAgICBuZXdEc3RbMl0gPSBtW29mZiArIDJdO1xuICAgICAgICByZXR1cm4gbmV3RHN0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBzY2FsaW5nIGNvbXBvbmVudCBvZiB0aGUgbWF0cml4XG4gICAgICogQHBhcmFtIG0gLSBUaGUgTWF0cml4XG4gICAgICogQHBhcmFtIGRzdCAtIFRoZSB2ZWN0b3IgdG8gc2V0LiBJZiBub3QgcGFzc2VkIGEgbmV3IG9uZSBpcyBjcmVhdGVkLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGdldFNjYWxpbmcobSwgZHN0KSB7XG4gICAgICAgIGNvbnN0IG5ld0RzdCA9IChkc3QgPz8gbmV3IEN0b3IoMykpO1xuICAgICAgICBjb25zdCB4eCA9IG1bMF07XG4gICAgICAgIGNvbnN0IHh5ID0gbVsxXTtcbiAgICAgICAgY29uc3QgeHogPSBtWzJdO1xuICAgICAgICBjb25zdCB5eCA9IG1bNF07XG4gICAgICAgIGNvbnN0IHl5ID0gbVs1XTtcbiAgICAgICAgY29uc3QgeXogPSBtWzZdO1xuICAgICAgICBjb25zdCB6eCA9IG1bOF07XG4gICAgICAgIGNvbnN0IHp5ID0gbVs5XTtcbiAgICAgICAgY29uc3QgenogPSBtWzEwXTtcbiAgICAgICAgbmV3RHN0WzBdID0gTWF0aC5zcXJ0KHh4ICogeHggKyB4eSAqIHh5ICsgeHogKiB4eik7XG4gICAgICAgIG5ld0RzdFsxXSA9IE1hdGguc3FydCh5eCAqIHl4ICsgeXkgKiB5eSArIHl6ICogeXopO1xuICAgICAgICBuZXdEc3RbMl0gPSBNYXRoLnNxcnQoenggKiB6eCArIHp5ICogenkgKyB6eiAqIHp6KTtcbiAgICAgICAgcmV0dXJuIG5ld0RzdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUm90YXRlIGEgM0QgdmVjdG9yIGFyb3VuZCB0aGUgeC1heGlzXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gYSBUaGUgdmVjMyBwb2ludCB0byByb3RhdGVcbiAgICAgKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gYiBUaGUgb3JpZ2luIG9mIHRoZSByb3RhdGlvblxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSByYWQgVGhlIGFuZ2xlIG9mIHJvdGF0aW9uIGluIHJhZGlhbnNcbiAgICAgKiBAcGFyYW0gZHN0IC0gVGhlIHZlY3RvciB0byBzZXQuIElmIG5vdCBwYXNzZWQgYSBuZXcgb25lIGlzIGNyZWF0ZWQuXG4gICAgICogQHJldHVybnMgdGhlIHJvdGF0ZWQgdmVjdG9yXG4gICAgICovXG4gICAgZnVuY3Rpb24gcm90YXRlWChhLCBiLCByYWQsIGRzdCkge1xuICAgICAgICBjb25zdCBuZXdEc3QgPSAoZHN0ID8/IG5ldyBDdG9yKDMpKTtcbiAgICAgICAgY29uc3QgcCA9IFtdO1xuICAgICAgICBjb25zdCByID0gW107XG4gICAgICAgIC8vVHJhbnNsYXRlIHBvaW50IHRvIHRoZSBvcmlnaW5cbiAgICAgICAgcFswXSA9IGFbMF0gLSBiWzBdO1xuICAgICAgICBwWzFdID0gYVsxXSAtIGJbMV07XG4gICAgICAgIHBbMl0gPSBhWzJdIC0gYlsyXTtcbiAgICAgICAgLy9wZXJmb3JtIHJvdGF0aW9uXG4gICAgICAgIHJbMF0gPSBwWzBdO1xuICAgICAgICByWzFdID0gcFsxXSAqIE1hdGguY29zKHJhZCkgLSBwWzJdICogTWF0aC5zaW4ocmFkKTtcbiAgICAgICAgclsyXSA9IHBbMV0gKiBNYXRoLnNpbihyYWQpICsgcFsyXSAqIE1hdGguY29zKHJhZCk7XG4gICAgICAgIC8vdHJhbnNsYXRlIHRvIGNvcnJlY3QgcG9zaXRpb25cbiAgICAgICAgbmV3RHN0WzBdID0gclswXSArIGJbMF07XG4gICAgICAgIG5ld0RzdFsxXSA9IHJbMV0gKyBiWzFdO1xuICAgICAgICBuZXdEc3RbMl0gPSByWzJdICsgYlsyXTtcbiAgICAgICAgcmV0dXJuIG5ld0RzdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUm90YXRlIGEgM0QgdmVjdG9yIGFyb3VuZCB0aGUgeS1heGlzXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gYSBUaGUgdmVjMyBwb2ludCB0byByb3RhdGVcbiAgICAgKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gYiBUaGUgb3JpZ2luIG9mIHRoZSByb3RhdGlvblxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSByYWQgVGhlIGFuZ2xlIG9mIHJvdGF0aW9uIGluIHJhZGlhbnNcbiAgICAgKiBAcGFyYW0gZHN0IC0gVGhlIHZlY3RvciB0byBzZXQuIElmIG5vdCBwYXNzZWQgYSBuZXcgb25lIGlzIGNyZWF0ZWQuXG4gICAgICogQHJldHVybnMgdGhlIHJvdGF0ZWQgdmVjdG9yXG4gICAgICovXG4gICAgZnVuY3Rpb24gcm90YXRlWShhLCBiLCByYWQsIGRzdCkge1xuICAgICAgICBjb25zdCBuZXdEc3QgPSAoZHN0ID8/IG5ldyBDdG9yKDMpKTtcbiAgICAgICAgY29uc3QgcCA9IFtdO1xuICAgICAgICBjb25zdCByID0gW107XG4gICAgICAgIC8vIHRyYW5zbGF0ZSBwb2ludCB0byB0aGUgb3JpZ2luXG4gICAgICAgIHBbMF0gPSBhWzBdIC0gYlswXTtcbiAgICAgICAgcFsxXSA9IGFbMV0gLSBiWzFdO1xuICAgICAgICBwWzJdID0gYVsyXSAtIGJbMl07XG4gICAgICAgIC8vIHBlcmZvcm0gcm90YXRpb25cbiAgICAgICAgclswXSA9IHBbMl0gKiBNYXRoLnNpbihyYWQpICsgcFswXSAqIE1hdGguY29zKHJhZCk7XG4gICAgICAgIHJbMV0gPSBwWzFdO1xuICAgICAgICByWzJdID0gcFsyXSAqIE1hdGguY29zKHJhZCkgLSBwWzBdICogTWF0aC5zaW4ocmFkKTtcbiAgICAgICAgLy8gdHJhbnNsYXRlIHRvIGNvcnJlY3QgcG9zaXRpb25cbiAgICAgICAgbmV3RHN0WzBdID0gclswXSArIGJbMF07XG4gICAgICAgIG5ld0RzdFsxXSA9IHJbMV0gKyBiWzFdO1xuICAgICAgICBuZXdEc3RbMl0gPSByWzJdICsgYlsyXTtcbiAgICAgICAgcmV0dXJuIG5ld0RzdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUm90YXRlIGEgM0QgdmVjdG9yIGFyb3VuZCB0aGUgei1heGlzXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gYSBUaGUgdmVjMyBwb2ludCB0byByb3RhdGVcbiAgICAgKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gYiBUaGUgb3JpZ2luIG9mIHRoZSByb3RhdGlvblxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSByYWQgVGhlIGFuZ2xlIG9mIHJvdGF0aW9uIGluIHJhZGlhbnNcbiAgICAgKiBAcGFyYW0gZHN0IC0gVGhlIHZlY3RvciB0byBzZXQuIElmIG5vdCBwYXNzZWQgYSBuZXcgb25lIGlzIGNyZWF0ZWQuXG4gICAgICogQHJldHVybnMge3ZlYzN9IG91dFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHJvdGF0ZVooYSwgYiwgcmFkLCBkc3QpIHtcbiAgICAgICAgY29uc3QgbmV3RHN0ID0gKGRzdCA/PyBuZXcgQ3RvcigzKSk7XG4gICAgICAgIGNvbnN0IHAgPSBbXTtcbiAgICAgICAgY29uc3QgciA9IFtdO1xuICAgICAgICAvLyB0cmFuc2xhdGUgcG9pbnQgdG8gdGhlIG9yaWdpblxuICAgICAgICBwWzBdID0gYVswXSAtIGJbMF07XG4gICAgICAgIHBbMV0gPSBhWzFdIC0gYlsxXTtcbiAgICAgICAgcFsyXSA9IGFbMl0gLSBiWzJdO1xuICAgICAgICAvLyBwZXJmb3JtIHJvdGF0aW9uXG4gICAgICAgIHJbMF0gPSBwWzBdICogTWF0aC5jb3MocmFkKSAtIHBbMV0gKiBNYXRoLnNpbihyYWQpO1xuICAgICAgICByWzFdID0gcFswXSAqIE1hdGguc2luKHJhZCkgKyBwWzFdICogTWF0aC5jb3MocmFkKTtcbiAgICAgICAgclsyXSA9IHBbMl07XG4gICAgICAgIC8vIHRyYW5zbGF0ZSB0byBjb3JyZWN0IHBvc2l0aW9uXG4gICAgICAgIG5ld0RzdFswXSA9IHJbMF0gKyBiWzBdO1xuICAgICAgICBuZXdEc3RbMV0gPSByWzFdICsgYlsxXTtcbiAgICAgICAgbmV3RHN0WzJdID0gclsyXSArIGJbMl07XG4gICAgICAgIHJldHVybiBuZXdEc3Q7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRyZWF0IGEgM0QgdmVjdG9yIGFzIGEgZGlyZWN0aW9uIGFuZCBzZXQgaXQncyBsZW5ndGhcbiAgICAgKlxuICAgICAqIEBwYXJhbSBhIFRoZSB2ZWMzIHRvIGxlbmd0aGVuXG4gICAgICogQHBhcmFtIGxlbiBUaGUgbGVuZ3RoIG9mIHRoZSByZXN1bHRpbmcgdmVjdG9yXG4gICAgICogQHJldHVybnMgVGhlIGxlbmd0aGVuZWQgdmVjdG9yXG4gICAgICovXG4gICAgZnVuY3Rpb24gc2V0TGVuZ3RoKGEsIGxlbiwgZHN0KSB7XG4gICAgICAgIGNvbnN0IG5ld0RzdCA9IChkc3QgPz8gbmV3IEN0b3IoMykpO1xuICAgICAgICBub3JtYWxpemUoYSwgbmV3RHN0KTtcbiAgICAgICAgcmV0dXJuIG11bFNjYWxhcihuZXdEc3QsIGxlbiwgbmV3RHN0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRW5zdXJlIGEgdmVjdG9yIGlzIG5vdCBsb25nZXIgdGhhbiBhIG1heCBsZW5ndGhcbiAgICAgKlxuICAgICAqIEBwYXJhbSBhIFRoZSB2ZWMzIHRvIGxpbWl0XG4gICAgICogQHBhcmFtIG1heExlbiBUaGUgbG9uZ2VzdCBsZW5ndGggb2YgdGhlIHJlc3VsdGluZyB2ZWN0b3JcbiAgICAgKiBAcmV0dXJucyBUaGUgdmVjdG9yLCBzaG9ydGVuZWQgdG8gbWF4TGVuIGlmIGl0J3MgdG9vIGxvbmdcbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0cnVuY2F0ZShhLCBtYXhMZW4sIGRzdCkge1xuICAgICAgICBjb25zdCBuZXdEc3QgPSAoZHN0ID8/IG5ldyBDdG9yKDMpKTtcbiAgICAgICAgaWYgKGxlbmd0aChhKSA+IG1heExlbikge1xuICAgICAgICAgICAgcmV0dXJuIHNldExlbmd0aChhLCBtYXhMZW4sIG5ld0RzdCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvcHkoYSwgbmV3RHN0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJuIHRoZSB2ZWN0b3IgZXhhY3RseSBiZXR3ZWVuIDIgZW5kcG9pbnQgdmVjdG9yc1xuICAgICAqXG4gICAgICogQHBhcmFtIGEgRW5kcG9pbnQgMVxuICAgICAqIEBwYXJhbSBiIEVuZHBvaW50IDJcbiAgICAgKiBAcmV0dXJucyBUaGUgdmVjdG9yIGV4YWN0bHkgcmVzaWRpbmcgYmV0d2VlbiBlbmRwb2ludHMgMSBhbmQgMlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG1pZHBvaW50KGEsIGIsIGRzdCkge1xuICAgICAgICBjb25zdCBuZXdEc3QgPSAoZHN0ID8/IG5ldyBDdG9yKDMpKTtcbiAgICAgICAgcmV0dXJuIGxlcnAoYSwgYiwgMC41LCBuZXdEc3QpO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBjcmVhdGUsXG4gICAgICAgIGZyb21WYWx1ZXMsXG4gICAgICAgIHNldCxcbiAgICAgICAgY2VpbCxcbiAgICAgICAgZmxvb3IsXG4gICAgICAgIHJvdW5kLFxuICAgICAgICBjbGFtcCxcbiAgICAgICAgYWRkLFxuICAgICAgICBhZGRTY2FsZWQsXG4gICAgICAgIGFuZ2xlLFxuICAgICAgICBzdWJ0cmFjdCxcbiAgICAgICAgc3ViLFxuICAgICAgICBlcXVhbHNBcHByb3hpbWF0ZWx5LFxuICAgICAgICBlcXVhbHMsXG4gICAgICAgIGxlcnAsXG4gICAgICAgIGxlcnBWLFxuICAgICAgICBtYXgsXG4gICAgICAgIG1pbixcbiAgICAgICAgbXVsU2NhbGFyLFxuICAgICAgICBzY2FsZSxcbiAgICAgICAgZGl2U2NhbGFyLFxuICAgICAgICBpbnZlcnNlLFxuICAgICAgICBpbnZlcnQsXG4gICAgICAgIGNyb3NzLFxuICAgICAgICBkb3QsXG4gICAgICAgIGxlbmd0aCxcbiAgICAgICAgbGVuLFxuICAgICAgICBsZW5ndGhTcSxcbiAgICAgICAgbGVuU3EsXG4gICAgICAgIGRpc3RhbmNlLFxuICAgICAgICBkaXN0LFxuICAgICAgICBkaXN0YW5jZVNxLFxuICAgICAgICBkaXN0U3EsXG4gICAgICAgIG5vcm1hbGl6ZSxcbiAgICAgICAgbmVnYXRlLFxuICAgICAgICBjb3B5LFxuICAgICAgICBjbG9uZSxcbiAgICAgICAgbXVsdGlwbHksXG4gICAgICAgIG11bCxcbiAgICAgICAgZGl2aWRlLFxuICAgICAgICBkaXYsXG4gICAgICAgIHJhbmRvbSxcbiAgICAgICAgemVybyxcbiAgICAgICAgdHJhbnNmb3JtTWF0NCxcbiAgICAgICAgdHJhbnNmb3JtTWF0NFVwcGVyM3gzLFxuICAgICAgICB0cmFuc2Zvcm1NYXQzLFxuICAgICAgICB0cmFuc2Zvcm1RdWF0LFxuICAgICAgICBnZXRUcmFuc2xhdGlvbixcbiAgICAgICAgZ2V0QXhpcyxcbiAgICAgICAgZ2V0U2NhbGluZyxcbiAgICAgICAgcm90YXRlWCxcbiAgICAgICAgcm90YXRlWSxcbiAgICAgICAgcm90YXRlWixcbiAgICAgICAgc2V0TGVuZ3RoLFxuICAgICAgICB0cnVuY2F0ZSxcbiAgICAgICAgbWlkcG9pbnQsXG4gICAgfTtcbn1cbmNvbnN0IGNhY2hlJDMgPSBuZXcgTWFwKCk7XG5mdW5jdGlvbiBnZXRBUEkkMyhDdG9yKSB7XG4gICAgbGV0IGFwaSA9IGNhY2hlJDMuZ2V0KEN0b3IpO1xuICAgIGlmICghYXBpKSB7XG4gICAgICAgIGFwaSA9IGdldEFQSUltcGwkMyhDdG9yKTtcbiAgICAgICAgY2FjaGUkMy5zZXQoQ3RvciwgYXBpKTtcbiAgICB9XG4gICAgcmV0dXJuIGFwaTtcbn1cblxuLyoqXG4gKiBHZW5lcmF0ZXMgYSB0eXBlZCBBUEkgZm9yIE1hdDRcbiAqICovXG5mdW5jdGlvbiBnZXRBUElJbXBsJDIoQ3Rvcikge1xuICAgIGNvbnN0IHZlYzMgPSBnZXRBUEkkMyhDdG9yKTtcbiAgICAvKipcbiAgICAgKiA0eDQgTWF0cml4IG1hdGggbWF0aCBmdW5jdGlvbnMuXG4gICAgICpcbiAgICAgKiBBbG1vc3QgYWxsIGZ1bmN0aW9ucyB0YWtlIGFuIG9wdGlvbmFsIGBuZXdEc3RgIGFyZ3VtZW50LiBJZiBpdCBpcyBub3QgcGFzc2VkIGluIHRoZVxuICAgICAqIGZ1bmN0aW9ucyB3aWxsIGNyZWF0ZSBhIG5ldyBtYXRyaXguIEluIG90aGVyIHdvcmRzIHlvdSBjYW4gZG8gdGhpc1xuICAgICAqXG4gICAgICogICAgIGNvbnN0IG1hdCA9IG1hdDQudHJhbnNsYXRpb24oWzEsIDIsIDNdKTsgIC8vIENyZWF0ZXMgYSBuZXcgdHJhbnNsYXRpb24gbWF0cml4XG4gICAgICpcbiAgICAgKiBvclxuICAgICAqXG4gICAgICogICAgIGNvbnN0IG1hdCA9IG1hdDQuY3JlYXRlKCk7XG4gICAgICogICAgIG1hdDQudHJhbnNsYXRpb24oWzEsIDIsIDNdLCBtYXQpOyAgLy8gUHV0cyB0cmFuc2xhdGlvbiBtYXRyaXggaW4gbWF0LlxuICAgICAqXG4gICAgICogVGhlIGZpcnN0IHN0eWxlIGlzIG9mdGVuIGVhc2llciBidXQgZGVwZW5kaW5nIG9uIHdoZXJlIGl0J3MgdXNlZCBpdCBnZW5lcmF0ZXMgZ2FyYmFnZSB3aGVyZVxuICAgICAqIGFzIHRoZXJlIGlzIGFsbW9zdCBuZXZlciBhbGxvY2F0aW9uIHdpdGggdGhlIHNlY29uZCBzdHlsZS5cbiAgICAgKlxuICAgICAqIEl0IGlzIGFsd2F5cyBzYXZlIHRvIHBhc3MgYW55IG1hdHJpeCBhcyB0aGUgZGVzdGluYXRpb24uIFNvIGZvciBleGFtcGxlXG4gICAgICpcbiAgICAgKiAgICAgY29uc3QgbWF0ID0gbWF0NC5pZGVudGl0eSgpO1xuICAgICAqICAgICBjb25zdCB0cmFucyA9IG1hdDQudHJhbnNsYXRpb24oWzEsIDIsIDNdKTtcbiAgICAgKiAgICAgbWF0NC5tdWx0aXBseShtYXQsIHRyYW5zLCBtYXQpOyAgLy8gTXVsdGlwbGllcyBtYXQgKiB0cmFucyBhbmQgcHV0cyByZXN1bHQgaW4gbWF0LlxuICAgICAqXG4gICAgICovXG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgTWF0NCBmcm9tIHZhbHVlc1xuICAgICAqXG4gICAgICogTm90ZTogU2luY2UgcGFzc2luZyBpbiBhIHJhdyBKYXZhU2NyaXB0IGFycmF5XG4gICAgICogaXMgdmFsaWQgaW4gYWxsIGNpcmN1bXN0YW5jZXMsIGlmIHlvdSB3YW50IHRvXG4gICAgICogZm9yY2UgYSBKYXZhU2NyaXB0IGFycmF5IGludG8gYSBNYXQ0J3Mgc3BlY2lmaWVkIHR5cGVcbiAgICAgKiBpdCB3b3VsZCBiZSBmYXN0ZXIgdG8gdXNlXG4gICAgICpcbiAgICAgKiBgYGBcbiAgICAgKiBjb25zdCBtID0gbWF0NC5jbG9uZShzb21lSlNBcnJheSk7XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdjAgLSB2YWx1ZSBmb3IgZWxlbWVudCAwXG4gICAgICogQHBhcmFtIHYxIC0gdmFsdWUgZm9yIGVsZW1lbnQgMVxuICAgICAqIEBwYXJhbSB2MiAtIHZhbHVlIGZvciBlbGVtZW50IDJcbiAgICAgKiBAcGFyYW0gdjMgLSB2YWx1ZSBmb3IgZWxlbWVudCAzXG4gICAgICogQHBhcmFtIHY0IC0gdmFsdWUgZm9yIGVsZW1lbnQgNFxuICAgICAqIEBwYXJhbSB2NSAtIHZhbHVlIGZvciBlbGVtZW50IDVcbiAgICAgKiBAcGFyYW0gdjYgLSB2YWx1ZSBmb3IgZWxlbWVudCA2XG4gICAgICogQHBhcmFtIHY3IC0gdmFsdWUgZm9yIGVsZW1lbnQgN1xuICAgICAqIEBwYXJhbSB2OCAtIHZhbHVlIGZvciBlbGVtZW50IDhcbiAgICAgKiBAcGFyYW0gdjkgLSB2YWx1ZSBmb3IgZWxlbWVudCA5XG4gICAgICogQHBhcmFtIHYxMCAtIHZhbHVlIGZvciBlbGVtZW50IDEwXG4gICAgICogQHBhcmFtIHYxMSAtIHZhbHVlIGZvciBlbGVtZW50IDExXG4gICAgICogQHBhcmFtIHYxMiAtIHZhbHVlIGZvciBlbGVtZW50IDEyXG4gICAgICogQHBhcmFtIHYxMyAtIHZhbHVlIGZvciBlbGVtZW50IDEzXG4gICAgICogQHBhcmFtIHYxNCAtIHZhbHVlIGZvciBlbGVtZW50IDE0XG4gICAgICogQHBhcmFtIHYxNSAtIHZhbHVlIGZvciBlbGVtZW50IDE1XG4gICAgICogQHJldHVybnMgY3JlYXRlZCBmcm9tIHZhbHVlcy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGUodjAsIHYxLCB2MiwgdjMsIHY0LCB2NSwgdjYsIHY3LCB2OCwgdjksIHYxMCwgdjExLCB2MTIsIHYxMywgdjE0LCB2MTUpIHtcbiAgICAgICAgY29uc3QgbmV3RHN0ID0gbmV3IEN0b3IoMTYpO1xuICAgICAgICBpZiAodjAgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgbmV3RHN0WzBdID0gdjA7XG4gICAgICAgICAgICBpZiAodjEgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIG5ld0RzdFsxXSA9IHYxO1xuICAgICAgICAgICAgICAgIGlmICh2MiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIG5ld0RzdFsyXSA9IHYyO1xuICAgICAgICAgICAgICAgICAgICBpZiAodjMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV3RHN0WzNdID0gdjM7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodjQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld0RzdFs0XSA9IHY0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2NSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld0RzdFs1XSA9IHY1O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodjYgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3RHN0WzZdID0gdjY7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodjcgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld0RzdFs3XSA9IHY3O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2OCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld0RzdFs4XSA9IHY4O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodjkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3RHN0WzldID0gdjk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodjEwICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXdEc3RbMTBdID0gdjEwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2MTEgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXdEc3RbMTFdID0gdjExO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodjEyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld0RzdFsxMl0gPSB2MTI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodjEzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXdEc3RbMTNdID0gdjEzO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2MTQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXdEc3RbMTRdID0gdjE0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodjE1ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld0RzdFsxNV0gPSB2MTU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ld0RzdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgdmFsdWVzIG9mIGEgTWF0NFxuICAgICAqIEFsc28gc2VlIHtAbGluayBtYXQ0LmNyZWF0ZX0gYW5kIHtAbGluayBtYXQ0LmNvcHl9XG4gICAgICpcbiAgICAgKiBAcGFyYW0gdjAgLSB2YWx1ZSBmb3IgZWxlbWVudCAwXG4gICAgICogQHBhcmFtIHYxIC0gdmFsdWUgZm9yIGVsZW1lbnQgMVxuICAgICAqIEBwYXJhbSB2MiAtIHZhbHVlIGZvciBlbGVtZW50IDJcbiAgICAgKiBAcGFyYW0gdjMgLSB2YWx1ZSBmb3IgZWxlbWVudCAzXG4gICAgICogQHBhcmFtIHY0IC0gdmFsdWUgZm9yIGVsZW1lbnQgNFxuICAgICAqIEBwYXJhbSB2NSAtIHZhbHVlIGZvciBlbGVtZW50IDVcbiAgICAgKiBAcGFyYW0gdjYgLSB2YWx1ZSBmb3IgZWxlbWVudCA2XG4gICAgICogQHBhcmFtIHY3IC0gdmFsdWUgZm9yIGVsZW1lbnQgN1xuICAgICAqIEBwYXJhbSB2OCAtIHZhbHVlIGZvciBlbGVtZW50IDhcbiAgICAgKiBAcGFyYW0gdjkgLSB2YWx1ZSBmb3IgZWxlbWVudCA5XG4gICAgICogQHBhcmFtIHYxMCAtIHZhbHVlIGZvciBlbGVtZW50IDEwXG4gICAgICogQHBhcmFtIHYxMSAtIHZhbHVlIGZvciBlbGVtZW50IDExXG4gICAgICogQHBhcmFtIHYxMiAtIHZhbHVlIGZvciBlbGVtZW50IDEyXG4gICAgICogQHBhcmFtIHYxMyAtIHZhbHVlIGZvciBlbGVtZW50IDEzXG4gICAgICogQHBhcmFtIHYxNCAtIHZhbHVlIGZvciBlbGVtZW50IDE0XG4gICAgICogQHBhcmFtIHYxNSAtIHZhbHVlIGZvciBlbGVtZW50IDE1XG4gICAgICogQHBhcmFtIGRzdCAtIG1hdHJpeCB0byBob2xkIHJlc3VsdC4gSWYgbm90IHBhc3NlZCBhIG5ldyBvbmUgaXMgY3JlYXRlZC5cbiAgICAgKiBAcmV0dXJucyBNYXQ0IGNyZWF0ZWQgZnJvbSB2YWx1ZXMuXG4gICAgICovXG4gICAgZnVuY3Rpb24gc2V0KHYwLCB2MSwgdjIsIHYzLCB2NCwgdjUsIHY2LCB2NywgdjgsIHY5LCB2MTAsIHYxMSwgdjEyLCB2MTMsIHYxNCwgdjE1LCBkc3QpIHtcbiAgICAgICAgY29uc3QgbmV3RHN0ID0gKGRzdCA/PyBuZXcgQ3RvcigxNikpO1xuICAgICAgICBuZXdEc3RbMF0gPSB2MDtcbiAgICAgICAgbmV3RHN0WzFdID0gdjE7XG4gICAgICAgIG5ld0RzdFsyXSA9IHYyO1xuICAgICAgICBuZXdEc3RbM10gPSB2MztcbiAgICAgICAgbmV3RHN0WzRdID0gdjQ7XG4gICAgICAgIG5ld0RzdFs1XSA9IHY1O1xuICAgICAgICBuZXdEc3RbNl0gPSB2NjtcbiAgICAgICAgbmV3RHN0WzddID0gdjc7XG4gICAgICAgIG5ld0RzdFs4XSA9IHY4O1xuICAgICAgICBuZXdEc3RbOV0gPSB2OTtcbiAgICAgICAgbmV3RHN0WzEwXSA9IHYxMDtcbiAgICAgICAgbmV3RHN0WzExXSA9IHYxMTtcbiAgICAgICAgbmV3RHN0WzEyXSA9IHYxMjtcbiAgICAgICAgbmV3RHN0WzEzXSA9IHYxMztcbiAgICAgICAgbmV3RHN0WzE0XSA9IHYxNDtcbiAgICAgICAgbmV3RHN0WzE1XSA9IHYxNTtcbiAgICAgICAgcmV0dXJuIG5ld0RzdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIE1hdDQgZnJvbSBhIE1hdDNcbiAgICAgKiBAcGFyYW0gbTMgLSBzb3VyY2UgbWF0cml4XG4gICAgICogQHBhcmFtIGRzdCAtIG1hdHJpeCB0byBob2xkIHJlc3VsdC4gSWYgbm90IHBhc3NlZCBhIG5ldyBvbmUgaXMgY3JlYXRlZC5cbiAgICAgKiBAcmV0dXJucyBNYXQ0IG1hZGUgZnJvbSBtM1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZyb21NYXQzKG0zLCBkc3QpIHtcbiAgICAgICAgY29uc3QgbmV3RHN0ID0gKGRzdCA/PyBuZXcgQ3RvcigxNikpO1xuICAgICAgICBuZXdEc3RbMF0gPSBtM1swXTtcbiAgICAgICAgbmV3RHN0WzFdID0gbTNbMV07XG4gICAgICAgIG5ld0RzdFsyXSA9IG0zWzJdO1xuICAgICAgICBuZXdEc3RbM10gPSAwO1xuICAgICAgICBuZXdEc3RbNF0gPSBtM1s0XTtcbiAgICAgICAgbmV3RHN0WzVdID0gbTNbNV07XG4gICAgICAgIG5ld0RzdFs2XSA9IG0zWzZdO1xuICAgICAgICBuZXdEc3RbN10gPSAwO1xuICAgICAgICBuZXdEc3RbOF0gPSBtM1s4XTtcbiAgICAgICAgbmV3RHN0WzldID0gbTNbOV07XG4gICAgICAgIG5ld0RzdFsxMF0gPSBtM1sxMF07XG4gICAgICAgIG5ld0RzdFsxMV0gPSAwO1xuICAgICAgICBuZXdEc3RbMTJdID0gMDtcbiAgICAgICAgbmV3RHN0WzEzXSA9IDA7XG4gICAgICAgIG5ld0RzdFsxNF0gPSAwO1xuICAgICAgICBuZXdEc3RbMTVdID0gMTtcbiAgICAgICAgcmV0dXJuIG5ld0RzdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIE1hdDQgcm90YXRpb24gbWF0cml4IGZyb20gYSBxdWF0ZXJuaW9uXG4gICAgICogQHBhcmFtIHEgLSBxdWF0ZXJuaW9uIHRvIGNyZWF0ZSBtYXRyaXggZnJvbVxuICAgICAqIEBwYXJhbSBkc3QgLSBtYXRyaXggdG8gaG9sZCByZXN1bHQuIElmIG5vdCBwYXNzZWQgYSBuZXcgb25lIGlzIGNyZWF0ZWQuXG4gICAgICogQHJldHVybnMgTWF0NCBtYWRlIGZyb20gcVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZyb21RdWF0KHEsIGRzdCkge1xuICAgICAgICBjb25zdCBuZXdEc3QgPSAoZHN0ID8/IG5ldyBDdG9yKDE2KSk7XG4gICAgICAgIGNvbnN0IHggPSBxWzBdO1xuICAgICAgICBjb25zdCB5ID0gcVsxXTtcbiAgICAgICAgY29uc3QgeiA9IHFbMl07XG4gICAgICAgIGNvbnN0IHcgPSBxWzNdO1xuICAgICAgICBjb25zdCB4MiA9IHggKyB4O1xuICAgICAgICBjb25zdCB5MiA9IHkgKyB5O1xuICAgICAgICBjb25zdCB6MiA9IHogKyB6O1xuICAgICAgICBjb25zdCB4eCA9IHggKiB4MjtcbiAgICAgICAgY29uc3QgeXggPSB5ICogeDI7XG4gICAgICAgIGNvbnN0IHl5ID0geSAqIHkyO1xuICAgICAgICBjb25zdCB6eCA9IHogKiB4MjtcbiAgICAgICAgY29uc3QgenkgPSB6ICogeTI7XG4gICAgICAgIGNvbnN0IHp6ID0geiAqIHoyO1xuICAgICAgICBjb25zdCB3eCA9IHcgKiB4MjtcbiAgICAgICAgY29uc3Qgd3kgPSB3ICogeTI7XG4gICAgICAgIGNvbnN0IHd6ID0gdyAqIHoyO1xuICAgICAgICBuZXdEc3RbMF0gPSAxIC0geXkgLSB6ejtcbiAgICAgICAgbmV3RHN0WzFdID0geXggKyB3ejtcbiAgICAgICAgbmV3RHN0WzJdID0genggLSB3eTtcbiAgICAgICAgbmV3RHN0WzNdID0gMDtcbiAgICAgICAgbmV3RHN0WzRdID0geXggLSB3ejtcbiAgICAgICAgbmV3RHN0WzVdID0gMSAtIHh4IC0geno7XG4gICAgICAgIG5ld0RzdFs2XSA9IHp5ICsgd3g7XG4gICAgICAgIG5ld0RzdFs3XSA9IDA7XG4gICAgICAgIG5ld0RzdFs4XSA9IHp4ICsgd3k7XG4gICAgICAgIG5ld0RzdFs5XSA9IHp5IC0gd3g7XG4gICAgICAgIG5ld0RzdFsxMF0gPSAxIC0geHggLSB5eTtcbiAgICAgICAgbmV3RHN0WzExXSA9IDA7XG4gICAgICAgIG5ld0RzdFsxMl0gPSAwO1xuICAgICAgICBuZXdEc3RbMTNdID0gMDtcbiAgICAgICAgbmV3RHN0WzE0XSA9IDA7XG4gICAgICAgIG5ld0RzdFsxNV0gPSAxO1xuICAgICAgICByZXR1cm4gbmV3RHN0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBOZWdhdGVzIGEgbWF0cml4LlxuICAgICAqIEBwYXJhbSBtIC0gVGhlIG1hdHJpeC5cbiAgICAgKiBAcGFyYW0gZHN0IC0gbWF0cml4IHRvIGhvbGQgcmVzdWx0LiBJZiBub3QgcGFzc2VkIGEgbmV3IG9uZSBpcyBjcmVhdGVkLlxuICAgICAqIEByZXR1cm5zIC1tLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG5lZ2F0ZShtLCBkc3QpIHtcbiAgICAgICAgY29uc3QgbmV3RHN0ID0gKGRzdCA/PyBuZXcgQ3RvcigxNikpO1xuICAgICAgICBuZXdEc3RbMF0gPSAtbVswXTtcbiAgICAgICAgbmV3RHN0WzFdID0gLW1bMV07XG4gICAgICAgIG5ld0RzdFsyXSA9IC1tWzJdO1xuICAgICAgICBuZXdEc3RbM10gPSAtbVszXTtcbiAgICAgICAgbmV3RHN0WzRdID0gLW1bNF07XG4gICAgICAgIG5ld0RzdFs1XSA9IC1tWzVdO1xuICAgICAgICBuZXdEc3RbNl0gPSAtbVs2XTtcbiAgICAgICAgbmV3RHN0WzddID0gLW1bN107XG4gICAgICAgIG5ld0RzdFs4XSA9IC1tWzhdO1xuICAgICAgICBuZXdEc3RbOV0gPSAtbVs5XTtcbiAgICAgICAgbmV3RHN0WzEwXSA9IC1tWzEwXTtcbiAgICAgICAgbmV3RHN0WzExXSA9IC1tWzExXTtcbiAgICAgICAgbmV3RHN0WzEyXSA9IC1tWzEyXTtcbiAgICAgICAgbmV3RHN0WzEzXSA9IC1tWzEzXTtcbiAgICAgICAgbmV3RHN0WzE0XSA9IC1tWzE0XTtcbiAgICAgICAgbmV3RHN0WzE1XSA9IC1tWzE1XTtcbiAgICAgICAgcmV0dXJuIG5ld0RzdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29waWVzIGEgbWF0cml4LiAoc2FtZSBhcyB7QGxpbmsgbWF0NC5jbG9uZX0pXG4gICAgICogQWxzbyBzZWUge0BsaW5rIG1hdDQuY3JlYXRlfSBhbmQge0BsaW5rIG1hdDQuc2V0fVxuICAgICAqIEBwYXJhbSBtIC0gVGhlIG1hdHJpeC5cbiAgICAgKiBAcGFyYW0gZHN0IC0gVGhlIG1hdHJpeC4gSWYgbm90IHBhc3NlZCBhIG5ldyBvbmUgaXMgY3JlYXRlZC5cbiAgICAgKiBAcmV0dXJucyBBIGNvcHkgb2YgbS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjb3B5KG0sIGRzdCkge1xuICAgICAgICBjb25zdCBuZXdEc3QgPSAoZHN0ID8/IG5ldyBDdG9yKDE2KSk7XG4gICAgICAgIG5ld0RzdFswXSA9IG1bMF07XG4gICAgICAgIG5ld0RzdFsxXSA9IG1bMV07XG4gICAgICAgIG5ld0RzdFsyXSA9IG1bMl07XG4gICAgICAgIG5ld0RzdFszXSA9IG1bM107XG4gICAgICAgIG5ld0RzdFs0XSA9IG1bNF07XG4gICAgICAgIG5ld0RzdFs1XSA9IG1bNV07XG4gICAgICAgIG5ld0RzdFs2XSA9IG1bNl07XG4gICAgICAgIG5ld0RzdFs3XSA9IG1bN107XG4gICAgICAgIG5ld0RzdFs4XSA9IG1bOF07XG4gICAgICAgIG5ld0RzdFs5XSA9IG1bOV07XG4gICAgICAgIG5ld0RzdFsxMF0gPSBtWzEwXTtcbiAgICAgICAgbmV3RHN0WzExXSA9IG1bMTFdO1xuICAgICAgICBuZXdEc3RbMTJdID0gbVsxMl07XG4gICAgICAgIG5ld0RzdFsxM10gPSBtWzEzXTtcbiAgICAgICAgbmV3RHN0WzE0XSA9IG1bMTRdO1xuICAgICAgICBuZXdEc3RbMTVdID0gbVsxNV07XG4gICAgICAgIHJldHVybiBuZXdEc3Q7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvcGllcyBhIG1hdHJpeCAoc2FtZSBhcyB7QGxpbmsgbWF0NC5jb3B5fSlcbiAgICAgKiBBbHNvIHNlZSB7QGxpbmsgbWF0NC5jcmVhdGV9IGFuZCB7QGxpbmsgbWF0NC5zZXR9XG4gICAgICogQHBhcmFtIG0gLSBUaGUgbWF0cml4LlxuICAgICAqIEBwYXJhbSBkc3QgLSBUaGUgbWF0cml4LiBJZiBub3QgcGFzc2VkIGEgbmV3IG9uZSBpcyBjcmVhdGVkLlxuICAgICAqIEByZXR1cm5zIEEgY29weSBvZiBtLlxuICAgICAqL1xuICAgIGNvbnN0IGNsb25lID0gY29weTtcbiAgICAvKipcbiAgICAgKiBDaGVjayBpZiAyIG1hdHJpY2VzIGFyZSBhcHByb3hpbWF0ZWx5IGVxdWFsXG4gICAgICogQHBhcmFtIGEgLSBPcGVyYW5kIG1hdHJpeC5cbiAgICAgKiBAcGFyYW0gYiAtIE9wZXJhbmQgbWF0cml4LlxuICAgICAqIEByZXR1cm5zIHRydWUgaWYgbWF0cmljZXMgYXJlIGFwcHJveGltYXRlbHkgZXF1YWxcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBlcXVhbHNBcHByb3hpbWF0ZWx5KGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIE1hdGguYWJzKGFbMF0gLSBiWzBdKSA8IEVQU0lMT04gJiZcbiAgICAgICAgICAgIE1hdGguYWJzKGFbMV0gLSBiWzFdKSA8IEVQU0lMT04gJiZcbiAgICAgICAgICAgIE1hdGguYWJzKGFbMl0gLSBiWzJdKSA8IEVQU0lMT04gJiZcbiAgICAgICAgICAgIE1hdGguYWJzKGFbM10gLSBiWzNdKSA8IEVQU0lMT04gJiZcbiAgICAgICAgICAgIE1hdGguYWJzKGFbNF0gLSBiWzRdKSA8IEVQU0lMT04gJiZcbiAgICAgICAgICAgIE1hdGguYWJzKGFbNV0gLSBiWzVdKSA8IEVQU0lMT04gJiZcbiAgICAgICAgICAgIE1hdGguYWJzKGFbNl0gLSBiWzZdKSA8IEVQU0lMT04gJiZcbiAgICAgICAgICAgIE1hdGguYWJzKGFbN10gLSBiWzddKSA8IEVQU0lMT04gJiZcbiAgICAgICAgICAgIE1hdGguYWJzKGFbOF0gLSBiWzhdKSA8IEVQU0lMT04gJiZcbiAgICAgICAgICAgIE1hdGguYWJzKGFbOV0gLSBiWzldKSA8IEVQU0lMT04gJiZcbiAgICAgICAgICAgIE1hdGguYWJzKGFbMTBdIC0gYlsxMF0pIDwgRVBTSUxPTiAmJlxuICAgICAgICAgICAgTWF0aC5hYnMoYVsxMV0gLSBiWzExXSkgPCBFUFNJTE9OICYmXG4gICAgICAgICAgICBNYXRoLmFicyhhWzEyXSAtIGJbMTJdKSA8IEVQU0lMT04gJiZcbiAgICAgICAgICAgIE1hdGguYWJzKGFbMTNdIC0gYlsxM10pIDwgRVBTSUxPTiAmJlxuICAgICAgICAgICAgTWF0aC5hYnMoYVsxNF0gLSBiWzE0XSkgPCBFUFNJTE9OICYmXG4gICAgICAgICAgICBNYXRoLmFicyhhWzE1XSAtIGJbMTVdKSA8IEVQU0lMT047XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENoZWNrIGlmIDIgbWF0cmljZXMgYXJlIGV4YWN0bHkgZXF1YWxcbiAgICAgKiBAcGFyYW0gYSAtIE9wZXJhbmQgbWF0cml4LlxuICAgICAqIEBwYXJhbSBiIC0gT3BlcmFuZCBtYXRyaXguXG4gICAgICogQHJldHVybnMgdHJ1ZSBpZiBtYXRyaWNlcyBhcmUgZXhhY3RseSBlcXVhbFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGVxdWFscyhhLCBiKSB7XG4gICAgICAgIHJldHVybiBhWzBdID09PSBiWzBdICYmXG4gICAgICAgICAgICBhWzFdID09PSBiWzFdICYmXG4gICAgICAgICAgICBhWzJdID09PSBiWzJdICYmXG4gICAgICAgICAgICBhWzNdID09PSBiWzNdICYmXG4gICAgICAgICAgICBhWzRdID09PSBiWzRdICYmXG4gICAgICAgICAgICBhWzVdID09PSBiWzVdICYmXG4gICAgICAgICAgICBhWzZdID09PSBiWzZdICYmXG4gICAgICAgICAgICBhWzddID09PSBiWzddICYmXG4gICAgICAgICAgICBhWzhdID09PSBiWzhdICYmXG4gICAgICAgICAgICBhWzldID09PSBiWzldICYmXG4gICAgICAgICAgICBhWzEwXSA9PT0gYlsxMF0gJiZcbiAgICAgICAgICAgIGFbMTFdID09PSBiWzExXSAmJlxuICAgICAgICAgICAgYVsxMl0gPT09IGJbMTJdICYmXG4gICAgICAgICAgICBhWzEzXSA9PT0gYlsxM10gJiZcbiAgICAgICAgICAgIGFbMTRdID09PSBiWzE0XSAmJlxuICAgICAgICAgICAgYVsxNV0gPT09IGJbMTVdO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgNC1ieS00IGlkZW50aXR5IG1hdHJpeC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBkc3QgLSBtYXRyaXggdG8gaG9sZCByZXN1bHQuIElmIG5vdCBwYXNzZWQgYSBuZXcgb25lIGlzIGNyZWF0ZWQuXG4gICAgICogQHJldHVybnMgQSA0LWJ5LTQgaWRlbnRpdHkgbWF0cml4LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlkZW50aXR5KGRzdCkge1xuICAgICAgICBjb25zdCBuZXdEc3QgPSAoZHN0ID8/IG5ldyBDdG9yKDE2KSk7XG4gICAgICAgIG5ld0RzdFswXSA9IDE7XG4gICAgICAgIG5ld0RzdFsxXSA9IDA7XG4gICAgICAgIG5ld0RzdFsyXSA9IDA7XG4gICAgICAgIG5ld0RzdFszXSA9IDA7XG4gICAgICAgIG5ld0RzdFs0XSA9IDA7XG4gICAgICAgIG5ld0RzdFs1XSA9IDE7XG4gICAgICAgIG5ld0RzdFs2XSA9IDA7XG4gICAgICAgIG5ld0RzdFs3XSA9IDA7XG4gICAgICAgIG5ld0RzdFs4XSA9IDA7XG4gICAgICAgIG5ld0RzdFs5XSA9IDA7XG4gICAgICAgIG5ld0RzdFsxMF0gPSAxO1xuICAgICAgICBuZXdEc3RbMTFdID0gMDtcbiAgICAgICAgbmV3RHN0WzEyXSA9IDA7XG4gICAgICAgIG5ld0RzdFsxM10gPSAwO1xuICAgICAgICBuZXdEc3RbMTRdID0gMDtcbiAgICAgICAgbmV3RHN0WzE1XSA9IDE7XG4gICAgICAgIHJldHVybiBuZXdEc3Q7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRha2VzIHRoZSB0cmFuc3Bvc2Ugb2YgYSBtYXRyaXguXG4gICAgICogQHBhcmFtIG0gLSBUaGUgbWF0cml4LlxuICAgICAqIEBwYXJhbSBkc3QgLSBtYXRyaXggdG8gaG9sZCByZXN1bHQuIElmIG5vdCBwYXNzZWQgYSBuZXcgb25lIGlzIGNyZWF0ZWQuXG4gICAgICogQHJldHVybnMgVGhlIHRyYW5zcG9zZSBvZiBtLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRyYW5zcG9zZShtLCBkc3QpIHtcbiAgICAgICAgY29uc3QgbmV3RHN0ID0gKGRzdCA/PyBuZXcgQ3RvcigxNikpO1xuICAgICAgICBpZiAobmV3RHN0ID09PSBtKSB7XG4gICAgICAgICAgICBsZXQgdDtcbiAgICAgICAgICAgIHQgPSBtWzFdO1xuICAgICAgICAgICAgbVsxXSA9IG1bNF07XG4gICAgICAgICAgICBtWzRdID0gdDtcbiAgICAgICAgICAgIHQgPSBtWzJdO1xuICAgICAgICAgICAgbVsyXSA9IG1bOF07XG4gICAgICAgICAgICBtWzhdID0gdDtcbiAgICAgICAgICAgIHQgPSBtWzNdO1xuICAgICAgICAgICAgbVszXSA9IG1bMTJdO1xuICAgICAgICAgICAgbVsxMl0gPSB0O1xuICAgICAgICAgICAgdCA9IG1bNl07XG4gICAgICAgICAgICBtWzZdID0gbVs5XTtcbiAgICAgICAgICAgIG1bOV0gPSB0O1xuICAgICAgICAgICAgdCA9IG1bN107XG4gICAgICAgICAgICBtWzddID0gbVsxM107XG4gICAgICAgICAgICBtWzEzXSA9IHQ7XG4gICAgICAgICAgICB0ID0gbVsxMV07XG4gICAgICAgICAgICBtWzExXSA9IG1bMTRdO1xuICAgICAgICAgICAgbVsxNF0gPSB0O1xuICAgICAgICAgICAgcmV0dXJuIG5ld0RzdDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBtMDAgPSBtWzAgKiA0ICsgMF07XG4gICAgICAgIGNvbnN0IG0wMSA9IG1bMCAqIDQgKyAxXTtcbiAgICAgICAgY29uc3QgbTAyID0gbVswICogNCArIDJdO1xuICAgICAgICBjb25zdCBtMDMgPSBtWzAgKiA0ICsgM107XG4gICAgICAgIGNvbnN0IG0xMCA9IG1bMSAqIDQgKyAwXTtcbiAgICAgICAgY29uc3QgbTExID0gbVsxICogNCArIDFdO1xuICAgICAgICBjb25zdCBtMTIgPSBtWzEgKiA0ICsgMl07XG4gICAgICAgIGNvbnN0IG0xMyA9IG1bMSAqIDQgKyAzXTtcbiAgICAgICAgY29uc3QgbTIwID0gbVsyICogNCArIDBdO1xuICAgICAgICBjb25zdCBtMjEgPSBtWzIgKiA0ICsgMV07XG4gICAgICAgIGNvbnN0IG0yMiA9IG1bMiAqIDQgKyAyXTtcbiAgICAgICAgY29uc3QgbTIzID0gbVsyICogNCArIDNdO1xuICAgICAgICBjb25zdCBtMzAgPSBtWzMgKiA0ICsgMF07XG4gICAgICAgIGNvbnN0IG0zMSA9IG1bMyAqIDQgKyAxXTtcbiAgICAgICAgY29uc3QgbTMyID0gbVszICogNCArIDJdO1xuICAgICAgICBjb25zdCBtMzMgPSBtWzMgKiA0ICsgM107XG4gICAgICAgIG5ld0RzdFswXSA9IG0wMDtcbiAgICAgICAgbmV3RHN0WzFdID0gbTEwO1xuICAgICAgICBuZXdEc3RbMl0gPSBtMjA7XG4gICAgICAgIG5ld0RzdFszXSA9IG0zMDtcbiAgICAgICAgbmV3RHN0WzRdID0gbTAxO1xuICAgICAgICBuZXdEc3RbNV0gPSBtMTE7XG4gICAgICAgIG5ld0RzdFs2XSA9IG0yMTtcbiAgICAgICAgbmV3RHN0WzddID0gbTMxO1xuICAgICAgICBuZXdEc3RbOF0gPSBtMDI7XG4gICAgICAgIG5ld0RzdFs5XSA9IG0xMjtcbiAgICAgICAgbmV3RHN0WzEwXSA9IG0yMjtcbiAgICAgICAgbmV3RHN0WzExXSA9IG0zMjtcbiAgICAgICAgbmV3RHN0WzEyXSA9IG0wMztcbiAgICAgICAgbmV3RHN0WzEzXSA9IG0xMztcbiAgICAgICAgbmV3RHN0WzE0XSA9IG0yMztcbiAgICAgICAgbmV3RHN0WzE1XSA9IG0zMztcbiAgICAgICAgcmV0dXJuIG5ld0RzdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29tcHV0ZXMgdGhlIGludmVyc2Ugb2YgYSA0LWJ5LTQgbWF0cml4LlxuICAgICAqIEBwYXJhbSBtIC0gVGhlIG1hdHJpeC5cbiAgICAgKiBAcGFyYW0gZHN0IC0gbWF0cml4IHRvIGhvbGQgcmVzdWx0LiBJZiBub3QgcGFzc2VkIGEgbmV3IG9uZSBpcyBjcmVhdGVkLlxuICAgICAqIEByZXR1cm5zIFRoZSBpbnZlcnNlIG9mIG0uXG4gICAgICovXG4gICAgZnVuY3Rpb24gaW52ZXJzZShtLCBkc3QpIHtcbiAgICAgICAgY29uc3QgbmV3RHN0ID0gKGRzdCA/PyBuZXcgQ3RvcigxNikpO1xuICAgICAgICBjb25zdCBtMDAgPSBtWzAgKiA0ICsgMF07XG4gICAgICAgIGNvbnN0IG0wMSA9IG1bMCAqIDQgKyAxXTtcbiAgICAgICAgY29uc3QgbTAyID0gbVswICogNCArIDJdO1xuICAgICAgICBjb25zdCBtMDMgPSBtWzAgKiA0ICsgM107XG4gICAgICAgIGNvbnN0IG0xMCA9IG1bMSAqIDQgKyAwXTtcbiAgICAgICAgY29uc3QgbTExID0gbVsxICogNCArIDFdO1xuICAgICAgICBjb25zdCBtMTIgPSBtWzEgKiA0ICsgMl07XG4gICAgICAgIGNvbnN0IG0xMyA9IG1bMSAqIDQgKyAzXTtcbiAgICAgICAgY29uc3QgbTIwID0gbVsyICogNCArIDBdO1xuICAgICAgICBjb25zdCBtMjEgPSBtWzIgKiA0ICsgMV07XG4gICAgICAgIGNvbnN0IG0yMiA9IG1bMiAqIDQgKyAyXTtcbiAgICAgICAgY29uc3QgbTIzID0gbVsyICogNCArIDNdO1xuICAgICAgICBjb25zdCBtMzAgPSBtWzMgKiA0ICsgMF07XG4gICAgICAgIGNvbnN0IG0zMSA9IG1bMyAqIDQgKyAxXTtcbiAgICAgICAgY29uc3QgbTMyID0gbVszICogNCArIDJdO1xuICAgICAgICBjb25zdCBtMzMgPSBtWzMgKiA0ICsgM107XG4gICAgICAgIGNvbnN0IHRtcDAgPSBtMjIgKiBtMzM7XG4gICAgICAgIGNvbnN0IHRtcDEgPSBtMzIgKiBtMjM7XG4gICAgICAgIGNvbnN0IHRtcDIgPSBtMTIgKiBtMzM7XG4gICAgICAgIGNvbnN0IHRtcDMgPSBtMzIgKiBtMTM7XG4gICAgICAgIGNvbnN0IHRtcDQgPSBtMTIgKiBtMjM7XG4gICAgICAgIGNvbnN0IHRtcDUgPSBtMjIgKiBtMTM7XG4gICAgICAgIGNvbnN0IHRtcDYgPSBtMDIgKiBtMzM7XG4gICAgICAgIGNvbnN0IHRtcDcgPSBtMzIgKiBtMDM7XG4gICAgICAgIGNvbnN0IHRtcDggPSBtMDIgKiBtMjM7XG4gICAgICAgIGNvbnN0IHRtcDkgPSBtMjIgKiBtMDM7XG4gICAgICAgIGNvbnN0IHRtcDEwID0gbTAyICogbTEzO1xuICAgICAgICBjb25zdCB0bXAxMSA9IG0xMiAqIG0wMztcbiAgICAgICAgY29uc3QgdG1wMTIgPSBtMjAgKiBtMzE7XG4gICAgICAgIGNvbnN0IHRtcDEzID0gbTMwICogbTIxO1xuICAgICAgICBjb25zdCB0bXAxNCA9IG0xMCAqIG0zMTtcbiAgICAgICAgY29uc3QgdG1wMTUgPSBtMzAgKiBtMTE7XG4gICAgICAgIGNvbnN0IHRtcDE2ID0gbTEwICogbTIxO1xuICAgICAgICBjb25zdCB0bXAxNyA9IG0yMCAqIG0xMTtcbiAgICAgICAgY29uc3QgdG1wMTggPSBtMDAgKiBtMzE7XG4gICAgICAgIGNvbnN0IHRtcDE5ID0gbTMwICogbTAxO1xuICAgICAgICBjb25zdCB0bXAyMCA9IG0wMCAqIG0yMTtcbiAgICAgICAgY29uc3QgdG1wMjEgPSBtMjAgKiBtMDE7XG4gICAgICAgIGNvbnN0IHRtcDIyID0gbTAwICogbTExO1xuICAgICAgICBjb25zdCB0bXAyMyA9IG0xMCAqIG0wMTtcbiAgICAgICAgY29uc3QgdDAgPSAodG1wMCAqIG0xMSArIHRtcDMgKiBtMjEgKyB0bXA0ICogbTMxKSAtXG4gICAgICAgICAgICAodG1wMSAqIG0xMSArIHRtcDIgKiBtMjEgKyB0bXA1ICogbTMxKTtcbiAgICAgICAgY29uc3QgdDEgPSAodG1wMSAqIG0wMSArIHRtcDYgKiBtMjEgKyB0bXA5ICogbTMxKSAtXG4gICAgICAgICAgICAodG1wMCAqIG0wMSArIHRtcDcgKiBtMjEgKyB0bXA4ICogbTMxKTtcbiAgICAgICAgY29uc3QgdDIgPSAodG1wMiAqIG0wMSArIHRtcDcgKiBtMTEgKyB0bXAxMCAqIG0zMSkgLVxuICAgICAgICAgICAgKHRtcDMgKiBtMDEgKyB0bXA2ICogbTExICsgdG1wMTEgKiBtMzEpO1xuICAgICAgICBjb25zdCB0MyA9ICh0bXA1ICogbTAxICsgdG1wOCAqIG0xMSArIHRtcDExICogbTIxKSAtXG4gICAgICAgICAgICAodG1wNCAqIG0wMSArIHRtcDkgKiBtMTEgKyB0bXAxMCAqIG0yMSk7XG4gICAgICAgIGNvbnN0IGQgPSAxIC8gKG0wMCAqIHQwICsgbTEwICogdDEgKyBtMjAgKiB0MiArIG0zMCAqIHQzKTtcbiAgICAgICAgbmV3RHN0WzBdID0gZCAqIHQwO1xuICAgICAgICBuZXdEc3RbMV0gPSBkICogdDE7XG4gICAgICAgIG5ld0RzdFsyXSA9IGQgKiB0MjtcbiAgICAgICAgbmV3RHN0WzNdID0gZCAqIHQzO1xuICAgICAgICBuZXdEc3RbNF0gPSBkICogKCh0bXAxICogbTEwICsgdG1wMiAqIG0yMCArIHRtcDUgKiBtMzApIC1cbiAgICAgICAgICAgICh0bXAwICogbTEwICsgdG1wMyAqIG0yMCArIHRtcDQgKiBtMzApKTtcbiAgICAgICAgbmV3RHN0WzVdID0gZCAqICgodG1wMCAqIG0wMCArIHRtcDcgKiBtMjAgKyB0bXA4ICogbTMwKSAtXG4gICAgICAgICAgICAodG1wMSAqIG0wMCArIHRtcDYgKiBtMjAgKyB0bXA5ICogbTMwKSk7XG4gICAgICAgIG5ld0RzdFs2XSA9IGQgKiAoKHRtcDMgKiBtMDAgKyB0bXA2ICogbTEwICsgdG1wMTEgKiBtMzApIC1cbiAgICAgICAgICAgICh0bXAyICogbTAwICsgdG1wNyAqIG0xMCArIHRtcDEwICogbTMwKSk7XG4gICAgICAgIG5ld0RzdFs3XSA9IGQgKiAoKHRtcDQgKiBtMDAgKyB0bXA5ICogbTEwICsgdG1wMTAgKiBtMjApIC1cbiAgICAgICAgICAgICh0bXA1ICogbTAwICsgdG1wOCAqIG0xMCArIHRtcDExICogbTIwKSk7XG4gICAgICAgIG5ld0RzdFs4XSA9IGQgKiAoKHRtcDEyICogbTEzICsgdG1wMTUgKiBtMjMgKyB0bXAxNiAqIG0zMykgLVxuICAgICAgICAgICAgKHRtcDEzICogbTEzICsgdG1wMTQgKiBtMjMgKyB0bXAxNyAqIG0zMykpO1xuICAgICAgICBuZXdEc3RbOV0gPSBkICogKCh0bXAxMyAqIG0wMyArIHRtcDE4ICogbTIzICsgdG1wMjEgKiBtMzMpIC1cbiAgICAgICAgICAgICh0bXAxMiAqIG0wMyArIHRtcDE5ICogbTIzICsgdG1wMjAgKiBtMzMpKTtcbiAgICAgICAgbmV3RHN0WzEwXSA9IGQgKiAoKHRtcDE0ICogbTAzICsgdG1wMTkgKiBtMTMgKyB0bXAyMiAqIG0zMykgLVxuICAgICAgICAgICAgKHRtcDE1ICogbTAzICsgdG1wMTggKiBtMTMgKyB0bXAyMyAqIG0zMykpO1xuICAgICAgICBuZXdEc3RbMTFdID0gZCAqICgodG1wMTcgKiBtMDMgKyB0bXAyMCAqIG0xMyArIHRtcDIzICogbTIzKSAtXG4gICAgICAgICAgICAodG1wMTYgKiBtMDMgKyB0bXAyMSAqIG0xMyArIHRtcDIyICogbTIzKSk7XG4gICAgICAgIG5ld0RzdFsxMl0gPSBkICogKCh0bXAxNCAqIG0yMiArIHRtcDE3ICogbTMyICsgdG1wMTMgKiBtMTIpIC1cbiAgICAgICAgICAgICh0bXAxNiAqIG0zMiArIHRtcDEyICogbTEyICsgdG1wMTUgKiBtMjIpKTtcbiAgICAgICAgbmV3RHN0WzEzXSA9IGQgKiAoKHRtcDIwICogbTMyICsgdG1wMTIgKiBtMDIgKyB0bXAxOSAqIG0yMikgLVxuICAgICAgICAgICAgKHRtcDE4ICogbTIyICsgdG1wMjEgKiBtMzIgKyB0bXAxMyAqIG0wMikpO1xuICAgICAgICBuZXdEc3RbMTRdID0gZCAqICgodG1wMTggKiBtMTIgKyB0bXAyMyAqIG0zMiArIHRtcDE1ICogbTAyKSAtXG4gICAgICAgICAgICAodG1wMjIgKiBtMzIgKyB0bXAxNCAqIG0wMiArIHRtcDE5ICogbTEyKSk7XG4gICAgICAgIG5ld0RzdFsxNV0gPSBkICogKCh0bXAyMiAqIG0yMiArIHRtcDE2ICogbTAyICsgdG1wMjEgKiBtMTIpIC1cbiAgICAgICAgICAgICh0bXAyMCAqIG0xMiArIHRtcDIzICogbTIyICsgdG1wMTcgKiBtMDIpKTtcbiAgICAgICAgcmV0dXJuIG5ld0RzdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29tcHV0ZSB0aGUgZGV0ZXJtaW5hbnQgb2YgYSBtYXRyaXhcbiAgICAgKiBAcGFyYW0gbSAtIHRoZSBtYXRyaXhcbiAgICAgKiBAcmV0dXJucyB0aGUgZGV0ZXJtaW5hbnRcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBkZXRlcm1pbmFudChtKSB7XG4gICAgICAgIGNvbnN0IG0wMCA9IG1bMCAqIDQgKyAwXTtcbiAgICAgICAgY29uc3QgbTAxID0gbVswICogNCArIDFdO1xuICAgICAgICBjb25zdCBtMDIgPSBtWzAgKiA0ICsgMl07XG4gICAgICAgIGNvbnN0IG0wMyA9IG1bMCAqIDQgKyAzXTtcbiAgICAgICAgY29uc3QgbTEwID0gbVsxICogNCArIDBdO1xuICAgICAgICBjb25zdCBtMTEgPSBtWzEgKiA0ICsgMV07XG4gICAgICAgIGNvbnN0IG0xMiA9IG1bMSAqIDQgKyAyXTtcbiAgICAgICAgY29uc3QgbTEzID0gbVsxICogNCArIDNdO1xuICAgICAgICBjb25zdCBtMjAgPSBtWzIgKiA0ICsgMF07XG4gICAgICAgIGNvbnN0IG0yMSA9IG1bMiAqIDQgKyAxXTtcbiAgICAgICAgY29uc3QgbTIyID0gbVsyICogNCArIDJdO1xuICAgICAgICBjb25zdCBtMjMgPSBtWzIgKiA0ICsgM107XG4gICAgICAgIGNvbnN0IG0zMCA9IG1bMyAqIDQgKyAwXTtcbiAgICAgICAgY29uc3QgbTMxID0gbVszICogNCArIDFdO1xuICAgICAgICBjb25zdCBtMzIgPSBtWzMgKiA0ICsgMl07XG4gICAgICAgIGNvbnN0IG0zMyA9IG1bMyAqIDQgKyAzXTtcbiAgICAgICAgY29uc3QgdG1wMCA9IG0yMiAqIG0zMztcbiAgICAgICAgY29uc3QgdG1wMSA9IG0zMiAqIG0yMztcbiAgICAgICAgY29uc3QgdG1wMiA9IG0xMiAqIG0zMztcbiAgICAgICAgY29uc3QgdG1wMyA9IG0zMiAqIG0xMztcbiAgICAgICAgY29uc3QgdG1wNCA9IG0xMiAqIG0yMztcbiAgICAgICAgY29uc3QgdG1wNSA9IG0yMiAqIG0xMztcbiAgICAgICAgY29uc3QgdG1wNiA9IG0wMiAqIG0zMztcbiAgICAgICAgY29uc3QgdG1wNyA9IG0zMiAqIG0wMztcbiAgICAgICAgY29uc3QgdG1wOCA9IG0wMiAqIG0yMztcbiAgICAgICAgY29uc3QgdG1wOSA9IG0yMiAqIG0wMztcbiAgICAgICAgY29uc3QgdG1wMTAgPSBtMDIgKiBtMTM7XG4gICAgICAgIGNvbnN0IHRtcDExID0gbTEyICogbTAzO1xuICAgICAgICBjb25zdCB0MCA9ICh0bXAwICogbTExICsgdG1wMyAqIG0yMSArIHRtcDQgKiBtMzEpIC1cbiAgICAgICAgICAgICh0bXAxICogbTExICsgdG1wMiAqIG0yMSArIHRtcDUgKiBtMzEpO1xuICAgICAgICBjb25zdCB0MSA9ICh0bXAxICogbTAxICsgdG1wNiAqIG0yMSArIHRtcDkgKiBtMzEpIC1cbiAgICAgICAgICAgICh0bXAwICogbTAxICsgdG1wNyAqIG0yMSArIHRtcDggKiBtMzEpO1xuICAgICAgICBjb25zdCB0MiA9ICh0bXAyICogbTAxICsgdG1wNyAqIG0xMSArIHRtcDEwICogbTMxKSAtXG4gICAgICAgICAgICAodG1wMyAqIG0wMSArIHRtcDYgKiBtMTEgKyB0bXAxMSAqIG0zMSk7XG4gICAgICAgIGNvbnN0IHQzID0gKHRtcDUgKiBtMDEgKyB0bXA4ICogbTExICsgdG1wMTEgKiBtMjEpIC1cbiAgICAgICAgICAgICh0bXA0ICogbTAxICsgdG1wOSAqIG0xMSArIHRtcDEwICogbTIxKTtcbiAgICAgICAgcmV0dXJuIG0wMCAqIHQwICsgbTEwICogdDEgKyBtMjAgKiB0MiArIG0zMCAqIHQzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb21wdXRlcyB0aGUgaW52ZXJzZSBvZiBhIDQtYnktNCBtYXRyaXguIChzYW1lIGFzIGludmVyc2UpXG4gICAgICogQHBhcmFtIG0gLSBUaGUgbWF0cml4LlxuICAgICAqIEBwYXJhbSBkc3QgLSBtYXRyaXggdG8gaG9sZCByZXN1bHQuIElmIG5vdCBwYXNzZWQgYSBuZXcgb25lIGlzIGNyZWF0ZWQuXG4gICAgICogQHJldHVybnMgVGhlIGludmVyc2Ugb2YgbS5cbiAgICAgKi9cbiAgICBjb25zdCBpbnZlcnQgPSBpbnZlcnNlO1xuICAgIC8qKlxuICAgICAqIE11bHRpcGxpZXMgdHdvIDQtYnktNCBtYXRyaWNlcyB3aXRoIGEgb24gdGhlIGxlZnQgYW5kIGIgb24gdGhlIHJpZ2h0XG4gICAgICogQHBhcmFtIGEgLSBUaGUgbWF0cml4IG9uIHRoZSBsZWZ0LlxuICAgICAqIEBwYXJhbSBiIC0gVGhlIG1hdHJpeCBvbiB0aGUgcmlnaHQuXG4gICAgICogQHBhcmFtIGRzdCAtIG1hdHJpeCB0byBob2xkIHJlc3VsdC4gSWYgbm90IHBhc3NlZCBhIG5ldyBvbmUgaXMgY3JlYXRlZC5cbiAgICAgKiBAcmV0dXJucyBUaGUgbWF0cml4IHByb2R1Y3Qgb2YgYSBhbmQgYi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBtdWx0aXBseShhLCBiLCBkc3QpIHtcbiAgICAgICAgY29uc3QgbmV3RHN0ID0gKGRzdCA/PyBuZXcgQ3RvcigxNikpO1xuICAgICAgICBjb25zdCBhMDAgPSBhWzBdO1xuICAgICAgICBjb25zdCBhMDEgPSBhWzFdO1xuICAgICAgICBjb25zdCBhMDIgPSBhWzJdO1xuICAgICAgICBjb25zdCBhMDMgPSBhWzNdO1xuICAgICAgICBjb25zdCBhMTAgPSBhWzQgKyAwXTtcbiAgICAgICAgY29uc3QgYTExID0gYVs0ICsgMV07XG4gICAgICAgIGNvbnN0IGExMiA9IGFbNCArIDJdO1xuICAgICAgICBjb25zdCBhMTMgPSBhWzQgKyAzXTtcbiAgICAgICAgY29uc3QgYTIwID0gYVs4ICsgMF07XG4gICAgICAgIGNvbnN0IGEyMSA9IGFbOCArIDFdO1xuICAgICAgICBjb25zdCBhMjIgPSBhWzggKyAyXTtcbiAgICAgICAgY29uc3QgYTIzID0gYVs4ICsgM107XG4gICAgICAgIGNvbnN0IGEzMCA9IGFbMTIgKyAwXTtcbiAgICAgICAgY29uc3QgYTMxID0gYVsxMiArIDFdO1xuICAgICAgICBjb25zdCBhMzIgPSBhWzEyICsgMl07XG4gICAgICAgIGNvbnN0IGEzMyA9IGFbMTIgKyAzXTtcbiAgICAgICAgY29uc3QgYjAwID0gYlswXTtcbiAgICAgICAgY29uc3QgYjAxID0gYlsxXTtcbiAgICAgICAgY29uc3QgYjAyID0gYlsyXTtcbiAgICAgICAgY29uc3QgYjAzID0gYlszXTtcbiAgICAgICAgY29uc3QgYjEwID0gYls0ICsgMF07XG4gICAgICAgIGNvbnN0IGIxMSA9IGJbNCArIDFdO1xuICAgICAgICBjb25zdCBiMTIgPSBiWzQgKyAyXTtcbiAgICAgICAgY29uc3QgYjEzID0gYls0ICsgM107XG4gICAgICAgIGNvbnN0IGIyMCA9IGJbOCArIDBdO1xuICAgICAgICBjb25zdCBiMjEgPSBiWzggKyAxXTtcbiAgICAgICAgY29uc3QgYjIyID0gYls4ICsgMl07XG4gICAgICAgIGNvbnN0IGIyMyA9IGJbOCArIDNdO1xuICAgICAgICBjb25zdCBiMzAgPSBiWzEyICsgMF07XG4gICAgICAgIGNvbnN0IGIzMSA9IGJbMTIgKyAxXTtcbiAgICAgICAgY29uc3QgYjMyID0gYlsxMiArIDJdO1xuICAgICAgICBjb25zdCBiMzMgPSBiWzEyICsgM107XG4gICAgICAgIG5ld0RzdFswXSA9IGEwMCAqIGIwMCArIGExMCAqIGIwMSArIGEyMCAqIGIwMiArIGEzMCAqIGIwMztcbiAgICAgICAgbmV3RHN0WzFdID0gYTAxICogYjAwICsgYTExICogYjAxICsgYTIxICogYjAyICsgYTMxICogYjAzO1xuICAgICAgICBuZXdEc3RbMl0gPSBhMDIgKiBiMDAgKyBhMTIgKiBiMDEgKyBhMjIgKiBiMDIgKyBhMzIgKiBiMDM7XG4gICAgICAgIG5ld0RzdFszXSA9IGEwMyAqIGIwMCArIGExMyAqIGIwMSArIGEyMyAqIGIwMiArIGEzMyAqIGIwMztcbiAgICAgICAgbmV3RHN0WzRdID0gYTAwICogYjEwICsgYTEwICogYjExICsgYTIwICogYjEyICsgYTMwICogYjEzO1xuICAgICAgICBuZXdEc3RbNV0gPSBhMDEgKiBiMTAgKyBhMTEgKiBiMTEgKyBhMjEgKiBiMTIgKyBhMzEgKiBiMTM7XG4gICAgICAgIG5ld0RzdFs2XSA9IGEwMiAqIGIxMCArIGExMiAqIGIxMSArIGEyMiAqIGIxMiArIGEzMiAqIGIxMztcbiAgICAgICAgbmV3RHN0WzddID0gYTAzICogYjEwICsgYTEzICogYjExICsgYTIzICogYjEyICsgYTMzICogYjEzO1xuICAgICAgICBuZXdEc3RbOF0gPSBhMDAgKiBiMjAgKyBhMTAgKiBiMjEgKyBhMjAgKiBiMjIgKyBhMzAgKiBiMjM7XG4gICAgICAgIG5ld0RzdFs5XSA9IGEwMSAqIGIyMCArIGExMSAqIGIyMSArIGEyMSAqIGIyMiArIGEzMSAqIGIyMztcbiAgICAgICAgbmV3RHN0WzEwXSA9IGEwMiAqIGIyMCArIGExMiAqIGIyMSArIGEyMiAqIGIyMiArIGEzMiAqIGIyMztcbiAgICAgICAgbmV3RHN0WzExXSA9IGEwMyAqIGIyMCArIGExMyAqIGIyMSArIGEyMyAqIGIyMiArIGEzMyAqIGIyMztcbiAgICAgICAgbmV3RHN0WzEyXSA9IGEwMCAqIGIzMCArIGExMCAqIGIzMSArIGEyMCAqIGIzMiArIGEzMCAqIGIzMztcbiAgICAgICAgbmV3RHN0WzEzXSA9IGEwMSAqIGIzMCArIGExMSAqIGIzMSArIGEyMSAqIGIzMiArIGEzMSAqIGIzMztcbiAgICAgICAgbmV3RHN0WzE0XSA9IGEwMiAqIGIzMCArIGExMiAqIGIzMSArIGEyMiAqIGIzMiArIGEzMiAqIGIzMztcbiAgICAgICAgbmV3RHN0WzE1XSA9IGEwMyAqIGIzMCArIGExMyAqIGIzMSArIGEyMyAqIGIzMiArIGEzMyAqIGIzMztcbiAgICAgICAgcmV0dXJuIG5ld0RzdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTXVsdGlwbGllcyB0d28gNC1ieS00IG1hdHJpY2VzIHdpdGggYSBvbiB0aGUgbGVmdCBhbmQgYiBvbiB0aGUgcmlnaHQgKHNhbWUgYXMgbXVsdGlwbHkpXG4gICAgICogQHBhcmFtIGEgLSBUaGUgbWF0cml4IG9uIHRoZSBsZWZ0LlxuICAgICAqIEBwYXJhbSBiIC0gVGhlIG1hdHJpeCBvbiB0aGUgcmlnaHQuXG4gICAgICogQHBhcmFtIGRzdCAtIG1hdHJpeCB0byBob2xkIHJlc3VsdC4gSWYgbm90IHBhc3NlZCBhIG5ldyBvbmUgaXMgY3JlYXRlZC5cbiAgICAgKiBAcmV0dXJucyBUaGUgbWF0cml4IHByb2R1Y3Qgb2YgYSBhbmQgYi5cbiAgICAgKi9cbiAgICBjb25zdCBtdWwgPSBtdWx0aXBseTtcbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSB0cmFuc2xhdGlvbiBjb21wb25lbnQgb2YgYSA0LWJ5LTQgbWF0cml4IHRvIHRoZSBnaXZlblxuICAgICAqIHZlY3Rvci5cbiAgICAgKiBAcGFyYW0gYSAtIFRoZSBtYXRyaXguXG4gICAgICogQHBhcmFtIHYgLSBUaGUgdmVjdG9yLlxuICAgICAqIEBwYXJhbSBkc3QgLSBtYXRyaXggdG8gaG9sZCByZXN1bHQuIElmIG5vdCBwYXNzZWQgYSBuZXcgb25lIGlzIGNyZWF0ZWQuXG4gICAgICogQHJldHVybnMgVGhlIG1hdHJpeCB3aXRoIHRyYW5zbGF0aW9uIHNldC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzZXRUcmFuc2xhdGlvbihhLCB2LCBkc3QpIHtcbiAgICAgICAgY29uc3QgbmV3RHN0ID0gKGRzdCA/PyBpZGVudGl0eSgpKTtcbiAgICAgICAgaWYgKGEgIT09IG5ld0RzdCkge1xuICAgICAgICAgICAgbmV3RHN0WzBdID0gYVswXTtcbiAgICAgICAgICAgIG5ld0RzdFsxXSA9IGFbMV07XG4gICAgICAgICAgICBuZXdEc3RbMl0gPSBhWzJdO1xuICAgICAgICAgICAgbmV3RHN0WzNdID0gYVszXTtcbiAgICAgICAgICAgIG5ld0RzdFs0XSA9IGFbNF07XG4gICAgICAgICAgICBuZXdEc3RbNV0gPSBhWzVdO1xuICAgICAgICAgICAgbmV3RHN0WzZdID0gYVs2XTtcbiAgICAgICAgICAgIG5ld0RzdFs3XSA9IGFbN107XG4gICAgICAgICAgICBuZXdEc3RbOF0gPSBhWzhdO1xuICAgICAgICAgICAgbmV3RHN0WzldID0gYVs5XTtcbiAgICAgICAgICAgIG5ld0RzdFsxMF0gPSBhWzEwXTtcbiAgICAgICAgICAgIG5ld0RzdFsxMV0gPSBhWzExXTtcbiAgICAgICAgfVxuICAgICAgICBuZXdEc3RbMTJdID0gdlswXTtcbiAgICAgICAgbmV3RHN0WzEzXSA9IHZbMV07XG4gICAgICAgIG5ld0RzdFsxNF0gPSB2WzJdO1xuICAgICAgICBuZXdEc3RbMTVdID0gMTtcbiAgICAgICAgcmV0dXJuIG5ld0RzdDtcbiAgICB9XG4gICAgLy8vKipcbiAgICAvLyAqIFJldHVybnMgdGhlIHRyYW5zbGF0aW9uIGNvbXBvbmVudCBvZiBhIDQtYnktNCBtYXRyaXggYXMgYSB2ZWN0b3Igd2l0aCAzXG4gICAgLy8gKiBlbnRyaWVzLlxuICAgIC8vICogQHBhcmFtIG0gLSBUaGUgbWF0cml4LlxuICAgIC8vICogQHBhcmFtIGRzdCAtIHZlY3RvciB0byBob2xkIHJlc3VsdC4gSWYgbm90IHBhc3NlZCBhIG5ldyBvbmUgaXMgY3JlYXRlZC5cbiAgICAvLyAqIEByZXR1cm5zIFRoZSB0cmFuc2xhdGlvbiBjb21wb25lbnQgb2YgbS5cbiAgICAvLyAqL1xuICAgIGZ1bmN0aW9uIGdldFRyYW5zbGF0aW9uKG0sIGRzdCkge1xuICAgICAgICBjb25zdCBuZXdEc3QgPSAoZHN0ID8/IHZlYzMuY3JlYXRlKCkpO1xuICAgICAgICBuZXdEc3RbMF0gPSBtWzEyXTtcbiAgICAgICAgbmV3RHN0WzFdID0gbVsxM107XG4gICAgICAgIG5ld0RzdFsyXSA9IG1bMTRdO1xuICAgICAgICByZXR1cm4gbmV3RHN0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGFuIGF4aXMgb2YgYSA0eDQgbWF0cml4IGFzIGEgdmVjdG9yIHdpdGggMyBlbnRyaWVzXG4gICAgICogQHBhcmFtIG0gLSBUaGUgbWF0cml4LlxuICAgICAqIEBwYXJhbSBheGlzIC0gVGhlIGF4aXMgMCA9IHgsIDEgPSB5LCAyID0gejtcbiAgICAgKiBAcmV0dXJucyBUaGUgYXhpcyBjb21wb25lbnQgb2YgbS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBnZXRBeGlzKG0sIGF4aXMsIGRzdCkge1xuICAgICAgICBjb25zdCBuZXdEc3QgPSAoZHN0ID8/IHZlYzMuY3JlYXRlKCkpO1xuICAgICAgICBjb25zdCBvZmYgPSBheGlzICogNDtcbiAgICAgICAgbmV3RHN0WzBdID0gbVtvZmYgKyAwXTtcbiAgICAgICAgbmV3RHN0WzFdID0gbVtvZmYgKyAxXTtcbiAgICAgICAgbmV3RHN0WzJdID0gbVtvZmYgKyAyXTtcbiAgICAgICAgcmV0dXJuIG5ld0RzdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyBhbiBheGlzIG9mIGEgNHg0IG1hdHJpeCBhcyBhIHZlY3RvciB3aXRoIDMgZW50cmllc1xuICAgICAqIEBwYXJhbSBtIC0gVGhlIG1hdHJpeC5cbiAgICAgKiBAcGFyYW0gdiAtIHRoZSBheGlzIHZlY3RvclxuICAgICAqIEBwYXJhbSBheGlzIC0gVGhlIGF4aXMgIDAgPSB4LCAxID0geSwgMiA9IHo7XG4gICAgICogQHBhcmFtIGRzdCAtIFRoZSBtYXRyaXggdG8gc2V0LiBJZiBub3QgcGFzc2VkIGEgbmV3IG9uZSBpcyBjcmVhdGVkLlxuICAgICAqIEByZXR1cm5zIFRoZSBtYXRyaXggd2l0aCBheGlzIHNldC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzZXRBeGlzKG0sIHYsIGF4aXMsIGRzdCkge1xuICAgICAgICBjb25zdCBuZXdEc3QgPSAoZHN0ID09PSBtKSA/IGRzdCA6IGNvcHkobSwgZHN0KTtcbiAgICAgICAgY29uc3Qgb2ZmID0gYXhpcyAqIDQ7XG4gICAgICAgIG5ld0RzdFtvZmYgKyAwXSA9IHZbMF07XG4gICAgICAgIG5ld0RzdFtvZmYgKyAxXSA9IHZbMV07XG4gICAgICAgIG5ld0RzdFtvZmYgKyAyXSA9IHZbMl07XG4gICAgICAgIHJldHVybiBuZXdEc3Q7XG4gICAgfVxuICAgIC8vLyoqXG4gICAgLy8gKiBSZXR1cm5zIHRoZSBzY2FsaW5nIGNvbXBvbmVudCBvZiB0aGUgbWF0cml4XG4gICAgLy8gKiBAcGFyYW0gbSAtIFRoZSBNYXRyaXhcbiAgICAvLyAqIEBwYXJhbSBkc3QgLSBUaGUgdmVjdG9yIHRvIHNldC4gSWYgbm90IHBhc3NlZCBhIG5ldyBvbmUgaXMgY3JlYXRlZC5cbiAgICAvLyAqL1xuICAgIGZ1bmN0aW9uIGdldFNjYWxpbmcobSwgZHN0KSB7XG4gICAgICAgIGNvbnN0IG5ld0RzdCA9IChkc3QgPz8gdmVjMy5jcmVhdGUoKSk7XG4gICAgICAgIGNvbnN0IHh4ID0gbVswXTtcbiAgICAgICAgY29uc3QgeHkgPSBtWzFdO1xuICAgICAgICBjb25zdCB4eiA9IG1bMl07XG4gICAgICAgIGNvbnN0IHl4ID0gbVs0XTtcbiAgICAgICAgY29uc3QgeXkgPSBtWzVdO1xuICAgICAgICBjb25zdCB5eiA9IG1bNl07XG4gICAgICAgIGNvbnN0IHp4ID0gbVs4XTtcbiAgICAgICAgY29uc3QgenkgPSBtWzldO1xuICAgICAgICBjb25zdCB6eiA9IG1bMTBdO1xuICAgICAgICBuZXdEc3RbMF0gPSBNYXRoLnNxcnQoeHggKiB4eCArIHh5ICogeHkgKyB4eiAqIHh6KTtcbiAgICAgICAgbmV3RHN0WzFdID0gTWF0aC5zcXJ0KHl4ICogeXggKyB5eSAqIHl5ICsgeXogKiB5eik7XG4gICAgICAgIG5ld0RzdFsyXSA9IE1hdGguc3FydCh6eCAqIHp4ICsgenkgKiB6eSArIHp6ICogenopO1xuICAgICAgICByZXR1cm4gbmV3RHN0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb21wdXRlcyBhIDQtYnktNCBwZXJzcGVjdGl2ZSB0cmFuc2Zvcm1hdGlvbiBtYXRyaXggZ2l2ZW4gdGhlIGFuZ3VsYXIgaGVpZ2h0XG4gICAgICogb2YgdGhlIGZydXN0dW0sIHRoZSBhc3BlY3QgcmF0aW8sIGFuZCB0aGUgbmVhciBhbmQgZmFyIGNsaXBwaW5nIHBsYW5lcy4gIFRoZVxuICAgICAqIGFyZ3VtZW50cyBkZWZpbmUgYSBmcnVzdHVtIGV4dGVuZGluZyBpbiB0aGUgbmVnYXRpdmUgeiBkaXJlY3Rpb24uICBUaGUgZ2l2ZW5cbiAgICAgKiBhbmdsZSBpcyB0aGUgdmVydGljYWwgYW5nbGUgb2YgdGhlIGZydXN0dW0sIGFuZCB0aGUgaG9yaXpvbnRhbCBhbmdsZSBpc1xuICAgICAqIGRldGVybWluZWQgdG8gcHJvZHVjZSB0aGUgZ2l2ZW4gYXNwZWN0IHJhdGlvLiAgVGhlIGFyZ3VtZW50cyBuZWFyIGFuZCBmYXIgYXJlXG4gICAgICogdGhlIGRpc3RhbmNlcyB0byB0aGUgbmVhciBhbmQgZmFyIGNsaXBwaW5nIHBsYW5lcy4gIE5vdGUgdGhhdCBuZWFyIGFuZCBmYXJcbiAgICAgKiBhcmUgbm90IHogY29vcmRpbmF0ZXMsIGJ1dCByYXRoZXIgdGhleSBhcmUgZGlzdGFuY2VzIGFsb25nIHRoZSBuZWdhdGl2ZVxuICAgICAqIHotYXhpcy4gIFRoZSBtYXRyaXggZ2VuZXJhdGVkIHNlbmRzIHRoZSB2aWV3aW5nIGZydXN0dW0gdG8gdGhlIHVuaXQgYm94LlxuICAgICAqIFdlIGFzc3VtZSBhIHVuaXQgYm94IGV4dGVuZGluZyBmcm9tIC0xIHRvIDEgaW4gdGhlIHggYW5kIHkgZGltZW5zaW9ucyBhbmRcbiAgICAgKiBmcm9tIDAgdG8gMSBpbiB0aGUgeiBkaW1lbnNpb24uXG4gICAgICpcbiAgICAgKiBOb3RlOiBJZiB5b3UgcGFzcyBgSW5maW5pdHlgIGZvciB6RmFyIHRoZW4gaXQgd2lsbCBwcm9kdWNlIGEgcHJvamVjdGlvbiBtYXRyaXhcbiAgICAgKiByZXR1cm5zIC1JbmZpbml0eSBmb3IgWiB3aGVuIHRyYW5zZm9ybWluZyBjb29yZGluYXRlcyB3aXRoIFogPD0gMCBhbmQgK0luZmluaXR5IGZvciBaXG4gICAgICogb3RoZXJ3aXNlLlxuICAgICAqXG4gICAgICogQHBhcmFtIGZpZWxkT2ZWaWV3WUluUmFkaWFucyAtIFRoZSBjYW1lcmEgYW5nbGUgZnJvbSB0b3AgdG8gYm90dG9tIChpbiByYWRpYW5zKS5cbiAgICAgKiBAcGFyYW0gYXNwZWN0IC0gVGhlIGFzcGVjdCByYXRpbyB3aWR0aCAvIGhlaWdodC5cbiAgICAgKiBAcGFyYW0gek5lYXIgLSBUaGUgZGVwdGggKG5lZ2F0aXZlIHogY29vcmRpbmF0ZSlcbiAgICAgKiAgICAgb2YgdGhlIG5lYXIgY2xpcHBpbmcgcGxhbmUuXG4gICAgICogQHBhcmFtIHpGYXIgLSBUaGUgZGVwdGggKG5lZ2F0aXZlIHogY29vcmRpbmF0ZSlcbiAgICAgKiAgICAgb2YgdGhlIGZhciBjbGlwcGluZyBwbGFuZS5cbiAgICAgKiBAcGFyYW0gZHN0IC0gbWF0cml4IHRvIGhvbGQgcmVzdWx0LiBJZiBub3QgcGFzc2VkIGEgbmV3IG9uZSBpcyBjcmVhdGVkLlxuICAgICAqIEByZXR1cm5zIFRoZSBwZXJzcGVjdGl2ZSBtYXRyaXguXG4gICAgICovXG4gICAgZnVuY3Rpb24gcGVyc3BlY3RpdmUoZmllbGRPZlZpZXdZSW5SYWRpYW5zLCBhc3BlY3QsIHpOZWFyLCB6RmFyLCBkc3QpIHtcbiAgICAgICAgY29uc3QgbmV3RHN0ID0gKGRzdCA/PyBuZXcgQ3RvcigxNikpO1xuICAgICAgICBjb25zdCBmID0gTWF0aC50YW4oTWF0aC5QSSAqIDAuNSAtIDAuNSAqIGZpZWxkT2ZWaWV3WUluUmFkaWFucyk7XG4gICAgICAgIG5ld0RzdFswXSA9IGYgLyBhc3BlY3Q7XG4gICAgICAgIG5ld0RzdFsxXSA9IDA7XG4gICAgICAgIG5ld0RzdFsyXSA9IDA7XG4gICAgICAgIG5ld0RzdFszXSA9IDA7XG4gICAgICAgIG5ld0RzdFs0XSA9IDA7XG4gICAgICAgIG5ld0RzdFs1XSA9IGY7XG4gICAgICAgIG5ld0RzdFs2XSA9IDA7XG4gICAgICAgIG5ld0RzdFs3XSA9IDA7XG4gICAgICAgIG5ld0RzdFs4XSA9IDA7XG4gICAgICAgIG5ld0RzdFs5XSA9IDA7XG4gICAgICAgIG5ld0RzdFsxMV0gPSAtMTtcbiAgICAgICAgbmV3RHN0WzEyXSA9IDA7XG4gICAgICAgIG5ld0RzdFsxM10gPSAwO1xuICAgICAgICBuZXdEc3RbMTVdID0gMDtcbiAgICAgICAgaWYgKE51bWJlci5pc0Zpbml0ZSh6RmFyKSkge1xuICAgICAgICAgICAgY29uc3QgcmFuZ2VJbnYgPSAxIC8gKHpOZWFyIC0gekZhcik7XG4gICAgICAgICAgICBuZXdEc3RbMTBdID0gekZhciAqIHJhbmdlSW52O1xuICAgICAgICAgICAgbmV3RHN0WzE0XSA9IHpGYXIgKiB6TmVhciAqIHJhbmdlSW52O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbmV3RHN0WzEwXSA9IC0xO1xuICAgICAgICAgICAgbmV3RHN0WzE0XSA9IC16TmVhcjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3RHN0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb21wdXRlcyBhIDQtYnktNCByZXZlcnNlLXogcGVyc3BlY3RpdmUgdHJhbnNmb3JtYXRpb24gbWF0cml4IGdpdmVuIHRoZSBhbmd1bGFyIGhlaWdodFxuICAgICAqIG9mIHRoZSBmcnVzdHVtLCB0aGUgYXNwZWN0IHJhdGlvLCBhbmQgdGhlIG5lYXIgYW5kIGZhciBjbGlwcGluZyBwbGFuZXMuICBUaGVcbiAgICAgKiBhcmd1bWVudHMgZGVmaW5lIGEgZnJ1c3R1bSBleHRlbmRpbmcgaW4gdGhlIG5lZ2F0aXZlIHogZGlyZWN0aW9uLiAgVGhlIGdpdmVuXG4gICAgICogYW5nbGUgaXMgdGhlIHZlcnRpY2FsIGFuZ2xlIG9mIHRoZSBmcnVzdHVtLCBhbmQgdGhlIGhvcml6b250YWwgYW5nbGUgaXNcbiAgICAgKiBkZXRlcm1pbmVkIHRvIHByb2R1Y2UgdGhlIGdpdmVuIGFzcGVjdCByYXRpby4gIFRoZSBhcmd1bWVudHMgbmVhciBhbmQgZmFyIGFyZVxuICAgICAqIHRoZSBkaXN0YW5jZXMgdG8gdGhlIG5lYXIgYW5kIGZhciBjbGlwcGluZyBwbGFuZXMuICBOb3RlIHRoYXQgbmVhciBhbmQgZmFyXG4gICAgICogYXJlIG5vdCB6IGNvb3JkaW5hdGVzLCBidXQgcmF0aGVyIHRoZXkgYXJlIGRpc3RhbmNlcyBhbG9uZyB0aGUgbmVnYXRpdmVcbiAgICAgKiB6LWF4aXMuICBUaGUgbWF0cml4IGdlbmVyYXRlZCBzZW5kcyB0aGUgdmlld2luZyBmcnVzdHVtIHRvIHRoZSB1bml0IGJveC5cbiAgICAgKiBXZSBhc3N1bWUgYSB1bml0IGJveCBleHRlbmRpbmcgZnJvbSAtMSB0byAxIGluIHRoZSB4IGFuZCB5IGRpbWVuc2lvbnMgYW5kXG4gICAgICogZnJvbSAxIChhdCAtek5lYXIpIHRvIDAgKGF0IC16RmFyKSBpbiB0aGUgeiBkaW1lbnNpb24uXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZmllbGRPZlZpZXdZSW5SYWRpYW5zIC0gVGhlIGNhbWVyYSBhbmdsZSBmcm9tIHRvcCB0byBib3R0b20gKGluIHJhZGlhbnMpLlxuICAgICAqIEBwYXJhbSBhc3BlY3QgLSBUaGUgYXNwZWN0IHJhdGlvIHdpZHRoIC8gaGVpZ2h0LlxuICAgICAqIEBwYXJhbSB6TmVhciAtIFRoZSBkZXB0aCAobmVnYXRpdmUgeiBjb29yZGluYXRlKVxuICAgICAqICAgICBvZiB0aGUgbmVhciBjbGlwcGluZyBwbGFuZS5cbiAgICAgKiBAcGFyYW0gekZhciAtIFRoZSBkZXB0aCAobmVnYXRpdmUgeiBjb29yZGluYXRlKVxuICAgICAqICAgICBvZiB0aGUgZmFyIGNsaXBwaW5nIHBsYW5lLiAoZGVmYXVsdCA9IEluZmluaXR5KVxuICAgICAqIEBwYXJhbSBkc3QgLSBtYXRyaXggdG8gaG9sZCByZXN1bHQuIElmIG5vdCBwYXNzZWQgYSBuZXcgb25lIGlzIGNyZWF0ZWQuXG4gICAgICogQHJldHVybnMgVGhlIHBlcnNwZWN0aXZlIG1hdHJpeC5cbiAgICAgKi8gZnVuY3Rpb24gcGVyc3BlY3RpdmVSZXZlcnNlWihmaWVsZE9mVmlld1lJblJhZGlhbnMsIGFzcGVjdCwgek5lYXIsIHpGYXIgPSBJbmZpbml0eSwgZHN0KSB7XG4gICAgICAgIGNvbnN0IG5ld0RzdCA9IChkc3QgPz8gbmV3IEN0b3IoMTYpKTtcbiAgICAgICAgY29uc3QgZiA9IDEgLyBNYXRoLnRhbihmaWVsZE9mVmlld1lJblJhZGlhbnMgKiAwLjUpO1xuICAgICAgICBuZXdEc3RbMF0gPSBmIC8gYXNwZWN0O1xuICAgICAgICBuZXdEc3RbMV0gPSAwO1xuICAgICAgICBuZXdEc3RbMl0gPSAwO1xuICAgICAgICBuZXdEc3RbM10gPSAwO1xuICAgICAgICBuZXdEc3RbNF0gPSAwO1xuICAgICAgICBuZXdEc3RbNV0gPSBmO1xuICAgICAgICBuZXdEc3RbNl0gPSAwO1xuICAgICAgICBuZXdEc3RbN10gPSAwO1xuICAgICAgICBuZXdEc3RbOF0gPSAwO1xuICAgICAgICBuZXdEc3RbOV0gPSAwO1xuICAgICAgICBuZXdEc3RbMTFdID0gLTE7XG4gICAgICAgIG5ld0RzdFsxMl0gPSAwO1xuICAgICAgICBuZXdEc3RbMTNdID0gMDtcbiAgICAgICAgbmV3RHN0WzE1XSA9IDA7XG4gICAgICAgIGlmICh6RmFyID09PSBJbmZpbml0eSkge1xuICAgICAgICAgICAgbmV3RHN0WzEwXSA9IDA7XG4gICAgICAgICAgICBuZXdEc3RbMTRdID0gek5lYXI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCByYW5nZUludiA9IDEgLyAoekZhciAtIHpOZWFyKTtcbiAgICAgICAgICAgIG5ld0RzdFsxMF0gPSB6TmVhciAqIHJhbmdlSW52O1xuICAgICAgICAgICAgbmV3RHN0WzE0XSA9IHpGYXIgKiB6TmVhciAqIHJhbmdlSW52O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXdEc3Q7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbXB1dGVzIGEgNC1ieS00IG9ydGhvZ29uYWwgdHJhbnNmb3JtYXRpb24gbWF0cml4IHRoYXQgdHJhbnNmb3JtcyBmcm9tXG4gICAgICogdGhlIGdpdmVuIHRoZSBsZWZ0LCByaWdodCwgYm90dG9tLCBhbmQgdG9wIGRpbWVuc2lvbnMgdG8gLTEgKzEgaW4geCwgYW5kIHlcbiAgICAgKiBhbmQgMCB0byArMSBpbiB6LlxuICAgICAqIEBwYXJhbSBsZWZ0IC0gTGVmdCBzaWRlIG9mIHRoZSBuZWFyIGNsaXBwaW5nIHBsYW5lIHZpZXdwb3J0LlxuICAgICAqIEBwYXJhbSByaWdodCAtIFJpZ2h0IHNpZGUgb2YgdGhlIG5lYXIgY2xpcHBpbmcgcGxhbmUgdmlld3BvcnQuXG4gICAgICogQHBhcmFtIGJvdHRvbSAtIEJvdHRvbSBvZiB0aGUgbmVhciBjbGlwcGluZyBwbGFuZSB2aWV3cG9ydC5cbiAgICAgKiBAcGFyYW0gdG9wIC0gVG9wIG9mIHRoZSBuZWFyIGNsaXBwaW5nIHBsYW5lIHZpZXdwb3J0LlxuICAgICAqIEBwYXJhbSBuZWFyIC0gVGhlIGRlcHRoIChuZWdhdGl2ZSB6IGNvb3JkaW5hdGUpXG4gICAgICogICAgIG9mIHRoZSBuZWFyIGNsaXBwaW5nIHBsYW5lLlxuICAgICAqIEBwYXJhbSBmYXIgLSBUaGUgZGVwdGggKG5lZ2F0aXZlIHogY29vcmRpbmF0ZSlcbiAgICAgKiAgICAgb2YgdGhlIGZhciBjbGlwcGluZyBwbGFuZS5cbiAgICAgKiBAcGFyYW0gZHN0IC0gT3V0cHV0IG1hdHJpeC4gSWYgbm90IHBhc3NlZCBhIG5ldyBvbmUgaXMgY3JlYXRlZC5cbiAgICAgKiBAcmV0dXJucyBUaGUgb3J0aG9ncmFwaGljIHByb2plY3Rpb24gbWF0cml4LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG9ydGhvKGxlZnQsIHJpZ2h0LCBib3R0b20sIHRvcCwgbmVhciwgZmFyLCBkc3QpIHtcbiAgICAgICAgY29uc3QgbmV3RHN0ID0gKGRzdCA/PyBuZXcgQ3RvcigxNikpO1xuICAgICAgICBuZXdEc3RbMF0gPSAyIC8gKHJpZ2h0IC0gbGVmdCk7XG4gICAgICAgIG5ld0RzdFsxXSA9IDA7XG4gICAgICAgIG5ld0RzdFsyXSA9IDA7XG4gICAgICAgIG5ld0RzdFszXSA9IDA7XG4gICAgICAgIG5ld0RzdFs0XSA9IDA7XG4gICAgICAgIG5ld0RzdFs1XSA9IDIgLyAodG9wIC0gYm90dG9tKTtcbiAgICAgICAgbmV3RHN0WzZdID0gMDtcbiAgICAgICAgbmV3RHN0WzddID0gMDtcbiAgICAgICAgbmV3RHN0WzhdID0gMDtcbiAgICAgICAgbmV3RHN0WzldID0gMDtcbiAgICAgICAgbmV3RHN0WzEwXSA9IDEgLyAobmVhciAtIGZhcik7XG4gICAgICAgIG5ld0RzdFsxMV0gPSAwO1xuICAgICAgICBuZXdEc3RbMTJdID0gKHJpZ2h0ICsgbGVmdCkgLyAobGVmdCAtIHJpZ2h0KTtcbiAgICAgICAgbmV3RHN0WzEzXSA9ICh0b3AgKyBib3R0b20pIC8gKGJvdHRvbSAtIHRvcCk7XG4gICAgICAgIG5ld0RzdFsxNF0gPSBuZWFyIC8gKG5lYXIgLSBmYXIpO1xuICAgICAgICBuZXdEc3RbMTVdID0gMTtcbiAgICAgICAgcmV0dXJuIG5ld0RzdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29tcHV0ZXMgYSA0LWJ5LTQgcGVyc3BlY3RpdmUgdHJhbnNmb3JtYXRpb24gbWF0cml4IGdpdmVuIHRoZSBsZWZ0LCByaWdodCxcbiAgICAgKiB0b3AsIGJvdHRvbSwgbmVhciBhbmQgZmFyIGNsaXBwaW5nIHBsYW5lcy4gVGhlIGFyZ3VtZW50cyBkZWZpbmUgYSBmcnVzdHVtXG4gICAgICogZXh0ZW5kaW5nIGluIHRoZSBuZWdhdGl2ZSB6IGRpcmVjdGlvbi4gVGhlIGFyZ3VtZW50cyBuZWFyIGFuZCBmYXIgYXJlIHRoZVxuICAgICAqIGRpc3RhbmNlcyB0byB0aGUgbmVhciBhbmQgZmFyIGNsaXBwaW5nIHBsYW5lcy4gTm90ZSB0aGF0IG5lYXIgYW5kIGZhciBhcmUgbm90XG4gICAgICogeiBjb29yZGluYXRlcywgYnV0IHJhdGhlciB0aGV5IGFyZSBkaXN0YW5jZXMgYWxvbmcgdGhlIG5lZ2F0aXZlIHotYXhpcy4gVGhlXG4gICAgICogbWF0cml4IGdlbmVyYXRlZCBzZW5kcyB0aGUgdmlld2luZyBmcnVzdHVtIHRvIHRoZSB1bml0IGJveC4gV2UgYXNzdW1lIGEgdW5pdFxuICAgICAqIGJveCBleHRlbmRpbmcgZnJvbSAtMSB0byAxIGluIHRoZSB4IGFuZCB5IGRpbWVuc2lvbnMgYW5kIGZyb20gMCB0byAxIGluIHRoZSB6XG4gICAgICogZGltZW5zaW9uLlxuICAgICAqIEBwYXJhbSBsZWZ0IC0gVGhlIHggY29vcmRpbmF0ZSBvZiB0aGUgbGVmdCBwbGFuZSBvZiB0aGUgYm94LlxuICAgICAqIEBwYXJhbSByaWdodCAtIFRoZSB4IGNvb3JkaW5hdGUgb2YgdGhlIHJpZ2h0IHBsYW5lIG9mIHRoZSBib3guXG4gICAgICogQHBhcmFtIGJvdHRvbSAtIFRoZSB5IGNvb3JkaW5hdGUgb2YgdGhlIGJvdHRvbSBwbGFuZSBvZiB0aGUgYm94LlxuICAgICAqIEBwYXJhbSB0b3AgLSBUaGUgeSBjb29yZGluYXRlIG9mIHRoZSByaWdodCBwbGFuZSBvZiB0aGUgYm94LlxuICAgICAqIEBwYXJhbSBuZWFyIC0gVGhlIG5lZ2F0aXZlIHogY29vcmRpbmF0ZSBvZiB0aGUgbmVhciBwbGFuZSBvZiB0aGUgYm94LlxuICAgICAqIEBwYXJhbSBmYXIgLSBUaGUgbmVnYXRpdmUgeiBjb29yZGluYXRlIG9mIHRoZSBmYXIgcGxhbmUgb2YgdGhlIGJveC5cbiAgICAgKiBAcGFyYW0gZHN0IC0gT3V0cHV0IG1hdHJpeC4gSWYgbm90IHBhc3NlZCBhIG5ldyBvbmUgaXMgY3JlYXRlZC5cbiAgICAgKiBAcmV0dXJucyBUaGUgcGVyc3BlY3RpdmUgcHJvamVjdGlvbiBtYXRyaXguXG4gICAgICovXG4gICAgZnVuY3Rpb24gZnJ1c3R1bShsZWZ0LCByaWdodCwgYm90dG9tLCB0b3AsIG5lYXIsIGZhciwgZHN0KSB7XG4gICAgICAgIGNvbnN0IG5ld0RzdCA9IChkc3QgPz8gbmV3IEN0b3IoMTYpKTtcbiAgICAgICAgY29uc3QgZHggPSAocmlnaHQgLSBsZWZ0KTtcbiAgICAgICAgY29uc3QgZHkgPSAodG9wIC0gYm90dG9tKTtcbiAgICAgICAgY29uc3QgZHogPSAobmVhciAtIGZhcik7XG4gICAgICAgIG5ld0RzdFswXSA9IDIgKiBuZWFyIC8gZHg7XG4gICAgICAgIG5ld0RzdFsxXSA9IDA7XG4gICAgICAgIG5ld0RzdFsyXSA9IDA7XG4gICAgICAgIG5ld0RzdFszXSA9IDA7XG4gICAgICAgIG5ld0RzdFs0XSA9IDA7XG4gICAgICAgIG5ld0RzdFs1XSA9IDIgKiBuZWFyIC8gZHk7XG4gICAgICAgIG5ld0RzdFs2XSA9IDA7XG4gICAgICAgIG5ld0RzdFs3XSA9IDA7XG4gICAgICAgIG5ld0RzdFs4XSA9IChsZWZ0ICsgcmlnaHQpIC8gZHg7XG4gICAgICAgIG5ld0RzdFs5XSA9ICh0b3AgKyBib3R0b20pIC8gZHk7XG4gICAgICAgIG5ld0RzdFsxMF0gPSBmYXIgLyBkejtcbiAgICAgICAgbmV3RHN0WzExXSA9IC0xO1xuICAgICAgICBuZXdEc3RbMTJdID0gMDtcbiAgICAgICAgbmV3RHN0WzEzXSA9IDA7XG4gICAgICAgIG5ld0RzdFsxNF0gPSBuZWFyICogZmFyIC8gZHo7XG4gICAgICAgIG5ld0RzdFsxNV0gPSAwO1xuICAgICAgICByZXR1cm4gbmV3RHN0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb21wdXRlcyBhIDQtYnktNCByZXZlcnNlLXogcGVyc3BlY3RpdmUgdHJhbnNmb3JtYXRpb24gbWF0cml4IGdpdmVuIHRoZSBsZWZ0LCByaWdodCxcbiAgICAgKiB0b3AsIGJvdHRvbSwgbmVhciBhbmQgZmFyIGNsaXBwaW5nIHBsYW5lcy4gVGhlIGFyZ3VtZW50cyBkZWZpbmUgYSBmcnVzdHVtXG4gICAgICogZXh0ZW5kaW5nIGluIHRoZSBuZWdhdGl2ZSB6IGRpcmVjdGlvbi4gVGhlIGFyZ3VtZW50cyBuZWFyIGFuZCBmYXIgYXJlIHRoZVxuICAgICAqIGRpc3RhbmNlcyB0byB0aGUgbmVhciBhbmQgZmFyIGNsaXBwaW5nIHBsYW5lcy4gTm90ZSB0aGF0IG5lYXIgYW5kIGZhciBhcmUgbm90XG4gICAgICogeiBjb29yZGluYXRlcywgYnV0IHJhdGhlciB0aGV5IGFyZSBkaXN0YW5jZXMgYWxvbmcgdGhlIG5lZ2F0aXZlIHotYXhpcy4gVGhlXG4gICAgICogbWF0cml4IGdlbmVyYXRlZCBzZW5kcyB0aGUgdmlld2luZyBmcnVzdHVtIHRvIHRoZSB1bml0IGJveC4gV2UgYXNzdW1lIGEgdW5pdFxuICAgICAqIGJveCBleHRlbmRpbmcgZnJvbSAtMSB0byAxIGluIHRoZSB4IGFuZCB5IGRpbWVuc2lvbnMgYW5kIGZyb20gMSAoLW5lYXIpIHRvIDAgKC1mYXIpIGluIHRoZSB6XG4gICAgICogZGltZW5zaW9uLlxuICAgICAqIEBwYXJhbSBsZWZ0IC0gVGhlIHggY29vcmRpbmF0ZSBvZiB0aGUgbGVmdCBwbGFuZSBvZiB0aGUgYm94LlxuICAgICAqIEBwYXJhbSByaWdodCAtIFRoZSB4IGNvb3JkaW5hdGUgb2YgdGhlIHJpZ2h0IHBsYW5lIG9mIHRoZSBib3guXG4gICAgICogQHBhcmFtIGJvdHRvbSAtIFRoZSB5IGNvb3JkaW5hdGUgb2YgdGhlIGJvdHRvbSBwbGFuZSBvZiB0aGUgYm94LlxuICAgICAqIEBwYXJhbSB0b3AgLSBUaGUgeSBjb29yZGluYXRlIG9mIHRoZSByaWdodCBwbGFuZSBvZiB0aGUgYm94LlxuICAgICAqIEBwYXJhbSBuZWFyIC0gVGhlIG5lZ2F0aXZlIHogY29vcmRpbmF0ZSBvZiB0aGUgbmVhciBwbGFuZSBvZiB0aGUgYm94LlxuICAgICAqIEBwYXJhbSBmYXIgLSBUaGUgbmVnYXRpdmUgeiBjb29yZGluYXRlIG9mIHRoZSBmYXIgcGxhbmUgb2YgdGhlIGJveC5cbiAgICAgKiBAcGFyYW0gZHN0IC0gT3V0cHV0IG1hdHJpeC4gSWYgbm90IHBhc3NlZCBhIG5ldyBvbmUgaXMgY3JlYXRlZC5cbiAgICAgKiBAcmV0dXJucyBUaGUgcGVyc3BlY3RpdmUgcHJvamVjdGlvbiBtYXRyaXguXG4gICAgICovXG4gICAgZnVuY3Rpb24gZnJ1c3R1bVJldmVyc2VaKGxlZnQsIHJpZ2h0LCBib3R0b20sIHRvcCwgbmVhciwgZmFyID0gSW5maW5pdHksIGRzdCkge1xuICAgICAgICBjb25zdCBuZXdEc3QgPSAoZHN0ID8/IG5ldyBDdG9yKDE2KSk7XG4gICAgICAgIGNvbnN0IGR4ID0gKHJpZ2h0IC0gbGVmdCk7XG4gICAgICAgIGNvbnN0IGR5ID0gKHRvcCAtIGJvdHRvbSk7XG4gICAgICAgIG5ld0RzdFswXSA9IDIgKiBuZWFyIC8gZHg7XG4gICAgICAgIG5ld0RzdFsxXSA9IDA7XG4gICAgICAgIG5ld0RzdFsyXSA9IDA7XG4gICAgICAgIG5ld0RzdFszXSA9IDA7XG4gICAgICAgIG5ld0RzdFs0XSA9IDA7XG4gICAgICAgIG5ld0RzdFs1XSA9IDIgKiBuZWFyIC8gZHk7XG4gICAgICAgIG5ld0RzdFs2XSA9IDA7XG4gICAgICAgIG5ld0RzdFs3XSA9IDA7XG4gICAgICAgIG5ld0RzdFs4XSA9IChsZWZ0ICsgcmlnaHQpIC8gZHg7XG4gICAgICAgIG5ld0RzdFs5XSA9ICh0b3AgKyBib3R0b20pIC8gZHk7XG4gICAgICAgIG5ld0RzdFsxMV0gPSAtMTtcbiAgICAgICAgbmV3RHN0WzEyXSA9IDA7XG4gICAgICAgIG5ld0RzdFsxM10gPSAwO1xuICAgICAgICBuZXdEc3RbMTVdID0gMDtcbiAgICAgICAgaWYgKGZhciA9PT0gSW5maW5pdHkpIHtcbiAgICAgICAgICAgIG5ld0RzdFsxMF0gPSAwO1xuICAgICAgICAgICAgbmV3RHN0WzE0XSA9IG5lYXI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCByYW5nZUludiA9IDEgLyAoZmFyIC0gbmVhcik7XG4gICAgICAgICAgICBuZXdEc3RbMTBdID0gbmVhciAqIHJhbmdlSW52O1xuICAgICAgICAgICAgbmV3RHN0WzE0XSA9IGZhciAqIG5lYXIgKiByYW5nZUludjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3RHN0O1xuICAgIH1cbiAgICBjb25zdCB4QXhpcyA9IHZlYzMuY3JlYXRlKCk7XG4gICAgY29uc3QgeUF4aXMgPSB2ZWMzLmNyZWF0ZSgpO1xuICAgIGNvbnN0IHpBeGlzID0gdmVjMy5jcmVhdGUoKTtcbiAgICAvKipcbiAgICAgKiBDb21wdXRlcyBhIDQtYnktNCBhaW0gdHJhbnNmb3JtYXRpb24uXG4gICAgICpcbiAgICAgKiBUaGlzIGlzIGEgbWF0cml4IHdoaWNoIHBvc2l0aW9ucyBhbiBvYmplY3QgYWltaW5nIGRvd24gcG9zaXRpdmUgWi5cbiAgICAgKiB0b3dhcmQgdGhlIHRhcmdldC5cbiAgICAgKlxuICAgICAqIE5vdGU6IHRoaXMgaXMgKipOT1QqKiB0aGUgaW52ZXJzZSBvZiBsb29rQXQgYXMgbG9va0F0IGxvb2tzIGF0IG5lZ2F0aXZlIFouXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcG9zaXRpb24gLSBUaGUgcG9zaXRpb24gb2YgdGhlIG9iamVjdC5cbiAgICAgKiBAcGFyYW0gdGFyZ2V0IC0gVGhlIHBvc2l0aW9uIG1lYW50IHRvIGJlIGFpbWVkIGF0LlxuICAgICAqIEBwYXJhbSB1cCAtIEEgdmVjdG9yIHBvaW50aW5nIHVwLlxuICAgICAqIEBwYXJhbSBkc3QgLSBtYXRyaXggdG8gaG9sZCByZXN1bHQuIElmIG5vdCBwYXNzZWQgYSBuZXcgb25lIGlzIGNyZWF0ZWQuXG4gICAgICogQHJldHVybnMgVGhlIGFpbSBtYXRyaXguXG4gICAgICovXG4gICAgZnVuY3Rpb24gYWltKHBvc2l0aW9uLCB0YXJnZXQsIHVwLCBkc3QpIHtcbiAgICAgICAgY29uc3QgbmV3RHN0ID0gKGRzdCA/PyBuZXcgQ3RvcigxNikpO1xuICAgICAgICB2ZWMzLm5vcm1hbGl6ZSh2ZWMzLnN1YnRyYWN0KHRhcmdldCwgcG9zaXRpb24sIHpBeGlzKSwgekF4aXMpO1xuICAgICAgICB2ZWMzLm5vcm1hbGl6ZSh2ZWMzLmNyb3NzKHVwLCB6QXhpcywgeEF4aXMpLCB4QXhpcyk7XG4gICAgICAgIHZlYzMubm9ybWFsaXplKHZlYzMuY3Jvc3MoekF4aXMsIHhBeGlzLCB5QXhpcyksIHlBeGlzKTtcbiAgICAgICAgbmV3RHN0WzBdID0geEF4aXNbMF07XG4gICAgICAgIG5ld0RzdFsxXSA9IHhBeGlzWzFdO1xuICAgICAgICBuZXdEc3RbMl0gPSB4QXhpc1syXTtcbiAgICAgICAgbmV3RHN0WzNdID0gMDtcbiAgICAgICAgbmV3RHN0WzRdID0geUF4aXNbMF07XG4gICAgICAgIG5ld0RzdFs1XSA9IHlBeGlzWzFdO1xuICAgICAgICBuZXdEc3RbNl0gPSB5QXhpc1syXTtcbiAgICAgICAgbmV3RHN0WzddID0gMDtcbiAgICAgICAgbmV3RHN0WzhdID0gekF4aXNbMF07XG4gICAgICAgIG5ld0RzdFs5XSA9IHpBeGlzWzFdO1xuICAgICAgICBuZXdEc3RbMTBdID0gekF4aXNbMl07XG4gICAgICAgIG5ld0RzdFsxMV0gPSAwO1xuICAgICAgICBuZXdEc3RbMTJdID0gcG9zaXRpb25bMF07XG4gICAgICAgIG5ld0RzdFsxM10gPSBwb3NpdGlvblsxXTtcbiAgICAgICAgbmV3RHN0WzE0XSA9IHBvc2l0aW9uWzJdO1xuICAgICAgICBuZXdEc3RbMTVdID0gMTtcbiAgICAgICAgcmV0dXJuIG5ld0RzdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29tcHV0ZXMgYSA0LWJ5LTQgY2FtZXJhIGFpbSB0cmFuc2Zvcm1hdGlvbi5cbiAgICAgKlxuICAgICAqIFRoaXMgaXMgYSBtYXRyaXggd2hpY2ggcG9zaXRpb25zIGFuIG9iamVjdCBhaW1pbmcgZG93biBuZWdhdGl2ZSBaLlxuICAgICAqIHRvd2FyZCB0aGUgdGFyZ2V0LlxuICAgICAqXG4gICAgICogTm90ZTogdGhpcyBpcyB0aGUgaW52ZXJzZSBvZiBgbG9va0F0YFxuICAgICAqXG4gICAgICogQHBhcmFtIGV5ZSAtIFRoZSBwb3NpdGlvbiBvZiB0aGUgb2JqZWN0LlxuICAgICAqIEBwYXJhbSB0YXJnZXQgLSBUaGUgcG9zaXRpb24gbWVhbnQgdG8gYmUgYWltZWQgYXQuXG4gICAgICogQHBhcmFtIHVwIC0gQSB2ZWN0b3IgcG9pbnRpbmcgdXAuXG4gICAgICogQHBhcmFtIGRzdCAtIG1hdHJpeCB0byBob2xkIHJlc3VsdC4gSWYgbm90IHBhc3NlZCBhIG5ldyBvbmUgaXMgY3JlYXRlZC5cbiAgICAgKiBAcmV0dXJucyBUaGUgYWltIG1hdHJpeC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjYW1lcmFBaW0oZXllLCB0YXJnZXQsIHVwLCBkc3QpIHtcbiAgICAgICAgY29uc3QgbmV3RHN0ID0gKGRzdCA/PyBuZXcgQ3RvcigxNikpO1xuICAgICAgICB2ZWMzLm5vcm1hbGl6ZSh2ZWMzLnN1YnRyYWN0KGV5ZSwgdGFyZ2V0LCB6QXhpcyksIHpBeGlzKTtcbiAgICAgICAgdmVjMy5ub3JtYWxpemUodmVjMy5jcm9zcyh1cCwgekF4aXMsIHhBeGlzKSwgeEF4aXMpO1xuICAgICAgICB2ZWMzLm5vcm1hbGl6ZSh2ZWMzLmNyb3NzKHpBeGlzLCB4QXhpcywgeUF4aXMpLCB5QXhpcyk7XG4gICAgICAgIG5ld0RzdFswXSA9IHhBeGlzWzBdO1xuICAgICAgICBuZXdEc3RbMV0gPSB4QXhpc1sxXTtcbiAgICAgICAgbmV3RHN0WzJdID0geEF4aXNbMl07XG4gICAgICAgIG5ld0RzdFszXSA9IDA7XG4gICAgICAgIG5ld0RzdFs0XSA9IHlBeGlzWzBdO1xuICAgICAgICBuZXdEc3RbNV0gPSB5QXhpc1sxXTtcbiAgICAgICAgbmV3RHN0WzZdID0geUF4aXNbMl07XG4gICAgICAgIG5ld0RzdFs3XSA9IDA7XG4gICAgICAgIG5ld0RzdFs4XSA9IHpBeGlzWzBdO1xuICAgICAgICBuZXdEc3RbOV0gPSB6QXhpc1sxXTtcbiAgICAgICAgbmV3RHN0WzEwXSA9IHpBeGlzWzJdO1xuICAgICAgICBuZXdEc3RbMTFdID0gMDtcbiAgICAgICAgbmV3RHN0WzEyXSA9IGV5ZVswXTtcbiAgICAgICAgbmV3RHN0WzEzXSA9IGV5ZVsxXTtcbiAgICAgICAgbmV3RHN0WzE0XSA9IGV5ZVsyXTtcbiAgICAgICAgbmV3RHN0WzE1XSA9IDE7XG4gICAgICAgIHJldHVybiBuZXdEc3Q7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbXB1dGVzIGEgNC1ieS00IHZpZXcgdHJhbnNmb3JtYXRpb24uXG4gICAgICpcbiAgICAgKiBUaGlzIGlzIGEgdmlldyBtYXRyaXggd2hpY2ggdHJhbnNmb3JtcyBhbGwgb3RoZXIgb2JqZWN0c1xuICAgICAqIHRvIGJlIGluIHRoZSBzcGFjZSBvZiB0aGUgdmlldyBkZWZpbmVkIGJ5IHRoZSBwYXJhbWV0ZXJzLlxuICAgICAqXG4gICAgICogQHBhcmFtIGV5ZSAtIFRoZSBwb3NpdGlvbiBvZiB0aGUgb2JqZWN0LlxuICAgICAqIEBwYXJhbSB0YXJnZXQgLSBUaGUgcG9zaXRpb24gbWVhbnQgdG8gYmUgYWltZWQgYXQuXG4gICAgICogQHBhcmFtIHVwIC0gQSB2ZWN0b3IgcG9pbnRpbmcgdXAuXG4gICAgICogQHBhcmFtIGRzdCAtIG1hdHJpeCB0byBob2xkIHJlc3VsdC4gSWYgbm90IHBhc3NlZCBhIG5ldyBvbmUgaXMgY3JlYXRlZC5cbiAgICAgKiBAcmV0dXJucyBUaGUgbG9vay1hdCBtYXRyaXguXG4gICAgICovXG4gICAgZnVuY3Rpb24gbG9va0F0KGV5ZSwgdGFyZ2V0LCB1cCwgZHN0KSB7XG4gICAgICAgIGNvbnN0IG5ld0RzdCA9IChkc3QgPz8gbmV3IEN0b3IoMTYpKTtcbiAgICAgICAgdmVjMy5ub3JtYWxpemUodmVjMy5zdWJ0cmFjdChleWUsIHRhcmdldCwgekF4aXMpLCB6QXhpcyk7XG4gICAgICAgIHZlYzMubm9ybWFsaXplKHZlYzMuY3Jvc3ModXAsIHpBeGlzLCB4QXhpcyksIHhBeGlzKTtcbiAgICAgICAgdmVjMy5ub3JtYWxpemUodmVjMy5jcm9zcyh6QXhpcywgeEF4aXMsIHlBeGlzKSwgeUF4aXMpO1xuICAgICAgICBuZXdEc3RbMF0gPSB4QXhpc1swXTtcbiAgICAgICAgbmV3RHN0WzFdID0geUF4aXNbMF07XG4gICAgICAgIG5ld0RzdFsyXSA9IHpBeGlzWzBdO1xuICAgICAgICBuZXdEc3RbM10gPSAwO1xuICAgICAgICBuZXdEc3RbNF0gPSB4QXhpc1sxXTtcbiAgICAgICAgbmV3RHN0WzVdID0geUF4aXNbMV07XG4gICAgICAgIG5ld0RzdFs2XSA9IHpBeGlzWzFdO1xuICAgICAgICBuZXdEc3RbN10gPSAwO1xuICAgICAgICBuZXdEc3RbOF0gPSB4QXhpc1syXTtcbiAgICAgICAgbmV3RHN0WzldID0geUF4aXNbMl07XG4gICAgICAgIG5ld0RzdFsxMF0gPSB6QXhpc1syXTtcbiAgICAgICAgbmV3RHN0WzExXSA9IDA7XG4gICAgICAgIG5ld0RzdFsxMl0gPSAtKHhBeGlzWzBdICogZXllWzBdICsgeEF4aXNbMV0gKiBleWVbMV0gKyB4QXhpc1syXSAqIGV5ZVsyXSk7XG4gICAgICAgIG5ld0RzdFsxM10gPSAtKHlBeGlzWzBdICogZXllWzBdICsgeUF4aXNbMV0gKiBleWVbMV0gKyB5QXhpc1syXSAqIGV5ZVsyXSk7XG4gICAgICAgIG5ld0RzdFsxNF0gPSAtKHpBeGlzWzBdICogZXllWzBdICsgekF4aXNbMV0gKiBleWVbMV0gKyB6QXhpc1syXSAqIGV5ZVsyXSk7XG4gICAgICAgIG5ld0RzdFsxNV0gPSAxO1xuICAgICAgICByZXR1cm4gbmV3RHN0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgNC1ieS00IG1hdHJpeCB3aGljaCB0cmFuc2xhdGVzIGJ5IHRoZSBnaXZlbiB2ZWN0b3Igdi5cbiAgICAgKiBAcGFyYW0gdiAtIFRoZSB2ZWN0b3IgYnlcbiAgICAgKiAgICAgd2hpY2ggdG8gdHJhbnNsYXRlLlxuICAgICAqIEBwYXJhbSBkc3QgLSBtYXRyaXggdG8gaG9sZCByZXN1bHQuIElmIG5vdCBwYXNzZWQgYSBuZXcgb25lIGlzIGNyZWF0ZWQuXG4gICAgICogQHJldHVybnMgVGhlIHRyYW5zbGF0aW9uIG1hdHJpeC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0cmFuc2xhdGlvbih2LCBkc3QpIHtcbiAgICAgICAgY29uc3QgbmV3RHN0ID0gKGRzdCA/PyBuZXcgQ3RvcigxNikpO1xuICAgICAgICBuZXdEc3RbMF0gPSAxO1xuICAgICAgICBuZXdEc3RbMV0gPSAwO1xuICAgICAgICBuZXdEc3RbMl0gPSAwO1xuICAgICAgICBuZXdEc3RbM10gPSAwO1xuICAgICAgICBuZXdEc3RbNF0gPSAwO1xuICAgICAgICBuZXdEc3RbNV0gPSAxO1xuICAgICAgICBuZXdEc3RbNl0gPSAwO1xuICAgICAgICBuZXdEc3RbN10gPSAwO1xuICAgICAgICBuZXdEc3RbOF0gPSAwO1xuICAgICAgICBuZXdEc3RbOV0gPSAwO1xuICAgICAgICBuZXdEc3RbMTBdID0gMTtcbiAgICAgICAgbmV3RHN0WzExXSA9IDA7XG4gICAgICAgIG5ld0RzdFsxMl0gPSB2WzBdO1xuICAgICAgICBuZXdEc3RbMTNdID0gdlsxXTtcbiAgICAgICAgbmV3RHN0WzE0XSA9IHZbMl07XG4gICAgICAgIG5ld0RzdFsxNV0gPSAxO1xuICAgICAgICByZXR1cm4gbmV3RHN0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUcmFuc2xhdGVzIHRoZSBnaXZlbiA0LWJ5LTQgbWF0cml4IGJ5IHRoZSBnaXZlbiB2ZWN0b3Igdi5cbiAgICAgKiBAcGFyYW0gbSAtIFRoZSBtYXRyaXguXG4gICAgICogQHBhcmFtIHYgLSBUaGUgdmVjdG9yIGJ5XG4gICAgICogICAgIHdoaWNoIHRvIHRyYW5zbGF0ZS5cbiAgICAgKiBAcGFyYW0gZHN0IC0gbWF0cml4IHRvIGhvbGQgcmVzdWx0LiBJZiBub3QgcGFzc2VkIGEgbmV3IG9uZSBpcyBjcmVhdGVkLlxuICAgICAqIEByZXR1cm5zIFRoZSB0cmFuc2xhdGVkIG1hdHJpeC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0cmFuc2xhdGUobSwgdiwgZHN0KSB7XG4gICAgICAgIGNvbnN0IG5ld0RzdCA9IChkc3QgPz8gbmV3IEN0b3IoMTYpKTtcbiAgICAgICAgY29uc3QgdjAgPSB2WzBdO1xuICAgICAgICBjb25zdCB2MSA9IHZbMV07XG4gICAgICAgIGNvbnN0IHYyID0gdlsyXTtcbiAgICAgICAgY29uc3QgbTAwID0gbVswXTtcbiAgICAgICAgY29uc3QgbTAxID0gbVsxXTtcbiAgICAgICAgY29uc3QgbTAyID0gbVsyXTtcbiAgICAgICAgY29uc3QgbTAzID0gbVszXTtcbiAgICAgICAgY29uc3QgbTEwID0gbVsxICogNCArIDBdO1xuICAgICAgICBjb25zdCBtMTEgPSBtWzEgKiA0ICsgMV07XG4gICAgICAgIGNvbnN0IG0xMiA9IG1bMSAqIDQgKyAyXTtcbiAgICAgICAgY29uc3QgbTEzID0gbVsxICogNCArIDNdO1xuICAgICAgICBjb25zdCBtMjAgPSBtWzIgKiA0ICsgMF07XG4gICAgICAgIGNvbnN0IG0yMSA9IG1bMiAqIDQgKyAxXTtcbiAgICAgICAgY29uc3QgbTIyID0gbVsyICogNCArIDJdO1xuICAgICAgICBjb25zdCBtMjMgPSBtWzIgKiA0ICsgM107XG4gICAgICAgIGNvbnN0IG0zMCA9IG1bMyAqIDQgKyAwXTtcbiAgICAgICAgY29uc3QgbTMxID0gbVszICogNCArIDFdO1xuICAgICAgICBjb25zdCBtMzIgPSBtWzMgKiA0ICsgMl07XG4gICAgICAgIGNvbnN0IG0zMyA9IG1bMyAqIDQgKyAzXTtcbiAgICAgICAgaWYgKG0gIT09IG5ld0RzdCkge1xuICAgICAgICAgICAgbmV3RHN0WzBdID0gbTAwO1xuICAgICAgICAgICAgbmV3RHN0WzFdID0gbTAxO1xuICAgICAgICAgICAgbmV3RHN0WzJdID0gbTAyO1xuICAgICAgICAgICAgbmV3RHN0WzNdID0gbTAzO1xuICAgICAgICAgICAgbmV3RHN0WzRdID0gbTEwO1xuICAgICAgICAgICAgbmV3RHN0WzVdID0gbTExO1xuICAgICAgICAgICAgbmV3RHN0WzZdID0gbTEyO1xuICAgICAgICAgICAgbmV3RHN0WzddID0gbTEzO1xuICAgICAgICAgICAgbmV3RHN0WzhdID0gbTIwO1xuICAgICAgICAgICAgbmV3RHN0WzldID0gbTIxO1xuICAgICAgICAgICAgbmV3RHN0WzEwXSA9IG0yMjtcbiAgICAgICAgICAgIG5ld0RzdFsxMV0gPSBtMjM7XG4gICAgICAgIH1cbiAgICAgICAgbmV3RHN0WzEyXSA9IG0wMCAqIHYwICsgbTEwICogdjEgKyBtMjAgKiB2MiArIG0zMDtcbiAgICAgICAgbmV3RHN0WzEzXSA9IG0wMSAqIHYwICsgbTExICogdjEgKyBtMjEgKiB2MiArIG0zMTtcbiAgICAgICAgbmV3RHN0WzE0XSA9IG0wMiAqIHYwICsgbTEyICogdjEgKyBtMjIgKiB2MiArIG0zMjtcbiAgICAgICAgbmV3RHN0WzE1XSA9IG0wMyAqIHYwICsgbTEzICogdjEgKyBtMjMgKiB2MiArIG0zMztcbiAgICAgICAgcmV0dXJuIG5ld0RzdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIDQtYnktNCBtYXRyaXggd2hpY2ggcm90YXRlcyBhcm91bmQgdGhlIHgtYXhpcyBieSB0aGUgZ2l2ZW4gYW5nbGUuXG4gICAgICogQHBhcmFtIGFuZ2xlSW5SYWRpYW5zIC0gVGhlIGFuZ2xlIGJ5IHdoaWNoIHRvIHJvdGF0ZSAoaW4gcmFkaWFucykuXG4gICAgICogQHBhcmFtIGRzdCAtIG1hdHJpeCB0byBob2xkIHJlc3VsdC4gSWYgbm90IHBhc3NlZCBhIG5ldyBvbmUgaXMgY3JlYXRlZC5cbiAgICAgKiBAcmV0dXJucyBUaGUgcm90YXRpb24gbWF0cml4LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHJvdGF0aW9uWChhbmdsZUluUmFkaWFucywgZHN0KSB7XG4gICAgICAgIGNvbnN0IG5ld0RzdCA9IChkc3QgPz8gbmV3IEN0b3IoMTYpKTtcbiAgICAgICAgY29uc3QgYyA9IE1hdGguY29zKGFuZ2xlSW5SYWRpYW5zKTtcbiAgICAgICAgY29uc3QgcyA9IE1hdGguc2luKGFuZ2xlSW5SYWRpYW5zKTtcbiAgICAgICAgbmV3RHN0WzBdID0gMTtcbiAgICAgICAgbmV3RHN0WzFdID0gMDtcbiAgICAgICAgbmV3RHN0WzJdID0gMDtcbiAgICAgICAgbmV3RHN0WzNdID0gMDtcbiAgICAgICAgbmV3RHN0WzRdID0gMDtcbiAgICAgICAgbmV3RHN0WzVdID0gYztcbiAgICAgICAgbmV3RHN0WzZdID0gcztcbiAgICAgICAgbmV3RHN0WzddID0gMDtcbiAgICAgICAgbmV3RHN0WzhdID0gMDtcbiAgICAgICAgbmV3RHN0WzldID0gLXM7XG4gICAgICAgIG5ld0RzdFsxMF0gPSBjO1xuICAgICAgICBuZXdEc3RbMTFdID0gMDtcbiAgICAgICAgbmV3RHN0WzEyXSA9IDA7XG4gICAgICAgIG5ld0RzdFsxM10gPSAwO1xuICAgICAgICBuZXdEc3RbMTRdID0gMDtcbiAgICAgICAgbmV3RHN0WzE1XSA9IDE7XG4gICAgICAgIHJldHVybiBuZXdEc3Q7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJvdGF0ZXMgdGhlIGdpdmVuIDQtYnktNCBtYXRyaXggYXJvdW5kIHRoZSB4LWF4aXMgYnkgdGhlIGdpdmVuXG4gICAgICogYW5nbGUuXG4gICAgICogQHBhcmFtIG0gLSBUaGUgbWF0cml4LlxuICAgICAqIEBwYXJhbSBhbmdsZUluUmFkaWFucyAtIFRoZSBhbmdsZSBieSB3aGljaCB0byByb3RhdGUgKGluIHJhZGlhbnMpLlxuICAgICAqIEBwYXJhbSBkc3QgLSBtYXRyaXggdG8gaG9sZCByZXN1bHQuIElmIG5vdCBwYXNzZWQgYSBuZXcgb25lIGlzIGNyZWF0ZWQuXG4gICAgICogQHJldHVybnMgVGhlIHJvdGF0ZWQgbWF0cml4LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHJvdGF0ZVgobSwgYW5nbGVJblJhZGlhbnMsIGRzdCkge1xuICAgICAgICBjb25zdCBuZXdEc3QgPSAoZHN0ID8/IG5ldyBDdG9yKDE2KSk7XG4gICAgICAgIGNvbnN0IG0xMCA9IG1bNF07XG4gICAgICAgIGNvbnN0IG0xMSA9IG1bNV07XG4gICAgICAgIGNvbnN0IG0xMiA9IG1bNl07XG4gICAgICAgIGNvbnN0IG0xMyA9IG1bN107XG4gICAgICAgIGNvbnN0IG0yMCA9IG1bOF07XG4gICAgICAgIGNvbnN0IG0yMSA9IG1bOV07XG4gICAgICAgIGNvbnN0IG0yMiA9IG1bMTBdO1xuICAgICAgICBjb25zdCBtMjMgPSBtWzExXTtcbiAgICAgICAgY29uc3QgYyA9IE1hdGguY29zKGFuZ2xlSW5SYWRpYW5zKTtcbiAgICAgICAgY29uc3QgcyA9IE1hdGguc2luKGFuZ2xlSW5SYWRpYW5zKTtcbiAgICAgICAgbmV3RHN0WzRdID0gYyAqIG0xMCArIHMgKiBtMjA7XG4gICAgICAgIG5ld0RzdFs1XSA9IGMgKiBtMTEgKyBzICogbTIxO1xuICAgICAgICBuZXdEc3RbNl0gPSBjICogbTEyICsgcyAqIG0yMjtcbiAgICAgICAgbmV3RHN0WzddID0gYyAqIG0xMyArIHMgKiBtMjM7XG4gICAgICAgIG5ld0RzdFs4XSA9IGMgKiBtMjAgLSBzICogbTEwO1xuICAgICAgICBuZXdEc3RbOV0gPSBjICogbTIxIC0gcyAqIG0xMTtcbiAgICAgICAgbmV3RHN0WzEwXSA9IGMgKiBtMjIgLSBzICogbTEyO1xuICAgICAgICBuZXdEc3RbMTFdID0gYyAqIG0yMyAtIHMgKiBtMTM7XG4gICAgICAgIGlmIChtICE9PSBuZXdEc3QpIHtcbiAgICAgICAgICAgIG5ld0RzdFswXSA9IG1bMF07XG4gICAgICAgICAgICBuZXdEc3RbMV0gPSBtWzFdO1xuICAgICAgICAgICAgbmV3RHN0WzJdID0gbVsyXTtcbiAgICAgICAgICAgIG5ld0RzdFszXSA9IG1bM107XG4gICAgICAgICAgICBuZXdEc3RbMTJdID0gbVsxMl07XG4gICAgICAgICAgICBuZXdEc3RbMTNdID0gbVsxM107XG4gICAgICAgICAgICBuZXdEc3RbMTRdID0gbVsxNF07XG4gICAgICAgICAgICBuZXdEc3RbMTVdID0gbVsxNV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ld0RzdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIDQtYnktNCBtYXRyaXggd2hpY2ggcm90YXRlcyBhcm91bmQgdGhlIHktYXhpcyBieSB0aGUgZ2l2ZW4gYW5nbGUuXG4gICAgICogQHBhcmFtIGFuZ2xlSW5SYWRpYW5zIC0gVGhlIGFuZ2xlIGJ5IHdoaWNoIHRvIHJvdGF0ZSAoaW4gcmFkaWFucykuXG4gICAgICogQHBhcmFtIGRzdCAtIG1hdHJpeCB0byBob2xkIHJlc3VsdC4gSWYgbm90IHBhc3NlZCBhIG5ldyBvbmUgaXMgY3JlYXRlZC5cbiAgICAgKiBAcmV0dXJucyBUaGUgcm90YXRpb24gbWF0cml4LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHJvdGF0aW9uWShhbmdsZUluUmFkaWFucywgZHN0KSB7XG4gICAgICAgIGNvbnN0IG5ld0RzdCA9IChkc3QgPz8gbmV3IEN0b3IoMTYpKTtcbiAgICAgICAgY29uc3QgYyA9IE1hdGguY29zKGFuZ2xlSW5SYWRpYW5zKTtcbiAgICAgICAgY29uc3QgcyA9IE1hdGguc2luKGFuZ2xlSW5SYWRpYW5zKTtcbiAgICAgICAgbmV3RHN0WzBdID0gYztcbiAgICAgICAgbmV3RHN0WzFdID0gMDtcbiAgICAgICAgbmV3RHN0WzJdID0gLXM7XG4gICAgICAgIG5ld0RzdFszXSA9IDA7XG4gICAgICAgIG5ld0RzdFs0XSA9IDA7XG4gICAgICAgIG5ld0RzdFs1XSA9IDE7XG4gICAgICAgIG5ld0RzdFs2XSA9IDA7XG4gICAgICAgIG5ld0RzdFs3XSA9IDA7XG4gICAgICAgIG5ld0RzdFs4XSA9IHM7XG4gICAgICAgIG5ld0RzdFs5XSA9IDA7XG4gICAgICAgIG5ld0RzdFsxMF0gPSBjO1xuICAgICAgICBuZXdEc3RbMTFdID0gMDtcbiAgICAgICAgbmV3RHN0WzEyXSA9IDA7XG4gICAgICAgIG5ld0RzdFsxM10gPSAwO1xuICAgICAgICBuZXdEc3RbMTRdID0gMDtcbiAgICAgICAgbmV3RHN0WzE1XSA9IDE7XG4gICAgICAgIHJldHVybiBuZXdEc3Q7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJvdGF0ZXMgdGhlIGdpdmVuIDQtYnktNCBtYXRyaXggYXJvdW5kIHRoZSB5LWF4aXMgYnkgdGhlIGdpdmVuXG4gICAgICogYW5nbGUuXG4gICAgICogQHBhcmFtIG0gLSBUaGUgbWF0cml4LlxuICAgICAqIEBwYXJhbSBhbmdsZUluUmFkaWFucyAtIFRoZSBhbmdsZSBieSB3aGljaCB0byByb3RhdGUgKGluIHJhZGlhbnMpLlxuICAgICAqIEBwYXJhbSBkc3QgLSBtYXRyaXggdG8gaG9sZCByZXN1bHQuIElmIG5vdCBwYXNzZWQgYSBuZXcgb25lIGlzIGNyZWF0ZWQuXG4gICAgICogQHJldHVybnMgVGhlIHJvdGF0ZWQgbWF0cml4LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHJvdGF0ZVkobSwgYW5nbGVJblJhZGlhbnMsIGRzdCkge1xuICAgICAgICBjb25zdCBuZXdEc3QgPSAoZHN0ID8/IG5ldyBDdG9yKDE2KSk7XG4gICAgICAgIGNvbnN0IG0wMCA9IG1bMCAqIDQgKyAwXTtcbiAgICAgICAgY29uc3QgbTAxID0gbVswICogNCArIDFdO1xuICAgICAgICBjb25zdCBtMDIgPSBtWzAgKiA0ICsgMl07XG4gICAgICAgIGNvbnN0IG0wMyA9IG1bMCAqIDQgKyAzXTtcbiAgICAgICAgY29uc3QgbTIwID0gbVsyICogNCArIDBdO1xuICAgICAgICBjb25zdCBtMjEgPSBtWzIgKiA0ICsgMV07XG4gICAgICAgIGNvbnN0IG0yMiA9IG1bMiAqIDQgKyAyXTtcbiAgICAgICAgY29uc3QgbTIzID0gbVsyICogNCArIDNdO1xuICAgICAgICBjb25zdCBjID0gTWF0aC5jb3MoYW5nbGVJblJhZGlhbnMpO1xuICAgICAgICBjb25zdCBzID0gTWF0aC5zaW4oYW5nbGVJblJhZGlhbnMpO1xuICAgICAgICBuZXdEc3RbMF0gPSBjICogbTAwIC0gcyAqIG0yMDtcbiAgICAgICAgbmV3RHN0WzFdID0gYyAqIG0wMSAtIHMgKiBtMjE7XG4gICAgICAgIG5ld0RzdFsyXSA9IGMgKiBtMDIgLSBzICogbTIyO1xuICAgICAgICBuZXdEc3RbM10gPSBjICogbTAzIC0gcyAqIG0yMztcbiAgICAgICAgbmV3RHN0WzhdID0gYyAqIG0yMCArIHMgKiBtMDA7XG4gICAgICAgIG5ld0RzdFs5XSA9IGMgKiBtMjEgKyBzICogbTAxO1xuICAgICAgICBuZXdEc3RbMTBdID0gYyAqIG0yMiArIHMgKiBtMDI7XG4gICAgICAgIG5ld0RzdFsxMV0gPSBjICogbTIzICsgcyAqIG0wMztcbiAgICAgICAgaWYgKG0gIT09IG5ld0RzdCkge1xuICAgICAgICAgICAgbmV3RHN0WzRdID0gbVs0XTtcbiAgICAgICAgICAgIG5ld0RzdFs1XSA9IG1bNV07XG4gICAgICAgICAgICBuZXdEc3RbNl0gPSBtWzZdO1xuICAgICAgICAgICAgbmV3RHN0WzddID0gbVs3XTtcbiAgICAgICAgICAgIG5ld0RzdFsxMl0gPSBtWzEyXTtcbiAgICAgICAgICAgIG5ld0RzdFsxM10gPSBtWzEzXTtcbiAgICAgICAgICAgIG5ld0RzdFsxNF0gPSBtWzE0XTtcbiAgICAgICAgICAgIG5ld0RzdFsxNV0gPSBtWzE1XTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3RHN0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgNC1ieS00IG1hdHJpeCB3aGljaCByb3RhdGVzIGFyb3VuZCB0aGUgei1heGlzIGJ5IHRoZSBnaXZlbiBhbmdsZS5cbiAgICAgKiBAcGFyYW0gYW5nbGVJblJhZGlhbnMgLSBUaGUgYW5nbGUgYnkgd2hpY2ggdG8gcm90YXRlIChpbiByYWRpYW5zKS5cbiAgICAgKiBAcGFyYW0gZHN0IC0gbWF0cml4IHRvIGhvbGQgcmVzdWx0LiBJZiBub3QgcGFzc2VkIGEgbmV3IG9uZSBpcyBjcmVhdGVkLlxuICAgICAqIEByZXR1cm5zIFRoZSByb3RhdGlvbiBtYXRyaXguXG4gICAgICovXG4gICAgZnVuY3Rpb24gcm90YXRpb25aKGFuZ2xlSW5SYWRpYW5zLCBkc3QpIHtcbiAgICAgICAgY29uc3QgbmV3RHN0ID0gKGRzdCA/PyBuZXcgQ3RvcigxNikpO1xuICAgICAgICBjb25zdCBjID0gTWF0aC5jb3MoYW5nbGVJblJhZGlhbnMpO1xuICAgICAgICBjb25zdCBzID0gTWF0aC5zaW4oYW5nbGVJblJhZGlhbnMpO1xuICAgICAgICBuZXdEc3RbMF0gPSBjO1xuICAgICAgICBuZXdEc3RbMV0gPSBzO1xuICAgICAgICBuZXdEc3RbMl0gPSAwO1xuICAgICAgICBuZXdEc3RbM10gPSAwO1xuICAgICAgICBuZXdEc3RbNF0gPSAtcztcbiAgICAgICAgbmV3RHN0WzVdID0gYztcbiAgICAgICAgbmV3RHN0WzZdID0gMDtcbiAgICAgICAgbmV3RHN0WzddID0gMDtcbiAgICAgICAgbmV3RHN0WzhdID0gMDtcbiAgICAgICAgbmV3RHN0WzldID0gMDtcbiAgICAgICAgbmV3RHN0WzEwXSA9IDE7XG4gICAgICAgIG5ld0RzdFsxMV0gPSAwO1xuICAgICAgICBuZXdEc3RbMTJdID0gMDtcbiAgICAgICAgbmV3RHN0WzEzXSA9IDA7XG4gICAgICAgIG5ld0RzdFsxNF0gPSAwO1xuICAgICAgICBuZXdEc3RbMTVdID0gMTtcbiAgICAgICAgcmV0dXJuIG5ld0RzdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUm90YXRlcyB0aGUgZ2l2ZW4gNC1ieS00IG1hdHJpeCBhcm91bmQgdGhlIHotYXhpcyBieSB0aGUgZ2l2ZW5cbiAgICAgKiBhbmdsZS5cbiAgICAgKiBAcGFyYW0gbSAtIFRoZSBtYXRyaXguXG4gICAgICogQHBhcmFtIGFuZ2xlSW5SYWRpYW5zIC0gVGhlIGFuZ2xlIGJ5IHdoaWNoIHRvIHJvdGF0ZSAoaW4gcmFkaWFucykuXG4gICAgICogQHBhcmFtIGRzdCAtIG1hdHJpeCB0byBob2xkIHJlc3VsdC4gSWYgbm90IHBhc3NlZCBhIG5ldyBvbmUgaXMgY3JlYXRlZC5cbiAgICAgKiBAcmV0dXJucyBUaGUgcm90YXRlZCBtYXRyaXguXG4gICAgICovXG4gICAgZnVuY3Rpb24gcm90YXRlWihtLCBhbmdsZUluUmFkaWFucywgZHN0KSB7XG4gICAgICAgIGNvbnN0IG5ld0RzdCA9IChkc3QgPz8gbmV3IEN0b3IoMTYpKTtcbiAgICAgICAgY29uc3QgbTAwID0gbVswICogNCArIDBdO1xuICAgICAgICBjb25zdCBtMDEgPSBtWzAgKiA0ICsgMV07XG4gICAgICAgIGNvbnN0IG0wMiA9IG1bMCAqIDQgKyAyXTtcbiAgICAgICAgY29uc3QgbTAzID0gbVswICogNCArIDNdO1xuICAgICAgICBjb25zdCBtMTAgPSBtWzEgKiA0ICsgMF07XG4gICAgICAgIGNvbnN0IG0xMSA9IG1bMSAqIDQgKyAxXTtcbiAgICAgICAgY29uc3QgbTEyID0gbVsxICogNCArIDJdO1xuICAgICAgICBjb25zdCBtMTMgPSBtWzEgKiA0ICsgM107XG4gICAgICAgIGNvbnN0IGMgPSBNYXRoLmNvcyhhbmdsZUluUmFkaWFucyk7XG4gICAgICAgIGNvbnN0IHMgPSBNYXRoLnNpbihhbmdsZUluUmFkaWFucyk7XG4gICAgICAgIG5ld0RzdFswXSA9IGMgKiBtMDAgKyBzICogbTEwO1xuICAgICAgICBuZXdEc3RbMV0gPSBjICogbTAxICsgcyAqIG0xMTtcbiAgICAgICAgbmV3RHN0WzJdID0gYyAqIG0wMiArIHMgKiBtMTI7XG4gICAgICAgIG5ld0RzdFszXSA9IGMgKiBtMDMgKyBzICogbTEzO1xuICAgICAgICBuZXdEc3RbNF0gPSBjICogbTEwIC0gcyAqIG0wMDtcbiAgICAgICAgbmV3RHN0WzVdID0gYyAqIG0xMSAtIHMgKiBtMDE7XG4gICAgICAgIG5ld0RzdFs2XSA9IGMgKiBtMTIgLSBzICogbTAyO1xuICAgICAgICBuZXdEc3RbN10gPSBjICogbTEzIC0gcyAqIG0wMztcbiAgICAgICAgaWYgKG0gIT09IG5ld0RzdCkge1xuICAgICAgICAgICAgbmV3RHN0WzhdID0gbVs4XTtcbiAgICAgICAgICAgIG5ld0RzdFs5XSA9IG1bOV07XG4gICAgICAgICAgICBuZXdEc3RbMTBdID0gbVsxMF07XG4gICAgICAgICAgICBuZXdEc3RbMTFdID0gbVsxMV07XG4gICAgICAgICAgICBuZXdEc3RbMTJdID0gbVsxMl07XG4gICAgICAgICAgICBuZXdEc3RbMTNdID0gbVsxM107XG4gICAgICAgICAgICBuZXdEc3RbMTRdID0gbVsxNF07XG4gICAgICAgICAgICBuZXdEc3RbMTVdID0gbVsxNV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ld0RzdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIDQtYnktNCBtYXRyaXggd2hpY2ggcm90YXRlcyBhcm91bmQgdGhlIGdpdmVuIGF4aXMgYnkgdGhlIGdpdmVuXG4gICAgICogYW5nbGUuXG4gICAgICogQHBhcmFtIGF4aXMgLSBUaGUgYXhpc1xuICAgICAqICAgICBhYm91dCB3aGljaCB0byByb3RhdGUuXG4gICAgICogQHBhcmFtIGFuZ2xlSW5SYWRpYW5zIC0gVGhlIGFuZ2xlIGJ5IHdoaWNoIHRvIHJvdGF0ZSAoaW4gcmFkaWFucykuXG4gICAgICogQHBhcmFtIGRzdCAtIG1hdHJpeCB0byBob2xkIHJlc3VsdC4gSWYgbm90IHBhc3NlZCBhIG5ldyBvbmUgaXMgY3JlYXRlZC5cbiAgICAgKiBAcmV0dXJucyBBIG1hdHJpeCB3aGljaCByb3RhdGVzIGFuZ2xlIHJhZGlhbnNcbiAgICAgKiAgICAgYXJvdW5kIHRoZSBheGlzLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGF4aXNSb3RhdGlvbihheGlzLCBhbmdsZUluUmFkaWFucywgZHN0KSB7XG4gICAgICAgIGNvbnN0IG5ld0RzdCA9IChkc3QgPz8gbmV3IEN0b3IoMTYpKTtcbiAgICAgICAgbGV0IHggPSBheGlzWzBdO1xuICAgICAgICBsZXQgeSA9IGF4aXNbMV07XG4gICAgICAgIGxldCB6ID0gYXhpc1syXTtcbiAgICAgICAgY29uc3QgbiA9IE1hdGguc3FydCh4ICogeCArIHkgKiB5ICsgeiAqIHopO1xuICAgICAgICB4IC89IG47XG4gICAgICAgIHkgLz0gbjtcbiAgICAgICAgeiAvPSBuO1xuICAgICAgICBjb25zdCB4eCA9IHggKiB4O1xuICAgICAgICBjb25zdCB5eSA9IHkgKiB5O1xuICAgICAgICBjb25zdCB6eiA9IHogKiB6O1xuICAgICAgICBjb25zdCBjID0gTWF0aC5jb3MoYW5nbGVJblJhZGlhbnMpO1xuICAgICAgICBjb25zdCBzID0gTWF0aC5zaW4oYW5nbGVJblJhZGlhbnMpO1xuICAgICAgICBjb25zdCBvbmVNaW51c0Nvc2luZSA9IDEgLSBjO1xuICAgICAgICBuZXdEc3RbMF0gPSB4eCArICgxIC0geHgpICogYztcbiAgICAgICAgbmV3RHN0WzFdID0geCAqIHkgKiBvbmVNaW51c0Nvc2luZSArIHogKiBzO1xuICAgICAgICBuZXdEc3RbMl0gPSB4ICogeiAqIG9uZU1pbnVzQ29zaW5lIC0geSAqIHM7XG4gICAgICAgIG5ld0RzdFszXSA9IDA7XG4gICAgICAgIG5ld0RzdFs0XSA9IHggKiB5ICogb25lTWludXNDb3NpbmUgLSB6ICogcztcbiAgICAgICAgbmV3RHN0WzVdID0geXkgKyAoMSAtIHl5KSAqIGM7XG4gICAgICAgIG5ld0RzdFs2XSA9IHkgKiB6ICogb25lTWludXNDb3NpbmUgKyB4ICogcztcbiAgICAgICAgbmV3RHN0WzddID0gMDtcbiAgICAgICAgbmV3RHN0WzhdID0geCAqIHogKiBvbmVNaW51c0Nvc2luZSArIHkgKiBzO1xuICAgICAgICBuZXdEc3RbOV0gPSB5ICogeiAqIG9uZU1pbnVzQ29zaW5lIC0geCAqIHM7XG4gICAgICAgIG5ld0RzdFsxMF0gPSB6eiArICgxIC0genopICogYztcbiAgICAgICAgbmV3RHN0WzExXSA9IDA7XG4gICAgICAgIG5ld0RzdFsxMl0gPSAwO1xuICAgICAgICBuZXdEc3RbMTNdID0gMDtcbiAgICAgICAgbmV3RHN0WzE0XSA9IDA7XG4gICAgICAgIG5ld0RzdFsxNV0gPSAxO1xuICAgICAgICByZXR1cm4gbmV3RHN0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgNC1ieS00IG1hdHJpeCB3aGljaCByb3RhdGVzIGFyb3VuZCB0aGUgZ2l2ZW4gYXhpcyBieSB0aGUgZ2l2ZW5cbiAgICAgKiBhbmdsZS4gKHNhbWUgYXMgYXhpc1JvdGF0aW9uKVxuICAgICAqIEBwYXJhbSBheGlzIC0gVGhlIGF4aXNcbiAgICAgKiAgICAgYWJvdXQgd2hpY2ggdG8gcm90YXRlLlxuICAgICAqIEBwYXJhbSBhbmdsZUluUmFkaWFucyAtIFRoZSBhbmdsZSBieSB3aGljaCB0byByb3RhdGUgKGluIHJhZGlhbnMpLlxuICAgICAqIEBwYXJhbSBkc3QgLSBtYXRyaXggdG8gaG9sZCByZXN1bHQuIElmIG5vdCBwYXNzZWQgYSBuZXcgb25lIGlzIGNyZWF0ZWQuXG4gICAgICogQHJldHVybnMgQSBtYXRyaXggd2hpY2ggcm90YXRlcyBhbmdsZSByYWRpYW5zXG4gICAgICogICAgIGFyb3VuZCB0aGUgYXhpcy5cbiAgICAgKi9cbiAgICBjb25zdCByb3RhdGlvbiA9IGF4aXNSb3RhdGlvbjtcbiAgICAvKipcbiAgICAgKiBSb3RhdGVzIHRoZSBnaXZlbiA0LWJ5LTQgbWF0cml4IGFyb3VuZCB0aGUgZ2l2ZW4gYXhpcyBieSB0aGVcbiAgICAgKiBnaXZlbiBhbmdsZS5cbiAgICAgKiBAcGFyYW0gbSAtIFRoZSBtYXRyaXguXG4gICAgICogQHBhcmFtIGF4aXMgLSBUaGUgYXhpc1xuICAgICAqICAgICBhYm91dCB3aGljaCB0byByb3RhdGUuXG4gICAgICogQHBhcmFtIGFuZ2xlSW5SYWRpYW5zIC0gVGhlIGFuZ2xlIGJ5IHdoaWNoIHRvIHJvdGF0ZSAoaW4gcmFkaWFucykuXG4gICAgICogQHBhcmFtIGRzdCAtIG1hdHJpeCB0byBob2xkIHJlc3VsdC4gSWYgbm90IHBhc3NlZCBhIG5ldyBvbmUgaXMgY3JlYXRlZC5cbiAgICAgKiBAcmV0dXJucyBUaGUgcm90YXRlZCBtYXRyaXguXG4gICAgICovXG4gICAgZnVuY3Rpb24gYXhpc1JvdGF0ZShtLCBheGlzLCBhbmdsZUluUmFkaWFucywgZHN0KSB7XG4gICAgICAgIGNvbnN0IG5ld0RzdCA9IChkc3QgPz8gbmV3IEN0b3IoMTYpKTtcbiAgICAgICAgbGV0IHggPSBheGlzWzBdO1xuICAgICAgICBsZXQgeSA9IGF4aXNbMV07XG4gICAgICAgIGxldCB6ID0gYXhpc1syXTtcbiAgICAgICAgY29uc3QgbiA9IE1hdGguc3FydCh4ICogeCArIHkgKiB5ICsgeiAqIHopO1xuICAgICAgICB4IC89IG47XG4gICAgICAgIHkgLz0gbjtcbiAgICAgICAgeiAvPSBuO1xuICAgICAgICBjb25zdCB4eCA9IHggKiB4O1xuICAgICAgICBjb25zdCB5eSA9IHkgKiB5O1xuICAgICAgICBjb25zdCB6eiA9IHogKiB6O1xuICAgICAgICBjb25zdCBjID0gTWF0aC5jb3MoYW5nbGVJblJhZGlhbnMpO1xuICAgICAgICBjb25zdCBzID0gTWF0aC5zaW4oYW5nbGVJblJhZGlhbnMpO1xuICAgICAgICBjb25zdCBvbmVNaW51c0Nvc2luZSA9IDEgLSBjO1xuICAgICAgICBjb25zdCByMDAgPSB4eCArICgxIC0geHgpICogYztcbiAgICAgICAgY29uc3QgcjAxID0geCAqIHkgKiBvbmVNaW51c0Nvc2luZSArIHogKiBzO1xuICAgICAgICBjb25zdCByMDIgPSB4ICogeiAqIG9uZU1pbnVzQ29zaW5lIC0geSAqIHM7XG4gICAgICAgIGNvbnN0IHIxMCA9IHggKiB5ICogb25lTWludXNDb3NpbmUgLSB6ICogcztcbiAgICAgICAgY29uc3QgcjExID0geXkgKyAoMSAtIHl5KSAqIGM7XG4gICAgICAgIGNvbnN0IHIxMiA9IHkgKiB6ICogb25lTWludXNDb3NpbmUgKyB4ICogcztcbiAgICAgICAgY29uc3QgcjIwID0geCAqIHogKiBvbmVNaW51c0Nvc2luZSArIHkgKiBzO1xuICAgICAgICBjb25zdCByMjEgPSB5ICogeiAqIG9uZU1pbnVzQ29zaW5lIC0geCAqIHM7XG4gICAgICAgIGNvbnN0IHIyMiA9IHp6ICsgKDEgLSB6eikgKiBjO1xuICAgICAgICBjb25zdCBtMDAgPSBtWzBdO1xuICAgICAgICBjb25zdCBtMDEgPSBtWzFdO1xuICAgICAgICBjb25zdCBtMDIgPSBtWzJdO1xuICAgICAgICBjb25zdCBtMDMgPSBtWzNdO1xuICAgICAgICBjb25zdCBtMTAgPSBtWzRdO1xuICAgICAgICBjb25zdCBtMTEgPSBtWzVdO1xuICAgICAgICBjb25zdCBtMTIgPSBtWzZdO1xuICAgICAgICBjb25zdCBtMTMgPSBtWzddO1xuICAgICAgICBjb25zdCBtMjAgPSBtWzhdO1xuICAgICAgICBjb25zdCBtMjEgPSBtWzldO1xuICAgICAgICBjb25zdCBtMjIgPSBtWzEwXTtcbiAgICAgICAgY29uc3QgbTIzID0gbVsxMV07XG4gICAgICAgIG5ld0RzdFswXSA9IHIwMCAqIG0wMCArIHIwMSAqIG0xMCArIHIwMiAqIG0yMDtcbiAgICAgICAgbmV3RHN0WzFdID0gcjAwICogbTAxICsgcjAxICogbTExICsgcjAyICogbTIxO1xuICAgICAgICBuZXdEc3RbMl0gPSByMDAgKiBtMDIgKyByMDEgKiBtMTIgKyByMDIgKiBtMjI7XG4gICAgICAgIG5ld0RzdFszXSA9IHIwMCAqIG0wMyArIHIwMSAqIG0xMyArIHIwMiAqIG0yMztcbiAgICAgICAgbmV3RHN0WzRdID0gcjEwICogbTAwICsgcjExICogbTEwICsgcjEyICogbTIwO1xuICAgICAgICBuZXdEc3RbNV0gPSByMTAgKiBtMDEgKyByMTEgKiBtMTEgKyByMTIgKiBtMjE7XG4gICAgICAgIG5ld0RzdFs2XSA9IHIxMCAqIG0wMiArIHIxMSAqIG0xMiArIHIxMiAqIG0yMjtcbiAgICAgICAgbmV3RHN0WzddID0gcjEwICogbTAzICsgcjExICogbTEzICsgcjEyICogbTIzO1xuICAgICAgICBuZXdEc3RbOF0gPSByMjAgKiBtMDAgKyByMjEgKiBtMTAgKyByMjIgKiBtMjA7XG4gICAgICAgIG5ld0RzdFs5XSA9IHIyMCAqIG0wMSArIHIyMSAqIG0xMSArIHIyMiAqIG0yMTtcbiAgICAgICAgbmV3RHN0WzEwXSA9IHIyMCAqIG0wMiArIHIyMSAqIG0xMiArIHIyMiAqIG0yMjtcbiAgICAgICAgbmV3RHN0WzExXSA9IHIyMCAqIG0wMyArIHIyMSAqIG0xMyArIHIyMiAqIG0yMztcbiAgICAgICAgaWYgKG0gIT09IG5ld0RzdCkge1xuICAgICAgICAgICAgbmV3RHN0WzEyXSA9IG1bMTJdO1xuICAgICAgICAgICAgbmV3RHN0WzEzXSA9IG1bMTNdO1xuICAgICAgICAgICAgbmV3RHN0WzE0XSA9IG1bMTRdO1xuICAgICAgICAgICAgbmV3RHN0WzE1XSA9IG1bMTVdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXdEc3Q7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJvdGF0ZXMgdGhlIGdpdmVuIDQtYnktNCBtYXRyaXggYXJvdW5kIHRoZSBnaXZlbiBheGlzIGJ5IHRoZVxuICAgICAqIGdpdmVuIGFuZ2xlLiAoc2FtZSBhcyByb3RhdGUpXG4gICAgICogQHBhcmFtIG0gLSBUaGUgbWF0cml4LlxuICAgICAqIEBwYXJhbSBheGlzIC0gVGhlIGF4aXNcbiAgICAgKiAgICAgYWJvdXQgd2hpY2ggdG8gcm90YXRlLlxuICAgICAqIEBwYXJhbSBhbmdsZUluUmFkaWFucyAtIFRoZSBhbmdsZSBieSB3aGljaCB0byByb3RhdGUgKGluIHJhZGlhbnMpLlxuICAgICAqIEBwYXJhbSBkc3QgLSBtYXRyaXggdG8gaG9sZCByZXN1bHQuIElmIG5vdCBwYXNzZWQgYSBuZXcgb25lIGlzIGNyZWF0ZWQuXG4gICAgICogQHJldHVybnMgVGhlIHJvdGF0ZWQgbWF0cml4LlxuICAgICAqL1xuICAgIGNvbnN0IHJvdGF0ZSA9IGF4aXNSb3RhdGU7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIDQtYnktNCBtYXRyaXggd2hpY2ggc2NhbGVzIGluIGVhY2ggZGltZW5zaW9uIGJ5IGFuIGFtb3VudCBnaXZlbiBieVxuICAgICAqIHRoZSBjb3JyZXNwb25kaW5nIGVudHJ5IGluIHRoZSBnaXZlbiB2ZWN0b3I7IGFzc3VtZXMgdGhlIHZlY3RvciBoYXMgdGhyZWVcbiAgICAgKiBlbnRyaWVzLlxuICAgICAqIEBwYXJhbSB2IC0gQSB2ZWN0b3Igb2ZcbiAgICAgKiAgICAgdGhyZWUgZW50cmllcyBzcGVjaWZ5aW5nIHRoZSBmYWN0b3IgYnkgd2hpY2ggdG8gc2NhbGUgaW4gZWFjaCBkaW1lbnNpb24uXG4gICAgICogQHBhcmFtIGRzdCAtIG1hdHJpeCB0byBob2xkIHJlc3VsdC4gSWYgbm90IHBhc3NlZCBhIG5ldyBvbmUgaXMgY3JlYXRlZC5cbiAgICAgKiBAcmV0dXJucyBUaGUgc2NhbGluZyBtYXRyaXguXG4gICAgICovXG4gICAgZnVuY3Rpb24gc2NhbGluZyh2LCBkc3QpIHtcbiAgICAgICAgY29uc3QgbmV3RHN0ID0gKGRzdCA/PyBuZXcgQ3RvcigxNikpO1xuICAgICAgICBuZXdEc3RbMF0gPSB2WzBdO1xuICAgICAgICBuZXdEc3RbMV0gPSAwO1xuICAgICAgICBuZXdEc3RbMl0gPSAwO1xuICAgICAgICBuZXdEc3RbM10gPSAwO1xuICAgICAgICBuZXdEc3RbNF0gPSAwO1xuICAgICAgICBuZXdEc3RbNV0gPSB2WzFdO1xuICAgICAgICBuZXdEc3RbNl0gPSAwO1xuICAgICAgICBuZXdEc3RbN10gPSAwO1xuICAgICAgICBuZXdEc3RbOF0gPSAwO1xuICAgICAgICBuZXdEc3RbOV0gPSAwO1xuICAgICAgICBuZXdEc3RbMTBdID0gdlsyXTtcbiAgICAgICAgbmV3RHN0WzExXSA9IDA7XG4gICAgICAgIG5ld0RzdFsxMl0gPSAwO1xuICAgICAgICBuZXdEc3RbMTNdID0gMDtcbiAgICAgICAgbmV3RHN0WzE0XSA9IDA7XG4gICAgICAgIG5ld0RzdFsxNV0gPSAxO1xuICAgICAgICByZXR1cm4gbmV3RHN0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTY2FsZXMgdGhlIGdpdmVuIDQtYnktNCBtYXRyaXggaW4gZWFjaCBkaW1lbnNpb24gYnkgYW4gYW1vdW50XG4gICAgICogZ2l2ZW4gYnkgdGhlIGNvcnJlc3BvbmRpbmcgZW50cnkgaW4gdGhlIGdpdmVuIHZlY3RvcjsgYXNzdW1lcyB0aGUgdmVjdG9yIGhhc1xuICAgICAqIHRocmVlIGVudHJpZXMuXG4gICAgICogQHBhcmFtIG0gLSBUaGUgbWF0cml4IHRvIGJlIG1vZGlmaWVkLlxuICAgICAqIEBwYXJhbSB2IC0gQSB2ZWN0b3Igb2YgdGhyZWUgZW50cmllcyBzcGVjaWZ5aW5nIHRoZVxuICAgICAqICAgICBmYWN0b3IgYnkgd2hpY2ggdG8gc2NhbGUgaW4gZWFjaCBkaW1lbnNpb24uXG4gICAgICogQHBhcmFtIGRzdCAtIG1hdHJpeCB0byBob2xkIHJlc3VsdC4gSWYgbm90IHBhc3NlZCBhIG5ldyBvbmUgaXMgY3JlYXRlZC5cbiAgICAgKiBAcmV0dXJucyBUaGUgc2NhbGVkIG1hdHJpeC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzY2FsZShtLCB2LCBkc3QpIHtcbiAgICAgICAgY29uc3QgbmV3RHN0ID0gKGRzdCA/PyBuZXcgQ3RvcigxNikpO1xuICAgICAgICBjb25zdCB2MCA9IHZbMF07XG4gICAgICAgIGNvbnN0IHYxID0gdlsxXTtcbiAgICAgICAgY29uc3QgdjIgPSB2WzJdO1xuICAgICAgICBuZXdEc3RbMF0gPSB2MCAqIG1bMCAqIDQgKyAwXTtcbiAgICAgICAgbmV3RHN0WzFdID0gdjAgKiBtWzAgKiA0ICsgMV07XG4gICAgICAgIG5ld0RzdFsyXSA9IHYwICogbVswICogNCArIDJdO1xuICAgICAgICBuZXdEc3RbM10gPSB2MCAqIG1bMCAqIDQgKyAzXTtcbiAgICAgICAgbmV3RHN0WzRdID0gdjEgKiBtWzEgKiA0ICsgMF07XG4gICAgICAgIG5ld0RzdFs1XSA9IHYxICogbVsxICogNCArIDFdO1xuICAgICAgICBuZXdEc3RbNl0gPSB2MSAqIG1bMSAqIDQgKyAyXTtcbiAgICAgICAgbmV3RHN0WzddID0gdjEgKiBtWzEgKiA0ICsgM107XG4gICAgICAgIG5ld0RzdFs4XSA9IHYyICogbVsyICogNCArIDBdO1xuICAgICAgICBuZXdEc3RbOV0gPSB2MiAqIG1bMiAqIDQgKyAxXTtcbiAgICAgICAgbmV3RHN0WzEwXSA9IHYyICogbVsyICogNCArIDJdO1xuICAgICAgICBuZXdEc3RbMTFdID0gdjIgKiBtWzIgKiA0ICsgM107XG4gICAgICAgIGlmIChtICE9PSBuZXdEc3QpIHtcbiAgICAgICAgICAgIG5ld0RzdFsxMl0gPSBtWzEyXTtcbiAgICAgICAgICAgIG5ld0RzdFsxM10gPSBtWzEzXTtcbiAgICAgICAgICAgIG5ld0RzdFsxNF0gPSBtWzE0XTtcbiAgICAgICAgICAgIG5ld0RzdFsxNV0gPSBtWzE1XTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3RHN0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgNC1ieS00IG1hdHJpeCB3aGljaCBzY2FsZXMgYSB1bmlmb3JtIGFtb3VudCBpbiBlYWNoIGRpbWVuc2lvbi5cbiAgICAgKiBAcGFyYW0gcyAtIHRoZSBhbW91bnQgdG8gc2NhbGVcbiAgICAgKiBAcGFyYW0gZHN0IC0gbWF0cml4IHRvIGhvbGQgcmVzdWx0LiBJZiBub3QgcGFzc2VkIGEgbmV3IG9uZSBpcyBjcmVhdGVkLlxuICAgICAqIEByZXR1cm5zIFRoZSBzY2FsaW5nIG1hdHJpeC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB1bmlmb3JtU2NhbGluZyhzLCBkc3QpIHtcbiAgICAgICAgY29uc3QgbmV3RHN0ID0gKGRzdCA/PyBuZXcgQ3RvcigxNikpO1xuICAgICAgICBuZXdEc3RbMF0gPSBzO1xuICAgICAgICBuZXdEc3RbMV0gPSAwO1xuICAgICAgICBuZXdEc3RbMl0gPSAwO1xuICAgICAgICBuZXdEc3RbM10gPSAwO1xuICAgICAgICBuZXdEc3RbNF0gPSAwO1xuICAgICAgICBuZXdEc3RbNV0gPSBzO1xuICAgICAgICBuZXdEc3RbNl0gPSAwO1xuICAgICAgICBuZXdEc3RbN10gPSAwO1xuICAgICAgICBuZXdEc3RbOF0gPSAwO1xuICAgICAgICBuZXdEc3RbOV0gPSAwO1xuICAgICAgICBuZXdEc3RbMTBdID0gcztcbiAgICAgICAgbmV3RHN0WzExXSA9IDA7XG4gICAgICAgIG5ld0RzdFsxMl0gPSAwO1xuICAgICAgICBuZXdEc3RbMTNdID0gMDtcbiAgICAgICAgbmV3RHN0WzE0XSA9IDA7XG4gICAgICAgIG5ld0RzdFsxNV0gPSAxO1xuICAgICAgICByZXR1cm4gbmV3RHN0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTY2FsZXMgdGhlIGdpdmVuIDQtYnktNCBtYXRyaXggaW4gZWFjaCBkaW1lbnNpb24gYnkgYSB1bmlmb3JtIHNjYWxlLlxuICAgICAqIEBwYXJhbSBtIC0gVGhlIG1hdHJpeCB0byBiZSBtb2RpZmllZC5cbiAgICAgKiBAcGFyYW0gcyAtIFRoZSBhbW91bnQgdG8gc2NhbGUuXG4gICAgICogQHBhcmFtIGRzdCAtIG1hdHJpeCB0byBob2xkIHJlc3VsdC4gSWYgbm90IHBhc3NlZCBhIG5ldyBvbmUgaXMgY3JlYXRlZC5cbiAgICAgKiBAcmV0dXJucyBUaGUgc2NhbGVkIG1hdHJpeC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB1bmlmb3JtU2NhbGUobSwgcywgZHN0KSB7XG4gICAgICAgIGNvbnN0IG5ld0RzdCA9IChkc3QgPz8gbmV3IEN0b3IoMTYpKTtcbiAgICAgICAgbmV3RHN0WzBdID0gcyAqIG1bMCAqIDQgKyAwXTtcbiAgICAgICAgbmV3RHN0WzFdID0gcyAqIG1bMCAqIDQgKyAxXTtcbiAgICAgICAgbmV3RHN0WzJdID0gcyAqIG1bMCAqIDQgKyAyXTtcbiAgICAgICAgbmV3RHN0WzNdID0gcyAqIG1bMCAqIDQgKyAzXTtcbiAgICAgICAgbmV3RHN0WzRdID0gcyAqIG1bMSAqIDQgKyAwXTtcbiAgICAgICAgbmV3RHN0WzVdID0gcyAqIG1bMSAqIDQgKyAxXTtcbiAgICAgICAgbmV3RHN0WzZdID0gcyAqIG1bMSAqIDQgKyAyXTtcbiAgICAgICAgbmV3RHN0WzddID0gcyAqIG1bMSAqIDQgKyAzXTtcbiAgICAgICAgbmV3RHN0WzhdID0gcyAqIG1bMiAqIDQgKyAwXTtcbiAgICAgICAgbmV3RHN0WzldID0gcyAqIG1bMiAqIDQgKyAxXTtcbiAgICAgICAgbmV3RHN0WzEwXSA9IHMgKiBtWzIgKiA0ICsgMl07XG4gICAgICAgIG5ld0RzdFsxMV0gPSBzICogbVsyICogNCArIDNdO1xuICAgICAgICBpZiAobSAhPT0gbmV3RHN0KSB7XG4gICAgICAgICAgICBuZXdEc3RbMTJdID0gbVsxMl07XG4gICAgICAgICAgICBuZXdEc3RbMTNdID0gbVsxM107XG4gICAgICAgICAgICBuZXdEc3RbMTRdID0gbVsxNF07XG4gICAgICAgICAgICBuZXdEc3RbMTVdID0gbVsxNV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ld0RzdDtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgY3JlYXRlLFxuICAgICAgICBzZXQsXG4gICAgICAgIGZyb21NYXQzLFxuICAgICAgICBmcm9tUXVhdCxcbiAgICAgICAgbmVnYXRlLFxuICAgICAgICBjb3B5LFxuICAgICAgICBjbG9uZSxcbiAgICAgICAgZXF1YWxzQXBwcm94aW1hdGVseSxcbiAgICAgICAgZXF1YWxzLFxuICAgICAgICBpZGVudGl0eSxcbiAgICAgICAgdHJhbnNwb3NlLFxuICAgICAgICBpbnZlcnNlLFxuICAgICAgICBkZXRlcm1pbmFudCxcbiAgICAgICAgaW52ZXJ0LFxuICAgICAgICBtdWx0aXBseSxcbiAgICAgICAgbXVsLFxuICAgICAgICBzZXRUcmFuc2xhdGlvbixcbiAgICAgICAgZ2V0VHJhbnNsYXRpb24sXG4gICAgICAgIGdldEF4aXMsXG4gICAgICAgIHNldEF4aXMsXG4gICAgICAgIGdldFNjYWxpbmcsXG4gICAgICAgIHBlcnNwZWN0aXZlLFxuICAgICAgICBwZXJzcGVjdGl2ZVJldmVyc2VaLFxuICAgICAgICBvcnRobyxcbiAgICAgICAgZnJ1c3R1bSxcbiAgICAgICAgZnJ1c3R1bVJldmVyc2VaLFxuICAgICAgICBhaW0sXG4gICAgICAgIGNhbWVyYUFpbSxcbiAgICAgICAgbG9va0F0LFxuICAgICAgICB0cmFuc2xhdGlvbixcbiAgICAgICAgdHJhbnNsYXRlLFxuICAgICAgICByb3RhdGlvblgsXG4gICAgICAgIHJvdGF0ZVgsXG4gICAgICAgIHJvdGF0aW9uWSxcbiAgICAgICAgcm90YXRlWSxcbiAgICAgICAgcm90YXRpb25aLFxuICAgICAgICByb3RhdGVaLFxuICAgICAgICBheGlzUm90YXRpb24sXG4gICAgICAgIHJvdGF0aW9uLFxuICAgICAgICBheGlzUm90YXRlLFxuICAgICAgICByb3RhdGUsXG4gICAgICAgIHNjYWxpbmcsXG4gICAgICAgIHNjYWxlLFxuICAgICAgICB1bmlmb3JtU2NhbGluZyxcbiAgICAgICAgdW5pZm9ybVNjYWxlLFxuICAgIH07XG59XG5jb25zdCBjYWNoZSQyID0gbmV3IE1hcCgpO1xuZnVuY3Rpb24gZ2V0QVBJJDIoQ3Rvcikge1xuICAgIGxldCBhcGkgPSBjYWNoZSQyLmdldChDdG9yKTtcbiAgICBpZiAoIWFwaSkge1xuICAgICAgICBhcGkgPSBnZXRBUElJbXBsJDIoQ3Rvcik7XG4gICAgICAgIGNhY2hlJDIuc2V0KEN0b3IsIGFwaSk7XG4gICAgfVxuICAgIHJldHVybiBhcGk7XG59XG5cbi8qXG4gKiBDb3B5cmlnaHQgMjAyMiBHcmVnZyBUYXZhcmVzXG4gKlxuICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbiAqIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSxcbiAqIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb25cbiAqIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLFxuICogYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlXG4gKiBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuICpcbiAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4gKiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbiAqXG4gKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4gKiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbiAqIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuICBJTiBOTyBFVkVOVCBTSEFMTFxuICogVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbiAqIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HXG4gKiBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSXG4gKiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG4gKi9cbi8qKlxuICogR2VuZXJhdGVzIGFtIHR5cGVkIEFQSSBmb3IgUXVkXG4gKiAqL1xuZnVuY3Rpb24gZ2V0QVBJSW1wbCQxKEN0b3IpIHtcbiAgICBjb25zdCB2ZWMzID0gZ2V0QVBJJDMoQ3Rvcik7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIHF1YXQ0OyBtYXkgYmUgY2FsbGVkIHdpdGggeCwgeSwgeiB0byBzZXQgaW5pdGlhbCB2YWx1ZXMuXG4gICAgICogQHBhcmFtIHggLSBJbml0aWFsIHggdmFsdWUuXG4gICAgICogQHBhcmFtIHkgLSBJbml0aWFsIHkgdmFsdWUuXG4gICAgICogQHBhcmFtIHogLSBJbml0aWFsIHogdmFsdWUuXG4gICAgICogQHBhcmFtIHcgLSBJbml0aWFsIHcgdmFsdWUuXG4gICAgICogQHJldHVybnMgdGhlIGNyZWF0ZWQgdmVjdG9yXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlKHgsIHksIHosIHcpIHtcbiAgICAgICAgY29uc3QgbmV3RHN0ID0gbmV3IEN0b3IoNCk7XG4gICAgICAgIGlmICh4ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIG5ld0RzdFswXSA9IHg7XG4gICAgICAgICAgICBpZiAoeSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgbmV3RHN0WzFdID0geTtcbiAgICAgICAgICAgICAgICBpZiAoeiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIG5ld0RzdFsyXSA9IHo7XG4gICAgICAgICAgICAgICAgICAgIGlmICh3ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld0RzdFszXSA9IHc7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ld0RzdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIFF1YXQ7IG1heSBiZSBjYWxsZWQgd2l0aCB4LCB5LCB6IHRvIHNldCBpbml0aWFsIHZhbHVlcy4gKHNhbWUgYXMgY3JlYXRlKVxuICAgICAqIEBwYXJhbSB4IC0gSW5pdGlhbCB4IHZhbHVlLlxuICAgICAqIEBwYXJhbSB5IC0gSW5pdGlhbCB5IHZhbHVlLlxuICAgICAqIEBwYXJhbSB6IC0gSW5pdGlhbCB6IHZhbHVlLlxuICAgICAqIEBwYXJhbSB6IC0gSW5pdGlhbCB3IHZhbHVlLlxuICAgICAqIEByZXR1cm5zIHRoZSBjcmVhdGVkIHZlY3RvclxuICAgICAqL1xuICAgIGNvbnN0IGZyb21WYWx1ZXMgPSBjcmVhdGU7XG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgdmFsdWVzIG9mIGEgUXVhdFxuICAgICAqIEFsc28gc2VlIHtAbGluayBxdWF0LmNyZWF0ZX0gYW5kIHtAbGluayBxdWF0LmNvcHl9XG4gICAgICpcbiAgICAgKiBAcGFyYW0geCBmaXJzdCB2YWx1ZVxuICAgICAqIEBwYXJhbSB5IHNlY29uZCB2YWx1ZVxuICAgICAqIEBwYXJhbSB6IHRoaXJkIHZhbHVlXG4gICAgICogQHBhcmFtIHcgZm91cnRoIHZhbHVlXG4gICAgICogQHBhcmFtIGRzdCAtIHZlY3RvciB0byBob2xkIHJlc3VsdC4gSWYgbm90IHBhc3NlZCBpbiBhIG5ldyBvbmUgaXMgY3JlYXRlZC5cbiAgICAgKiBAcmV0dXJucyBBIHZlY3RvciB3aXRoIGl0cyBlbGVtZW50cyBzZXQuXG4gICAgICovXG4gICAgZnVuY3Rpb24gc2V0KHgsIHksIHosIHcsIGRzdCkge1xuICAgICAgICBjb25zdCBuZXdEc3QgPSAoZHN0ID8/IG5ldyBDdG9yKDQpKTtcbiAgICAgICAgbmV3RHN0WzBdID0geDtcbiAgICAgICAgbmV3RHN0WzFdID0geTtcbiAgICAgICAgbmV3RHN0WzJdID0gejtcbiAgICAgICAgbmV3RHN0WzNdID0gdztcbiAgICAgICAgcmV0dXJuIG5ld0RzdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyBhIHF1YXRlcm5pb24gZnJvbSB0aGUgZ2l2ZW4gYW5nbGUgYW5kICBheGlzLFxuICAgICAqIHRoZW4gcmV0dXJucyBpdC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBheGlzIC0gdGhlIGF4aXMgdG8gcm90YXRlIGFyb3VuZFxuICAgICAqIEBwYXJhbSBhbmdsZUluUmFkaWFucyAtIHRoZSBhbmdsZVxuICAgICAqIEBwYXJhbSBkc3QgLSBxdWF0ZXJuaW9uIHRvIGhvbGQgcmVzdWx0LiBJZiBub3QgcGFzc2VkIGluIGEgbmV3IG9uZSBpcyBjcmVhdGVkLlxuICAgICAqIEByZXR1cm5zIFRoZSBxdWF0ZXJuaW9uIHRoYXQgcmVwcmVzZW50cyB0aGUgZ2l2ZW4gYXhpcyBhbmQgYW5nbGVcbiAgICAgKiovXG4gICAgZnVuY3Rpb24gZnJvbUF4aXNBbmdsZShheGlzLCBhbmdsZUluUmFkaWFucywgZHN0KSB7XG4gICAgICAgIGNvbnN0IG5ld0RzdCA9IChkc3QgPz8gbmV3IEN0b3IoNCkpO1xuICAgICAgICBjb25zdCBoYWxmQW5nbGUgPSBhbmdsZUluUmFkaWFucyAqIDAuNTtcbiAgICAgICAgY29uc3QgcyA9IE1hdGguc2luKGhhbGZBbmdsZSk7XG4gICAgICAgIG5ld0RzdFswXSA9IHMgKiBheGlzWzBdO1xuICAgICAgICBuZXdEc3RbMV0gPSBzICogYXhpc1sxXTtcbiAgICAgICAgbmV3RHN0WzJdID0gcyAqIGF4aXNbMl07XG4gICAgICAgIG5ld0RzdFszXSA9IE1hdGguY29zKGhhbGZBbmdsZSk7XG4gICAgICAgIHJldHVybiBuZXdEc3Q7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIHJvdGF0aW9uIGF4aXMgYW5kIGFuZ2xlXG4gICAgICogQHBhcmFtIHEgLSBxdWF0ZXJuaW9uIHRvIGNvbXB1dGUgZnJvbVxuICAgICAqIEBwYXJhbSBkc3QgLSBWZWMzIHRvIGhvbGQgcmVzdWx0LiBJZiBub3QgcGFzc2VkIGluIGEgbmV3IG9uZSBpcyBjcmVhdGVkLlxuICAgICAqIEByZXR1cm4gYW5nbGUgYW5kIGF4aXNcbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0b0F4aXNBbmdsZShxLCBkc3QpIHtcbiAgICAgICAgY29uc3QgbmV3RHN0ID0gKGRzdCA/PyB2ZWMzLmNyZWF0ZSgzKSk7XG4gICAgICAgIGNvbnN0IGFuZ2xlID0gTWF0aC5hY29zKHFbM10pICogMjtcbiAgICAgICAgY29uc3QgcyA9IE1hdGguc2luKGFuZ2xlICogMC41KTtcbiAgICAgICAgaWYgKHMgPiBFUFNJTE9OKSB7XG4gICAgICAgICAgICBuZXdEc3RbMF0gPSBxWzBdIC8gcztcbiAgICAgICAgICAgIG5ld0RzdFsxXSA9IHFbMV0gLyBzO1xuICAgICAgICAgICAgbmV3RHN0WzJdID0gcVsyXSAvIHM7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBuZXdEc3RbMF0gPSAxO1xuICAgICAgICAgICAgbmV3RHN0WzFdID0gMDtcbiAgICAgICAgICAgIG5ld0RzdFsyXSA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgYW5nbGUsIGF4aXM6IG5ld0RzdCB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBhbmdsZSBpbiBkZWdyZWVzIGJldHdlZW4gdHdvIHJvdGF0aW9ucyBhIGFuZCBiLlxuICAgICAqIEBwYXJhbSBhIC0gcXVhdGVybmlvbiBhXG4gICAgICogQHBhcmFtIGIgLSBxdWF0ZXJuaW9uIGJcbiAgICAgKiBAcmV0dXJuIGFuZ2xlIGluIHJhZGlhbnMgYmV0d2VlbiB0aGUgdHdvIHF1YXRlcm5pb25zXG4gICAgICovXG4gICAgZnVuY3Rpb24gYW5nbGUoYSwgYikge1xuICAgICAgICBjb25zdCBkID0gZG90KGEsIGIpO1xuICAgICAgICByZXR1cm4gTWF0aC5hY29zKDIgKiBkICogZCAtIDEpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBNdWx0aXBsaWVzIHR3byBxdWF0ZXJuaW9uc1xuICAgICAqXG4gICAgICogQHBhcmFtIGEgLSB0aGUgZmlyc3QgcXVhdGVybmlvblxuICAgICAqIEBwYXJhbSBiIC0gdGhlIHNlY29uZCBxdWF0ZXJuaW9uXG4gICAgICogQHBhcmFtIGRzdCAtIHF1YXRlcm5pb24gdG8gaG9sZCByZXN1bHQuIElmIG5vdCBwYXNzZWQgaW4gYSBuZXcgb25lIGlzIGNyZWF0ZWQuXG4gICAgICogQHJldHVybnMgQSBxdWF0ZXJuaW9uIHRoYXQgaXMgdGhlIHJlc3VsdCBvZiBhICogYlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG11bHRpcGx5KGEsIGIsIGRzdCkge1xuICAgICAgICBjb25zdCBuZXdEc3QgPSAoZHN0ID8/IG5ldyBDdG9yKDQpKTtcbiAgICAgICAgY29uc3QgYXggPSBhWzBdO1xuICAgICAgICBjb25zdCBheSA9IGFbMV07XG4gICAgICAgIGNvbnN0IGF6ID0gYVsyXTtcbiAgICAgICAgY29uc3QgYXcgPSBhWzNdO1xuICAgICAgICBjb25zdCBieCA9IGJbMF07XG4gICAgICAgIGNvbnN0IGJ5ID0gYlsxXTtcbiAgICAgICAgY29uc3QgYnogPSBiWzJdO1xuICAgICAgICBjb25zdCBidyA9IGJbM107XG4gICAgICAgIG5ld0RzdFswXSA9IGF4ICogYncgKyBhdyAqIGJ4ICsgYXkgKiBieiAtIGF6ICogYnk7XG4gICAgICAgIG5ld0RzdFsxXSA9IGF5ICogYncgKyBhdyAqIGJ5ICsgYXogKiBieCAtIGF4ICogYno7XG4gICAgICAgIG5ld0RzdFsyXSA9IGF6ICogYncgKyBhdyAqIGJ6ICsgYXggKiBieSAtIGF5ICogYng7XG4gICAgICAgIG5ld0RzdFszXSA9IGF3ICogYncgLSBheCAqIGJ4IC0gYXkgKiBieSAtIGF6ICogYno7XG4gICAgICAgIHJldHVybiBuZXdEc3Q7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE11bHRpcGxpZXMgdHdvIHF1YXRlcm5pb25zXG4gICAgICpcbiAgICAgKiBAcGFyYW0gYSAtIHRoZSBmaXJzdCBxdWF0ZXJuaW9uXG4gICAgICogQHBhcmFtIGIgLSB0aGUgc2Vjb25kIHF1YXRlcm5pb25cbiAgICAgKiBAcGFyYW0gZHN0IC0gcXVhdGVybmlvbiB0byBob2xkIHJlc3VsdC4gSWYgbm90IHBhc3NlZCBpbiBhIG5ldyBvbmUgaXMgY3JlYXRlZC5cbiAgICAgKiBAcmV0dXJucyBBIHF1YXRlcm5pb24gdGhhdCBpcyB0aGUgcmVzdWx0IG9mIGEgKiBiXG4gICAgICovXG4gICAgY29uc3QgbXVsID0gbXVsdGlwbHk7XG4gICAgLyoqXG4gICAgICogUm90YXRlcyB0aGUgZ2l2ZW4gcXVhdGVybmlvbiBhcm91bmQgdGhlIFggYXhpcyBieSB0aGUgZ2l2ZW4gYW5nbGUuXG4gICAgICogQHBhcmFtIHEgLSBxdWF0ZXJuaW9uIHRvIHJvdGF0ZVxuICAgICAqIEBwYXJhbSBhbmdsZUluUmFkaWFucyAtIFRoZSBhbmdsZSBieSB3aGljaCB0byByb3RhdGVcbiAgICAgKiBAcGFyYW0gZHN0IC0gcXVhdGVybmlvbiB0byBob2xkIHJlc3VsdC4gSWYgbm90IHBhc3NlZCBpbiBhIG5ldyBvbmUgaXMgY3JlYXRlZC5cbiAgICAgKiBAcmV0dXJucyBBIHF1YXRlcm5pb24gdGhhdCBpcyB0aGUgcmVzdWx0IG9mIGEgKiBiXG4gICAgICovXG4gICAgZnVuY3Rpb24gcm90YXRlWChxLCBhbmdsZUluUmFkaWFucywgZHN0KSB7XG4gICAgICAgIGNvbnN0IG5ld0RzdCA9IChkc3QgPz8gbmV3IEN0b3IoNCkpO1xuICAgICAgICBjb25zdCBoYWxmQW5nbGUgPSBhbmdsZUluUmFkaWFucyAqIDAuNTtcbiAgICAgICAgY29uc3QgcXggPSBxWzBdO1xuICAgICAgICBjb25zdCBxeSA9IHFbMV07XG4gICAgICAgIGNvbnN0IHF6ID0gcVsyXTtcbiAgICAgICAgY29uc3QgcXcgPSBxWzNdO1xuICAgICAgICBjb25zdCBieCA9IE1hdGguc2luKGhhbGZBbmdsZSk7XG4gICAgICAgIGNvbnN0IGJ3ID0gTWF0aC5jb3MoaGFsZkFuZ2xlKTtcbiAgICAgICAgbmV3RHN0WzBdID0gcXggKiBidyArIHF3ICogYng7XG4gICAgICAgIG5ld0RzdFsxXSA9IHF5ICogYncgKyBxeiAqIGJ4O1xuICAgICAgICBuZXdEc3RbMl0gPSBxeiAqIGJ3IC0gcXkgKiBieDtcbiAgICAgICAgbmV3RHN0WzNdID0gcXcgKiBidyAtIHF4ICogYng7XG4gICAgICAgIHJldHVybiBuZXdEc3Q7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJvdGF0ZXMgdGhlIGdpdmVuIHF1YXRlcm5pb24gYXJvdW5kIHRoZSBZIGF4aXMgYnkgdGhlIGdpdmVuIGFuZ2xlLlxuICAgICAqIEBwYXJhbSBxIC0gcXVhdGVybmlvbiB0byByb3RhdGVcbiAgICAgKiBAcGFyYW0gYW5nbGVJblJhZGlhbnMgLSBUaGUgYW5nbGUgYnkgd2hpY2ggdG8gcm90YXRlXG4gICAgICogQHBhcmFtIGRzdCAtIHF1YXRlcm5pb24gdG8gaG9sZCByZXN1bHQuIElmIG5vdCBwYXNzZWQgaW4gYSBuZXcgb25lIGlzIGNyZWF0ZWQuXG4gICAgICogQHJldHVybnMgQSBxdWF0ZXJuaW9uIHRoYXQgaXMgdGhlIHJlc3VsdCBvZiBhICogYlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHJvdGF0ZVkocSwgYW5nbGVJblJhZGlhbnMsIGRzdCkge1xuICAgICAgICBjb25zdCBuZXdEc3QgPSAoZHN0ID8/IG5ldyBDdG9yKDQpKTtcbiAgICAgICAgY29uc3QgaGFsZkFuZ2xlID0gYW5nbGVJblJhZGlhbnMgKiAwLjU7XG4gICAgICAgIGNvbnN0IHF4ID0gcVswXTtcbiAgICAgICAgY29uc3QgcXkgPSBxWzFdO1xuICAgICAgICBjb25zdCBxeiA9IHFbMl07XG4gICAgICAgIGNvbnN0IHF3ID0gcVszXTtcbiAgICAgICAgY29uc3QgYnkgPSBNYXRoLnNpbihoYWxmQW5nbGUpO1xuICAgICAgICBjb25zdCBidyA9IE1hdGguY29zKGhhbGZBbmdsZSk7XG4gICAgICAgIG5ld0RzdFswXSA9IHF4ICogYncgLSBxeiAqIGJ5O1xuICAgICAgICBuZXdEc3RbMV0gPSBxeSAqIGJ3ICsgcXcgKiBieTtcbiAgICAgICAgbmV3RHN0WzJdID0gcXogKiBidyArIHF4ICogYnk7XG4gICAgICAgIG5ld0RzdFszXSA9IHF3ICogYncgLSBxeSAqIGJ5O1xuICAgICAgICByZXR1cm4gbmV3RHN0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSb3RhdGVzIHRoZSBnaXZlbiBxdWF0ZXJuaW9uIGFyb3VuZCB0aGUgWiBheGlzIGJ5IHRoZSBnaXZlbiBhbmdsZS5cbiAgICAgKiBAcGFyYW0gcSAtIHF1YXRlcm5pb24gdG8gcm90YXRlXG4gICAgICogQHBhcmFtIGFuZ2xlSW5SYWRpYW5zIC0gVGhlIGFuZ2xlIGJ5IHdoaWNoIHRvIHJvdGF0ZVxuICAgICAqIEBwYXJhbSBkc3QgLSBxdWF0ZXJuaW9uIHRvIGhvbGQgcmVzdWx0LiBJZiBub3QgcGFzc2VkIGluIGEgbmV3IG9uZSBpcyBjcmVhdGVkLlxuICAgICAqIEByZXR1cm5zIEEgcXVhdGVybmlvbiB0aGF0IGlzIHRoZSByZXN1bHQgb2YgYSAqIGJcbiAgICAgKi9cbiAgICBmdW5jdGlvbiByb3RhdGVaKHEsIGFuZ2xlSW5SYWRpYW5zLCBkc3QpIHtcbiAgICAgICAgY29uc3QgbmV3RHN0ID0gKGRzdCA/PyBuZXcgQ3Rvcig0KSk7XG4gICAgICAgIGNvbnN0IGhhbGZBbmdsZSA9IGFuZ2xlSW5SYWRpYW5zICogMC41O1xuICAgICAgICBjb25zdCBxeCA9IHFbMF07XG4gICAgICAgIGNvbnN0IHF5ID0gcVsxXTtcbiAgICAgICAgY29uc3QgcXogPSBxWzJdO1xuICAgICAgICBjb25zdCBxdyA9IHFbM107XG4gICAgICAgIGNvbnN0IGJ6ID0gTWF0aC5zaW4oaGFsZkFuZ2xlKTtcbiAgICAgICAgY29uc3QgYncgPSBNYXRoLmNvcyhoYWxmQW5nbGUpO1xuICAgICAgICBuZXdEc3RbMF0gPSBxeCAqIGJ3ICsgcXkgKiBiejtcbiAgICAgICAgbmV3RHN0WzFdID0gcXkgKiBidyAtIHF4ICogYno7XG4gICAgICAgIG5ld0RzdFsyXSA9IHF6ICogYncgKyBxdyAqIGJ6O1xuICAgICAgICBuZXdEc3RbM10gPSBxdyAqIGJ3IC0gcXogKiBiejtcbiAgICAgICAgcmV0dXJuIG5ld0RzdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU3BoZXJpY2FsbHkgbGluZWFyIGludGVycG9sYXRlIGJldHdlZW4gdHdvIHF1YXRlcm5pb25zXG4gICAgICpcbiAgICAgKiBAcGFyYW0gYSAtIHN0YXJ0aW5nIHZhbHVlXG4gICAgICogQHBhcmFtIGIgLSBlbmRpbmcgdmFsdWVcbiAgICAgKiBAcGFyYW0gdCAtIHZhbHVlIHdoZXJlIDAgPSBhIGFuZCAxID0gYlxuICAgICAqIEBwYXJhbSBkc3QgLSBxdWF0ZXJuaW9uIHRvIGhvbGQgcmVzdWx0LiBJZiBub3QgcGFzc2VkIGluIGEgbmV3IG9uZSBpcyBjcmVhdGVkLlxuICAgICAqIEByZXR1cm5zIEEgcXVhdGVybmlvbiB0aGF0IGlzIHRoZSByZXN1bHQgb2YgYSAqIGJcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzbGVycChhLCBiLCB0LCBkc3QpIHtcbiAgICAgICAgY29uc3QgbmV3RHN0ID0gKGRzdCA/PyBuZXcgQ3Rvcig0KSk7XG4gICAgICAgIGNvbnN0IGF4ID0gYVswXTtcbiAgICAgICAgY29uc3QgYXkgPSBhWzFdO1xuICAgICAgICBjb25zdCBheiA9IGFbMl07XG4gICAgICAgIGNvbnN0IGF3ID0gYVszXTtcbiAgICAgICAgbGV0IGJ4ID0gYlswXTtcbiAgICAgICAgbGV0IGJ5ID0gYlsxXTtcbiAgICAgICAgbGV0IGJ6ID0gYlsyXTtcbiAgICAgICAgbGV0IGJ3ID0gYlszXTtcbiAgICAgICAgbGV0IGNvc09tZWdhID0gYXggKiBieCArIGF5ICogYnkgKyBheiAqIGJ6ICsgYXcgKiBidztcbiAgICAgICAgaWYgKGNvc09tZWdhIDwgMCkge1xuICAgICAgICAgICAgY29zT21lZ2EgPSAtY29zT21lZ2E7XG4gICAgICAgICAgICBieCA9IC1ieDtcbiAgICAgICAgICAgIGJ5ID0gLWJ5O1xuICAgICAgICAgICAgYnogPSAtYno7XG4gICAgICAgICAgICBidyA9IC1idztcbiAgICAgICAgfVxuICAgICAgICBsZXQgc2NhbGUwO1xuICAgICAgICBsZXQgc2NhbGUxO1xuICAgICAgICBpZiAoMS4wIC0gY29zT21lZ2EgPiBFUFNJTE9OKSB7XG4gICAgICAgICAgICBjb25zdCBvbWVnYSA9IE1hdGguYWNvcyhjb3NPbWVnYSk7XG4gICAgICAgICAgICBjb25zdCBzaW5PbWVnYSA9IE1hdGguc2luKG9tZWdhKTtcbiAgICAgICAgICAgIHNjYWxlMCA9IE1hdGguc2luKCgxIC0gdCkgKiBvbWVnYSkgLyBzaW5PbWVnYTtcbiAgICAgICAgICAgIHNjYWxlMSA9IE1hdGguc2luKHQgKiBvbWVnYSkgLyBzaW5PbWVnYTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHNjYWxlMCA9IDEuMCAtIHQ7XG4gICAgICAgICAgICBzY2FsZTEgPSB0O1xuICAgICAgICB9XG4gICAgICAgIG5ld0RzdFswXSA9IHNjYWxlMCAqIGF4ICsgc2NhbGUxICogYng7XG4gICAgICAgIG5ld0RzdFsxXSA9IHNjYWxlMCAqIGF5ICsgc2NhbGUxICogYnk7XG4gICAgICAgIG5ld0RzdFsyXSA9IHNjYWxlMCAqIGF6ICsgc2NhbGUxICogYno7XG4gICAgICAgIG5ld0RzdFszXSA9IHNjYWxlMCAqIGF3ICsgc2NhbGUxICogYnc7XG4gICAgICAgIHJldHVybiBuZXdEc3Q7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbXB1dGUgdGhlIGludmVyc2Ugb2YgYSBxdWF0ZXJuaW9uXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcSAtIHF1YXRlcm5pb24gdG8gY29tcHV0ZSB0aGUgaW52ZXJzZSBvZlxuICAgICAqIEByZXR1cm5zIEEgcXVhdGVybmlvbiB0aGF0IGlzIHRoZSByZXN1bHQgb2YgYSAqIGJcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpbnZlcnNlKHEsIGRzdCkge1xuICAgICAgICBjb25zdCBuZXdEc3QgPSAoZHN0ID8/IG5ldyBDdG9yKDQpKTtcbiAgICAgICAgY29uc3QgYTAgPSBxWzBdO1xuICAgICAgICBjb25zdCBhMSA9IHFbMV07XG4gICAgICAgIGNvbnN0IGEyID0gcVsyXTtcbiAgICAgICAgY29uc3QgYTMgPSBxWzNdO1xuICAgICAgICBjb25zdCBkb3QgPSBhMCAqIGEwICsgYTEgKiBhMSArIGEyICogYTIgKyBhMyAqIGEzO1xuICAgICAgICBjb25zdCBpbnZEb3QgPSBkb3QgPyAxIC8gZG90IDogMDtcbiAgICAgICAgbmV3RHN0WzBdID0gLWEwICogaW52RG90O1xuICAgICAgICBuZXdEc3RbMV0gPSAtYTEgKiBpbnZEb3Q7XG4gICAgICAgIG5ld0RzdFsyXSA9IC1hMiAqIGludkRvdDtcbiAgICAgICAgbmV3RHN0WzNdID0gYTMgKiBpbnZEb3Q7XG4gICAgICAgIHJldHVybiBuZXdEc3Q7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbXB1dGUgdGhlIGNvbmp1Z2F0ZSBvZiBhIHF1YXRlcm5pb25cbiAgICAgKiBGb3IgcXVhdGVybmlvbnMgd2l0aCBhIG1hZ25pdHVkZSBvZiAxIChhIHVuaXQgcXVhdGVybmlvbilcbiAgICAgKiB0aGlzIHJldHVybnMgdGhlIHNhbWUgYXMgdGhlIGludmVyc2UgYnV0IGlzIGZhc3RlciB0byBjYWxjdWxhdGUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcSAtIHF1YXRlcm5pb24gdG8gY29tcHV0ZSB0aGUgY29uanVnYXRlIG9mLlxuICAgICAqIEBwYXJhbSBkc3QgLSBxdWF0ZXJuaW9uIHRvIGhvbGQgcmVzdWx0LiBJZiBub3QgcGFzc2VkIGluIGEgbmV3IG9uZSBpcyBjcmVhdGVkLlxuICAgICAqIEByZXR1cm5zIFRoZSBjb25qdWdhdGUgb2YgcVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNvbmp1Z2F0ZShxLCBkc3QpIHtcbiAgICAgICAgY29uc3QgbmV3RHN0ID0gKGRzdCA/PyBuZXcgQ3Rvcig0KSk7XG4gICAgICAgIG5ld0RzdFswXSA9IC1xWzBdO1xuICAgICAgICBuZXdEc3RbMV0gPSAtcVsxXTtcbiAgICAgICAgbmV3RHN0WzJdID0gLXFbMl07XG4gICAgICAgIG5ld0RzdFszXSA9IHFbM107XG4gICAgICAgIHJldHVybiBuZXdEc3Q7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBxdWF0ZXJuaW9uIGZyb20gdGhlIGdpdmVuIHJvdGF0aW9uIG1hdHJpeC5cbiAgICAgKlxuICAgICAqIFRoZSBjcmVhdGVkIHF1YXRlcm5pb24gaXMgbm90IG5vcm1hbGl6ZWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gbSAtIHJvdGF0aW9uIG1hdHJpeFxuICAgICAqIEBwYXJhbSBkc3QgLSBxdWF0ZXJuaW9uIHRvIGhvbGQgcmVzdWx0LiBJZiBub3QgcGFzc2VkIGluIGEgbmV3IG9uZSBpcyBjcmVhdGVkLlxuICAgICAqIEByZXR1cm5zIHRoZSByZXN1bHRcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmcm9tTWF0KG0sIGRzdCkge1xuICAgICAgICBjb25zdCBuZXdEc3QgPSAoZHN0ID8/IG5ldyBDdG9yKDQpKTtcbiAgICAgICAgLypcbiAgICAgICAgMCAxIDJcbiAgICAgICAgMyA0IDVcbiAgICAgICAgNiA3IDhcbiAgICAgIFxuICAgICAgICAwIDEgMlxuICAgICAgICA0IDUgNlxuICAgICAgICA4IDkgMTBcbiAgICAgICAgICovXG4gICAgICAgIC8vIEFsZ29yaXRobSBpbiBLZW4gU2hvZW1ha2UncyBhcnRpY2xlIGluIDE5ODcgU0lHR1JBUEggY291cnNlIG5vdGVzXG4gICAgICAgIC8vIGFydGljbGUgXCJRdWF0ZXJuaW9uIENhbGN1bHVzIGFuZCBGYXN0IEFuaW1hdGlvblwiLlxuICAgICAgICBjb25zdCB0cmFjZSA9IG1bMF0gKyBtWzVdICsgbVsxMF07XG4gICAgICAgIGlmICh0cmFjZSA+IDAuMCkge1xuICAgICAgICAgICAgLy8gfHd8ID4gMS8yLCBtYXkgYXMgd2VsbCBjaG9vc2UgdyA+IDEvMlxuICAgICAgICAgICAgY29uc3Qgcm9vdCA9IE1hdGguc3FydCh0cmFjZSArIDEpOyAvLyAyd1xuICAgICAgICAgICAgbmV3RHN0WzNdID0gMC41ICogcm9vdDtcbiAgICAgICAgICAgIGNvbnN0IGludlJvb3QgPSAwLjUgLyByb290OyAvLyAxLyg0dylcbiAgICAgICAgICAgIG5ld0RzdFswXSA9IChtWzZdIC0gbVs5XSkgKiBpbnZSb290O1xuICAgICAgICAgICAgbmV3RHN0WzFdID0gKG1bOF0gLSBtWzJdKSAqIGludlJvb3Q7XG4gICAgICAgICAgICBuZXdEc3RbMl0gPSAobVsxXSAtIG1bNF0pICogaW52Um9vdDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIHx3fCA8PSAxLzJcbiAgICAgICAgICAgIGxldCBpID0gMDtcbiAgICAgICAgICAgIGlmIChtWzVdID4gbVswXSkge1xuICAgICAgICAgICAgICAgIGkgPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1bMTBdID4gbVtpICogNCArIGldKSB7XG4gICAgICAgICAgICAgICAgaSA9IDI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBqID0gKGkgKyAxKSAlIDM7XG4gICAgICAgICAgICBjb25zdCBrID0gKGkgKyAyKSAlIDM7XG4gICAgICAgICAgICBjb25zdCByb290ID0gTWF0aC5zcXJ0KG1baSAqIDQgKyBpXSAtIG1baiAqIDQgKyBqXSAtIG1bayAqIDQgKyBrXSArIDEuMCk7XG4gICAgICAgICAgICBuZXdEc3RbaV0gPSAwLjUgKiByb290O1xuICAgICAgICAgICAgY29uc3QgaW52Um9vdCA9IDAuNSAvIHJvb3Q7XG4gICAgICAgICAgICBuZXdEc3RbM10gPSAobVtqICogNCArIGtdIC0gbVtrICogNCArIGpdKSAqIGludlJvb3Q7XG4gICAgICAgICAgICBuZXdEc3Rbal0gPSAobVtqICogNCArIGldICsgbVtpICogNCArIGpdKSAqIGludlJvb3Q7XG4gICAgICAgICAgICBuZXdEc3Rba10gPSAobVtrICogNCArIGldICsgbVtpICogNCArIGtdKSAqIGludlJvb3Q7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ld0RzdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIHF1YXRlcm5pb24gZnJvbSB0aGUgZ2l2ZW4gZXVsZXIgYW5nbGUgeCwgeSwgeiB1c2luZyB0aGUgcHJvdmlkZWQgaW50cmluc2ljIG9yZGVyIGZvciB0aGUgY29udmVyc2lvbi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB4QW5nbGVJblJhZGlhbnMgLSBhbmdsZSB0byByb3RhdGUgYXJvdW5kIFggYXhpcyBpbiByYWRpYW5zLlxuICAgICAqIEBwYXJhbSB5QW5nbGVJblJhZGlhbnMgLSBhbmdsZSB0byByb3RhdGUgYXJvdW5kIFkgYXhpcyBpbiByYWRpYW5zLlxuICAgICAqIEBwYXJhbSB6QW5nbGVJblJhZGlhbnMgLSBhbmdsZSB0byByb3RhdGUgYXJvdW5kIFogYXhpcyBpbiByYWRpYW5zLlxuICAgICAqIEBwYXJhbSBvcmRlciAtIG9yZGVyIHRvIGFwcGx5IGV1bGVyIGFuZ2xlc1xuICAgICAqIEBwYXJhbSBkc3QgLSBxdWF0ZXJuaW9uIHRvIGhvbGQgcmVzdWx0LiBJZiBub3QgcGFzc2VkIGluIGEgbmV3IG9uZSBpcyBjcmVhdGVkLlxuICAgICAqIEByZXR1cm5zIEEgcXVhdGVybmlvbiByZXByZXNlbnRpbmcgdGhlIHNhbWUgcm90YXRpb24gYXMgdGhlIGV1bGVyIGFuZ2xlcyBhcHBsaWVkIGluIHRoZSBnaXZlbiBvcmRlclxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZyb21FdWxlcih4QW5nbGVJblJhZGlhbnMsIHlBbmdsZUluUmFkaWFucywgekFuZ2xlSW5SYWRpYW5zLCBvcmRlciwgZHN0KSB7XG4gICAgICAgIGNvbnN0IG5ld0RzdCA9IChkc3QgPz8gbmV3IEN0b3IoNCkpO1xuICAgICAgICBjb25zdCB4SGFsZkFuZ2xlID0geEFuZ2xlSW5SYWRpYW5zICogMC41O1xuICAgICAgICBjb25zdCB5SGFsZkFuZ2xlID0geUFuZ2xlSW5SYWRpYW5zICogMC41O1xuICAgICAgICBjb25zdCB6SGFsZkFuZ2xlID0gekFuZ2xlSW5SYWRpYW5zICogMC41O1xuICAgICAgICBjb25zdCBzeCA9IE1hdGguc2luKHhIYWxmQW5nbGUpO1xuICAgICAgICBjb25zdCBjeCA9IE1hdGguY29zKHhIYWxmQW5nbGUpO1xuICAgICAgICBjb25zdCBzeSA9IE1hdGguc2luKHlIYWxmQW5nbGUpO1xuICAgICAgICBjb25zdCBjeSA9IE1hdGguY29zKHlIYWxmQW5nbGUpO1xuICAgICAgICBjb25zdCBzeiA9IE1hdGguc2luKHpIYWxmQW5nbGUpO1xuICAgICAgICBjb25zdCBjeiA9IE1hdGguY29zKHpIYWxmQW5nbGUpO1xuICAgICAgICBzd2l0Y2ggKG9yZGVyKSB7XG4gICAgICAgICAgICBjYXNlICd4eXonOlxuICAgICAgICAgICAgICAgIG5ld0RzdFswXSA9IHN4ICogY3kgKiBjeiArIGN4ICogc3kgKiBzejtcbiAgICAgICAgICAgICAgICBuZXdEc3RbMV0gPSBjeCAqIHN5ICogY3ogLSBzeCAqIGN5ICogc3o7XG4gICAgICAgICAgICAgICAgbmV3RHN0WzJdID0gY3ggKiBjeSAqIHN6ICsgc3ggKiBzeSAqIGN6O1xuICAgICAgICAgICAgICAgIG5ld0RzdFszXSA9IGN4ICogY3kgKiBjeiAtIHN4ICogc3kgKiBzejtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ3h6eSc6XG4gICAgICAgICAgICAgICAgbmV3RHN0WzBdID0gc3ggKiBjeSAqIGN6IC0gY3ggKiBzeSAqIHN6O1xuICAgICAgICAgICAgICAgIG5ld0RzdFsxXSA9IGN4ICogc3kgKiBjeiAtIHN4ICogY3kgKiBzejtcbiAgICAgICAgICAgICAgICBuZXdEc3RbMl0gPSBjeCAqIGN5ICogc3ogKyBzeCAqIHN5ICogY3o7XG4gICAgICAgICAgICAgICAgbmV3RHN0WzNdID0gY3ggKiBjeSAqIGN6ICsgc3ggKiBzeSAqIHN6O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAneXh6JzpcbiAgICAgICAgICAgICAgICBuZXdEc3RbMF0gPSBzeCAqIGN5ICogY3ogKyBjeCAqIHN5ICogc3o7XG4gICAgICAgICAgICAgICAgbmV3RHN0WzFdID0gY3ggKiBzeSAqIGN6IC0gc3ggKiBjeSAqIHN6O1xuICAgICAgICAgICAgICAgIG5ld0RzdFsyXSA9IGN4ICogY3kgKiBzeiAtIHN4ICogc3kgKiBjejtcbiAgICAgICAgICAgICAgICBuZXdEc3RbM10gPSBjeCAqIGN5ICogY3ogKyBzeCAqIHN5ICogc3o7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICd5engnOlxuICAgICAgICAgICAgICAgIG5ld0RzdFswXSA9IHN4ICogY3kgKiBjeiArIGN4ICogc3kgKiBzejtcbiAgICAgICAgICAgICAgICBuZXdEc3RbMV0gPSBjeCAqIHN5ICogY3ogKyBzeCAqIGN5ICogc3o7XG4gICAgICAgICAgICAgICAgbmV3RHN0WzJdID0gY3ggKiBjeSAqIHN6IC0gc3ggKiBzeSAqIGN6O1xuICAgICAgICAgICAgICAgIG5ld0RzdFszXSA9IGN4ICogY3kgKiBjeiAtIHN4ICogc3kgKiBzejtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ3p4eSc6XG4gICAgICAgICAgICAgICAgbmV3RHN0WzBdID0gc3ggKiBjeSAqIGN6IC0gY3ggKiBzeSAqIHN6O1xuICAgICAgICAgICAgICAgIG5ld0RzdFsxXSA9IGN4ICogc3kgKiBjeiArIHN4ICogY3kgKiBzejtcbiAgICAgICAgICAgICAgICBuZXdEc3RbMl0gPSBjeCAqIGN5ICogc3ogKyBzeCAqIHN5ICogY3o7XG4gICAgICAgICAgICAgICAgbmV3RHN0WzNdID0gY3ggKiBjeSAqIGN6IC0gc3ggKiBzeSAqIHN6O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnenl4JzpcbiAgICAgICAgICAgICAgICBuZXdEc3RbMF0gPSBzeCAqIGN5ICogY3ogLSBjeCAqIHN5ICogc3o7XG4gICAgICAgICAgICAgICAgbmV3RHN0WzFdID0gY3ggKiBzeSAqIGN6ICsgc3ggKiBjeSAqIHN6O1xuICAgICAgICAgICAgICAgIG5ld0RzdFsyXSA9IGN4ICogY3kgKiBzeiAtIHN4ICogc3kgKiBjejtcbiAgICAgICAgICAgICAgICBuZXdEc3RbM10gPSBjeCAqIGN5ICogY3ogKyBzeCAqIHN5ICogc3o7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5rbm93biByb3RhdGlvbiBvcmRlcjogJHtvcmRlcn1gKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3RHN0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb3BpZXMgYSBxdWF0ZXJuaW9uLiAoc2FtZSBhcyB7QGxpbmsgcXVhdC5jbG9uZX0pXG4gICAgICogQWxzbyBzZWUge0BsaW5rIHF1YXQuY3JlYXRlfSBhbmQge0BsaW5rIHF1YXQuc2V0fVxuICAgICAqIEBwYXJhbSBxIC0gVGhlIHF1YXRlcm5pb24uXG4gICAgICogQHBhcmFtIGRzdCAtIHF1YXRlcm5pb24gdG8gaG9sZCByZXN1bHQuIElmIG5vdCBwYXNzZWQgaW4gYSBuZXcgb25lIGlzIGNyZWF0ZWQuXG4gICAgICogQHJldHVybnMgQSBxdWF0ZXJuaW9uIHRoYXQgaXMgYSBjb3B5IG9mIHFcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjb3B5KHEsIGRzdCkge1xuICAgICAgICBjb25zdCBuZXdEc3QgPSAoZHN0ID8/IG5ldyBDdG9yKDQpKTtcbiAgICAgICAgbmV3RHN0WzBdID0gcVswXTtcbiAgICAgICAgbmV3RHN0WzFdID0gcVsxXTtcbiAgICAgICAgbmV3RHN0WzJdID0gcVsyXTtcbiAgICAgICAgbmV3RHN0WzNdID0gcVszXTtcbiAgICAgICAgcmV0dXJuIG5ld0RzdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2xvbmVzIGEgcXVhdGVybmlvbi4gKHNhbWUgYXMge0BsaW5rIHF1YXQuY29weX0pXG4gICAgICogQWxzbyBzZWUge0BsaW5rIHF1YXQuY3JlYXRlfSBhbmQge0BsaW5rIHF1YXQuc2V0fVxuICAgICAqIEBwYXJhbSBxIC0gVGhlIHF1YXRlcm5pb24uXG4gICAgICogQHBhcmFtIGRzdCAtIHF1YXRlcm5pb24gdG8gaG9sZCByZXN1bHQuIElmIG5vdCBwYXNzZWQgaW4gYSBuZXcgb25lIGlzIGNyZWF0ZWQuXG4gICAgICogQHJldHVybnMgQSBjb3B5IG9mIHEuXG4gICAgICovXG4gICAgY29uc3QgY2xvbmUgPSBjb3B5O1xuICAgIC8qKlxuICAgICAqIEFkZHMgdHdvIHF1YXRlcm5pb25zOyBhc3N1bWVzIGEgYW5kIGIgaGF2ZSB0aGUgc2FtZSBkaW1lbnNpb24uXG4gICAgICogQHBhcmFtIGEgLSBPcGVyYW5kIHF1YXRlcm5pb24uXG4gICAgICogQHBhcmFtIGIgLSBPcGVyYW5kIHF1YXRlcm5pb24uXG4gICAgICogQHBhcmFtIGRzdCAtIHF1YXRlcm5pb24gdG8gaG9sZCByZXN1bHQuIElmIG5vdCBwYXNzZWQgaW4gYSBuZXcgb25lIGlzIGNyZWF0ZWQuXG4gICAgICogQHJldHVybnMgQSBxdWF0ZXJuaW9uIHRoYXQgaXMgdGhlIHN1bSBvZiBhIGFuZCBiLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGFkZChhLCBiLCBkc3QpIHtcbiAgICAgICAgY29uc3QgbmV3RHN0ID0gKGRzdCA/PyBuZXcgQ3Rvcig0KSk7XG4gICAgICAgIG5ld0RzdFswXSA9IGFbMF0gKyBiWzBdO1xuICAgICAgICBuZXdEc3RbMV0gPSBhWzFdICsgYlsxXTtcbiAgICAgICAgbmV3RHN0WzJdID0gYVsyXSArIGJbMl07XG4gICAgICAgIG5ld0RzdFszXSA9IGFbM10gKyBiWzNdO1xuICAgICAgICByZXR1cm4gbmV3RHN0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTdWJ0cmFjdHMgdHdvIHF1YXRlcm5pb25zLlxuICAgICAqIEBwYXJhbSBhIC0gT3BlcmFuZCBxdWF0ZXJuaW9uLlxuICAgICAqIEBwYXJhbSBiIC0gT3BlcmFuZCBxdWF0ZXJuaW9uLlxuICAgICAqIEBwYXJhbSBkc3QgLSBxdWF0ZXJuaW9uIHRvIGhvbGQgcmVzdWx0LiBJZiBub3QgcGFzc2VkIGluIGEgbmV3IG9uZSBpcyBjcmVhdGVkLlxuICAgICAqIEByZXR1cm5zIEEgcXVhdGVybmlvbiB0aGF0IGlzIHRoZSBkaWZmZXJlbmNlIG9mIGEgYW5kIGIuXG4gICAgICovXG4gICAgZnVuY3Rpb24gc3VidHJhY3QoYSwgYiwgZHN0KSB7XG4gICAgICAgIGNvbnN0IG5ld0RzdCA9IChkc3QgPz8gbmV3IEN0b3IoNCkpO1xuICAgICAgICBuZXdEc3RbMF0gPSBhWzBdIC0gYlswXTtcbiAgICAgICAgbmV3RHN0WzFdID0gYVsxXSAtIGJbMV07XG4gICAgICAgIG5ld0RzdFsyXSA9IGFbMl0gLSBiWzJdO1xuICAgICAgICBuZXdEc3RbM10gPSBhWzNdIC0gYlszXTtcbiAgICAgICAgcmV0dXJuIG5ld0RzdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU3VidHJhY3RzIHR3byBxdWF0ZXJuaW9ucy5cbiAgICAgKiBAcGFyYW0gYSAtIE9wZXJhbmQgcXVhdGVybmlvbi5cbiAgICAgKiBAcGFyYW0gYiAtIE9wZXJhbmQgcXVhdGVybmlvbi5cbiAgICAgKiBAcGFyYW0gZHN0IC0gcXVhdGVybmlvbiB0byBob2xkIHJlc3VsdC4gSWYgbm90IHBhc3NlZCBpbiBhIG5ldyBvbmUgaXMgY3JlYXRlZC5cbiAgICAgKiBAcmV0dXJucyBBIHF1YXRlcm5pb24gdGhhdCBpcyB0aGUgZGlmZmVyZW5jZSBvZiBhIGFuZCBiLlxuICAgICAqL1xuICAgIGNvbnN0IHN1YiA9IHN1YnRyYWN0O1xuICAgIC8qKlxuICAgICAqIE11bHRpcGxpZXMgYSBxdWF0ZXJuaW9uIGJ5IGEgc2NhbGFyLlxuICAgICAqIEBwYXJhbSB2IC0gVGhlIHF1YXRlcm5pb24uXG4gICAgICogQHBhcmFtIGsgLSBUaGUgc2NhbGFyLlxuICAgICAqIEBwYXJhbSBkc3QgLSBxdWF0ZXJuaW9uIHRvIGhvbGQgcmVzdWx0LiBJZiBub3QgcGFzc2VkIGluIGEgbmV3IG9uZSBpcyBjcmVhdGVkLlxuICAgICAqIEByZXR1cm5zIFRoZSBzY2FsZWQgcXVhdGVybmlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBtdWxTY2FsYXIodiwgaywgZHN0KSB7XG4gICAgICAgIGNvbnN0IG5ld0RzdCA9IChkc3QgPz8gbmV3IEN0b3IoNCkpO1xuICAgICAgICBuZXdEc3RbMF0gPSB2WzBdICogaztcbiAgICAgICAgbmV3RHN0WzFdID0gdlsxXSAqIGs7XG4gICAgICAgIG5ld0RzdFsyXSA9IHZbMl0gKiBrO1xuICAgICAgICBuZXdEc3RbM10gPSB2WzNdICogaztcbiAgICAgICAgcmV0dXJuIG5ld0RzdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTXVsdGlwbGllcyBhIHF1YXRlcm5pb24gYnkgYSBzY2FsYXIuIChzYW1lIGFzIG11bFNjYWxhcilcbiAgICAgKiBAcGFyYW0gdiAtIFRoZSBxdWF0ZXJuaW9uLlxuICAgICAqIEBwYXJhbSBrIC0gVGhlIHNjYWxhci5cbiAgICAgKiBAcGFyYW0gZHN0IC0gcXVhdGVybmlvbiB0byBob2xkIHJlc3VsdC4gSWYgbm90IHBhc3NlZCBpbiBhIG5ldyBvbmUgaXMgY3JlYXRlZC5cbiAgICAgKiBAcmV0dXJucyBUaGUgc2NhbGVkIHF1YXRlcm5pb24uXG4gICAgICovXG4gICAgY29uc3Qgc2NhbGUgPSBtdWxTY2FsYXI7XG4gICAgLyoqXG4gICAgICogRGl2aWRlcyBhIHZlY3RvciBieSBhIHNjYWxhci5cbiAgICAgKiBAcGFyYW0gdiAtIFRoZSB2ZWN0b3IuXG4gICAgICogQHBhcmFtIGsgLSBUaGUgc2NhbGFyLlxuICAgICAqIEBwYXJhbSBkc3QgLSBxdWF0ZXJuaW9uIHRvIGhvbGQgcmVzdWx0LiBJZiBub3QgcGFzc2VkIGluIGEgbmV3IG9uZSBpcyBjcmVhdGVkLlxuICAgICAqIEByZXR1cm5zIFRoZSBzY2FsZWQgcXVhdGVybmlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBkaXZTY2FsYXIodiwgaywgZHN0KSB7XG4gICAgICAgIGNvbnN0IG5ld0RzdCA9IChkc3QgPz8gbmV3IEN0b3IoNCkpO1xuICAgICAgICBuZXdEc3RbMF0gPSB2WzBdIC8gaztcbiAgICAgICAgbmV3RHN0WzFdID0gdlsxXSAvIGs7XG4gICAgICAgIG5ld0RzdFsyXSA9IHZbMl0gLyBrO1xuICAgICAgICBuZXdEc3RbM10gPSB2WzNdIC8gaztcbiAgICAgICAgcmV0dXJuIG5ld0RzdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29tcHV0ZXMgdGhlIGRvdCBwcm9kdWN0IG9mIHR3byBxdWF0ZXJuaW9uc1xuICAgICAqIEBwYXJhbSBhIC0gT3BlcmFuZCBxdWF0ZXJuaW9uLlxuICAgICAqIEBwYXJhbSBiIC0gT3BlcmFuZCBxdWF0ZXJuaW9uLlxuICAgICAqIEByZXR1cm5zIGRvdCBwcm9kdWN0XG4gICAgICovXG4gICAgZnVuY3Rpb24gZG90KGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIChhWzBdICogYlswXSkgKyAoYVsxXSAqIGJbMV0pICsgKGFbMl0gKiBiWzJdKSArIChhWzNdICogYlszXSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFBlcmZvcm1zIGxpbmVhciBpbnRlcnBvbGF0aW9uIG9uIHR3byBxdWF0ZXJuaW9ucy5cbiAgICAgKiBHaXZlbiBxdWF0ZXJuaW9ucyBhIGFuZCBiIGFuZCBpbnRlcnBvbGF0aW9uIGNvZWZmaWNpZW50IHQsIHJldHVybnNcbiAgICAgKiBhICsgdCAqIChiIC0gYSkuXG4gICAgICogQHBhcmFtIGEgLSBPcGVyYW5kIHF1YXRlcm5pb24uXG4gICAgICogQHBhcmFtIGIgLSBPcGVyYW5kIHF1YXRlcm5pb24uXG4gICAgICogQHBhcmFtIHQgLSBJbnRlcnBvbGF0aW9uIGNvZWZmaWNpZW50LlxuICAgICAqIEBwYXJhbSBkc3QgLSBxdWF0ZXJuaW9uIHRvIGhvbGQgcmVzdWx0LiBJZiBub3QgcGFzc2VkIGluIGEgbmV3IG9uZSBpcyBjcmVhdGVkLlxuICAgICAqIEByZXR1cm5zIFRoZSBsaW5lYXIgaW50ZXJwb2xhdGVkIHJlc3VsdC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBsZXJwKGEsIGIsIHQsIGRzdCkge1xuICAgICAgICBjb25zdCBuZXdEc3QgPSAoZHN0ID8/IG5ldyBDdG9yKDQpKTtcbiAgICAgICAgbmV3RHN0WzBdID0gYVswXSArIHQgKiAoYlswXSAtIGFbMF0pO1xuICAgICAgICBuZXdEc3RbMV0gPSBhWzFdICsgdCAqIChiWzFdIC0gYVsxXSk7XG4gICAgICAgIG5ld0RzdFsyXSA9IGFbMl0gKyB0ICogKGJbMl0gLSBhWzJdKTtcbiAgICAgICAgbmV3RHN0WzNdID0gYVszXSArIHQgKiAoYlszXSAtIGFbM10pO1xuICAgICAgICByZXR1cm4gbmV3RHN0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb21wdXRlcyB0aGUgbGVuZ3RoIG9mIHF1YXRlcm5pb25cbiAgICAgKiBAcGFyYW0gdiAtIHF1YXRlcm5pb24uXG4gICAgICogQHJldHVybnMgbGVuZ3RoIG9mIHF1YXRlcm5pb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gbGVuZ3RoKHYpIHtcbiAgICAgICAgY29uc3QgdjAgPSB2WzBdO1xuICAgICAgICBjb25zdCB2MSA9IHZbMV07XG4gICAgICAgIGNvbnN0IHYyID0gdlsyXTtcbiAgICAgICAgY29uc3QgdjMgPSB2WzNdO1xuICAgICAgICByZXR1cm4gTWF0aC5zcXJ0KHYwICogdjAgKyB2MSAqIHYxICsgdjIgKiB2MiArIHYzICogdjMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb21wdXRlcyB0aGUgbGVuZ3RoIG9mIHF1YXRlcm5pb24gKHNhbWUgYXMgbGVuZ3RoKVxuICAgICAqIEBwYXJhbSB2IC0gcXVhdGVybmlvbi5cbiAgICAgKiBAcmV0dXJucyBsZW5ndGggb2YgcXVhdGVybmlvbi5cbiAgICAgKi9cbiAgICBjb25zdCBsZW4gPSBsZW5ndGg7XG4gICAgLyoqXG4gICAgICogQ29tcHV0ZXMgdGhlIHNxdWFyZSBvZiB0aGUgbGVuZ3RoIG9mIHF1YXRlcm5pb25cbiAgICAgKiBAcGFyYW0gdiAtIHF1YXRlcm5pb24uXG4gICAgICogQHJldHVybnMgc3F1YXJlIG9mIHRoZSBsZW5ndGggb2YgcXVhdGVybmlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBsZW5ndGhTcSh2KSB7XG4gICAgICAgIGNvbnN0IHYwID0gdlswXTtcbiAgICAgICAgY29uc3QgdjEgPSB2WzFdO1xuICAgICAgICBjb25zdCB2MiA9IHZbMl07XG4gICAgICAgIGNvbnN0IHYzID0gdlszXTtcbiAgICAgICAgcmV0dXJuIHYwICogdjAgKyB2MSAqIHYxICsgdjIgKiB2MiArIHYzICogdjM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbXB1dGVzIHRoZSBzcXVhcmUgb2YgdGhlIGxlbmd0aCBvZiBxdWF0ZXJuaW9uIChzYW1lIGFzIGxlbmd0aFNxKVxuICAgICAqIEBwYXJhbSB2IC0gcXVhdGVybmlvbi5cbiAgICAgKiBAcmV0dXJucyBzcXVhcmUgb2YgdGhlIGxlbmd0aCBvZiBxdWF0ZXJuaW9uLlxuICAgICAqL1xuICAgIGNvbnN0IGxlblNxID0gbGVuZ3RoU3E7XG4gICAgLyoqXG4gICAgICogRGl2aWRlcyBhIHF1YXRlcm5pb24gYnkgaXRzIEV1Y2xpZGVhbiBsZW5ndGggYW5kIHJldHVybnMgdGhlIHF1b3RpZW50LlxuICAgICAqIEBwYXJhbSB2IC0gVGhlIHF1YXRlcm5pb24uXG4gICAgICogQHBhcmFtIGRzdCAtIHF1YXRlcm5pb24gdG8gaG9sZCByZXN1bHQuIElmIG5vdCBwYXNzZWQgaW4gYSBuZXcgb25lIGlzIGNyZWF0ZWQuXG4gICAgICogQHJldHVybnMgVGhlIG5vcm1hbGl6ZWQgcXVhdGVybmlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBub3JtYWxpemUodiwgZHN0KSB7XG4gICAgICAgIGNvbnN0IG5ld0RzdCA9IChkc3QgPz8gbmV3IEN0b3IoNCkpO1xuICAgICAgICBjb25zdCB2MCA9IHZbMF07XG4gICAgICAgIGNvbnN0IHYxID0gdlsxXTtcbiAgICAgICAgY29uc3QgdjIgPSB2WzJdO1xuICAgICAgICBjb25zdCB2MyA9IHZbM107XG4gICAgICAgIGNvbnN0IGxlbiA9IE1hdGguc3FydCh2MCAqIHYwICsgdjEgKiB2MSArIHYyICogdjIgKyB2MyAqIHYzKTtcbiAgICAgICAgaWYgKGxlbiA+IDAuMDAwMDEpIHtcbiAgICAgICAgICAgIG5ld0RzdFswXSA9IHYwIC8gbGVuO1xuICAgICAgICAgICAgbmV3RHN0WzFdID0gdjEgLyBsZW47XG4gICAgICAgICAgICBuZXdEc3RbMl0gPSB2MiAvIGxlbjtcbiAgICAgICAgICAgIG5ld0RzdFszXSA9IHYzIC8gbGVuO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbmV3RHN0WzBdID0gMDtcbiAgICAgICAgICAgIG5ld0RzdFsxXSA9IDA7XG4gICAgICAgICAgICBuZXdEc3RbMl0gPSAwO1xuICAgICAgICAgICAgbmV3RHN0WzNdID0gMDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3RHN0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDaGVjayBpZiAyIHF1YXRlcm5pb25zIGFyZSBhcHByb3hpbWF0ZWx5IGVxdWFsXG4gICAgICogQHBhcmFtIGEgLSBPcGVyYW5kIHF1YXRlcm5pb24uXG4gICAgICogQHBhcmFtIGIgLSBPcGVyYW5kIHF1YXRlcm5pb24uXG4gICAgICogQHJldHVybnMgdHJ1ZSBpZiBxdWF0ZXJuaW9ucyBhcmUgYXBwcm94aW1hdGVseSBlcXVhbFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGVxdWFsc0FwcHJveGltYXRlbHkoYSwgYikge1xuICAgICAgICByZXR1cm4gTWF0aC5hYnMoYVswXSAtIGJbMF0pIDwgRVBTSUxPTiAmJlxuICAgICAgICAgICAgTWF0aC5hYnMoYVsxXSAtIGJbMV0pIDwgRVBTSUxPTiAmJlxuICAgICAgICAgICAgTWF0aC5hYnMoYVsyXSAtIGJbMl0pIDwgRVBTSUxPTiAmJlxuICAgICAgICAgICAgTWF0aC5hYnMoYVszXSAtIGJbM10pIDwgRVBTSUxPTjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2hlY2sgaWYgMiBxdWF0ZXJuaW9ucyBhcmUgZXhhY3RseSBlcXVhbFxuICAgICAqIEBwYXJhbSBhIC0gT3BlcmFuZCBxdWF0ZXJuaW9uLlxuICAgICAqIEBwYXJhbSBiIC0gT3BlcmFuZCBxdWF0ZXJuaW9uLlxuICAgICAqIEByZXR1cm5zIHRydWUgaWYgcXVhdGVybmlvbnMgYXJlIGV4YWN0bHkgZXF1YWxcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBlcXVhbHMoYSwgYikge1xuICAgICAgICByZXR1cm4gYVswXSA9PT0gYlswXSAmJiBhWzFdID09PSBiWzFdICYmIGFbMl0gPT09IGJbMl0gJiYgYVszXSA9PT0gYlszXTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBpZGVudGl0eSBxdWF0ZXJuaW9uXG4gICAgICogQHBhcmFtIGRzdCAtIHF1YXRlcm5pb24gdG8gaG9sZCByZXN1bHQuIElmIG5vdCBwYXNzZWQgaW4gYSBuZXcgb25lIGlzIGNyZWF0ZWQuXG4gICAgICogQHJldHVybnMgYW4gaWRlbnRpdHkgcXVhdGVybmlvblxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlkZW50aXR5KGRzdCkge1xuICAgICAgICBjb25zdCBuZXdEc3QgPSAoZHN0ID8/IG5ldyBDdG9yKDQpKTtcbiAgICAgICAgbmV3RHN0WzBdID0gMDtcbiAgICAgICAgbmV3RHN0WzFdID0gMDtcbiAgICAgICAgbmV3RHN0WzJdID0gMDtcbiAgICAgICAgbmV3RHN0WzNdID0gMTtcbiAgICAgICAgcmV0dXJuIG5ld0RzdDtcbiAgICB9XG4gICAgY29uc3QgdGVtcFZlYzMgPSB2ZWMzLmNyZWF0ZSgpO1xuICAgIGNvbnN0IHhVbml0VmVjMyA9IHZlYzMuY3JlYXRlKCk7XG4gICAgY29uc3QgeVVuaXRWZWMzID0gdmVjMy5jcmVhdGUoKTtcbiAgICAvKipcbiAgICAgKiBDb21wdXRlcyBhIHF1YXRlcm5pb24gdG8gcmVwcmVzZW50IHRoZSBzaG9ydGVzdCByb3RhdGlvbiBmcm9tIG9uZSB2ZWN0b3IgdG8gYW5vdGhlci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBhVW5pdCAtIHRoZSBzdGFydCB2ZWN0b3JcbiAgICAgKiBAcGFyYW0gYlVuaXQgLSB0aGUgZW5kIHZlY3RvclxuICAgICAqIEBwYXJhbSBkc3QgLSBxdWF0ZXJuaW9uIHRvIGhvbGQgcmVzdWx0LiBJZiBub3QgcGFzc2VkIGluIGEgbmV3IG9uZSBpcyBjcmVhdGVkLlxuICAgICAqIEByZXR1cm5zIHRoZSByZXN1bHRcbiAgICAgKi9cbiAgICBmdW5jdGlvbiByb3RhdGlvblRvKGFVbml0LCBiVW5pdCwgZHN0KSB7XG4gICAgICAgIGNvbnN0IG5ld0RzdCA9IChkc3QgPz8gbmV3IEN0b3IoNCkpO1xuICAgICAgICBjb25zdCBkb3QgPSB2ZWMzLmRvdChhVW5pdCwgYlVuaXQpO1xuICAgICAgICBpZiAoZG90IDwgLTAuOTk5OTk5KSB7XG4gICAgICAgICAgICB2ZWMzLmNyb3NzKHhVbml0VmVjMywgYVVuaXQsIHRlbXBWZWMzKTtcbiAgICAgICAgICAgIGlmICh2ZWMzLmxlbih0ZW1wVmVjMykgPCAwLjAwMDAwMSkge1xuICAgICAgICAgICAgICAgIHZlYzMuY3Jvc3MoeVVuaXRWZWMzLCBhVW5pdCwgdGVtcFZlYzMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmVjMy5ub3JtYWxpemUodGVtcFZlYzMsIHRlbXBWZWMzKTtcbiAgICAgICAgICAgIGZyb21BeGlzQW5nbGUodGVtcFZlYzMsIE1hdGguUEksIG5ld0RzdCk7XG4gICAgICAgICAgICByZXR1cm4gbmV3RHN0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGRvdCA+IDAuOTk5OTk5KSB7XG4gICAgICAgICAgICBuZXdEc3RbMF0gPSAwO1xuICAgICAgICAgICAgbmV3RHN0WzFdID0gMDtcbiAgICAgICAgICAgIG5ld0RzdFsyXSA9IDA7XG4gICAgICAgICAgICBuZXdEc3RbM10gPSAxO1xuICAgICAgICAgICAgcmV0dXJuIG5ld0RzdDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZlYzMuY3Jvc3MoYVVuaXQsIGJVbml0LCB0ZW1wVmVjMyk7XG4gICAgICAgICAgICBuZXdEc3RbMF0gPSB0ZW1wVmVjM1swXTtcbiAgICAgICAgICAgIG5ld0RzdFsxXSA9IHRlbXBWZWMzWzFdO1xuICAgICAgICAgICAgbmV3RHN0WzJdID0gdGVtcFZlYzNbMl07XG4gICAgICAgICAgICBuZXdEc3RbM10gPSAxICsgZG90O1xuICAgICAgICAgICAgcmV0dXJuIG5vcm1hbGl6ZShuZXdEc3QsIG5ld0RzdCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgdGVtcFF1YXQxID0gbmV3IEN0b3IoNCk7XG4gICAgY29uc3QgdGVtcFF1YXQyID0gbmV3IEN0b3IoNCk7XG4gICAgLyoqXG4gICAgICogUGVyZm9ybXMgYSBzcGhlcmljYWwgbGluZWFyIGludGVycG9sYXRpb24gd2l0aCB0d28gY29udHJvbCBwb2ludHNcbiAgICAgKlxuICAgICAqIEBwYXJhbSBhIC0gdGhlIGZpcnN0IHF1YXRlcm5pb25cbiAgICAgKiBAcGFyYW0gYiAtIHRoZSBzZWNvbmQgcXVhdGVybmlvblxuICAgICAqIEBwYXJhbSBjIC0gdGhlIHRoaXJkIHF1YXRlcm5pb25cbiAgICAgKiBAcGFyYW0gZCAtIHRoZSBmb3VydGggcXVhdGVybmlvblxuICAgICAqIEBwYXJhbSB0IC0gSW50ZXJwb2xhdGlvbiBjb2VmZmljaWVudCAwIHRvIDFcbiAgICAgKiBAcmV0dXJucyByZXN1bHRcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzcWxlcnAoYSwgYiwgYywgZCwgdCwgZHN0KSB7XG4gICAgICAgIGNvbnN0IG5ld0RzdCA9IChkc3QgPz8gbmV3IEN0b3IoNCkpO1xuICAgICAgICBzbGVycChhLCBkLCB0LCB0ZW1wUXVhdDEpO1xuICAgICAgICBzbGVycChiLCBjLCB0LCB0ZW1wUXVhdDIpO1xuICAgICAgICBzbGVycCh0ZW1wUXVhdDEsIHRlbXBRdWF0MiwgMiAqIHQgKiAoMSAtIHQpLCBuZXdEc3QpO1xuICAgICAgICByZXR1cm4gbmV3RHN0O1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBjcmVhdGUsXG4gICAgICAgIGZyb21WYWx1ZXMsXG4gICAgICAgIHNldCxcbiAgICAgICAgZnJvbUF4aXNBbmdsZSxcbiAgICAgICAgdG9BeGlzQW5nbGUsXG4gICAgICAgIGFuZ2xlLFxuICAgICAgICBtdWx0aXBseSxcbiAgICAgICAgbXVsLFxuICAgICAgICByb3RhdGVYLFxuICAgICAgICByb3RhdGVZLFxuICAgICAgICByb3RhdGVaLFxuICAgICAgICBzbGVycCxcbiAgICAgICAgaW52ZXJzZSxcbiAgICAgICAgY29uanVnYXRlLFxuICAgICAgICBmcm9tTWF0LFxuICAgICAgICBmcm9tRXVsZXIsXG4gICAgICAgIGNvcHksXG4gICAgICAgIGNsb25lLFxuICAgICAgICBhZGQsXG4gICAgICAgIHN1YnRyYWN0LFxuICAgICAgICBzdWIsXG4gICAgICAgIG11bFNjYWxhcixcbiAgICAgICAgc2NhbGUsXG4gICAgICAgIGRpdlNjYWxhcixcbiAgICAgICAgZG90LFxuICAgICAgICBsZXJwLFxuICAgICAgICBsZW5ndGgsXG4gICAgICAgIGxlbixcbiAgICAgICAgbGVuZ3RoU3EsXG4gICAgICAgIGxlblNxLFxuICAgICAgICBub3JtYWxpemUsXG4gICAgICAgIGVxdWFsc0FwcHJveGltYXRlbHksXG4gICAgICAgIGVxdWFscyxcbiAgICAgICAgaWRlbnRpdHksXG4gICAgICAgIHJvdGF0aW9uVG8sXG4gICAgICAgIHNxbGVycCxcbiAgICB9O1xufVxuY29uc3QgY2FjaGUkMSA9IG5ldyBNYXAoKTtcbi8qKlxuICpcbiAqIFF1YXQ0IG1hdGggZnVuY3Rpb25zLlxuICpcbiAqIEFsbW9zdCBhbGwgZnVuY3Rpb25zIHRha2UgYW4gb3B0aW9uYWwgYG5ld0RzdGAgYXJndW1lbnQuIElmIGl0IGlzIG5vdCBwYXNzZWQgaW4gdGhlXG4gKiBmdW5jdGlvbnMgd2lsbCBjcmVhdGUgYSBuZXcgYFF1YXQ0YC4gSW4gb3RoZXIgd29yZHMgeW91IGNhbiBkbyB0aGlzXG4gKlxuICogICAgIGNvbnN0IHYgPSBxdWF0NC5jcm9zcyh2MSwgdjIpOyAgLy8gQ3JlYXRlcyBhIG5ldyBRdWF0NCB3aXRoIHRoZSBjcm9zcyBwcm9kdWN0IG9mIHYxIHggdjIuXG4gKlxuICogb3JcbiAqXG4gKiAgICAgY29uc3QgdiA9IHF1YXQ0LmNyZWF0ZSgpO1xuICogICAgIHF1YXQ0LmNyb3NzKHYxLCB2Miwgdik7ICAvLyBQdXRzIHRoZSBjcm9zcyBwcm9kdWN0IG9mIHYxIHggdjIgaW4gdlxuICpcbiAqIFRoZSBmaXJzdCBzdHlsZSBpcyBvZnRlbiBlYXNpZXIgYnV0IGRlcGVuZGluZyBvbiB3aGVyZSBpdCdzIHVzZWQgaXQgZ2VuZXJhdGVzIGdhcmJhZ2Ugd2hlcmVcbiAqIGFzIHRoZXJlIGlzIGFsbW9zdCBuZXZlciBhbGxvY2F0aW9uIHdpdGggdGhlIHNlY29uZCBzdHlsZS5cbiAqXG4gKiBJdCBpcyBhbHdheXMgc2FmZSB0byBwYXNzIGFueSB2ZWN0b3IgYXMgdGhlIGRlc3RpbmF0aW9uLiBTbyBmb3IgZXhhbXBsZVxuICpcbiAqICAgICBxdWF0NC5jcm9zcyh2MSwgdjIsIHYxKTsgIC8vIFB1dHMgdGhlIGNyb3NzIHByb2R1Y3Qgb2YgdjEgeCB2MiBpbiB2MVxuICpcbiAqL1xuZnVuY3Rpb24gZ2V0QVBJJDEoQ3Rvcikge1xuICAgIGxldCBhcGkgPSBjYWNoZSQxLmdldChDdG9yKTtcbiAgICBpZiAoIWFwaSkge1xuICAgICAgICBhcGkgPSBnZXRBUElJbXBsJDEoQ3Rvcik7XG4gICAgICAgIGNhY2hlJDEuc2V0KEN0b3IsIGFwaSk7XG4gICAgfVxuICAgIHJldHVybiBhcGk7XG59XG5cbi8qXG4gKiBDb3B5cmlnaHQgMjAyMiBHcmVnZyBUYXZhcmVzXG4gKlxuICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbiAqIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSxcbiAqIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb25cbiAqIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLFxuICogYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlXG4gKiBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuICpcbiAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4gKiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbiAqXG4gKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4gKiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbiAqIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuICBJTiBOTyBFVkVOVCBTSEFMTFxuICogVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbiAqIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HXG4gKiBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSXG4gKiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG4gKi9cbi8qKlxuICogR2VuZXJhdGVzIGFtIHR5cGVkIEFQSSBmb3IgVmVjNFxuICogKi9cbmZ1bmN0aW9uIGdldEFQSUltcGwoQ3Rvcikge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSB2ZWM0OyBtYXkgYmUgY2FsbGVkIHdpdGggeCwgeSwgeiB0byBzZXQgaW5pdGlhbCB2YWx1ZXMuXG4gICAgICogQHBhcmFtIHggLSBJbml0aWFsIHggdmFsdWUuXG4gICAgICogQHBhcmFtIHkgLSBJbml0aWFsIHkgdmFsdWUuXG4gICAgICogQHBhcmFtIHogLSBJbml0aWFsIHogdmFsdWUuXG4gICAgICogQHBhcmFtIHcgLSBJbml0aWFsIHcgdmFsdWUuXG4gICAgICogQHJldHVybnMgdGhlIGNyZWF0ZWQgdmVjdG9yXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlKHgsIHksIHosIHcpIHtcbiAgICAgICAgY29uc3QgbmV3RHN0ID0gbmV3IEN0b3IoNCk7XG4gICAgICAgIGlmICh4ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIG5ld0RzdFswXSA9IHg7XG4gICAgICAgICAgICBpZiAoeSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgbmV3RHN0WzFdID0geTtcbiAgICAgICAgICAgICAgICBpZiAoeiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIG5ld0RzdFsyXSA9IHo7XG4gICAgICAgICAgICAgICAgICAgIGlmICh3ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld0RzdFszXSA9IHc7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ld0RzdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIHZlYzQ7IG1heSBiZSBjYWxsZWQgd2l0aCB4LCB5LCB6IHRvIHNldCBpbml0aWFsIHZhbHVlcy4gKHNhbWUgYXMgY3JlYXRlKVxuICAgICAqIEBwYXJhbSB4IC0gSW5pdGlhbCB4IHZhbHVlLlxuICAgICAqIEBwYXJhbSB5IC0gSW5pdGlhbCB5IHZhbHVlLlxuICAgICAqIEBwYXJhbSB6IC0gSW5pdGlhbCB6IHZhbHVlLlxuICAgICAqIEBwYXJhbSB6IC0gSW5pdGlhbCB3IHZhbHVlLlxuICAgICAqIEByZXR1cm5zIHRoZSBjcmVhdGVkIHZlY3RvclxuICAgICAqL1xuICAgIGNvbnN0IGZyb21WYWx1ZXMgPSBjcmVhdGU7XG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgdmFsdWVzIG9mIGEgVmVjNFxuICAgICAqIEFsc28gc2VlIHtAbGluayB2ZWM0LmNyZWF0ZX0gYW5kIHtAbGluayB2ZWM0LmNvcHl9XG4gICAgICpcbiAgICAgKiBAcGFyYW0geCBmaXJzdCB2YWx1ZVxuICAgICAqIEBwYXJhbSB5IHNlY29uZCB2YWx1ZVxuICAgICAqIEBwYXJhbSB6IHRoaXJkIHZhbHVlXG4gICAgICogQHBhcmFtIHcgZm91cnRoIHZhbHVlXG4gICAgICogQHBhcmFtIGRzdCAtIHZlY3RvciB0byBob2xkIHJlc3VsdC4gSWYgbm90IHBhc3NlZCBpbiBhIG5ldyBvbmUgaXMgY3JlYXRlZC5cbiAgICAgKiBAcmV0dXJucyBBIHZlY3RvciB3aXRoIGl0cyBlbGVtZW50cyBzZXQuXG4gICAgICovXG4gICAgZnVuY3Rpb24gc2V0KHgsIHksIHosIHcsIGRzdCkge1xuICAgICAgICBjb25zdCBuZXdEc3QgPSAoZHN0ID8/IG5ldyBDdG9yKDQpKTtcbiAgICAgICAgbmV3RHN0WzBdID0geDtcbiAgICAgICAgbmV3RHN0WzFdID0geTtcbiAgICAgICAgbmV3RHN0WzJdID0gejtcbiAgICAgICAgbmV3RHN0WzNdID0gdztcbiAgICAgICAgcmV0dXJuIG5ld0RzdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQXBwbGllcyBNYXRoLmNlaWwgdG8gZWFjaCBlbGVtZW50IG9mIHZlY3RvclxuICAgICAqIEBwYXJhbSB2IC0gT3BlcmFuZCB2ZWN0b3IuXG4gICAgICogQHBhcmFtIGRzdCAtIHZlY3RvciB0byBob2xkIHJlc3VsdC4gSWYgbm90IHBhc3NlZCBpbiBhIG5ldyBvbmUgaXMgY3JlYXRlZC5cbiAgICAgKiBAcmV0dXJucyBBIHZlY3RvciB0aGF0IGlzIHRoZSBjZWlsIG9mIGVhY2ggZWxlbWVudCBvZiB2LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNlaWwodiwgZHN0KSB7XG4gICAgICAgIGNvbnN0IG5ld0RzdCA9IChkc3QgPz8gbmV3IEN0b3IoNCkpO1xuICAgICAgICBuZXdEc3RbMF0gPSBNYXRoLmNlaWwodlswXSk7XG4gICAgICAgIG5ld0RzdFsxXSA9IE1hdGguY2VpbCh2WzFdKTtcbiAgICAgICAgbmV3RHN0WzJdID0gTWF0aC5jZWlsKHZbMl0pO1xuICAgICAgICBuZXdEc3RbM10gPSBNYXRoLmNlaWwodlszXSk7XG4gICAgICAgIHJldHVybiBuZXdEc3Q7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFwcGxpZXMgTWF0aC5mbG9vciB0byBlYWNoIGVsZW1lbnQgb2YgdmVjdG9yXG4gICAgICogQHBhcmFtIHYgLSBPcGVyYW5kIHZlY3Rvci5cbiAgICAgKiBAcGFyYW0gZHN0IC0gdmVjdG9yIHRvIGhvbGQgcmVzdWx0LiBJZiBub3QgcGFzc2VkIGluIGEgbmV3IG9uZSBpcyBjcmVhdGVkLlxuICAgICAqIEByZXR1cm5zIEEgdmVjdG9yIHRoYXQgaXMgdGhlIGZsb29yIG9mIGVhY2ggZWxlbWVudCBvZiB2LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZsb29yKHYsIGRzdCkge1xuICAgICAgICBjb25zdCBuZXdEc3QgPSAoZHN0ID8/IG5ldyBDdG9yKDQpKTtcbiAgICAgICAgbmV3RHN0WzBdID0gTWF0aC5mbG9vcih2WzBdKTtcbiAgICAgICAgbmV3RHN0WzFdID0gTWF0aC5mbG9vcih2WzFdKTtcbiAgICAgICAgbmV3RHN0WzJdID0gTWF0aC5mbG9vcih2WzJdKTtcbiAgICAgICAgbmV3RHN0WzNdID0gTWF0aC5mbG9vcih2WzNdKTtcbiAgICAgICAgcmV0dXJuIG5ld0RzdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQXBwbGllcyBNYXRoLnJvdW5kIHRvIGVhY2ggZWxlbWVudCBvZiB2ZWN0b3JcbiAgICAgKiBAcGFyYW0gdiAtIE9wZXJhbmQgdmVjdG9yLlxuICAgICAqIEBwYXJhbSBkc3QgLSB2ZWN0b3IgdG8gaG9sZCByZXN1bHQuIElmIG5vdCBwYXNzZWQgaW4gYSBuZXcgb25lIGlzIGNyZWF0ZWQuXG4gICAgICogQHJldHVybnMgQSB2ZWN0b3IgdGhhdCBpcyB0aGUgcm91bmQgb2YgZWFjaCBlbGVtZW50IG9mIHYuXG4gICAgICovXG4gICAgZnVuY3Rpb24gcm91bmQodiwgZHN0KSB7XG4gICAgICAgIGNvbnN0IG5ld0RzdCA9IChkc3QgPz8gbmV3IEN0b3IoNCkpO1xuICAgICAgICBuZXdEc3RbMF0gPSBNYXRoLnJvdW5kKHZbMF0pO1xuICAgICAgICBuZXdEc3RbMV0gPSBNYXRoLnJvdW5kKHZbMV0pO1xuICAgICAgICBuZXdEc3RbMl0gPSBNYXRoLnJvdW5kKHZbMl0pO1xuICAgICAgICBuZXdEc3RbM10gPSBNYXRoLnJvdW5kKHZbM10pO1xuICAgICAgICByZXR1cm4gbmV3RHN0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDbGFtcCBlYWNoIGVsZW1lbnQgb2YgdmVjdG9yIGJldHdlZW4gbWluIGFuZCBtYXhcbiAgICAgKiBAcGFyYW0gdiAtIE9wZXJhbmQgdmVjdG9yLlxuICAgICAqIEBwYXJhbSBtYXggLSBNaW4gdmFsdWUsIGRlZmF1bHQgMFxuICAgICAqIEBwYXJhbSBtaW4gLSBNYXggdmFsdWUsIGRlZmF1bHQgMVxuICAgICAqIEBwYXJhbSBkc3QgLSB2ZWN0b3IgdG8gaG9sZCByZXN1bHQuIElmIG5vdCBwYXNzZWQgaW4gYSBuZXcgb25lIGlzIGNyZWF0ZWQuXG4gICAgICogQHJldHVybnMgQSB2ZWN0b3IgdGhhdCB0aGUgY2xhbXBlZCB2YWx1ZSBvZiBlYWNoIGVsZW1lbnQgb2Ygdi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjbGFtcCh2LCBtaW4gPSAwLCBtYXggPSAxLCBkc3QpIHtcbiAgICAgICAgY29uc3QgbmV3RHN0ID0gKGRzdCA/PyBuZXcgQ3Rvcig0KSk7XG4gICAgICAgIG5ld0RzdFswXSA9IE1hdGgubWluKG1heCwgTWF0aC5tYXgobWluLCB2WzBdKSk7XG4gICAgICAgIG5ld0RzdFsxXSA9IE1hdGgubWluKG1heCwgTWF0aC5tYXgobWluLCB2WzFdKSk7XG4gICAgICAgIG5ld0RzdFsyXSA9IE1hdGgubWluKG1heCwgTWF0aC5tYXgobWluLCB2WzJdKSk7XG4gICAgICAgIG5ld0RzdFszXSA9IE1hdGgubWluKG1heCwgTWF0aC5tYXgobWluLCB2WzNdKSk7XG4gICAgICAgIHJldHVybiBuZXdEc3Q7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkZHMgdHdvIHZlY3RvcnM7IGFzc3VtZXMgYSBhbmQgYiBoYXZlIHRoZSBzYW1lIGRpbWVuc2lvbi5cbiAgICAgKiBAcGFyYW0gYSAtIE9wZXJhbmQgdmVjdG9yLlxuICAgICAqIEBwYXJhbSBiIC0gT3BlcmFuZCB2ZWN0b3IuXG4gICAgICogQHBhcmFtIGRzdCAtIHZlY3RvciB0byBob2xkIHJlc3VsdC4gSWYgbm90IHBhc3NlZCBpbiBhIG5ldyBvbmUgaXMgY3JlYXRlZC5cbiAgICAgKiBAcmV0dXJucyBBIHZlY3RvciB0aGF0IGlzIHRoZSBzdW0gb2YgYSBhbmQgYi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBhZGQoYSwgYiwgZHN0KSB7XG4gICAgICAgIGNvbnN0IG5ld0RzdCA9IChkc3QgPz8gbmV3IEN0b3IoNCkpO1xuICAgICAgICBuZXdEc3RbMF0gPSBhWzBdICsgYlswXTtcbiAgICAgICAgbmV3RHN0WzFdID0gYVsxXSArIGJbMV07XG4gICAgICAgIG5ld0RzdFsyXSA9IGFbMl0gKyBiWzJdO1xuICAgICAgICBuZXdEc3RbM10gPSBhWzNdICsgYlszXTtcbiAgICAgICAgcmV0dXJuIG5ld0RzdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWRkcyB0d28gdmVjdG9ycywgc2NhbGluZyB0aGUgMm5kOyBhc3N1bWVzIGEgYW5kIGIgaGF2ZSB0aGUgc2FtZSBkaW1lbnNpb24uXG4gICAgICogQHBhcmFtIGEgLSBPcGVyYW5kIHZlY3Rvci5cbiAgICAgKiBAcGFyYW0gYiAtIE9wZXJhbmQgdmVjdG9yLlxuICAgICAqIEBwYXJhbSBzY2FsZSAtIEFtb3VudCB0byBzY2FsZSBiXG4gICAgICogQHBhcmFtIGRzdCAtIHZlY3RvciB0byBob2xkIHJlc3VsdC4gSWYgbm90IHBhc3NlZCBpbiBhIG5ldyBvbmUgaXMgY3JlYXRlZC5cbiAgICAgKiBAcmV0dXJucyBBIHZlY3RvciB0aGF0IGlzIHRoZSBzdW0gb2YgYSArIGIgKiBzY2FsZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBhZGRTY2FsZWQoYSwgYiwgc2NhbGUsIGRzdCkge1xuICAgICAgICBjb25zdCBuZXdEc3QgPSAoZHN0ID8/IG5ldyBDdG9yKDQpKTtcbiAgICAgICAgbmV3RHN0WzBdID0gYVswXSArIGJbMF0gKiBzY2FsZTtcbiAgICAgICAgbmV3RHN0WzFdID0gYVsxXSArIGJbMV0gKiBzY2FsZTtcbiAgICAgICAgbmV3RHN0WzJdID0gYVsyXSArIGJbMl0gKiBzY2FsZTtcbiAgICAgICAgbmV3RHN0WzNdID0gYVszXSArIGJbM10gKiBzY2FsZTtcbiAgICAgICAgcmV0dXJuIG5ld0RzdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU3VidHJhY3RzIHR3byB2ZWN0b3JzLlxuICAgICAqIEBwYXJhbSBhIC0gT3BlcmFuZCB2ZWN0b3IuXG4gICAgICogQHBhcmFtIGIgLSBPcGVyYW5kIHZlY3Rvci5cbiAgICAgKiBAcGFyYW0gZHN0IC0gdmVjdG9yIHRvIGhvbGQgcmVzdWx0LiBJZiBub3QgcGFzc2VkIGluIGEgbmV3IG9uZSBpcyBjcmVhdGVkLlxuICAgICAqIEByZXR1cm5zIEEgdmVjdG9yIHRoYXQgaXMgdGhlIGRpZmZlcmVuY2Ugb2YgYSBhbmQgYi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzdWJ0cmFjdChhLCBiLCBkc3QpIHtcbiAgICAgICAgY29uc3QgbmV3RHN0ID0gKGRzdCA/PyBuZXcgQ3Rvcig0KSk7XG4gICAgICAgIG5ld0RzdFswXSA9IGFbMF0gLSBiWzBdO1xuICAgICAgICBuZXdEc3RbMV0gPSBhWzFdIC0gYlsxXTtcbiAgICAgICAgbmV3RHN0WzJdID0gYVsyXSAtIGJbMl07XG4gICAgICAgIG5ld0RzdFszXSA9IGFbM10gLSBiWzNdO1xuICAgICAgICByZXR1cm4gbmV3RHN0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTdWJ0cmFjdHMgdHdvIHZlY3RvcnMuXG4gICAgICogQHBhcmFtIGEgLSBPcGVyYW5kIHZlY3Rvci5cbiAgICAgKiBAcGFyYW0gYiAtIE9wZXJhbmQgdmVjdG9yLlxuICAgICAqIEBwYXJhbSBkc3QgLSB2ZWN0b3IgdG8gaG9sZCByZXN1bHQuIElmIG5vdCBwYXNzZWQgaW4gYSBuZXcgb25lIGlzIGNyZWF0ZWQuXG4gICAgICogQHJldHVybnMgQSB2ZWN0b3IgdGhhdCBpcyB0aGUgZGlmZmVyZW5jZSBvZiBhIGFuZCBiLlxuICAgICAqL1xuICAgIGNvbnN0IHN1YiA9IHN1YnRyYWN0O1xuICAgIC8qKlxuICAgICAqIENoZWNrIGlmIDIgdmVjdG9ycyBhcmUgYXBwcm94aW1hdGVseSBlcXVhbFxuICAgICAqIEBwYXJhbSBhIC0gT3BlcmFuZCB2ZWN0b3IuXG4gICAgICogQHBhcmFtIGIgLSBPcGVyYW5kIHZlY3Rvci5cbiAgICAgKiBAcmV0dXJucyB0cnVlIGlmIHZlY3RvcnMgYXJlIGFwcHJveGltYXRlbHkgZXF1YWxcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBlcXVhbHNBcHByb3hpbWF0ZWx5KGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIE1hdGguYWJzKGFbMF0gLSBiWzBdKSA8IEVQU0lMT04gJiZcbiAgICAgICAgICAgIE1hdGguYWJzKGFbMV0gLSBiWzFdKSA8IEVQU0lMT04gJiZcbiAgICAgICAgICAgIE1hdGguYWJzKGFbMl0gLSBiWzJdKSA8IEVQU0lMT04gJiZcbiAgICAgICAgICAgIE1hdGguYWJzKGFbM10gLSBiWzNdKSA8IEVQU0lMT047XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENoZWNrIGlmIDIgdmVjdG9ycyBhcmUgZXhhY3RseSBlcXVhbFxuICAgICAqIEBwYXJhbSBhIC0gT3BlcmFuZCB2ZWN0b3IuXG4gICAgICogQHBhcmFtIGIgLSBPcGVyYW5kIHZlY3Rvci5cbiAgICAgKiBAcmV0dXJucyB0cnVlIGlmIHZlY3RvcnMgYXJlIGV4YWN0bHkgZXF1YWxcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBlcXVhbHMoYSwgYikge1xuICAgICAgICByZXR1cm4gYVswXSA9PT0gYlswXSAmJiBhWzFdID09PSBiWzFdICYmIGFbMl0gPT09IGJbMl0gJiYgYVszXSA9PT0gYlszXTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUGVyZm9ybXMgbGluZWFyIGludGVycG9sYXRpb24gb24gdHdvIHZlY3RvcnMuXG4gICAgICogR2l2ZW4gdmVjdG9ycyBhIGFuZCBiIGFuZCBpbnRlcnBvbGF0aW9uIGNvZWZmaWNpZW50IHQsIHJldHVybnNcbiAgICAgKiBhICsgdCAqIChiIC0gYSkuXG4gICAgICogQHBhcmFtIGEgLSBPcGVyYW5kIHZlY3Rvci5cbiAgICAgKiBAcGFyYW0gYiAtIE9wZXJhbmQgdmVjdG9yLlxuICAgICAqIEBwYXJhbSB0IC0gSW50ZXJwb2xhdGlvbiBjb2VmZmljaWVudC5cbiAgICAgKiBAcGFyYW0gZHN0IC0gdmVjdG9yIHRvIGhvbGQgcmVzdWx0LiBJZiBub3QgcGFzc2VkIGluIGEgbmV3IG9uZSBpcyBjcmVhdGVkLlxuICAgICAqIEByZXR1cm5zIFRoZSBsaW5lYXIgaW50ZXJwb2xhdGVkIHJlc3VsdC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBsZXJwKGEsIGIsIHQsIGRzdCkge1xuICAgICAgICBjb25zdCBuZXdEc3QgPSAoZHN0ID8/IG5ldyBDdG9yKDQpKTtcbiAgICAgICAgbmV3RHN0WzBdID0gYVswXSArIHQgKiAoYlswXSAtIGFbMF0pO1xuICAgICAgICBuZXdEc3RbMV0gPSBhWzFdICsgdCAqIChiWzFdIC0gYVsxXSk7XG4gICAgICAgIG5ld0RzdFsyXSA9IGFbMl0gKyB0ICogKGJbMl0gLSBhWzJdKTtcbiAgICAgICAgbmV3RHN0WzNdID0gYVszXSArIHQgKiAoYlszXSAtIGFbM10pO1xuICAgICAgICByZXR1cm4gbmV3RHN0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQZXJmb3JtcyBsaW5lYXIgaW50ZXJwb2xhdGlvbiBvbiB0d28gdmVjdG9ycy5cbiAgICAgKiBHaXZlbiB2ZWN0b3JzIGEgYW5kIGIgYW5kIGludGVycG9sYXRpb24gY29lZmZpY2llbnQgdmVjdG9yIHQsIHJldHVybnNcbiAgICAgKiBhICsgdCAqIChiIC0gYSkuXG4gICAgICogQHBhcmFtIGEgLSBPcGVyYW5kIHZlY3Rvci5cbiAgICAgKiBAcGFyYW0gYiAtIE9wZXJhbmQgdmVjdG9yLlxuICAgICAqIEBwYXJhbSB0IC0gSW50ZXJwb2xhdGlvbiBjb2VmZmljaWVudHMgdmVjdG9yLlxuICAgICAqIEBwYXJhbSBkc3QgLSB2ZWN0b3IgdG8gaG9sZCByZXN1bHQuIElmIG5vdCBwYXNzZWQgaW4gYSBuZXcgb25lIGlzIGNyZWF0ZWQuXG4gICAgICogQHJldHVybnMgdGhlIGxpbmVhciBpbnRlcnBvbGF0ZWQgcmVzdWx0LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGxlcnBWKGEsIGIsIHQsIGRzdCkge1xuICAgICAgICBjb25zdCBuZXdEc3QgPSAoZHN0ID8/IG5ldyBDdG9yKDQpKTtcbiAgICAgICAgbmV3RHN0WzBdID0gYVswXSArIHRbMF0gKiAoYlswXSAtIGFbMF0pO1xuICAgICAgICBuZXdEc3RbMV0gPSBhWzFdICsgdFsxXSAqIChiWzFdIC0gYVsxXSk7XG4gICAgICAgIG5ld0RzdFsyXSA9IGFbMl0gKyB0WzJdICogKGJbMl0gLSBhWzJdKTtcbiAgICAgICAgbmV3RHN0WzNdID0gYVszXSArIHRbM10gKiAoYlszXSAtIGFbM10pO1xuICAgICAgICByZXR1cm4gbmV3RHN0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gbWF4IHZhbHVlcyBvZiB0d28gdmVjdG9ycy5cbiAgICAgKiBHaXZlbiB2ZWN0b3JzIGEgYW5kIGIgcmV0dXJuc1xuICAgICAqIFttYXgoYVswXSwgYlswXSksIG1heChhWzFdLCBiWzFdKSwgbWF4KGFbMl0sIGJbMl0pXS5cbiAgICAgKiBAcGFyYW0gYSAtIE9wZXJhbmQgdmVjdG9yLlxuICAgICAqIEBwYXJhbSBiIC0gT3BlcmFuZCB2ZWN0b3IuXG4gICAgICogQHBhcmFtIGRzdCAtIHZlY3RvciB0byBob2xkIHJlc3VsdC4gSWYgbm90IHBhc3NlZCBpbiBhIG5ldyBvbmUgaXMgY3JlYXRlZC5cbiAgICAgKiBAcmV0dXJucyBUaGUgbWF4IGNvbXBvbmVudHMgdmVjdG9yLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG1heChhLCBiLCBkc3QpIHtcbiAgICAgICAgY29uc3QgbmV3RHN0ID0gKGRzdCA/PyBuZXcgQ3Rvcig0KSk7XG4gICAgICAgIG5ld0RzdFswXSA9IE1hdGgubWF4KGFbMF0sIGJbMF0pO1xuICAgICAgICBuZXdEc3RbMV0gPSBNYXRoLm1heChhWzFdLCBiWzFdKTtcbiAgICAgICAgbmV3RHN0WzJdID0gTWF0aC5tYXgoYVsyXSwgYlsyXSk7XG4gICAgICAgIG5ld0RzdFszXSA9IE1hdGgubWF4KGFbM10sIGJbM10pO1xuICAgICAgICByZXR1cm4gbmV3RHN0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gbWluIHZhbHVlcyBvZiB0d28gdmVjdG9ycy5cbiAgICAgKiBHaXZlbiB2ZWN0b3JzIGEgYW5kIGIgcmV0dXJuc1xuICAgICAqIFttaW4oYVswXSwgYlswXSksIG1pbihhWzFdLCBiWzFdKSwgbWluKGFbMl0sIGJbMl0pXS5cbiAgICAgKiBAcGFyYW0gYSAtIE9wZXJhbmQgdmVjdG9yLlxuICAgICAqIEBwYXJhbSBiIC0gT3BlcmFuZCB2ZWN0b3IuXG4gICAgICogQHBhcmFtIGRzdCAtIHZlY3RvciB0byBob2xkIHJlc3VsdC4gSWYgbm90IHBhc3NlZCBpbiBhIG5ldyBvbmUgaXMgY3JlYXRlZC5cbiAgICAgKiBAcmV0dXJucyBUaGUgbWluIGNvbXBvbmVudHMgdmVjdG9yLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG1pbihhLCBiLCBkc3QpIHtcbiAgICAgICAgY29uc3QgbmV3RHN0ID0gKGRzdCA/PyBuZXcgQ3Rvcig0KSk7XG4gICAgICAgIG5ld0RzdFswXSA9IE1hdGgubWluKGFbMF0sIGJbMF0pO1xuICAgICAgICBuZXdEc3RbMV0gPSBNYXRoLm1pbihhWzFdLCBiWzFdKTtcbiAgICAgICAgbmV3RHN0WzJdID0gTWF0aC5taW4oYVsyXSwgYlsyXSk7XG4gICAgICAgIG5ld0RzdFszXSA9IE1hdGgubWluKGFbM10sIGJbM10pO1xuICAgICAgICByZXR1cm4gbmV3RHN0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBNdWx0aXBsaWVzIGEgdmVjdG9yIGJ5IGEgc2NhbGFyLlxuICAgICAqIEBwYXJhbSB2IC0gVGhlIHZlY3Rvci5cbiAgICAgKiBAcGFyYW0gayAtIFRoZSBzY2FsYXIuXG4gICAgICogQHBhcmFtIGRzdCAtIHZlY3RvciB0byBob2xkIHJlc3VsdC4gSWYgbm90IHBhc3NlZCBpbiBhIG5ldyBvbmUgaXMgY3JlYXRlZC5cbiAgICAgKiBAcmV0dXJucyBUaGUgc2NhbGVkIHZlY3Rvci5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBtdWxTY2FsYXIodiwgaywgZHN0KSB7XG4gICAgICAgIGNvbnN0IG5ld0RzdCA9IChkc3QgPz8gbmV3IEN0b3IoNCkpO1xuICAgICAgICBuZXdEc3RbMF0gPSB2WzBdICogaztcbiAgICAgICAgbmV3RHN0WzFdID0gdlsxXSAqIGs7XG4gICAgICAgIG5ld0RzdFsyXSA9IHZbMl0gKiBrO1xuICAgICAgICBuZXdEc3RbM10gPSB2WzNdICogaztcbiAgICAgICAgcmV0dXJuIG5ld0RzdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTXVsdGlwbGllcyBhIHZlY3RvciBieSBhIHNjYWxhci4gKHNhbWUgYXMgbXVsU2NhbGFyKVxuICAgICAqIEBwYXJhbSB2IC0gVGhlIHZlY3Rvci5cbiAgICAgKiBAcGFyYW0gayAtIFRoZSBzY2FsYXIuXG4gICAgICogQHBhcmFtIGRzdCAtIHZlY3RvciB0byBob2xkIHJlc3VsdC4gSWYgbm90IHBhc3NlZCBpbiBhIG5ldyBvbmUgaXMgY3JlYXRlZC5cbiAgICAgKiBAcmV0dXJucyBUaGUgc2NhbGVkIHZlY3Rvci5cbiAgICAgKi9cbiAgICBjb25zdCBzY2FsZSA9IG11bFNjYWxhcjtcbiAgICAvKipcbiAgICAgKiBEaXZpZGVzIGEgdmVjdG9yIGJ5IGEgc2NhbGFyLlxuICAgICAqIEBwYXJhbSB2IC0gVGhlIHZlY3Rvci5cbiAgICAgKiBAcGFyYW0gayAtIFRoZSBzY2FsYXIuXG4gICAgICogQHBhcmFtIGRzdCAtIHZlY3RvciB0byBob2xkIHJlc3VsdC4gSWYgbm90IHBhc3NlZCBpbiBhIG5ldyBvbmUgaXMgY3JlYXRlZC5cbiAgICAgKiBAcmV0dXJucyBUaGUgc2NhbGVkIHZlY3Rvci5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBkaXZTY2FsYXIodiwgaywgZHN0KSB7XG4gICAgICAgIGNvbnN0IG5ld0RzdCA9IChkc3QgPz8gbmV3IEN0b3IoNCkpO1xuICAgICAgICBuZXdEc3RbMF0gPSB2WzBdIC8gaztcbiAgICAgICAgbmV3RHN0WzFdID0gdlsxXSAvIGs7XG4gICAgICAgIG5ld0RzdFsyXSA9IHZbMl0gLyBrO1xuICAgICAgICBuZXdEc3RbM10gPSB2WzNdIC8gaztcbiAgICAgICAgcmV0dXJuIG5ld0RzdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSW52ZXJzZSBhIHZlY3Rvci5cbiAgICAgKiBAcGFyYW0gdiAtIFRoZSB2ZWN0b3IuXG4gICAgICogQHBhcmFtIGRzdCAtIHZlY3RvciB0byBob2xkIHJlc3VsdC4gSWYgbm90IHBhc3NlZCBpbiBhIG5ldyBvbmUgaXMgY3JlYXRlZC5cbiAgICAgKiBAcmV0dXJucyBUaGUgaW52ZXJ0ZWQgdmVjdG9yLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGludmVyc2UodiwgZHN0KSB7XG4gICAgICAgIGNvbnN0IG5ld0RzdCA9IChkc3QgPz8gbmV3IEN0b3IoNCkpO1xuICAgICAgICBuZXdEc3RbMF0gPSAxIC8gdlswXTtcbiAgICAgICAgbmV3RHN0WzFdID0gMSAvIHZbMV07XG4gICAgICAgIG5ld0RzdFsyXSA9IDEgLyB2WzJdO1xuICAgICAgICBuZXdEc3RbM10gPSAxIC8gdlszXTtcbiAgICAgICAgcmV0dXJuIG5ld0RzdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSW52ZXJ0IGEgdmVjdG9yLiAoc2FtZSBhcyBpbnZlcnNlKVxuICAgICAqIEBwYXJhbSB2IC0gVGhlIHZlY3Rvci5cbiAgICAgKiBAcGFyYW0gZHN0IC0gdmVjdG9yIHRvIGhvbGQgcmVzdWx0LiBJZiBub3QgcGFzc2VkIGluIGEgbmV3IG9uZSBpcyBjcmVhdGVkLlxuICAgICAqIEByZXR1cm5zIFRoZSBpbnZlcnRlZCB2ZWN0b3IuXG4gICAgICovXG4gICAgY29uc3QgaW52ZXJ0ID0gaW52ZXJzZTtcbiAgICAvKipcbiAgICAgKiBDb21wdXRlcyB0aGUgZG90IHByb2R1Y3Qgb2YgdHdvIHZlY3RvcnNcbiAgICAgKiBAcGFyYW0gYSAtIE9wZXJhbmQgdmVjdG9yLlxuICAgICAqIEBwYXJhbSBiIC0gT3BlcmFuZCB2ZWN0b3IuXG4gICAgICogQHJldHVybnMgZG90IHByb2R1Y3RcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBkb3QoYSwgYikge1xuICAgICAgICByZXR1cm4gKGFbMF0gKiBiWzBdKSArIChhWzFdICogYlsxXSkgKyAoYVsyXSAqIGJbMl0pICsgKGFbM10gKiBiWzNdKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29tcHV0ZXMgdGhlIGxlbmd0aCBvZiB2ZWN0b3JcbiAgICAgKiBAcGFyYW0gdiAtIHZlY3Rvci5cbiAgICAgKiBAcmV0dXJucyBsZW5ndGggb2YgdmVjdG9yLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGxlbmd0aCh2KSB7XG4gICAgICAgIGNvbnN0IHYwID0gdlswXTtcbiAgICAgICAgY29uc3QgdjEgPSB2WzFdO1xuICAgICAgICBjb25zdCB2MiA9IHZbMl07XG4gICAgICAgIGNvbnN0IHYzID0gdlszXTtcbiAgICAgICAgcmV0dXJuIE1hdGguc3FydCh2MCAqIHYwICsgdjEgKiB2MSArIHYyICogdjIgKyB2MyAqIHYzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29tcHV0ZXMgdGhlIGxlbmd0aCBvZiB2ZWN0b3IgKHNhbWUgYXMgbGVuZ3RoKVxuICAgICAqIEBwYXJhbSB2IC0gdmVjdG9yLlxuICAgICAqIEByZXR1cm5zIGxlbmd0aCBvZiB2ZWN0b3IuXG4gICAgICovXG4gICAgY29uc3QgbGVuID0gbGVuZ3RoO1xuICAgIC8qKlxuICAgICAqIENvbXB1dGVzIHRoZSBzcXVhcmUgb2YgdGhlIGxlbmd0aCBvZiB2ZWN0b3JcbiAgICAgKiBAcGFyYW0gdiAtIHZlY3Rvci5cbiAgICAgKiBAcmV0dXJucyBzcXVhcmUgb2YgdGhlIGxlbmd0aCBvZiB2ZWN0b3IuXG4gICAgICovXG4gICAgZnVuY3Rpb24gbGVuZ3RoU3Eodikge1xuICAgICAgICBjb25zdCB2MCA9IHZbMF07XG4gICAgICAgIGNvbnN0IHYxID0gdlsxXTtcbiAgICAgICAgY29uc3QgdjIgPSB2WzJdO1xuICAgICAgICBjb25zdCB2MyA9IHZbM107XG4gICAgICAgIHJldHVybiB2MCAqIHYwICsgdjEgKiB2MSArIHYyICogdjIgKyB2MyAqIHYzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb21wdXRlcyB0aGUgc3F1YXJlIG9mIHRoZSBsZW5ndGggb2YgdmVjdG9yIChzYW1lIGFzIGxlbmd0aFNxKVxuICAgICAqIEBwYXJhbSB2IC0gdmVjdG9yLlxuICAgICAqIEByZXR1cm5zIHNxdWFyZSBvZiB0aGUgbGVuZ3RoIG9mIHZlY3Rvci5cbiAgICAgKi9cbiAgICBjb25zdCBsZW5TcSA9IGxlbmd0aFNxO1xuICAgIC8qKlxuICAgICAqIENvbXB1dGVzIHRoZSBkaXN0YW5jZSBiZXR3ZWVuIDIgcG9pbnRzXG4gICAgICogQHBhcmFtIGEgLSB2ZWN0b3IuXG4gICAgICogQHBhcmFtIGIgLSB2ZWN0b3IuXG4gICAgICogQHJldHVybnMgZGlzdGFuY2UgYmV0d2VlbiBhIGFuZCBiXG4gICAgICovXG4gICAgZnVuY3Rpb24gZGlzdGFuY2UoYSwgYikge1xuICAgICAgICBjb25zdCBkeCA9IGFbMF0gLSBiWzBdO1xuICAgICAgICBjb25zdCBkeSA9IGFbMV0gLSBiWzFdO1xuICAgICAgICBjb25zdCBkeiA9IGFbMl0gLSBiWzJdO1xuICAgICAgICBjb25zdCBkdyA9IGFbM10gLSBiWzNdO1xuICAgICAgICByZXR1cm4gTWF0aC5zcXJ0KGR4ICogZHggKyBkeSAqIGR5ICsgZHogKiBkeiArIGR3ICogZHcpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb21wdXRlcyB0aGUgZGlzdGFuY2UgYmV0d2VlbiAyIHBvaW50cyAoc2FtZSBhcyBkaXN0YW5jZSlcbiAgICAgKiBAcGFyYW0gYSAtIHZlY3Rvci5cbiAgICAgKiBAcGFyYW0gYiAtIHZlY3Rvci5cbiAgICAgKiBAcmV0dXJucyBkaXN0YW5jZSBiZXR3ZWVuIGEgYW5kIGJcbiAgICAgKi9cbiAgICBjb25zdCBkaXN0ID0gZGlzdGFuY2U7XG4gICAgLyoqXG4gICAgICogQ29tcHV0ZXMgdGhlIHNxdWFyZSBvZiB0aGUgZGlzdGFuY2UgYmV0d2VlbiAyIHBvaW50c1xuICAgICAqIEBwYXJhbSBhIC0gdmVjdG9yLlxuICAgICAqIEBwYXJhbSBiIC0gdmVjdG9yLlxuICAgICAqIEByZXR1cm5zIHNxdWFyZSBvZiB0aGUgZGlzdGFuY2UgYmV0d2VlbiBhIGFuZCBiXG4gICAgICovXG4gICAgZnVuY3Rpb24gZGlzdGFuY2VTcShhLCBiKSB7XG4gICAgICAgIGNvbnN0IGR4ID0gYVswXSAtIGJbMF07XG4gICAgICAgIGNvbnN0IGR5ID0gYVsxXSAtIGJbMV07XG4gICAgICAgIGNvbnN0IGR6ID0gYVsyXSAtIGJbMl07XG4gICAgICAgIGNvbnN0IGR3ID0gYVszXSAtIGJbM107XG4gICAgICAgIHJldHVybiBkeCAqIGR4ICsgZHkgKiBkeSArIGR6ICogZHogKyBkdyAqIGR3O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb21wdXRlcyB0aGUgc3F1YXJlIG9mIHRoZSBkaXN0YW5jZSBiZXR3ZWVuIDIgcG9pbnRzIChzYW1lIGFzIGRpc3RhbmNlU3EpXG4gICAgICogQHBhcmFtIGEgLSB2ZWN0b3IuXG4gICAgICogQHBhcmFtIGIgLSB2ZWN0b3IuXG4gICAgICogQHJldHVybnMgc3F1YXJlIG9mIHRoZSBkaXN0YW5jZSBiZXR3ZWVuIGEgYW5kIGJcbiAgICAgKi9cbiAgICBjb25zdCBkaXN0U3EgPSBkaXN0YW5jZVNxO1xuICAgIC8qKlxuICAgICAqIERpdmlkZXMgYSB2ZWN0b3IgYnkgaXRzIEV1Y2xpZGVhbiBsZW5ndGggYW5kIHJldHVybnMgdGhlIHF1b3RpZW50LlxuICAgICAqIEBwYXJhbSB2IC0gVGhlIHZlY3Rvci5cbiAgICAgKiBAcGFyYW0gZHN0IC0gdmVjdG9yIHRvIGhvbGQgcmVzdWx0LiBJZiBub3QgcGFzc2VkIGluIGEgbmV3IG9uZSBpcyBjcmVhdGVkLlxuICAgICAqIEByZXR1cm5zIFRoZSBub3JtYWxpemVkIHZlY3Rvci5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBub3JtYWxpemUodiwgZHN0KSB7XG4gICAgICAgIGNvbnN0IG5ld0RzdCA9IChkc3QgPz8gbmV3IEN0b3IoNCkpO1xuICAgICAgICBjb25zdCB2MCA9IHZbMF07XG4gICAgICAgIGNvbnN0IHYxID0gdlsxXTtcbiAgICAgICAgY29uc3QgdjIgPSB2WzJdO1xuICAgICAgICBjb25zdCB2MyA9IHZbM107XG4gICAgICAgIGNvbnN0IGxlbiA9IE1hdGguc3FydCh2MCAqIHYwICsgdjEgKiB2MSArIHYyICogdjIgKyB2MyAqIHYzKTtcbiAgICAgICAgaWYgKGxlbiA+IDAuMDAwMDEpIHtcbiAgICAgICAgICAgIG5ld0RzdFswXSA9IHYwIC8gbGVuO1xuICAgICAgICAgICAgbmV3RHN0WzFdID0gdjEgLyBsZW47XG4gICAgICAgICAgICBuZXdEc3RbMl0gPSB2MiAvIGxlbjtcbiAgICAgICAgICAgIG5ld0RzdFszXSA9IHYzIC8gbGVuO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbmV3RHN0WzBdID0gMDtcbiAgICAgICAgICAgIG5ld0RzdFsxXSA9IDA7XG4gICAgICAgICAgICBuZXdEc3RbMl0gPSAwO1xuICAgICAgICAgICAgbmV3RHN0WzNdID0gMDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3RHN0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBOZWdhdGVzIGEgdmVjdG9yLlxuICAgICAqIEBwYXJhbSB2IC0gVGhlIHZlY3Rvci5cbiAgICAgKiBAcGFyYW0gZHN0IC0gdmVjdG9yIHRvIGhvbGQgcmVzdWx0LiBJZiBub3QgcGFzc2VkIGluIGEgbmV3IG9uZSBpcyBjcmVhdGVkLlxuICAgICAqIEByZXR1cm5zIC12LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG5lZ2F0ZSh2LCBkc3QpIHtcbiAgICAgICAgY29uc3QgbmV3RHN0ID0gKGRzdCA/PyBuZXcgQ3Rvcig0KSk7XG4gICAgICAgIG5ld0RzdFswXSA9IC12WzBdO1xuICAgICAgICBuZXdEc3RbMV0gPSAtdlsxXTtcbiAgICAgICAgbmV3RHN0WzJdID0gLXZbMl07XG4gICAgICAgIG5ld0RzdFszXSA9IC12WzNdO1xuICAgICAgICByZXR1cm4gbmV3RHN0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb3BpZXMgYSB2ZWN0b3IuIChzYW1lIGFzIHtAbGluayB2ZWM0LmNsb25lfSlcbiAgICAgKiBBbHNvIHNlZSB7QGxpbmsgdmVjNC5jcmVhdGV9IGFuZCB7QGxpbmsgdmVjNC5zZXR9XG4gICAgICogQHBhcmFtIHYgLSBUaGUgdmVjdG9yLlxuICAgICAqIEBwYXJhbSBkc3QgLSB2ZWN0b3IgdG8gaG9sZCByZXN1bHQuIElmIG5vdCBwYXNzZWQgaW4gYSBuZXcgb25lIGlzIGNyZWF0ZWQuXG4gICAgICogQHJldHVybnMgQSBjb3B5IG9mIHYuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY29weSh2LCBkc3QpIHtcbiAgICAgICAgY29uc3QgbmV3RHN0ID0gKGRzdCA/PyBuZXcgQ3Rvcig0KSk7XG4gICAgICAgIG5ld0RzdFswXSA9IHZbMF07XG4gICAgICAgIG5ld0RzdFsxXSA9IHZbMV07XG4gICAgICAgIG5ld0RzdFsyXSA9IHZbMl07XG4gICAgICAgIG5ld0RzdFszXSA9IHZbM107XG4gICAgICAgIHJldHVybiBuZXdEc3Q7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENsb25lcyBhIHZlY3Rvci4gKHNhbWUgYXMge0BsaW5rIHZlYzQuY29weX0pXG4gICAgICogQWxzbyBzZWUge0BsaW5rIHZlYzQuY3JlYXRlfSBhbmQge0BsaW5rIHZlYzQuc2V0fVxuICAgICAqIEBwYXJhbSB2IC0gVGhlIHZlY3Rvci5cbiAgICAgKiBAcGFyYW0gZHN0IC0gdmVjdG9yIHRvIGhvbGQgcmVzdWx0LiBJZiBub3QgcGFzc2VkIGluIGEgbmV3IG9uZSBpcyBjcmVhdGVkLlxuICAgICAqIEByZXR1cm5zIEEgY29weSBvZiB2LlxuICAgICAqL1xuICAgIGNvbnN0IGNsb25lID0gY29weTtcbiAgICAvKipcbiAgICAgKiBNdWx0aXBsaWVzIGEgdmVjdG9yIGJ5IGFub3RoZXIgdmVjdG9yIChjb21wb25lbnQtd2lzZSk7IGFzc3VtZXMgYSBhbmRcbiAgICAgKiBiIGhhdmUgdGhlIHNhbWUgbGVuZ3RoLlxuICAgICAqIEBwYXJhbSBhIC0gT3BlcmFuZCB2ZWN0b3IuXG4gICAgICogQHBhcmFtIGIgLSBPcGVyYW5kIHZlY3Rvci5cbiAgICAgKiBAcGFyYW0gZHN0IC0gdmVjdG9yIHRvIGhvbGQgcmVzdWx0LiBJZiBub3QgcGFzc2VkIGluIGEgbmV3IG9uZSBpcyBjcmVhdGVkLlxuICAgICAqIEByZXR1cm5zIFRoZSB2ZWN0b3Igb2YgcHJvZHVjdHMgb2YgZW50cmllcyBvZiBhIGFuZCBiLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG11bHRpcGx5KGEsIGIsIGRzdCkge1xuICAgICAgICBjb25zdCBuZXdEc3QgPSAoZHN0ID8/IG5ldyBDdG9yKDQpKTtcbiAgICAgICAgbmV3RHN0WzBdID0gYVswXSAqIGJbMF07XG4gICAgICAgIG5ld0RzdFsxXSA9IGFbMV0gKiBiWzFdO1xuICAgICAgICBuZXdEc3RbMl0gPSBhWzJdICogYlsyXTtcbiAgICAgICAgbmV3RHN0WzNdID0gYVszXSAqIGJbM107XG4gICAgICAgIHJldHVybiBuZXdEc3Q7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE11bHRpcGxpZXMgYSB2ZWN0b3IgYnkgYW5vdGhlciB2ZWN0b3IgKGNvbXBvbmVudC13aXNlKTsgYXNzdW1lcyBhIGFuZFxuICAgICAqIGIgaGF2ZSB0aGUgc2FtZSBsZW5ndGguIChzYW1lIGFzIG11bClcbiAgICAgKiBAcGFyYW0gYSAtIE9wZXJhbmQgdmVjdG9yLlxuICAgICAqIEBwYXJhbSBiIC0gT3BlcmFuZCB2ZWN0b3IuXG4gICAgICogQHBhcmFtIGRzdCAtIHZlY3RvciB0byBob2xkIHJlc3VsdC4gSWYgbm90IHBhc3NlZCBpbiBhIG5ldyBvbmUgaXMgY3JlYXRlZC5cbiAgICAgKiBAcmV0dXJucyBUaGUgdmVjdG9yIG9mIHByb2R1Y3RzIG9mIGVudHJpZXMgb2YgYSBhbmQgYi5cbiAgICAgKi9cbiAgICBjb25zdCBtdWwgPSBtdWx0aXBseTtcbiAgICAvKipcbiAgICAgKiBEaXZpZGVzIGEgdmVjdG9yIGJ5IGFub3RoZXIgdmVjdG9yIChjb21wb25lbnQtd2lzZSk7IGFzc3VtZXMgYSBhbmRcbiAgICAgKiBiIGhhdmUgdGhlIHNhbWUgbGVuZ3RoLlxuICAgICAqIEBwYXJhbSBhIC0gT3BlcmFuZCB2ZWN0b3IuXG4gICAgICogQHBhcmFtIGIgLSBPcGVyYW5kIHZlY3Rvci5cbiAgICAgKiBAcGFyYW0gZHN0IC0gdmVjdG9yIHRvIGhvbGQgcmVzdWx0LiBJZiBub3QgcGFzc2VkIGluIGEgbmV3IG9uZSBpcyBjcmVhdGVkLlxuICAgICAqIEByZXR1cm5zIFRoZSB2ZWN0b3Igb2YgcXVvdGllbnRzIG9mIGVudHJpZXMgb2YgYSBhbmQgYi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBkaXZpZGUoYSwgYiwgZHN0KSB7XG4gICAgICAgIGNvbnN0IG5ld0RzdCA9IChkc3QgPz8gbmV3IEN0b3IoNCkpO1xuICAgICAgICBuZXdEc3RbMF0gPSBhWzBdIC8gYlswXTtcbiAgICAgICAgbmV3RHN0WzFdID0gYVsxXSAvIGJbMV07XG4gICAgICAgIG5ld0RzdFsyXSA9IGFbMl0gLyBiWzJdO1xuICAgICAgICBuZXdEc3RbM10gPSBhWzNdIC8gYlszXTtcbiAgICAgICAgcmV0dXJuIG5ld0RzdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGl2aWRlcyBhIHZlY3RvciBieSBhbm90aGVyIHZlY3RvciAoY29tcG9uZW50LXdpc2UpOyBhc3N1bWVzIGEgYW5kXG4gICAgICogYiBoYXZlIHRoZSBzYW1lIGxlbmd0aC4gKHNhbWUgYXMgZGl2aWRlKVxuICAgICAqIEBwYXJhbSBhIC0gT3BlcmFuZCB2ZWN0b3IuXG4gICAgICogQHBhcmFtIGIgLSBPcGVyYW5kIHZlY3Rvci5cbiAgICAgKiBAcGFyYW0gZHN0IC0gdmVjdG9yIHRvIGhvbGQgcmVzdWx0LiBJZiBub3QgcGFzc2VkIGluIGEgbmV3IG9uZSBpcyBjcmVhdGVkLlxuICAgICAqIEByZXR1cm5zIFRoZSB2ZWN0b3Igb2YgcXVvdGllbnRzIG9mIGVudHJpZXMgb2YgYSBhbmQgYi5cbiAgICAgKi9cbiAgICBjb25zdCBkaXYgPSBkaXZpZGU7XG4gICAgLyoqXG4gICAgICogWmVybydzIGEgdmVjdG9yXG4gICAgICogQHBhcmFtIGRzdCAtIHZlY3RvciB0byBob2xkIHJlc3VsdC4gSWYgbm90IHBhc3NlZCBpbiBhIG5ldyBvbmUgaXMgY3JlYXRlZC5cbiAgICAgKiBAcmV0dXJucyBUaGUgemVyb2VkIHZlY3Rvci5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB6ZXJvKGRzdCkge1xuICAgICAgICBjb25zdCBuZXdEc3QgPSAoZHN0ID8/IG5ldyBDdG9yKDQpKTtcbiAgICAgICAgbmV3RHN0WzBdID0gMDtcbiAgICAgICAgbmV3RHN0WzFdID0gMDtcbiAgICAgICAgbmV3RHN0WzJdID0gMDtcbiAgICAgICAgbmV3RHN0WzNdID0gMDtcbiAgICAgICAgcmV0dXJuIG5ld0RzdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogdHJhbnNmb3JtIHZlYzQgYnkgNHg0IG1hdHJpeFxuICAgICAqIEBwYXJhbSB2IC0gdGhlIHZlY3RvclxuICAgICAqIEBwYXJhbSBtIC0gVGhlIG1hdHJpeC5cbiAgICAgKiBAcGFyYW0gZHN0IC0gb3B0aW9uYWwgdmVjNCB0byBzdG9yZSByZXN1bHQuIElmIG5vdCBwYXNzZWQgYSBuZXcgb25lIGlzIGNyZWF0ZWQuXG4gICAgICogQHJldHVybnMgdGhlIHRyYW5zZm9ybWVkIHZlY3RvclxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRyYW5zZm9ybU1hdDQodiwgbSwgZHN0KSB7XG4gICAgICAgIGNvbnN0IG5ld0RzdCA9IChkc3QgPz8gbmV3IEN0b3IoNCkpO1xuICAgICAgICBjb25zdCB4ID0gdlswXTtcbiAgICAgICAgY29uc3QgeSA9IHZbMV07XG4gICAgICAgIGNvbnN0IHogPSB2WzJdO1xuICAgICAgICBjb25zdCB3ID0gdlszXTtcbiAgICAgICAgbmV3RHN0WzBdID0gbVswXSAqIHggKyBtWzRdICogeSArIG1bOF0gKiB6ICsgbVsxMl0gKiB3O1xuICAgICAgICBuZXdEc3RbMV0gPSBtWzFdICogeCArIG1bNV0gKiB5ICsgbVs5XSAqIHogKyBtWzEzXSAqIHc7XG4gICAgICAgIG5ld0RzdFsyXSA9IG1bMl0gKiB4ICsgbVs2XSAqIHkgKyBtWzEwXSAqIHogKyBtWzE0XSAqIHc7XG4gICAgICAgIG5ld0RzdFszXSA9IG1bM10gKiB4ICsgbVs3XSAqIHkgKyBtWzExXSAqIHogKyBtWzE1XSAqIHc7XG4gICAgICAgIHJldHVybiBuZXdEc3Q7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRyZWF0IGEgNEQgdmVjdG9yIGFzIGEgZGlyZWN0aW9uIGFuZCBzZXQgaXQncyBsZW5ndGhcbiAgICAgKlxuICAgICAqIEBwYXJhbSBhIFRoZSB2ZWM0IHRvIGxlbmd0aGVuXG4gICAgICogQHBhcmFtIGxlbiBUaGUgbGVuZ3RoIG9mIHRoZSByZXN1bHRpbmcgdmVjdG9yXG4gICAgICogQHJldHVybnMgVGhlIGxlbmd0aGVuZWQgdmVjdG9yXG4gICAgICovXG4gICAgZnVuY3Rpb24gc2V0TGVuZ3RoKGEsIGxlbiwgZHN0KSB7XG4gICAgICAgIGNvbnN0IG5ld0RzdCA9IChkc3QgPz8gbmV3IEN0b3IoNCkpO1xuICAgICAgICBub3JtYWxpemUoYSwgbmV3RHN0KTtcbiAgICAgICAgcmV0dXJuIG11bFNjYWxhcihuZXdEc3QsIGxlbiwgbmV3RHN0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRW5zdXJlIGEgdmVjdG9yIGlzIG5vdCBsb25nZXIgdGhhbiBhIG1heCBsZW5ndGhcbiAgICAgKlxuICAgICAqIEBwYXJhbSBhIFRoZSB2ZWM0IHRvIGxpbWl0XG4gICAgICogQHBhcmFtIG1heExlbiBUaGUgbG9uZ2VzdCBsZW5ndGggb2YgdGhlIHJlc3VsdGluZyB2ZWN0b3JcbiAgICAgKiBAcmV0dXJucyBUaGUgdmVjdG9yLCBzaG9ydGVuZWQgdG8gbWF4TGVuIGlmIGl0J3MgdG9vIGxvbmdcbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0cnVuY2F0ZShhLCBtYXhMZW4sIGRzdCkge1xuICAgICAgICBjb25zdCBuZXdEc3QgPSAoZHN0ID8/IG5ldyBDdG9yKDQpKTtcbiAgICAgICAgaWYgKGxlbmd0aChhKSA+IG1heExlbikge1xuICAgICAgICAgICAgcmV0dXJuIHNldExlbmd0aChhLCBtYXhMZW4sIG5ld0RzdCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvcHkoYSwgbmV3RHN0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJuIHRoZSB2ZWN0b3IgZXhhY3RseSBiZXR3ZWVuIDIgZW5kcG9pbnQgdmVjdG9yc1xuICAgICAqXG4gICAgICogQHBhcmFtIGEgRW5kcG9pbnQgMVxuICAgICAqIEBwYXJhbSBiIEVuZHBvaW50IDJcbiAgICAgKiBAcmV0dXJucyBUaGUgdmVjdG9yIGV4YWN0bHkgcmVzaWRpbmcgYmV0d2VlbiBlbmRwb2ludHMgMSBhbmQgMlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG1pZHBvaW50KGEsIGIsIGRzdCkge1xuICAgICAgICBjb25zdCBuZXdEc3QgPSAoZHN0ID8/IG5ldyBDdG9yKDQpKTtcbiAgICAgICAgcmV0dXJuIGxlcnAoYSwgYiwgMC41LCBuZXdEc3QpO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBjcmVhdGUsXG4gICAgICAgIGZyb21WYWx1ZXMsXG4gICAgICAgIHNldCxcbiAgICAgICAgY2VpbCxcbiAgICAgICAgZmxvb3IsXG4gICAgICAgIHJvdW5kLFxuICAgICAgICBjbGFtcCxcbiAgICAgICAgYWRkLFxuICAgICAgICBhZGRTY2FsZWQsXG4gICAgICAgIHN1YnRyYWN0LFxuICAgICAgICBzdWIsXG4gICAgICAgIGVxdWFsc0FwcHJveGltYXRlbHksXG4gICAgICAgIGVxdWFscyxcbiAgICAgICAgbGVycCxcbiAgICAgICAgbGVycFYsXG4gICAgICAgIG1heCxcbiAgICAgICAgbWluLFxuICAgICAgICBtdWxTY2FsYXIsXG4gICAgICAgIHNjYWxlLFxuICAgICAgICBkaXZTY2FsYXIsXG4gICAgICAgIGludmVyc2UsXG4gICAgICAgIGludmVydCxcbiAgICAgICAgZG90LFxuICAgICAgICBsZW5ndGgsXG4gICAgICAgIGxlbixcbiAgICAgICAgbGVuZ3RoU3EsXG4gICAgICAgIGxlblNxLFxuICAgICAgICBkaXN0YW5jZSxcbiAgICAgICAgZGlzdCxcbiAgICAgICAgZGlzdGFuY2VTcSxcbiAgICAgICAgZGlzdFNxLFxuICAgICAgICBub3JtYWxpemUsXG4gICAgICAgIG5lZ2F0ZSxcbiAgICAgICAgY29weSxcbiAgICAgICAgY2xvbmUsXG4gICAgICAgIG11bHRpcGx5LFxuICAgICAgICBtdWwsXG4gICAgICAgIGRpdmlkZSxcbiAgICAgICAgZGl2LFxuICAgICAgICB6ZXJvLFxuICAgICAgICB0cmFuc2Zvcm1NYXQ0LFxuICAgICAgICBzZXRMZW5ndGgsXG4gICAgICAgIHRydW5jYXRlLFxuICAgICAgICBtaWRwb2ludCxcbiAgICB9O1xufVxuY29uc3QgY2FjaGUgPSBuZXcgTWFwKCk7XG4vKipcbiAqXG4gKiBWZWM0IG1hdGggZnVuY3Rpb25zLlxuICpcbiAqIEFsbW9zdCBhbGwgZnVuY3Rpb25zIHRha2UgYW4gb3B0aW9uYWwgYG5ld0RzdGAgYXJndW1lbnQuIElmIGl0IGlzIG5vdCBwYXNzZWQgaW4gdGhlXG4gKiBmdW5jdGlvbnMgd2lsbCBjcmVhdGUgYSBuZXcgYFZlYzRgLiBJbiBvdGhlciB3b3JkcyB5b3UgY2FuIGRvIHRoaXNcbiAqXG4gKiAgICAgY29uc3QgdiA9IHZlYzQuY3Jvc3ModjEsIHYyKTsgIC8vIENyZWF0ZXMgYSBuZXcgVmVjNCB3aXRoIHRoZSBjcm9zcyBwcm9kdWN0IG9mIHYxIHggdjIuXG4gKlxuICogb3JcbiAqXG4gKiAgICAgY29uc3QgdiA9IHZlYzQuY3JlYXRlKCk7XG4gKiAgICAgdmVjNC5jcm9zcyh2MSwgdjIsIHYpOyAgLy8gUHV0cyB0aGUgY3Jvc3MgcHJvZHVjdCBvZiB2MSB4IHYyIGluIHZcbiAqXG4gKiBUaGUgZmlyc3Qgc3R5bGUgaXMgb2Z0ZW4gZWFzaWVyIGJ1dCBkZXBlbmRpbmcgb24gd2hlcmUgaXQncyB1c2VkIGl0IGdlbmVyYXRlcyBnYXJiYWdlIHdoZXJlXG4gKiBhcyB0aGVyZSBpcyBhbG1vc3QgbmV2ZXIgYWxsb2NhdGlvbiB3aXRoIHRoZSBzZWNvbmQgc3R5bGUuXG4gKlxuICogSXQgaXMgYWx3YXlzIHNhZmUgdG8gcGFzcyBhbnkgdmVjdG9yIGFzIHRoZSBkZXN0aW5hdGlvbi4gU28gZm9yIGV4YW1wbGVcbiAqXG4gKiAgICAgdmVjNC5jcm9zcyh2MSwgdjIsIHYxKTsgIC8vIFB1dHMgdGhlIGNyb3NzIHByb2R1Y3Qgb2YgdjEgeCB2MiBpbiB2MVxuICpcbiAqL1xuZnVuY3Rpb24gZ2V0QVBJKEN0b3IpIHtcbiAgICBsZXQgYXBpID0gY2FjaGUuZ2V0KEN0b3IpO1xuICAgIGlmICghYXBpKSB7XG4gICAgICAgIGFwaSA9IGdldEFQSUltcGwoQ3Rvcik7XG4gICAgICAgIGNhY2hlLnNldChDdG9yLCBhcGkpO1xuICAgIH1cbiAgICByZXR1cm4gYXBpO1xufVxuXG4vKipcbiAqIEdlbmVyYXRlIHdncHUtbWF0cml4IEFQSSBmb3IgdHlwZVxuICovXG5mdW5jdGlvbiB3Z3B1TWF0cml4QVBJKE1hdDNDdG9yLCBNYXQ0Q3RvciwgUXVhdEN0b3IsIFZlYzJDdG9yLCBWZWMzQ3RvciwgVmVjNEN0b3IpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICAvKiogQG5hbWVzcGFjZSBtYXQ0ICovXG4gICAgICAgIG1hdDQ6IGdldEFQSSQyKE1hdDNDdG9yKSxcbiAgICAgICAgLyoqIEBuYW1lc3BhY2UgbWF0MyAqL1xuICAgICAgICBtYXQzOiBnZXRBUEkkNChNYXQ0Q3RvciksXG4gICAgICAgIC8qKiBAbmFtZXNwYWNlIHF1YXQgKi9cbiAgICAgICAgcXVhdDogZ2V0QVBJJDEoUXVhdEN0b3IpLFxuICAgICAgICAvKiogQG5hbWVzcGFjZSB2ZWMyICovXG4gICAgICAgIHZlYzI6IGdldEFQSSQ1KFZlYzJDdG9yKSxcbiAgICAgICAgLyoqIEBuYW1lc3BhY2UgdmVjMyAqL1xuICAgICAgICB2ZWMzOiBnZXRBUEkkMyhWZWMzQ3RvciksXG4gICAgICAgIC8qKiBAbmFtZXNwYWNlIHZlYzQgKi9cbiAgICAgICAgdmVjNDogZ2V0QVBJKFZlYzRDdG9yKSxcbiAgICB9O1xufVxuY29uc3QgeyBcbi8qKiBAbmFtZXNwYWNlICovXG5tYXQ0LCBcbi8qKiBAbmFtZXNwYWNlICovXG5tYXQzLCBcbi8qKiBAbmFtZXNwYWNlICovXG5xdWF0LCBcbi8qKiBAbmFtZXNwYWNlICovXG52ZWMyLCBcbi8qKiBAbmFtZXNwYWNlICovXG52ZWMzLCBcbi8qKiBAbmFtZXNwYWNlICovXG52ZWM0LCB9ID0gd2dwdU1hdHJpeEFQSShGbG9hdDMyQXJyYXksIEZsb2F0MzJBcnJheSwgRmxvYXQzMkFycmF5LCBGbG9hdDMyQXJyYXksIEZsb2F0MzJBcnJheSwgRmxvYXQzMkFycmF5KTtcbmNvbnN0IHsgXG4vKiogQG5hbWVzcGFjZSAqL1xubWF0NDogbWF0NGQsIFxuLyoqIEBuYW1lc3BhY2UgKi9cbm1hdDM6IG1hdDNkLCBcbi8qKiBAbmFtZXNwYWNlICovXG5xdWF0OiBxdWF0ZCwgXG4vKiogQG5hbWVzcGFjZSAqL1xudmVjMjogdmVjMmQsIFxuLyoqIEBuYW1lc3BhY2UgKi9cbnZlYzM6IHZlYzNkLCBcbi8qKiBAbmFtZXNwYWNlICovXG52ZWM0OiB2ZWM0ZCwgfSA9IHdncHVNYXRyaXhBUEkoRmxvYXQ2NEFycmF5LCBGbG9hdDY0QXJyYXksIEZsb2F0NjRBcnJheSwgRmxvYXQ2NEFycmF5LCBGbG9hdDY0QXJyYXksIEZsb2F0NjRBcnJheSk7XG5jb25zdCB7IFxuLyoqIEBuYW1lc3BhY2UgKi9cbm1hdDQ6IG1hdDRuLCBcbi8qKiBAbmFtZXNwYWNlICovXG5tYXQzOiBtYXQzbiwgXG4vKiogQG5hbWVzcGFjZSAqL1xucXVhdDogcXVhdG4sIFxuLyoqIEBuYW1lc3BhY2UgKi9cbnZlYzI6IHZlYzJuLCBcbi8qKiBAbmFtZXNwYWNlICovXG52ZWMzOiB2ZWMzbiwgXG4vKiogQG5hbWVzcGFjZSAqL1xudmVjNDogdmVjNG4sIH0gPSB3Z3B1TWF0cml4QVBJKFplcm9BcnJheSwgQXJyYXksIEFycmF5LCBBcnJheSwgQXJyYXksIEFycmF5KTtcblxuZXhwb3J0IHsgbWF0MywgbWF0M2QsIG1hdDNuLCBtYXQ0LCBtYXQ0ZCwgbWF0NG4sIHF1YXQsIHF1YXRkLCBxdWF0biwgdXRpbHMsIHZlYzIsIHZlYzJkLCB2ZWMybiwgdmVjMywgdmVjM2QsIHZlYzNuLCB2ZWM0LCB2ZWM0ZCwgdmVjNG4gfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXdncHUtbWF0cml4Lm1vZHVsZS5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==